(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TEST_NETWORK = exports.NETWORK = exports.TAPROOT_UNSPENDABLE_KEY = exports.PubT = exports.tagSchnorr = exports.signSchnorr = exports.pubECDSA = exports.pubSchnorr = exports.randomPrivateKeyBytes = exports.sha256x2 = exports.hash160 = exports.sha256 = exports.isBytes = exports.equalBytes = exports.concatBytes = void 0;
exports.signECDSA = signECDSA;
exports.validatePubkey = validatePubkey;
exports.tapTweak = tapTweak;
exports.taprootTweakPrivKey = taprootTweakPrivKey;
exports.taprootTweakPubkey = taprootTweakPubkey;
exports.compareBytes = compareBytes;
const secp256k1_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/node_modules/@noble/curves/secp256k1.js [app-client] (ecmascript)");
const ripemd160_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/node_modules/@noble/hashes/ripemd160.js [app-client] (ecmascript)");
const sha256_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/node_modules/@noble/hashes/sha256.js [app-client] (ecmascript)");
Object.defineProperty(exports, "sha256", {
    enumerable: true,
    get: function() {
        return sha256_1.sha256;
    }
});
const micro_packed_1 = __turbopack_context__.r("[project]/node_modules/micro-packed/lib/index.js [app-client] (ecmascript)");
const Point = secp256k1_1.secp256k1.ProjectivePoint;
const CURVE_ORDER = secp256k1_1.secp256k1.CURVE.n;
const isBytes = micro_packed_1.utils.isBytes;
exports.isBytes = isBytes;
const concatBytes = micro_packed_1.utils.concatBytes;
exports.concatBytes = concatBytes;
const equalBytes = micro_packed_1.utils.equalBytes;
exports.equalBytes = equalBytes;
const hash160 = (msg)=>(0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(msg));
exports.hash160 = hash160;
const sha256x2 = function() {
    for(var _len = arguments.length, msgs = new Array(_len), _key = 0; _key < _len; _key++){
        msgs[_key] = arguments[_key];
    }
    return (0, sha256_1.sha256)((0, sha256_1.sha256)(concatBytes(...msgs)));
};
exports.sha256x2 = sha256x2;
exports.randomPrivateKeyBytes = secp256k1_1.schnorr.utils.randomPrivateKey;
exports.pubSchnorr = secp256k1_1.schnorr.getPublicKey;
exports.pubECDSA = secp256k1_1.secp256k1.getPublicKey;
// low-r signature grinding. Used to reduce tx size by 1 byte.
// noble/secp256k1 does not support the feature: it is not used outside of BTC.
// We implement it manually, because in BTC it's common.
// Not best way, but closest to bitcoin implementation (easier to check)
const hasLowR = (sig)=>sig.r < CURVE_ORDER / 2n;
function signECDSA(hash, privateKey) {
    let lowR = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let sig = secp256k1_1.secp256k1.sign(hash, privateKey);
    if (lowR && !hasLowR(sig)) {
        const extraEntropy = new Uint8Array(32);
        let counter = 0;
        while(!hasLowR(sig)){
            extraEntropy.set(micro_packed_1.U32LE.encode(counter++));
            sig = secp256k1_1.secp256k1.sign(hash, privateKey, {
                extraEntropy
            });
            if (counter > 4294967295) throw new Error('lowR counter overflow: report the error');
        }
    }
    return sig.toDERRawBytes();
}
exports.signSchnorr = secp256k1_1.schnorr.sign;
exports.tagSchnorr = secp256k1_1.schnorr.utils.taggedHash;
var PubT;
(function(PubT) {
    PubT[PubT["ecdsa"] = 0] = "ecdsa";
    PubT[PubT["schnorr"] = 1] = "schnorr";
})(PubT || (exports.PubT = PubT = {}));
function validatePubkey(pub, type) {
    const len = pub.length;
    if (type === PubT.ecdsa) {
        if (len === 32) throw new Error('Expected non-Schnorr key');
        Point.fromHex(pub); // does assertValidity
        return pub;
    } else if (type === PubT.schnorr) {
        if (len !== 32) throw new Error('Expected 32-byte Schnorr key');
        secp256k1_1.schnorr.utils.lift_x(secp256k1_1.schnorr.utils.bytesToNumberBE(pub));
        return pub;
    } else {
        throw new Error('Unknown key type');
    }
}
function tapTweak(a, b) {
    const u = secp256k1_1.schnorr.utils;
    const t = u.taggedHash('TapTweak', a, b);
    const tn = u.bytesToNumberBE(t);
    if (tn >= CURVE_ORDER) throw new Error('tweak higher than curve order');
    return tn;
}
function taprootTweakPrivKey(privKey) {
    let merkleRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Uint8Array();
    const u = secp256k1_1.schnorr.utils;
    const seckey0 = u.bytesToNumberBE(privKey); // seckey0 = int_from_bytes(seckey0)
    const P = Point.fromPrivateKey(seckey0); // P = point_mul(G, seckey0)
    // seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0
    const seckey = P.hasEvenY() ? seckey0 : u.mod(-seckey0, CURVE_ORDER);
    const xP = u.pointToBytes(P);
    // t = int_from_bytes(tagged_hash("TapTweak", bytes_from_int(x(P)) + h)); >= SECP256K1_ORDER check
    const t = tapTweak(xP, merkleRoot);
    // bytes_from_int((seckey + t) % SECP256K1_ORDER)
    return u.numberToBytesBE(u.mod(seckey + t, CURVE_ORDER), 32);
}
function taprootTweakPubkey(pubKey, h) {
    const u = secp256k1_1.schnorr.utils;
    const t = tapTweak(pubKey, h); // t = int_from_bytes(tagged_hash("TapTweak", pubkey + h))
    const P = u.lift_x(u.bytesToNumberBE(pubKey)); // P = lift_x(int_from_bytes(pubkey))
    const Q = P.add(Point.fromPrivateKey(t)); // Q = point_add(P, point_mul(G, t))
    const parity = Q.hasEvenY() ? 0 : 1; // 0 if has_even_y(Q) else 1
    return [
        u.pointToBytes(Q),
        parity
    ]; // bytes_from_int(x(Q))
}
// Another stupid decision, where lack of standard affects security.
// Multisig needs to be generated with some key.
// We are using approach from BIP 341/bitcoinjs-lib: SHA256(uncompressedDER(SECP256K1_GENERATOR_POINT))
// It is possible to switch SECP256K1_GENERATOR_POINT with some random point;
// but it's too complex to prove.
// Also used by bitcoin-core and bitcoinjs-lib
exports.TAPROOT_UNSPENDABLE_KEY = (0, sha256_1.sha256)(Point.BASE.toRawBytes(false));
exports.NETWORK = {
    bech32: 'bc',
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
};
exports.TEST_NETWORK = {
    bech32: 'tb',
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};
// Exported for tests, internal method
function compareBytes(a, b) {
    if (!isBytes(a) || !isBytes(b)) throw new Error("cmp: wrong type a=".concat(typeof a, " b=").concat(typeof b));
    // -1 -> a<b, 0 -> a==b, 1 -> a>b
    const len = Math.min(a.length, b.length);
    for(let i = 0; i < len; i++)if (a[i] != b[i]) return Math.sign(a[i] - b[i]);
    return Math.sign(a.length - b.length);
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@scure/btc-signer/script.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RawOldTx = exports.RawTx = exports.RawOutput = exports.RawInput = exports.BTCArray = exports.RawWitness = exports.VarBytes = exports.CompactSizeLen = exports.CompactSize = exports.Script = exports.OP = exports.MAX_SCRIPT_BYTE_LENGTH = void 0;
exports.ScriptNum = ScriptNum;
exports.OpToNum = OpToNum;
const P = __turbopack_context__.r("[project]/node_modules/micro-packed/lib/index.js [app-client] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
exports.MAX_SCRIPT_BYTE_LENGTH = 520;
// prettier-ignore
var OP;
(function(OP) {
    OP[OP["OP_0"] = 0] = "OP_0";
    OP[OP["PUSHDATA1"] = 76] = "PUSHDATA1";
    OP[OP["PUSHDATA2"] = 77] = "PUSHDATA2";
    OP[OP["PUSHDATA4"] = 78] = "PUSHDATA4";
    OP[OP["1NEGATE"] = 79] = "1NEGATE";
    OP[OP["RESERVED"] = 80] = "RESERVED";
    OP[OP["OP_1"] = 81] = "OP_1";
    OP[OP["OP_2"] = 82] = "OP_2";
    OP[OP["OP_3"] = 83] = "OP_3";
    OP[OP["OP_4"] = 84] = "OP_4";
    OP[OP["OP_5"] = 85] = "OP_5";
    OP[OP["OP_6"] = 86] = "OP_6";
    OP[OP["OP_7"] = 87] = "OP_7";
    OP[OP["OP_8"] = 88] = "OP_8";
    OP[OP["OP_9"] = 89] = "OP_9";
    OP[OP["OP_10"] = 90] = "OP_10";
    OP[OP["OP_11"] = 91] = "OP_11";
    OP[OP["OP_12"] = 92] = "OP_12";
    OP[OP["OP_13"] = 93] = "OP_13";
    OP[OP["OP_14"] = 94] = "OP_14";
    OP[OP["OP_15"] = 95] = "OP_15";
    OP[OP["OP_16"] = 96] = "OP_16";
    // Control
    OP[OP["NOP"] = 97] = "NOP";
    OP[OP["VER"] = 98] = "VER";
    OP[OP["IF"] = 99] = "IF";
    OP[OP["NOTIF"] = 100] = "NOTIF";
    OP[OP["VERIF"] = 101] = "VERIF";
    OP[OP["VERNOTIF"] = 102] = "VERNOTIF";
    OP[OP["ELSE"] = 103] = "ELSE";
    OP[OP["ENDIF"] = 104] = "ENDIF";
    OP[OP["VERIFY"] = 105] = "VERIFY";
    OP[OP["RETURN"] = 106] = "RETURN";
    // Stack
    OP[OP["TOALTSTACK"] = 107] = "TOALTSTACK";
    OP[OP["FROMALTSTACK"] = 108] = "FROMALTSTACK";
    OP[OP["2DROP"] = 109] = "2DROP";
    OP[OP["2DUP"] = 110] = "2DUP";
    OP[OP["3DUP"] = 111] = "3DUP";
    OP[OP["2OVER"] = 112] = "2OVER";
    OP[OP["2ROT"] = 113] = "2ROT";
    OP[OP["2SWAP"] = 114] = "2SWAP";
    OP[OP["IFDUP"] = 115] = "IFDUP";
    OP[OP["DEPTH"] = 116] = "DEPTH";
    OP[OP["DROP"] = 117] = "DROP";
    OP[OP["DUP"] = 118] = "DUP";
    OP[OP["NIP"] = 119] = "NIP";
    OP[OP["OVER"] = 120] = "OVER";
    OP[OP["PICK"] = 121] = "PICK";
    OP[OP["ROLL"] = 122] = "ROLL";
    OP[OP["ROT"] = 123] = "ROT";
    OP[OP["SWAP"] = 124] = "SWAP";
    OP[OP["TUCK"] = 125] = "TUCK";
    // Splice
    OP[OP["CAT"] = 126] = "CAT";
    OP[OP["SUBSTR"] = 127] = "SUBSTR";
    OP[OP["LEFT"] = 128] = "LEFT";
    OP[OP["RIGHT"] = 129] = "RIGHT";
    OP[OP["SIZE"] = 130] = "SIZE";
    // Boolean logic
    OP[OP["INVERT"] = 131] = "INVERT";
    OP[OP["AND"] = 132] = "AND";
    OP[OP["OR"] = 133] = "OR";
    OP[OP["XOR"] = 134] = "XOR";
    OP[OP["EQUAL"] = 135] = "EQUAL";
    OP[OP["EQUALVERIFY"] = 136] = "EQUALVERIFY";
    OP[OP["RESERVED1"] = 137] = "RESERVED1";
    OP[OP["RESERVED2"] = 138] = "RESERVED2";
    // Numbers
    OP[OP["1ADD"] = 139] = "1ADD";
    OP[OP["1SUB"] = 140] = "1SUB";
    OP[OP["2MUL"] = 141] = "2MUL";
    OP[OP["2DIV"] = 142] = "2DIV";
    OP[OP["NEGATE"] = 143] = "NEGATE";
    OP[OP["ABS"] = 144] = "ABS";
    OP[OP["NOT"] = 145] = "NOT";
    OP[OP["0NOTEQUAL"] = 146] = "0NOTEQUAL";
    OP[OP["ADD"] = 147] = "ADD";
    OP[OP["SUB"] = 148] = "SUB";
    OP[OP["MUL"] = 149] = "MUL";
    OP[OP["DIV"] = 150] = "DIV";
    OP[OP["MOD"] = 151] = "MOD";
    OP[OP["LSHIFT"] = 152] = "LSHIFT";
    OP[OP["RSHIFT"] = 153] = "RSHIFT";
    OP[OP["BOOLAND"] = 154] = "BOOLAND";
    OP[OP["BOOLOR"] = 155] = "BOOLOR";
    OP[OP["NUMEQUAL"] = 156] = "NUMEQUAL";
    OP[OP["NUMEQUALVERIFY"] = 157] = "NUMEQUALVERIFY";
    OP[OP["NUMNOTEQUAL"] = 158] = "NUMNOTEQUAL";
    OP[OP["LESSTHAN"] = 159] = "LESSTHAN";
    OP[OP["GREATERTHAN"] = 160] = "GREATERTHAN";
    OP[OP["LESSTHANOREQUAL"] = 161] = "LESSTHANOREQUAL";
    OP[OP["GREATERTHANOREQUAL"] = 162] = "GREATERTHANOREQUAL";
    OP[OP["MIN"] = 163] = "MIN";
    OP[OP["MAX"] = 164] = "MAX";
    OP[OP["WITHIN"] = 165] = "WITHIN";
    // Crypto
    OP[OP["RIPEMD160"] = 166] = "RIPEMD160";
    OP[OP["SHA1"] = 167] = "SHA1";
    OP[OP["SHA256"] = 168] = "SHA256";
    OP[OP["HASH160"] = 169] = "HASH160";
    OP[OP["HASH256"] = 170] = "HASH256";
    OP[OP["CODESEPARATOR"] = 171] = "CODESEPARATOR";
    OP[OP["CHECKSIG"] = 172] = "CHECKSIG";
    OP[OP["CHECKSIGVERIFY"] = 173] = "CHECKSIGVERIFY";
    OP[OP["CHECKMULTISIG"] = 174] = "CHECKMULTISIG";
    OP[OP["CHECKMULTISIGVERIFY"] = 175] = "CHECKMULTISIGVERIFY";
    // Expansion
    OP[OP["NOP1"] = 176] = "NOP1";
    OP[OP["CHECKLOCKTIMEVERIFY"] = 177] = "CHECKLOCKTIMEVERIFY";
    OP[OP["CHECKSEQUENCEVERIFY"] = 178] = "CHECKSEQUENCEVERIFY";
    OP[OP["NOP4"] = 179] = "NOP4";
    OP[OP["NOP5"] = 180] = "NOP5";
    OP[OP["NOP6"] = 181] = "NOP6";
    OP[OP["NOP7"] = 182] = "NOP7";
    OP[OP["NOP8"] = 183] = "NOP8";
    OP[OP["NOP9"] = 184] = "NOP9";
    OP[OP["NOP10"] = 185] = "NOP10";
    // BIP 342
    OP[OP["CHECKSIGADD"] = 186] = "CHECKSIGADD";
    // Invalid
    OP[OP["INVALID"] = 255] = "INVALID";
})(OP || (exports.OP = OP = {}));
// We can encode almost any number as ScriptNum, however, parsing will be a problem
// since we can't know if buffer is a number or something else.
function ScriptNum() {
    let bytesLimit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 6, forceMinimal = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return P.wrap({
        encodeStream: (w, value)=>{
            if (value === 0n) return;
            const neg = value < 0;
            const val = BigInt(value);
            const nums = [];
            for(let abs = neg ? -val : val; abs; abs >>= 8n)nums.push(Number(abs & 0xffn));
            if (nums[nums.length - 1] >= 0x80) nums.push(neg ? 0x80 : 0);
            else if (neg) nums[nums.length - 1] |= 0x80;
            w.bytes(new Uint8Array(nums));
        },
        decodeStream: (r)=>{
            const len = r.leftBytes;
            if (len > bytesLimit) throw new Error("ScriptNum: number (".concat(len, ") bigger than limit=").concat(bytesLimit));
            if (len === 0) return 0n;
            if (forceMinimal) {
                const data = r.bytes(len, true);
                // MSB is zero (without sign bit) -> not minimally encoded
                if ((data[data.length - 1] & 0x7f) === 0) {
                    // exception
                    if (len <= 1 || (data[data.length - 2] & 0x80) === 0) throw new Error('Non-minimally encoded ScriptNum');
                }
            }
            let last = 0;
            let res = 0n;
            for(let i = 0; i < len; ++i){
                last = r.byte();
                res |= BigInt(last) << 8n * BigInt(i);
            }
            if (last >= 0x80) {
                res &= 2n ** BigInt(len * 8) - 1n >> 1n;
                res = -res;
            }
            return res;
        }
    });
}
function OpToNum(op) {
    let bytesLimit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4, forceMinimal = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (typeof op === 'number') return op;
    if ((0, utils_js_1.isBytes)(op)) {
        try {
            const val = ScriptNum(bytesLimit, forceMinimal).decode(op);
            if (val > Number.MAX_SAFE_INTEGER) return;
            return Number(val);
        } catch (e) {
            return;
        }
    }
    return;
}
// Converts script bytes to parsed script
// 5221030000000000000000000000000000000000000000000000000000000000000001210300000000000000000000000000000000000000000000000000000000000000022103000000000000000000000000000000000000000000000000000000000000000353ae
// =>
// OP_2
//   030000000000000000000000000000000000000000000000000000000000000001
//   030000000000000000000000000000000000000000000000000000000000000002
//   030000000000000000000000000000000000000000000000000000000000000003
//   OP_3
//   CHECKMULTISIG
exports.Script = P.wrap({
    encodeStream: (w, value)=>{
        for (let o of value){
            if (typeof o === 'string') {
                if (OP[o] === undefined) throw new Error("Unknown opcode=".concat(o));
                w.byte(OP[o]);
                continue;
            } else if (typeof o === 'number') {
                if (o === 0x00) {
                    w.byte(0x00);
                    continue;
                } else if (1 <= o && o <= 16) {
                    w.byte(OP.OP_1 - 1 + o);
                    continue;
                }
            }
            // Encode big numbers
            if (typeof o === 'number') o = ScriptNum().encode(BigInt(o));
            if (!(0, utils_js_1.isBytes)(o)) throw new Error("Wrong Script OP=".concat(o, " (").concat(typeof o, ")"));
            // Bytes
            const len = o.length;
            if (len < OP.PUSHDATA1) w.byte(len);
            else if (len <= 0xff) {
                w.byte(OP.PUSHDATA1);
                w.byte(len);
            } else if (len <= 0xffff) {
                w.byte(OP.PUSHDATA2);
                w.bytes(P.U16LE.encode(len));
            } else {
                w.byte(OP.PUSHDATA4);
                w.bytes(P.U32LE.encode(len));
            }
            w.bytes(o);
        }
    },
    decodeStream: (r)=>{
        const out = [];
        while(!r.isEnd()){
            const cur = r.byte();
            // if 0 < cur < 78
            if (OP.OP_0 < cur && cur <= OP.PUSHDATA4) {
                let len;
                if (cur < OP.PUSHDATA1) len = cur;
                else if (cur === OP.PUSHDATA1) len = P.U8.decodeStream(r);
                else if (cur === OP.PUSHDATA2) len = P.U16LE.decodeStream(r);
                else if (cur === OP.PUSHDATA4) len = P.U32LE.decodeStream(r);
                else throw new Error('Should be not possible');
                out.push(r.bytes(len));
            } else if (cur === 0x00) {
                out.push(0);
            } else if (OP.OP_1 <= cur && cur <= OP.OP_16) {
                out.push(cur - (OP.OP_1 - 1));
            } else {
                const op = OP[cur];
                if (op === undefined) throw new Error("Unknown opcode=".concat(cur.toString(16)));
                out.push(op);
            }
        }
        return out;
    }
});
// BTC specific variable length integer encoding
// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer
const CSLimits = {
    0xfd: [
        0xfd,
        2,
        253n,
        65535n
    ],
    0xfe: [
        0xfe,
        4,
        65536n,
        4294967295n
    ],
    0xff: [
        0xff,
        8,
        4294967296n,
        18446744073709551615n
    ]
};
exports.CompactSize = P.wrap({
    encodeStream: (w, value)=>{
        if (typeof value === 'number') value = BigInt(value);
        if (0n <= value && value <= 252n) return w.byte(Number(value));
        for (const [flag, bytes, start, stop] of Object.values(CSLimits)){
            if (start > value || value > stop) continue;
            w.byte(flag);
            for(let i = 0; i < bytes; i++)w.byte(Number(value >> 8n * BigInt(i) & 0xffn));
            return;
        }
        throw w.err("VarInt too big: ".concat(value));
    },
    decodeStream: (r)=>{
        const b0 = r.byte();
        if (b0 <= 0xfc) return BigInt(b0);
        const [_, bytes, start] = CSLimits[b0];
        let num = 0n;
        for(let i = 0; i < bytes; i++)num |= BigInt(r.byte()) << 8n * BigInt(i);
        if (num < start) throw r.err("Wrong CompactSize(".concat(8 * bytes, ")"));
        return num;
    }
});
// Same thing, but in number instead of bigint. Checks for safe integer inside
exports.CompactSizeLen = P.apply(exports.CompactSize, P.coders.numberBigint);
// ui8a of size <CompactSize>
exports.VarBytes = P.bytes(exports.CompactSize);
// SegWit v0 stack of witness buffers
exports.RawWitness = P.array(exports.CompactSizeLen, exports.VarBytes);
// Array of size <CompactSize>
const BTCArray = (t)=>P.array(exports.CompactSize, t);
exports.BTCArray = BTCArray;
exports.RawInput = P.struct({
    txid: P.bytes(32, true),
    index: P.U32LE,
    finalScriptSig: exports.VarBytes,
    sequence: P.U32LE
});
exports.RawOutput = P.struct({
    amount: P.U64LE,
    script: exports.VarBytes
});
// https://en.bitcoin.it/wiki/Protocol_documentation#tx
const _RawTx = P.struct({
    version: P.I32LE,
    segwitFlag: P.flag(new Uint8Array([
        0x00,
        0x01
    ])),
    inputs: (0, exports.BTCArray)(exports.RawInput),
    outputs: (0, exports.BTCArray)(exports.RawOutput),
    witnesses: P.flagged('segwitFlag', P.array('inputs/length', exports.RawWitness)),
    // < 500000000	Block number at which this transaction is unlocked
    // >= 500000000	UNIX timestamp at which this transaction is unlocked
    // Handled as part of PSBTv2
    lockTime: P.U32LE
});
function validateRawTx(tx) {
    if (tx.segwitFlag && tx.witnesses && !tx.witnesses.length) throw new Error('Segwit flag with empty witnesses array');
    return tx;
}
exports.RawTx = P.validate(_RawTx, validateRawTx);
// Pre-SegWit serialization format (for PSBTv0)
exports.RawOldTx = P.struct({
    version: P.I32LE,
    inputs: (0, exports.BTCArray)(exports.RawInput),
    outputs: (0, exports.BTCArray)(exports.RawOutput),
    lockTime: P.U32LE
}); //# sourceMappingURL=script.js.map
}),
"[project]/node_modules/@scure/btc-signer/utxo.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._Estimator = exports._cmpBig = exports.toVsize = void 0;
exports.getPrevOut = getPrevOut;
exports.normalizeInput = normalizeInput;
exports.getInputType = getInputType;
exports.selectUTXO = selectUTXO;
const base_1 = __turbopack_context__.r("[project]/node_modules/@scure/base/lib/index.js [app-client] (ecmascript)");
const P = __turbopack_context__.r("[project]/node_modules/micro-packed/lib/index.js [app-client] (ecmascript)");
const payment_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/payment.js [app-client] (ecmascript)");
const psbt = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/psbt.js [app-client] (ecmascript)");
const script_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/script.js [app-client] (ecmascript)");
const transaction_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/transaction.js [app-client] (ecmascript)"); // circular
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
// Normalizes input
function getPrevOut(input) {
    if (input.nonWitnessUtxo) {
        if (input.index === undefined) throw new Error('Unknown input index');
        return input.nonWitnessUtxo.outputs[input.index];
    } else if (input.witnessUtxo) return input.witnessUtxo;
    else throw new Error('Cannot find previous output info');
}
function normalizeInput(i, cur, allowedFields) {
    let disableScriptCheck = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    let { nonWitnessUtxo, txid } = i;
    // String support for common fields. We usually prefer Uint8Array to avoid errors
    // like hex looking string accidentally passed, however, in case of nonWitnessUtxo
    // it is better to expect string, since constructing this complex object will be
    // difficult for user
    if (typeof nonWitnessUtxo === 'string') nonWitnessUtxo = base_1.hex.decode(nonWitnessUtxo);
    if ((0, utils_js_1.isBytes)(nonWitnessUtxo)) nonWitnessUtxo = script_js_1.RawTx.decode(nonWitnessUtxo);
    if (!('nonWitnessUtxo' in i) && nonWitnessUtxo === undefined) nonWitnessUtxo = cur === null || cur === void 0 ? void 0 : cur.nonWitnessUtxo;
    if (typeof txid === 'string') txid = base_1.hex.decode(txid);
    // TODO: if we have nonWitnessUtxo, we can extract txId from here
    if (txid === undefined) txid = cur === null || cur === void 0 ? void 0 : cur.txid;
    let res = {
        ...cur,
        ...i,
        nonWitnessUtxo,
        txid
    };
    if (!('nonWitnessUtxo' in i) && res.nonWitnessUtxo === undefined) delete res.nonWitnessUtxo;
    if (res.sequence === undefined) res.sequence = transaction_js_1.DEFAULT_SEQUENCE;
    if (res.tapMerkleRoot === null) delete res.tapMerkleRoot;
    res = psbt.mergeKeyMap(psbt.PSBTInput, res, cur, allowedFields);
    psbt.PSBTInputCoder.encode(res); // Validates that everything is correct at this point
    let prevOut;
    if (res.nonWitnessUtxo && res.index !== undefined) prevOut = res.nonWitnessUtxo.outputs[res.index];
    else if (res.witnessUtxo) prevOut = res.witnessUtxo;
    if (prevOut && !disableScriptCheck) (0, payment_js_1.checkScript)(prevOut && prevOut.script, res.redeemScript, res.witnessScript);
    return res;
}
function getInputType(input) {
    let allowLegacyWitnessUtxo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let txType = 'legacy';
    let defaultSighash = transaction_js_1.SignatureHash.ALL;
    const prevOut = getPrevOut(input);
    const first = payment_js_1.OutScript.decode(prevOut.script);
    let type = first.type;
    let cur = first;
    const stack = [
        first
    ];
    if (first.type === 'tr') {
        defaultSighash = transaction_js_1.SignatureHash.DEFAULT;
        return {
            txType: 'taproot',
            type: 'tr',
            last: first,
            lastScript: prevOut.script,
            defaultSighash,
            sighash: input.sighashType || defaultSighash
        };
    } else {
        if (first.type === 'wpkh' || first.type === 'wsh') txType = 'segwit';
        if (first.type === 'sh') {
            if (!input.redeemScript) throw new Error('inputType: sh without redeemScript');
            let child = payment_js_1.OutScript.decode(input.redeemScript);
            if (child.type === 'wpkh' || child.type === 'wsh') txType = 'segwit';
            stack.push(child);
            cur = child;
            type += "-".concat(child.type);
        }
        // wsh can be inside sh
        if (cur.type === 'wsh') {
            if (!input.witnessScript) throw new Error('inputType: wsh without witnessScript');
            let child = payment_js_1.OutScript.decode(input.witnessScript);
            if (child.type === 'wsh') txType = 'segwit';
            stack.push(child);
            cur = child;
            type += "-".concat(child.type);
        }
        const last = stack[stack.length - 1];
        if (last.type === 'sh' || last.type === 'wsh') throw new Error('inputType: sh/wsh cannot be terminal type');
        const lastScript = payment_js_1.OutScript.encode(last);
        const res = {
            type,
            txType,
            last,
            lastScript,
            defaultSighash,
            sighash: input.sighashType || defaultSighash
        };
        if (txType === 'legacy' && !allowLegacyWitnessUtxo && !input.nonWitnessUtxo) {
            throw new Error("Transaction/sign: legacy input without nonWitnessUtxo, can result in attack that forces paying higher fees. Pass allowLegacyWitnessUtxo=true, if you sure");
        }
        return res;
    }
}
const toVsize = (weight)=>Math.ceil(weight / 4);
exports.toVsize = toVsize;
const encodeTapBlock = (item)=>psbt.TaprootControlBlock.encode(item);
function iterLeafs(tapLeafScript, sigSize, customScripts) {
    if (!tapLeafScript || !tapLeafScript.length) throw new Error('no leafs');
    const empty = ()=>new Uint8Array(sigSize);
    // If user want to select specific leaf, which can signed,
    // it is possible to remove all other leafs manually.
    // Sort leafs by control block length.
    const leafs = tapLeafScript.sort((a, b)=>encodeTapBlock(a[0]).length - encodeTapBlock(b[0]).length);
    for (const [cb, _script] of leafs){
        // Last byte is version
        const script = _script.slice(0, -1);
        const ver = _script[_script.length - 1];
        const outs = payment_js_1.OutScript.decode(script);
        let signatures = [];
        if (outs.type === 'tr_ms') {
            const m = outs.m;
            const n = outs.pubkeys.length - m;
            for(let i = 0; i < m; i++)signatures.push(empty());
            for(let i = 0; i < n; i++)signatures.push(P.EMPTY);
        } else if (outs.type === 'tr_ns') {
            for (const _pub of outs.pubkeys)signatures.push(empty());
        } else {
            if (!customScripts) throw new Error('Finalize: Unknown tapLeafScript');
            const leafHash = (0, payment_js_1.tapLeafHash)(script, ver);
            for (const c of customScripts){
                if (!c.finalizeTaproot) continue;
                const scriptDecoded = script_js_1.Script.decode(script);
                const csEncoded = c.encode(scriptDecoded);
                if (csEncoded === undefined) continue;
                const pubKeys = scriptDecoded.filter((i)=>{
                    if (!(0, utils_js_1.isBytes)(i)) return false;
                    try {
                        (0, utils_js_1.validatePubkey)(i, utils_js_1.PubT.schnorr);
                        return true;
                    } catch (e) {
                        return false;
                    }
                });
                const finalized = c.finalizeTaproot(script, csEncoded, pubKeys.map((pubKey)=>[
                        {
                            pubKey,
                            leafHash
                        },
                        empty()
                    ]));
                if (!finalized) continue;
                return finalized.concat(encodeTapBlock(cb));
            }
        }
        // Witness is stack, so last element will be used first
        return signatures.reverse().concat([
            script,
            encodeTapBlock(cb)
        ]);
    }
    throw new Error('there was no witness');
}
function estimateInput(inputType, input, opts) {
    let script = P.EMPTY;
    let witness;
    // schnorr sig is always 64 bytes. except for cases when sighash is not default!
    if (inputType.txType === 'taproot') {
        const SCHNORR_SIG_SIZE = inputType.sighash !== transaction_js_1.SignatureHash.DEFAULT ? 65 : 64;
        if (input.tapInternalKey && !(0, utils_js_1.equalBytes)(input.tapInternalKey, utils_js_1.TAPROOT_UNSPENDABLE_KEY)) {
            witness = [
                new Uint8Array(SCHNORR_SIG_SIZE)
            ];
        } else if (input.tapLeafScript) {
            witness = iterLeafs(input.tapLeafScript, SCHNORR_SIG_SIZE, opts.customScripts);
        } else throw new Error('estimateInput/taproot: unknown input');
    } else {
        // It is possible to grind signatures until it has minimal size (but changing fee value +N satoshi),
        // which will make estimations exact. But will be very hard for multi sig (need to make sure all signatures has small size).
        const empty = ()=>new Uint8Array(72); // max size of sigs
        const emptyPub = ()=>new Uint8Array(33); // size of pubkey
        let inputScript = P.EMPTY;
        let inputWitness = [];
        const ltype = inputType.last.type;
        if (ltype === 'ms') {
            const m = inputType.last.m;
            const sig = [
                0
            ];
            for(let i = 0; i < m; i++)sig.push(empty());
            inputScript = script_js_1.Script.encode(sig);
        } else if (ltype === 'pk') {
            // 71 sig + 1 sighash
            inputScript = script_js_1.Script.encode([
                empty()
            ]);
        } else if (ltype === 'pkh') {
            inputScript = script_js_1.Script.encode([
                empty(),
                emptyPub()
            ]);
        } else if (ltype === 'wpkh') {
            inputScript = P.EMPTY;
            inputWitness = [
                empty(),
                emptyPub()
            ];
        } else if (ltype === 'unknown' && !opts.allowUnknownInputs) throw new Error('Unknown inputs are not allowed');
        if (inputType.type.includes('wsh-')) {
            // P2WSH
            if (inputScript.length && inputType.lastScript.length) {
                inputWitness = script_js_1.Script.decode(inputScript).map((i)=>{
                    if (i === 0) return P.EMPTY;
                    if ((0, utils_js_1.isBytes)(i)) return i;
                    throw new Error("Wrong witness op=".concat(i));
                });
            }
            inputWitness = inputWitness.concat(inputType.lastScript);
        }
        if (inputType.txType === 'segwit') witness = inputWitness;
        if (inputType.type.startsWith('sh-wsh-')) {
            script = script_js_1.Script.encode([
                script_js_1.Script.encode([
                    0,
                    new Uint8Array(utils_js_1.sha256.outputLen)
                ])
            ]);
        } else if (inputType.type.startsWith('sh-')) {
            script = script_js_1.Script.encode([
                ...script_js_1.Script.decode(inputScript),
                inputType.lastScript
            ]);
        } else if (inputType.type.startsWith('wsh-')) {} else if (inputType.txType !== 'segwit') script = inputScript;
    }
    let weight = 160 + 4 * script_js_1.VarBytes.encode(script).length;
    let hasWitnesses = false;
    if (witness) {
        weight += script_js_1.RawWitness.encode(witness).length;
        hasWitnesses = true;
    }
    return {
        weight,
        hasWitnesses
    };
}
// Exported for tests, internal method
const _cmpBig = (a, b)=>{
    const n = a - b;
    if (n < 0n) return -1;
    else if (n > 0n) return 1;
    return 0;
};
exports._cmpBig = _cmpBig;
function getScript(o) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, network = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : utils_js_1.NETWORK;
    let script;
    if ('script' in o && (0, utils_js_1.isBytes)(o.script)) {
        script = o.script;
    }
    if ('address' in o) {
        if (typeof o.address !== 'string') throw new Error("Estimator: wrong output address=".concat(o.address));
        script = payment_js_1.OutScript.encode((0, payment_js_1.Address)(network).decode(o.address));
    }
    if (!script) throw new Error('Estimator: wrong output script');
    if (typeof o.amount !== 'bigint') throw new Error("Estimator: wrong output amount=".concat(o.amount, ", should be of type bigint but got ").concat(typeof o.amount, "."));
    if (script && !opts.allowUnknownOutputs && payment_js_1.OutScript.decode(script).type === 'unknown') {
        throw new Error('Estimator: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');
    }
    if (!opts.disableScriptCheck) (0, payment_js_1.checkScript)(script);
    return script;
}
// class, because we need to re-use normalized inputs, instead of parsing each time
// internal stuff, exported for tests only
class _Estimator {
    checkInputIdx(idx) {
        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.normalizedInputs.length) throw new Error("Wrong input index=".concat(idx));
        return idx;
    }
    sortIndices(indices) {
        return indices.slice().sort((a, b)=>{
            const ai = this.normalizedInputs[this.checkInputIdx(a)];
            const bi = this.normalizedInputs[this.checkInputIdx(b)];
            const out = (0, utils_js_1.compareBytes)(ai.normalized.txid, bi.normalized.txid);
            if (out !== 0) return out;
            return ai.normalized.index - bi.normalized.index;
        });
    }
    sortOutputs(outputs) {
        const scripts = outputs.map((o)=>getScript(o, this.opts, this.opts.network));
        const indices = outputs.map((_, j)=>j);
        return indices.sort((a, b)=>{
            const aa = outputs[a].amount;
            const ba = outputs[b].amount;
            const out = (0, exports._cmpBig)(aa, ba);
            if (out !== 0) return out;
            return (0, utils_js_1.compareBytes)(scripts[a], scripts[b]);
        });
    }
    getSatoshi(weigth) {
        return this.opts.feePerByte * BigInt((0, exports.toVsize)(weigth));
    }
    // Sort by value instead of amount
    get biggest() {
        return this.normalizedInputs.map((_i, j)=>j).sort((a, b)=>(0, exports._cmpBig)(this.normalizedInputs[b].value, this.normalizedInputs[a].value));
    }
    get smallest() {
        return this.biggest.reverse();
    }
    // These assume that UTXO array has historical order.
    // Otherwise, we have no way to know which tx is oldest
    // Explorers usually give UTXO in this order.
    get oldest() {
        return this.normalizedInputs.map((_i, j)=>j);
    }
    get newest() {
        return this.oldest.reverse();
    }
    // exact - like blackjack from coinselect.
    // exact(biggest) will select one big utxo which is closer to targetValue+dust, if possible.
    // If not, it will accumulate largest utxo until value is close to targetValue+dust.
    accumulate(indices) {
        let exact = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, skipNegative = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true, all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        // TODO: how to handle change addresses?
        // - cost of input
        // - cost of change output (if input requires change)
        // - cost of output spending
        // Dust threshold should be significantly bigger, no point in
        // creating an output, which cannot be spent.
        // coinselect doesn't consider cost of output address for dust.
        // Changing that can actually reduce privacy
        let weight = this.opts.alwaysChange ? this.changeWeight : this.baseWeight;
        let hasWitnesses = false;
        let num = 0;
        let inputsAmount = 0n;
        const targetAmount = this.amount;
        const res = [];
        let fee;
        for (const idx of this.requiredIndices){
            this.checkInputIdx(idx);
            const { estimate, amount } = this.normalizedInputs[idx];
            let newWeight = weight + estimate.weight;
            if (!hasWitnesses && estimate.hasWitnesses) newWeight += 2; // enable witness if needed
            const totalWeight = newWeight + 4 * script_js_1.CompactSizeLen.encode(num).length; // number of outputs can change weight
            fee = this.getSatoshi(totalWeight);
            weight = newWeight;
            if (estimate.hasWitnesses) hasWitnesses = true;
            num++;
            inputsAmount += amount;
            res.push(idx);
            // inputsAmount is enough to cover cost of tx
            if (!all && targetAmount + fee <= inputsAmount) return {
                indices: res,
                fee,
                weight: totalWeight,
                total: inputsAmount
            };
        }
        for (const idx of indices){
            this.checkInputIdx(idx);
            const { estimate, amount, value } = this.normalizedInputs[idx];
            let newWeight = weight + estimate.weight;
            if (!hasWitnesses && estimate.hasWitnesses) newWeight += 2; // enable witness if needed
            const totalWeight = newWeight + 4 * script_js_1.CompactSizeLen.encode(num).length; // number of outputs can change weight
            fee = this.getSatoshi(totalWeight);
            // Best case scenario exact(biggest) -> we find biggest output, less than target+threshold
            if (exact && amount + inputsAmount > targetAmount + fee + this.dust) continue; // skip if added value is bigger than dust
            // Negative: cost of using input is more than value provided (negative)
            // By default 'blackjack' mode in coinselect doesn't use that, which means
            // it will use negative output if sorted by 'smallest'
            if (skipNegative && value <= 0n) continue;
            weight = newWeight;
            if (estimate.hasWitnesses) hasWitnesses = true;
            num++;
            inputsAmount += amount;
            res.push(idx);
            // inputsAmount is enough to cover cost of tx
            if (!all && targetAmount + fee <= inputsAmount) return {
                indices: res,
                fee,
                weight: totalWeight,
                total: inputsAmount
            };
        }
        if (all) {
            const newWeight = weight + 4 * script_js_1.CompactSizeLen.encode(num).length;
            return {
                indices: res,
                fee,
                weight: newWeight,
                total: inputsAmount
            };
        }
        return undefined;
    }
    // Works like coinselect default method
    default() {
        const { biggest } = this;
        const exact = this.accumulate(biggest, true, false);
        if (exact) return exact;
        return this.accumulate(biggest);
    }
    select(strategy) {
        if (strategy === 'all') {
            return this.accumulate(this.normalizedInputs.map((_, j)=>j), false, true, true);
        }
        if (strategy === 'default') return this.default();
        const data = {
            Oldest: ()=>this.oldest,
            Newest: ()=>this.newest,
            Smallest: ()=>this.smallest,
            Biggest: ()=>this.biggest
        };
        if (strategy.startsWith('exact')) {
            const [exactData, left] = strategy.slice(5).split('/');
            if (!data[exactData]) throw new Error("Estimator.select: wrong strategy=".concat(strategy));
            strategy = left;
            const exact = this.accumulate(data[exactData](), true, true);
            if (exact) return exact;
        }
        if (strategy.startsWith('accum')) {
            const accumData = strategy.slice(5);
            if (!data[accumData]) throw new Error("Estimator.select: wrong strategy=".concat(strategy));
            return this.accumulate(data[accumData]());
        }
        throw new Error("Estimator.select: wrong strategy=".concat(strategy));
    }
    result(strategy) {
        const s = this.select(strategy);
        if (!s) return;
        const { indices, weight, total } = s;
        let needChange = this.opts.alwaysChange;
        const changeWeight = this.opts.alwaysChange ? weight : weight + (this.changeWeight - this.baseWeight);
        const changeFee = this.getSatoshi(changeWeight);
        let fee = s.fee;
        const change = total - this.amount - changeFee;
        if (change > this.dust) needChange = true;
        let inputs = indices;
        let outputs = Array.from(this.outputs);
        if (needChange) {
            fee = changeFee;
            // this shouldn't happen!
            if (change < 0n) throw new Error("Estimator.result: negative change=".concat(change));
            outputs.push({
                address: this.opts.changeAddress,
                amount: change
            });
        }
        if (this.opts.bip69) {
            inputs = this.sortIndices(inputs);
            outputs = this.sortOutputs(outputs).map((i)=>outputs[i]);
        }
        const res = {
            inputs: inputs.map((i)=>this.normalizedInputs[i].normalized),
            outputs,
            fee,
            weight: this.opts.alwaysChange ? s.weight : changeWeight,
            change: !!needChange
        };
        let tx;
        if (this.opts.createTx) {
            const { inputs, outputs } = res;
            tx = new transaction_js_1.Transaction(this.opts);
            for (const i of inputs)tx.addInput(i);
            for (const o of outputs)tx.addOutput({
                ...o,
                script: getScript(o, this.opts, this.opts.network)
            });
        }
        return Object.assign(res, {
            tx
        });
    // return { ...res, tx: tx };
    }
    constructor(inputs, outputs, opts){
        this.outputs = outputs;
        this.opts = opts;
        this.requiredIndices = [];
        if (typeof opts.feePerByte !== 'bigint') throw new Error("Estimator: wrong feePerByte=".concat(opts.feePerByte, ", should be of type bigint but got ").concat(typeof opts.feePerByte, "."));
        // Dust stuff
        // TODO: think about this more:
        // - current dust filters tx which cannot be relayed by core
        // - but actual dust meaning is 'can be this amount spent?'
        // - dust contains full tx size. but we can use other inputs to pay for outputDust (and parially inputsDust)?
        // - not sure if we can spent anything with feePerByte: 3. It will be relayed, but will it be mined?
        // - for now it works exactly as bitcoin-core. But will create change/outputs which cannot be spent (reasonable).
        // Number of bytes needed to create and spend a UTXO.
        // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.cpp#L28-L41
        const inputsDust = 32 + 4 + 1 + 107 + 4; // NOTE: can be smaller for segwit tx?
        const outputDust = 34; // NOTE: 'nSize = GetSerializeSize(txout)'
        const dustBytes = opts.dust === undefined ? BigInt(inputsDust + outputDust) : opts.dust;
        if (typeof dustBytes !== 'bigint') {
            throw new Error("Estimator: wrong dust=".concat(opts.dust, ", should be of type bigint but got ").concat(typeof opts.dust, "."));
        }
        // 3 sat/vb is the default minimum fee rate used to calculate dust thresholds by bitcoin core.
        // 3000 sat/kvb -> 3 sat/vb.
        // https://github.com/bitcoin/bitcoin/blob/27a770b34b8f1dbb84760f442edb3e23a0c2420b/src/policy/policy.h#L55
        const dustFee = opts.dustRelayFeeRate === undefined ? 3n : opts.dustRelayFeeRate;
        if (typeof dustFee !== 'bigint') {
            throw new Error("Estimator: wrong dustRelayFeeRate=".concat(opts.dustRelayFeeRate, ", should be of type bigint but got ").concat(typeof opts.dustRelayFeeRate, "."));
        }
        // Dust uses feePerbyte by default, but we allow separate dust fee if needed
        this.dust = dustBytes * dustFee;
        if (opts.requiredInputs !== undefined && !Array.isArray(opts.requiredInputs)) throw new Error("Estimator: wrong required inputs=".concat(opts.requiredInputs));
        const network = opts.network || utils_js_1.NETWORK;
        let amount = 0n;
        // Base weight: tx with outputs, no inputs
        let baseWeight = 32;
        for (const o of outputs){
            const script = getScript(o, opts, opts.network);
            baseWeight += 32 + 4 * script_js_1.VarBytes.encode(script).length;
            amount += o.amount;
        }
        if (typeof opts.changeAddress !== 'string') throw new Error("Estimator: wrong change address=".concat(opts.changeAddress));
        let changeWeight = baseWeight + 32 + 4 * script_js_1.VarBytes.encode(payment_js_1.OutScript.encode((0, payment_js_1.Address)(network).decode(opts.changeAddress))).length;
        baseWeight += 4 * script_js_1.CompactSizeLen.encode(outputs.length).length;
        // If there a lot of outputs change can change fee
        changeWeight += 4 * script_js_1.CompactSizeLen.encode(outputs.length + 1).length;
        this.baseWeight = baseWeight;
        this.changeWeight = changeWeight;
        this.amount = amount;
        const allInputs = Array.from(inputs);
        if (opts.requiredInputs) {
            for(let i = 0; i < opts.requiredInputs.length; i++)this.requiredIndices.push(allInputs.push(opts.requiredInputs[i]) - 1);
        }
        const inputKeys = new Set();
        this.normalizedInputs = allInputs.map((i)=>{
            const normalized = normalizeInput(i, undefined, undefined, opts.disableScriptCheck);
            (0, transaction_js_1.inputBeforeSign)(normalized); // check fields
            const key = "".concat(base_1.hex.encode(normalized.txid), ":").concat(normalized.index);
            if (!opts.allowSameUtxo && inputKeys.has(key)) throw new Error("Estimator: same input passed multiple times: ".concat(key));
            inputKeys.add(key);
            const inputType = getInputType(normalized, opts.allowLegacyWitnessUtxo);
            const prev = getPrevOut(normalized);
            const estimate = estimateInput(inputType, normalized, this.opts);
            const value = prev.amount - opts.feePerByte * BigInt((0, exports.toVsize)(estimate.weight)); // value = amount-fee
            return {
                inputType,
                normalized,
                amount: prev.amount,
                value,
                estimate
            };
        });
    }
}
exports._Estimator = _Estimator;
function selectUTXO(inputs, outputs, strategy, opts) {
    // Defaults: do we want bip69 by default?
    const _opts = {
        createTx: true,
        bip69: true,
        ...opts
    };
    const est = new _Estimator(inputs, outputs, _opts);
    return est.result(strategy);
} //# sourceMappingURL=utxo.js.map
}),
"[project]/node_modules/@scure/btc-signer/transaction.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Transaction = exports.SigHash = exports.SignatureHash = exports.def = exports.Decimal = exports.DEFAULT_SEQUENCE = exports.DEFAULT_LOCKTIME = exports.DEFAULT_VERSION = exports.PRECISION = void 0;
exports.cloneDeep = cloneDeep;
exports.inputBeforeSign = inputBeforeSign;
exports.PSBTCombine = PSBTCombine;
exports.bip32Path = bip32Path;
const base_1 = __turbopack_context__.r("[project]/node_modules/@scure/base/lib/index.js [app-client] (ecmascript)");
const P = __turbopack_context__.r("[project]/node_modules/micro-packed/lib/index.js [app-client] (ecmascript)");
const payment_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/payment.js [app-client] (ecmascript)");
const psbt = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/psbt.js [app-client] (ecmascript)"); // circular
const script_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/script.js [app-client] (ecmascript)");
const u = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
const utxo_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utxo.js [app-client] (ecmascript)"); // circular
const EMPTY32 = new Uint8Array(32);
const EMPTY_OUTPUT = {
    amount: 0xffffffffffffffffn,
    script: P.EMPTY
};
exports.PRECISION = 8;
exports.DEFAULT_VERSION = 2;
exports.DEFAULT_LOCKTIME = 0;
exports.DEFAULT_SEQUENCE = 4294967295;
exports.Decimal = P.coders.decimal(exports.PRECISION);
// Same as value || def, but doesn't overwrites zero ('0', 0, 0n, etc)
const def = (value, def)=>value === undefined ? def : value;
exports.def = def;
function cloneDeep(obj) {
    if (Array.isArray(obj)) return obj.map((i)=>cloneDeep(i));
    else if ((0, utils_js_1.isBytes)(obj)) return Uint8Array.from(obj);
    else if ([
        'number',
        'bigint',
        'boolean',
        'string',
        'undefined'
    ].includes(typeof obj)) return obj;
    else if (obj === null) return obj;
    else if (typeof obj === 'object') {
        return Object.fromEntries(Object.entries(obj).map((param)=>{
            let [k, v] = param;
            return [
                k,
                cloneDeep(v)
            ];
        }));
    }
    throw new Error("cloneDeep: unknown type=".concat(obj, " (").concat(typeof obj, ")"));
}
/**
 * Internal, exported only for backwards-compat. Use `SigHash` instead.
 * @deprecated
 */ var SignatureHash;
(function(SignatureHash) {
    SignatureHash[SignatureHash["DEFAULT"] = 0] = "DEFAULT";
    SignatureHash[SignatureHash["ALL"] = 1] = "ALL";
    SignatureHash[SignatureHash["NONE"] = 2] = "NONE";
    SignatureHash[SignatureHash["SINGLE"] = 3] = "SINGLE";
    SignatureHash[SignatureHash["ANYONECANPAY"] = 128] = "ANYONECANPAY";
})(SignatureHash || (exports.SignatureHash = SignatureHash = {}));
var SigHash;
(function(SigHash) {
    SigHash[SigHash["DEFAULT"] = 0] = "DEFAULT";
    SigHash[SigHash["ALL"] = 1] = "ALL";
    SigHash[SigHash["NONE"] = 2] = "NONE";
    SigHash[SigHash["SINGLE"] = 3] = "SINGLE";
    SigHash[SigHash["DEFAULT_ANYONECANPAY"] = 128] = "DEFAULT_ANYONECANPAY";
    SigHash[SigHash["ALL_ANYONECANPAY"] = 129] = "ALL_ANYONECANPAY";
    SigHash[SigHash["NONE_ANYONECANPAY"] = 130] = "NONE_ANYONECANPAY";
    SigHash[SigHash["SINGLE_ANYONECANPAY"] = 131] = "SINGLE_ANYONECANPAY";
})(SigHash || (exports.SigHash = SigHash = {}));
function getTaprootKeys(privKey, pubKey, internalKey) {
    let merkleRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : P.EMPTY;
    if ((0, utils_js_1.equalBytes)(internalKey, pubKey)) {
        privKey = u.taprootTweakPrivKey(privKey, merkleRoot);
        pubKey = u.pubSchnorr(privKey);
    }
    return {
        privKey,
        pubKey
    };
}
// Force check amount/script
function outputBeforeSign(i) {
    if (i.script === undefined || i.amount === undefined) throw new Error('Transaction/output: script and amount required');
    return {
        script: i.script,
        amount: i.amount
    };
}
// Force check index/txid/sequence
function inputBeforeSign(i) {
    if (i.txid === undefined || i.index === undefined) throw new Error('Transaction/input: txid and index required');
    return {
        txid: i.txid,
        index: i.index,
        sequence: (0, exports.def)(i.sequence, exports.DEFAULT_SEQUENCE),
        finalScriptSig: (0, exports.def)(i.finalScriptSig, P.EMPTY)
    };
}
function cleanFinalInput(i) {
    for(const _k in i){
        const k = _k;
        if (!psbt.PSBTInputFinalKeys.includes(k)) delete i[k];
    }
}
// (TxHash, Idx)
const TxHashIdx = P.struct({
    txid: P.bytes(32, true),
    index: P.U32LE
});
function validateSigHash(s) {
    if (typeof s !== 'number' || typeof SigHash[s] !== 'string') throw new Error("Invalid SigHash=".concat(s));
    return s;
}
function unpackSighash(hashType) {
    const masked = hashType & 0b0011111;
    return {
        isAny: !!(hashType & SignatureHash.ANYONECANPAY),
        isNone: masked === SignatureHash.NONE,
        isSingle: masked === SignatureHash.SINGLE
    };
}
function validateOpts(opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error("Wrong object type for transaction options: ".concat(opts));
    const _opts = {
        ...opts,
        // Defaults
        version: (0, exports.def)(opts.version, exports.DEFAULT_VERSION),
        lockTime: (0, exports.def)(opts.lockTime, 0),
        PSBTVersion: (0, exports.def)(opts.PSBTVersion, 0)
    };
    if (typeof _opts.allowUnknowInput !== 'undefined') opts.allowUnknownInputs = _opts.allowUnknowInput;
    if (typeof _opts.allowUnknowOutput !== 'undefined') opts.allowUnknownOutputs = _opts.allowUnknowOutput;
    // 0 and -1 happens in tests
    if (![
        -1,
        0,
        1,
        2,
        3
    ].includes(_opts.version)) throw new Error("Unknown version: ".concat(_opts.version));
    if (typeof _opts.lockTime !== 'number') throw new Error('Transaction lock time should be number');
    P.U32LE.encode(_opts.lockTime); // Additional range checks that lockTime
    // There is no PSBT v1, and any new version will probably have fields which we don't know how to parse, which
    // can lead to constructing broken transactions
    if (_opts.PSBTVersion !== 0 && _opts.PSBTVersion !== 2) throw new Error("Unknown PSBT version ".concat(_opts.PSBTVersion));
    // Flags
    for (const k of [
        'allowUnknownOutputs',
        'allowUnknownInputs',
        'disableScriptCheck',
        'bip174jsCompat',
        'allowLegacyWitnessUtxo',
        'lowR'
    ]){
        const v = _opts[k];
        if (v === undefined) continue; // optional
        if (typeof v !== 'boolean') throw new Error("Transation options wrong type: ".concat(k, "=").concat(v, " (").concat(typeof v, ")"));
    }
    if (_opts.customScripts !== undefined) {
        const cs = _opts.customScripts;
        if (!Array.isArray(cs)) {
            throw new Error("wrong custom scripts type (expected array): customScripts=".concat(cs, " (").concat(typeof cs, ")"));
        }
        for (const s of cs){
            if (typeof s.encode !== 'function' || typeof s.decode !== 'function') throw new Error("wrong script=".concat(s, " (").concat(typeof s, ")"));
            if (s.finalizeTaproot !== undefined && typeof s.finalizeTaproot !== 'function') throw new Error("wrong script=".concat(s, " (").concat(typeof s, ")"));
        }
    }
    return Object.freeze(_opts);
}
class Transaction {
    // Import
    static fromRaw(raw) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const parsed = script_js_1.RawTx.decode(raw);
        const tx = new Transaction({
            ...opts,
            version: parsed.version,
            lockTime: parsed.lockTime
        });
        for (const o of parsed.outputs)tx.addOutput(o);
        tx.outputs = parsed.outputs;
        tx.inputs = parsed.inputs;
        if (parsed.witnesses) {
            for(let i = 0; i < parsed.witnesses.length; i++)tx.inputs[i].finalScriptWitness = parsed.witnesses[i];
        }
        return tx;
    }
    // PSBT
    static fromPSBT(psbt_) {
        let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let parsed;
        try {
            parsed = psbt.RawPSBTV0.decode(psbt_);
        } catch (e0) {
            try {
                parsed = psbt.RawPSBTV2.decode(psbt_);
            } catch (e2) {
                // Throw error for v0 parsing, since it popular, otherwise it would be shadowed by v2 error
                throw e0;
            }
        }
        const PSBTVersion = parsed.global.version || 0;
        if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error("Wrong PSBT version=".concat(PSBTVersion));
        const unsigned = parsed.global.unsignedTx;
        const version = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.version : parsed.global.txVersion;
        const lockTime = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.lockTime : parsed.global.fallbackLocktime;
        const tx = new Transaction({
            ...opts,
            version,
            lockTime,
            PSBTVersion
        });
        // We need slice here, because otherwise
        const inputCount = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.inputs.length : parsed.global.inputCount;
        tx.inputs = parsed.inputs.slice(0, inputCount).map((i, j)=>{
            var _parsed_global_unsignedTx;
            return {
                finalScriptSig: P.EMPTY,
                ...(_parsed_global_unsignedTx = parsed.global.unsignedTx) === null || _parsed_global_unsignedTx === void 0 ? void 0 : _parsed_global_unsignedTx.inputs[j],
                ...i
            };
        });
        const outputCount = PSBTVersion === 0 ? unsigned === null || unsigned === void 0 ? void 0 : unsigned.outputs.length : parsed.global.outputCount;
        tx.outputs = parsed.outputs.slice(0, outputCount).map((i, j)=>{
            var _parsed_global_unsignedTx;
            return {
                ...i,
                ...(_parsed_global_unsignedTx = parsed.global.unsignedTx) === null || _parsed_global_unsignedTx === void 0 ? void 0 : _parsed_global_unsignedTx.outputs[j]
            };
        });
        tx.global = {
            ...parsed.global,
            txVersion: version
        }; // just in case proprietary/unknown fields
        if (lockTime !== exports.DEFAULT_LOCKTIME) tx.global.fallbackLocktime = lockTime;
        return tx;
    }
    toPSBT() {
        let PSBTVersion = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.opts.PSBTVersion;
        if (PSBTVersion !== 0 && PSBTVersion !== 2) throw new Error("Wrong PSBT version=".concat(PSBTVersion));
        // if (PSBTVersion === 0 && this.inputs.length === 0) {
        //   throw new Error(
        //     'PSBT version=0 export for transaction without inputs disabled, please use version=2. Please check `toPSBT` method for explanation.'
        //   );
        // }
        const inputs = this.inputs.map((i)=>psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTInput, i));
        for (const inp of inputs){
            // Don't serialize empty fields
            if (inp.partialSig && !inp.partialSig.length) delete inp.partialSig;
            if (inp.finalScriptSig && !inp.finalScriptSig.length) delete inp.finalScriptSig;
            if (inp.finalScriptWitness && !inp.finalScriptWitness.length) delete inp.finalScriptWitness;
        }
        const outputs = this.outputs.map((i)=>psbt.cleanPSBTFields(PSBTVersion, psbt.PSBTOutput, i));
        const global = {
            ...this.global
        };
        if (PSBTVersion === 0) {
            /*
            - Bitcoin raw transaction expects to have at least 1 input because it uses case with zero inputs as marker for SegWit
            - this means we cannot serialize raw tx with zero inputs since it will be parsed as SegWit tx
            - Parsing of PSBTv0 depends on unsignedTx (it looks for input count here)
            - BIP-174 requires old serialization format (without witnesses) inside global, which solves this
            */ global.unsignedTx = script_js_1.RawOldTx.decode(script_js_1.RawOldTx.encode({
                version: this.version,
                lockTime: this.lockTime,
                inputs: this.inputs.map(inputBeforeSign).map((i)=>({
                        ...i,
                        finalScriptSig: P.EMPTY
                    })),
                outputs: this.outputs.map(outputBeforeSign)
            }));
            delete global.fallbackLocktime;
            delete global.txVersion;
        } else {
            global.version = PSBTVersion;
            global.txVersion = this.version;
            global.inputCount = this.inputs.length;
            global.outputCount = this.outputs.length;
            if (global.fallbackLocktime && global.fallbackLocktime === exports.DEFAULT_LOCKTIME) delete global.fallbackLocktime;
        }
        if (this.opts.bip174jsCompat) {
            if (!inputs.length) inputs.push({});
            if (!outputs.length) outputs.push({});
        }
        return (PSBTVersion === 0 ? psbt.RawPSBTV0 : psbt.RawPSBTV2).encode({
            global,
            inputs,
            outputs
        });
    }
    // BIP370 lockTime (https://github.com/bitcoin/bips/blob/master/bip-0370.mediawiki#determining-lock-time)
    get lockTime() {
        let height = exports.DEFAULT_LOCKTIME;
        let heightCnt = 0;
        let time = exports.DEFAULT_LOCKTIME;
        let timeCnt = 0;
        for (const i of this.inputs){
            if (i.requiredHeightLocktime) {
                height = Math.max(height, i.requiredHeightLocktime);
                heightCnt++;
            }
            if (i.requiredTimeLocktime) {
                time = Math.max(time, i.requiredTimeLocktime);
                timeCnt++;
            }
        }
        if (heightCnt && heightCnt >= timeCnt) return height;
        if (time !== exports.DEFAULT_LOCKTIME) return time;
        return this.global.fallbackLocktime || exports.DEFAULT_LOCKTIME;
    }
    get version() {
        // Should be not possible
        if (this.global.txVersion === undefined) throw new Error('No global.txVersion');
        return this.global.txVersion;
    }
    inputStatus(idx) {
        this.checkInputIdx(idx);
        const input = this.inputs[idx];
        // Finalized
        if (input.finalScriptSig && input.finalScriptSig.length) return 'finalized';
        if (input.finalScriptWitness && input.finalScriptWitness.length) return 'finalized';
        // Signed taproot
        if (input.tapKeySig) return 'signed';
        if (input.tapScriptSig && input.tapScriptSig.length) return 'signed';
        // Signed
        if (input.partialSig && input.partialSig.length) return 'signed';
        return 'unsigned';
    }
    // Cannot replace unpackSighash, tests rely on very generic implemenetation with signing inputs outside of range
    // We will lose some vectors -> smaller test coverage of preimages (very important!)
    inputSighash(idx) {
        this.checkInputIdx(idx);
        const inputSighash = this.inputs[idx].sighashType;
        const sighash = inputSighash === undefined ? SignatureHash.DEFAULT : inputSighash;
        // ALL or DEFAULT -- everything signed
        // NONE           -- all inputs + no outputs
        // SINGLE         -- all inputs + output with same index
        // ALL + ANYONE   -- specific input + all outputs
        // NONE + ANYONE  -- specific input + no outputs
        // SINGLE         -- specific inputs + output with same index
        const sigOutputs = sighash === SignatureHash.DEFAULT ? SignatureHash.ALL : sighash & 0b11;
        const sigInputs = sighash & SignatureHash.ANYONECANPAY;
        return {
            sigInputs,
            sigOutputs
        };
    }
    // Very nice for debug purposes, but slow. If there is too much inputs/outputs to add, will be quadratic.
    // Some cache will be nice, but there chance to have bugs with cache invalidation
    signStatus() {
        // if addInput or addOutput is not possible, then all inputs or outputs are signed
        let addInput = true, addOutput = true;
        let inputs = [], outputs = [];
        for(let idx = 0; idx < this.inputs.length; idx++){
            const status = this.inputStatus(idx);
            // Unsigned input doesn't affect anything
            if (status === 'unsigned') continue;
            const { sigInputs, sigOutputs } = this.inputSighash(idx);
            // Input type
            if (sigInputs === SignatureHash.ANYONECANPAY) inputs.push(idx);
            else addInput = false;
            // Output type
            if (sigOutputs === SignatureHash.ALL) addOutput = false;
            else if (sigOutputs === SignatureHash.SINGLE) outputs.push(idx);
            else if (sigOutputs === SignatureHash.NONE) {
            // Doesn't affect any outputs at all
            } else throw new Error("Wrong signature hash output type: ".concat(sigOutputs));
        }
        return {
            addInput,
            addOutput,
            inputs,
            outputs
        };
    }
    get isFinal() {
        for(let idx = 0; idx < this.inputs.length; idx++)if (this.inputStatus(idx) !== 'finalized') return false;
        return true;
    }
    // Info utils
    get hasWitnesses() {
        let out = false;
        for (const i of this.inputs)if (i.finalScriptWitness && i.finalScriptWitness.length) out = true;
        return out;
    }
    // https://en.bitcoin.it/wiki/Weight_units
    get weight() {
        if (!this.isFinal) throw new Error('Transaction is not finalized');
        let out = 32;
        // Outputs
        const outputs = this.outputs.map(outputBeforeSign);
        out += 4 * script_js_1.CompactSizeLen.encode(this.outputs.length).length;
        for (const o of outputs)out += 32 + 4 * script_js_1.VarBytes.encode(o.script).length;
        // Inputs
        if (this.hasWitnesses) out += 2;
        out += 4 * script_js_1.CompactSizeLen.encode(this.inputs.length).length;
        for (const i of this.inputs){
            out += 160 + 4 * script_js_1.VarBytes.encode(i.finalScriptSig || P.EMPTY).length;
            if (this.hasWitnesses && i.finalScriptWitness) out += script_js_1.RawWitness.encode(i.finalScriptWitness).length;
        }
        return out;
    }
    get vsize() {
        return (0, utxo_js_1.toVsize)(this.weight);
    }
    toBytes() {
        let withScriptSig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, withWitness = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return script_js_1.RawTx.encode({
            version: this.version,
            lockTime: this.lockTime,
            inputs: this.inputs.map(inputBeforeSign).map((i)=>({
                    ...i,
                    finalScriptSig: withScriptSig && i.finalScriptSig || P.EMPTY
                })),
            outputs: this.outputs.map(outputBeforeSign),
            witnesses: this.inputs.map((i)=>i.finalScriptWitness || []),
            segwitFlag: withWitness && this.hasWitnesses
        });
    }
    get unsignedTx() {
        return this.toBytes(false, false);
    }
    get hex() {
        return base_1.hex.encode(this.toBytes(true, this.hasWitnesses));
    }
    get hash() {
        if (!this.isFinal) throw new Error('Transaction is not finalized');
        return base_1.hex.encode(u.sha256x2(this.toBytes(true)));
    }
    get id() {
        if (!this.isFinal) throw new Error('Transaction is not finalized');
        return base_1.hex.encode(u.sha256x2(this.toBytes(true)).reverse());
    }
    // Input stuff
    checkInputIdx(idx) {
        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.inputs.length) throw new Error("Wrong input index=".concat(idx));
    }
    getInput(idx) {
        this.checkInputIdx(idx);
        return cloneDeep(this.inputs[idx]);
    }
    get inputsLength() {
        return this.inputs.length;
    }
    // Modification
    addInput(input) {
        let _ignoreSignStatus = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!_ignoreSignStatus && !this.signStatus().addInput) throw new Error('Tx has signed inputs, cannot add new one');
        this.inputs.push((0, utxo_js_1.normalizeInput)(input, undefined, undefined, this.opts.disableScriptCheck));
        return this.inputs.length - 1;
    }
    updateInput(idx, input) {
        let _ignoreSignStatus = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.checkInputIdx(idx);
        let allowedFields = undefined;
        if (!_ignoreSignStatus) {
            const status = this.signStatus();
            if (!status.addInput || status.inputs.includes(idx)) allowedFields = psbt.PSBTInputUnsignedKeys;
        }
        this.inputs[idx] = (0, utxo_js_1.normalizeInput)(input, this.inputs[idx], allowedFields, this.opts.disableScriptCheck);
    }
    // Output stuff
    checkOutputIdx(idx) {
        if (!Number.isSafeInteger(idx) || 0 > idx || idx >= this.outputs.length) throw new Error("Wrong output index=".concat(idx));
    }
    getOutput(idx) {
        this.checkOutputIdx(idx);
        return cloneDeep(this.outputs[idx]);
    }
    getOutputAddress(idx) {
        let network = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : utils_js_1.NETWORK;
        const out = this.getOutput(idx);
        if (!out.script) return;
        return (0, payment_js_1.Address)(network).encode(payment_js_1.OutScript.decode(out.script));
    }
    get outputsLength() {
        return this.outputs.length;
    }
    normalizeOutput(o, cur, allowedFields) {
        let { amount, script } = o;
        if (amount === undefined) amount = cur === null || cur === void 0 ? void 0 : cur.amount;
        if (typeof amount !== 'bigint') throw new Error("Wrong amount type, should be of type bigint in sats, but got ".concat(amount, " of type ").concat(typeof amount));
        if (typeof script === 'string') script = base_1.hex.decode(script);
        if (script === undefined) script = cur === null || cur === void 0 ? void 0 : cur.script;
        let res = {
            ...cur,
            ...o,
            amount,
            script
        };
        if (res.amount === undefined) delete res.amount;
        res = psbt.mergeKeyMap(psbt.PSBTOutput, res, cur, allowedFields);
        psbt.PSBTOutputCoder.encode(res);
        if (res.script && !this.opts.allowUnknownOutputs && payment_js_1.OutScript.decode(res.script).type === 'unknown') {
            throw new Error('Transaction/output: unknown output script type, there is a chance that input is unspendable. Pass allowUnknownOutputs=true, if you sure');
        }
        if (!this.opts.disableScriptCheck) (0, payment_js_1.checkScript)(res.script, res.redeemScript, res.witnessScript);
        return res;
    }
    addOutput(o) {
        let _ignoreSignStatus = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!_ignoreSignStatus && !this.signStatus().addOutput) throw new Error('Tx has signed outputs, cannot add new one');
        this.outputs.push(this.normalizeOutput(o));
        return this.outputs.length - 1;
    }
    updateOutput(idx, output) {
        let _ignoreSignStatus = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.checkOutputIdx(idx);
        let allowedFields = undefined;
        if (!_ignoreSignStatus) {
            const status = this.signStatus();
            if (!status.addOutput || status.outputs.includes(idx)) allowedFields = psbt.PSBTOutputUnsignedKeys;
        }
        this.outputs[idx] = this.normalizeOutput(output, this.outputs[idx], allowedFields);
    }
    addOutputAddress(address, amount) {
        let network = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : utils_js_1.NETWORK;
        return this.addOutput({
            script: payment_js_1.OutScript.encode((0, payment_js_1.Address)(network).decode(address)),
            amount
        });
    }
    // Utils
    get fee() {
        let res = 0n;
        for (const i of this.inputs){
            const prevOut = (0, utxo_js_1.getPrevOut)(i);
            if (!prevOut) throw new Error('Empty input amount');
            res += prevOut.amount;
        }
        const outputs = this.outputs.map(outputBeforeSign);
        for (const o of outputs)res -= o.amount;
        return res;
    }
    // Signing
    // Based on https://github.com/bitcoin/bitcoin/blob/5871b5b5ab57a0caf9b7514eb162c491c83281d5/test/functional/test_framework/script.py#L624
    // There is optimization opportunity to re-use hashes for multiple inputs for witness v0/v1,
    // but we are trying to be less complicated for audit purpose for now.
    preimageLegacy(idx, prevOutScript, hashType) {
        const { isAny, isNone, isSingle } = unpackSighash(hashType);
        if (idx < 0 || !Number.isSafeInteger(idx)) throw new Error("Invalid input idx=".concat(idx));
        if (isSingle && idx >= this.outputs.length || idx >= this.inputs.length) return P.U256BE.encode(1n);
        prevOutScript = script_js_1.Script.encode(script_js_1.Script.decode(prevOutScript).filter((i)=>i !== 'CODESEPARATOR'));
        let inputs = this.inputs.map(inputBeforeSign).map((input, inputIdx)=>({
                ...input,
                finalScriptSig: inputIdx === idx ? prevOutScript : P.EMPTY
            }));
        if (isAny) inputs = [
            inputs[idx]
        ];
        else if (isNone || isSingle) {
            inputs = inputs.map((input, inputIdx)=>({
                    ...input,
                    sequence: inputIdx === idx ? input.sequence : 0
                }));
        }
        let outputs = this.outputs.map(outputBeforeSign);
        if (isNone) outputs = [];
        else if (isSingle) {
            outputs = outputs.slice(0, idx).fill(EMPTY_OUTPUT).concat([
                outputs[idx]
            ]);
        }
        const tmpTx = script_js_1.RawTx.encode({
            lockTime: this.lockTime,
            version: this.version,
            segwitFlag: false,
            inputs,
            outputs
        });
        return u.sha256x2(tmpTx, P.I32LE.encode(hashType));
    }
    preimageWitnessV0(idx, prevOutScript, hashType, amount) {
        const { isAny, isNone, isSingle } = unpackSighash(hashType);
        let inputHash = EMPTY32;
        let sequenceHash = EMPTY32;
        let outputHash = EMPTY32;
        const inputs = this.inputs.map(inputBeforeSign);
        const outputs = this.outputs.map(outputBeforeSign);
        if (!isAny) inputHash = u.sha256x2(...inputs.map(TxHashIdx.encode));
        if (!isAny && !isSingle && !isNone) sequenceHash = u.sha256x2(...inputs.map((i)=>P.U32LE.encode(i.sequence)));
        if (!isSingle && !isNone) {
            outputHash = u.sha256x2(...outputs.map(script_js_1.RawOutput.encode));
        } else if (isSingle && idx < outputs.length) outputHash = u.sha256x2(script_js_1.RawOutput.encode(outputs[idx]));
        const input = inputs[idx];
        return u.sha256x2(P.I32LE.encode(this.version), inputHash, sequenceHash, P.bytes(32, true).encode(input.txid), P.U32LE.encode(input.index), script_js_1.VarBytes.encode(prevOutScript), P.U64LE.encode(amount), P.U32LE.encode(input.sequence), outputHash, P.U32LE.encode(this.lockTime), P.U32LE.encode(hashType));
    }
    preimageWitnessV1(idx, prevOutScript, hashType, amount) {
        let codeSeparator = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1, leafScript = arguments.length > 5 ? arguments[5] : void 0, leafVer = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0xc0, annex = arguments.length > 7 ? arguments[7] : void 0;
        if (!Array.isArray(amount) || this.inputs.length !== amount.length) throw new Error("Invalid amounts array=".concat(amount));
        if (!Array.isArray(prevOutScript) || this.inputs.length !== prevOutScript.length) throw new Error("Invalid prevOutScript array=".concat(prevOutScript));
        const out = [
            P.U8.encode(0),
            P.U8.encode(hashType),
            P.I32LE.encode(this.version),
            P.U32LE.encode(this.lockTime)
        ];
        const outType = hashType === SignatureHash.DEFAULT ? SignatureHash.ALL : hashType & 0b11;
        const inType = hashType & SignatureHash.ANYONECANPAY;
        const inputs = this.inputs.map(inputBeforeSign);
        const outputs = this.outputs.map(outputBeforeSign);
        if (inType !== SignatureHash.ANYONECANPAY) {
            out.push(...[
                inputs.map(TxHashIdx.encode),
                amount.map(P.U64LE.encode),
                prevOutScript.map(script_js_1.VarBytes.encode),
                inputs.map((i)=>P.U32LE.encode(i.sequence))
            ].map((i)=>u.sha256((0, utils_js_1.concatBytes)(...i))));
        }
        if (outType === SignatureHash.ALL) {
            out.push(u.sha256((0, utils_js_1.concatBytes)(...outputs.map(script_js_1.RawOutput.encode))));
        }
        const spendType = (annex ? 1 : 0) | (leafScript ? 2 : 0);
        out.push(new Uint8Array([
            spendType
        ]));
        if (inType === SignatureHash.ANYONECANPAY) {
            const inp = inputs[idx];
            out.push(TxHashIdx.encode(inp), P.U64LE.encode(amount[idx]), script_js_1.VarBytes.encode(prevOutScript[idx]), P.U32LE.encode(inp.sequence));
        } else out.push(P.U32LE.encode(idx));
        if (spendType & 1) out.push(u.sha256(script_js_1.VarBytes.encode(annex || P.EMPTY)));
        if (outType === SignatureHash.SINGLE) out.push(idx < outputs.length ? u.sha256(script_js_1.RawOutput.encode(outputs[idx])) : EMPTY32);
        if (leafScript) out.push((0, payment_js_1.tapLeafHash)(leafScript, leafVer), P.U8.encode(0), P.I32LE.encode(codeSeparator));
        return u.tagSchnorr('TapSighash', ...out);
    }
    // Signer can be privateKey OR instance of bip32 HD stuff
    signIdx(privateKey, idx, allowedSighash, _auxRand) {
        this.checkInputIdx(idx);
        const input = this.inputs[idx];
        const inputType = (0, utxo_js_1.getInputType)(input, this.opts.allowLegacyWitnessUtxo);
        // Handle BIP32 HDKey
        if (!(0, utils_js_1.isBytes)(privateKey)) {
            if (!input.bip32Derivation || !input.bip32Derivation.length) throw new Error('bip32Derivation: empty');
            const signers = input.bip32Derivation.filter((i)=>i[1].fingerprint == privateKey.fingerprint).map((param)=>{
                let [pubKey, { path }] = param;
                let s = privateKey;
                for (const i of path)s = s.deriveChild(i);
                if (!(0, utils_js_1.equalBytes)(s.publicKey, pubKey)) throw new Error('bip32Derivation: wrong pubKey');
                if (!s.privateKey) throw new Error('bip32Derivation: no privateKey');
                return s;
            });
            if (!signers.length) throw new Error("bip32Derivation: no items with fingerprint=".concat(privateKey.fingerprint));
            let signed = false;
            for (const s of signers)if (this.signIdx(s.privateKey, idx)) signed = true;
            return signed;
        }
        // Sighash checks
        // Just for compat with bitcoinjs-lib, so users won't face unexpected behaviour.
        if (!allowedSighash) allowedSighash = [
            inputType.defaultSighash
        ];
        else allowedSighash.forEach(validateSigHash);
        const sighash = inputType.sighash;
        if (!allowedSighash.includes(sighash)) {
            throw new Error("Input with not allowed sigHash=".concat(sighash, ". Allowed: ").concat(allowedSighash.join(', ')));
        }
        // It is possible to sign these inputs for legacy/segwit v0 (but no taproot!),
        // however this was because of bug in bitcoin-core, which remains here because of consensus.
        // If this is absolutely neccessary for your case, please open issue.
        // We disable it to avoid complicated workflow where SINGLE will block adding new outputs
        const { sigOutputs } = this.inputSighash(idx);
        if (sigOutputs === SignatureHash.SINGLE && idx >= this.outputs.length) {
            throw new Error("Input with sighash SINGLE, but there is no output with corresponding index=".concat(idx));
        }
        // Actual signing
        // Taproot
        const prevOut = (0, utxo_js_1.getPrevOut)(input);
        if (inputType.txType === 'taproot') {
            const prevOuts = this.inputs.map(utxo_js_1.getPrevOut);
            const prevOutScript = prevOuts.map((i)=>i.script);
            const amount = prevOuts.map((i)=>i.amount);
            let signed = false;
            let schnorrPub = u.pubSchnorr(privateKey);
            let merkleRoot = input.tapMerkleRoot || P.EMPTY;
            if (input.tapInternalKey) {
                // internal + tweak = tweaked key
                // if internal key == current public key, we need to tweak private key,
                // otherwise sign as is. bitcoinjs implementation always wants tweaked
                // priv key to be provided
                const { pubKey, privKey } = getTaprootKeys(privateKey, schnorrPub, input.tapInternalKey, merkleRoot);
                const [taprootPubKey, _] = u.taprootTweakPubkey(input.tapInternalKey, merkleRoot);
                if ((0, utils_js_1.equalBytes)(taprootPubKey, pubKey)) {
                    const hash = this.preimageWitnessV1(idx, prevOutScript, sighash, amount);
                    const sig = (0, utils_js_1.concatBytes)(u.signSchnorr(hash, privKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([
                        sighash
                    ]) : P.EMPTY);
                    this.updateInput(idx, {
                        tapKeySig: sig
                    }, true);
                    signed = true;
                }
            }
            if (input.tapLeafScript) {
                input.tapScriptSig = input.tapScriptSig || [];
                for (const [_, _script] of input.tapLeafScript){
                    const script = _script.subarray(0, -1);
                    const scriptDecoded = script_js_1.Script.decode(script);
                    const ver = _script[_script.length - 1];
                    const hash = (0, payment_js_1.tapLeafHash)(script, ver);
                    // NOTE: no need to tweak internal key here, since we don't support nested p2tr
                    const pos = scriptDecoded.findIndex((i)=>(0, utils_js_1.isBytes)(i) && (0, utils_js_1.equalBytes)(i, schnorrPub));
                    // Skip if there is no public key in tapLeafScript
                    if (pos === -1) continue;
                    const msg = this.preimageWitnessV1(idx, prevOutScript, sighash, amount, undefined, script, ver);
                    const sig = (0, utils_js_1.concatBytes)(u.signSchnorr(msg, privateKey, _auxRand), sighash !== SignatureHash.DEFAULT ? new Uint8Array([
                        sighash
                    ]) : P.EMPTY);
                    this.updateInput(idx, {
                        tapScriptSig: [
                            [
                                {
                                    pubKey: schnorrPub,
                                    leafHash: hash
                                },
                                sig
                            ]
                        ]
                    }, true);
                    signed = true;
                }
            }
            if (!signed) throw new Error('No taproot scripts signed');
            return true;
        } else {
            // only compressed keys are supported for now
            const pubKey = u.pubECDSA(privateKey);
            // TODO: replace with explicit checks
            // Check if script has public key or its has inside
            let hasPubkey = false;
            const pubKeyHash = u.hash160(pubKey);
            for (const i of script_js_1.Script.decode(inputType.lastScript)){
                if ((0, utils_js_1.isBytes)(i) && ((0, utils_js_1.equalBytes)(i, pubKey) || (0, utils_js_1.equalBytes)(i, pubKeyHash))) hasPubkey = true;
            }
            if (!hasPubkey) throw new Error("Input script doesn't have pubKey: ".concat(inputType.lastScript));
            let hash;
            if (inputType.txType === 'legacy') {
                hash = this.preimageLegacy(idx, inputType.lastScript, sighash);
            } else if (inputType.txType === 'segwit') {
                let script = inputType.lastScript;
                // If wpkh OR sh-wpkh, wsh-wpkh is impossible, so looks ok
                if (inputType.last.type === 'wpkh') script = payment_js_1.OutScript.encode({
                    type: 'pkh',
                    hash: inputType.last.hash
                });
                hash = this.preimageWitnessV0(idx, script, sighash, prevOut.amount);
            } else throw new Error("Transaction/sign: unknown tx type: ".concat(inputType.txType));
            const sig = u.signECDSA(hash, privateKey, this.opts.lowR);
            this.updateInput(idx, {
                partialSig: [
                    [
                        pubKey,
                        (0, utils_js_1.concatBytes)(sig, new Uint8Array([
                            sighash
                        ]))
                    ]
                ]
            }, true);
        }
        return true;
    }
    // This is bad API. Will work if user creates and signs tx, but if
    // there is some complex workflow with exchanging PSBT and signing them,
    // then it is better to validate which output user signs. How could a better API look like?
    // Example: user adds input, sends to another party, then signs received input (mixer etc),
    // another user can add different input for same key and user will sign it.
    // Even worse: another user can add bip32 derivation, and spend money from different address.
    // Better api: signIdx
    sign(privateKey, allowedSighash, _auxRand) {
        let num = 0;
        for(let i = 0; i < this.inputs.length; i++){
            try {
                if (this.signIdx(privateKey, i, allowedSighash, _auxRand)) num++;
            } catch (e) {}
        }
        if (!num) throw new Error('No inputs signed');
        return num;
    }
    finalizeIdx(idx) {
        this.checkInputIdx(idx);
        if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');
        const input = this.inputs[idx];
        const inputType = (0, utxo_js_1.getInputType)(input, this.opts.allowLegacyWitnessUtxo);
        // Taproot finalize
        if (inputType.txType === 'taproot') {
            if (input.tapKeySig) input.finalScriptWitness = [
                input.tapKeySig
            ];
            else if (input.tapLeafScript && input.tapScriptSig) {
                // Sort leafs by control block length.
                const leafs = input.tapLeafScript.sort((a, b)=>psbt.TaprootControlBlock.encode(a[0]).length - psbt.TaprootControlBlock.encode(b[0]).length);
                for (const [cb, _script] of leafs){
                    // Last byte is version
                    const script = _script.slice(0, -1);
                    const ver = _script[_script.length - 1];
                    const outScript = payment_js_1.OutScript.decode(script);
                    const hash = (0, payment_js_1.tapLeafHash)(script, ver);
                    const scriptSig = input.tapScriptSig.filter((i)=>(0, utils_js_1.equalBytes)(i[0].leafHash, hash));
                    let signatures = [];
                    if (outScript.type === 'tr_ms') {
                        const m = outScript.m;
                        const pubkeys = outScript.pubkeys;
                        let added = 0;
                        for (const pub of pubkeys){
                            const sigIdx = scriptSig.findIndex((i)=>(0, utils_js_1.equalBytes)(i[0].pubKey, pub));
                            // Should have exact amount of signatures (more -- will fail)
                            if (added === m || sigIdx === -1) {
                                signatures.push(P.EMPTY);
                                continue;
                            }
                            signatures.push(scriptSig[sigIdx][1]);
                            added++;
                        }
                        // Should be exact same as m
                        if (added !== m) continue;
                    } else if (outScript.type === 'tr_ns') {
                        for (const pub of outScript.pubkeys){
                            const sigIdx = scriptSig.findIndex((i)=>(0, utils_js_1.equalBytes)(i[0].pubKey, pub));
                            if (sigIdx === -1) continue;
                            signatures.push(scriptSig[sigIdx][1]);
                        }
                        if (signatures.length !== outScript.pubkeys.length) continue;
                    } else if (outScript.type === 'unknown' && this.opts.allowUnknownInputs) {
                        // Trying our best to sign what we can
                        const scriptDecoded = script_js_1.Script.decode(script);
                        signatures = scriptSig.map((param)=>{
                            let [{ pubKey }, signature] = param;
                            const pos = scriptDecoded.findIndex((i)=>(0, utils_js_1.isBytes)(i) && (0, utils_js_1.equalBytes)(i, pubKey));
                            if (pos === -1) throw new Error('finalize/taproot: cannot find position of pubkey in script');
                            return {
                                signature,
                                pos
                            };
                        })// Reverse order (because witness is stack and we take last element first from it)
                        .sort((a, b)=>a.pos - b.pos).map((i)=>i.signature);
                        if (!signatures.length) continue;
                    } else {
                        const custom = this.opts.customScripts;
                        if (custom) {
                            for (const c of custom){
                                if (!c.finalizeTaproot) continue;
                                const scriptDecoded = script_js_1.Script.decode(script);
                                const csEncoded = c.encode(scriptDecoded);
                                if (csEncoded === undefined) continue;
                                const finalized = c.finalizeTaproot(script, csEncoded, scriptSig);
                                if (!finalized) continue;
                                input.finalScriptWitness = finalized.concat(psbt.TaprootControlBlock.encode(cb));
                                input.finalScriptSig = P.EMPTY;
                                cleanFinalInput(input);
                                return;
                            }
                        }
                        throw new Error('Finalize: Unknown tapLeafScript');
                    }
                    // Witness is stack, so last element will be used first
                    input.finalScriptWitness = signatures.reverse().concat([
                        script,
                        psbt.TaprootControlBlock.encode(cb)
                    ]);
                    break;
                }
                if (!input.finalScriptWitness) throw new Error('finalize/taproot: empty witness');
            } else throw new Error('finalize/taproot: unknown input');
            input.finalScriptSig = P.EMPTY;
            cleanFinalInput(input);
            return;
        }
        if (!input.partialSig || !input.partialSig.length) throw new Error('Not enough partial sign');
        let inputScript = P.EMPTY;
        let witness = [];
        // TODO: move input scripts closer to payments/output scripts
        // Multisig
        if (inputType.last.type === 'ms') {
            const m = inputType.last.m;
            const pubkeys = inputType.last.pubkeys;
            let signatures = [];
            // partial: [pubkey, sign]
            for (const pub of pubkeys){
                const sign = input.partialSig.find((s)=>(0, utils_js_1.equalBytes)(pub, s[0]));
                if (!sign) continue;
                signatures.push(sign[1]);
            }
            signatures = signatures.slice(0, m);
            if (signatures.length !== m) {
                throw new Error("Multisig: wrong signatures count, m=".concat(m, " n=").concat(pubkeys.length, " signatures=").concat(signatures.length));
            }
            inputScript = script_js_1.Script.encode([
                0,
                ...signatures
            ]);
        } else if (inputType.last.type === 'pk') {
            inputScript = script_js_1.Script.encode([
                input.partialSig[0][1]
            ]);
        } else if (inputType.last.type === 'pkh') {
            inputScript = script_js_1.Script.encode([
                input.partialSig[0][1],
                input.partialSig[0][0]
            ]);
        } else if (inputType.last.type === 'wpkh') {
            inputScript = P.EMPTY;
            witness = [
                input.partialSig[0][1],
                input.partialSig[0][0]
            ];
        } else if (inputType.last.type === 'unknown' && !this.opts.allowUnknownInputs) throw new Error('Unknown inputs not allowed');
        // Create final scripts (generic part)
        let finalScriptSig, finalScriptWitness;
        if (inputType.type.includes('wsh-')) {
            // P2WSH
            if (inputScript.length && inputType.lastScript.length) {
                witness = script_js_1.Script.decode(inputScript).map((i)=>{
                    if (i === 0) return P.EMPTY;
                    if ((0, utils_js_1.isBytes)(i)) return i;
                    throw new Error("Wrong witness op=".concat(i));
                });
            }
            witness = witness.concat(inputType.lastScript);
        }
        if (inputType.txType === 'segwit') finalScriptWitness = witness;
        if (inputType.type.startsWith('sh-wsh-')) {
            finalScriptSig = script_js_1.Script.encode([
                script_js_1.Script.encode([
                    0,
                    u.sha256(inputType.lastScript)
                ])
            ]);
        } else if (inputType.type.startsWith('sh-')) {
            finalScriptSig = script_js_1.Script.encode([
                ...script_js_1.Script.decode(inputScript),
                inputType.lastScript
            ]);
        } else if (inputType.type.startsWith('wsh-')) {} else if (inputType.txType !== 'segwit') finalScriptSig = inputScript;
        if (!finalScriptSig && !finalScriptWitness) throw new Error('Unknown error finalizing input');
        if (finalScriptSig) input.finalScriptSig = finalScriptSig;
        if (finalScriptWitness) input.finalScriptWitness = finalScriptWitness;
        cleanFinalInput(input);
    }
    finalize() {
        for(let i = 0; i < this.inputs.length; i++)this.finalizeIdx(i);
    }
    extract() {
        if (!this.isFinal) throw new Error('Transaction has unfinalized inputs');
        if (!this.outputs.length) throw new Error('Transaction has no outputs');
        if (this.fee < 0n) throw new Error('Outputs spends more than inputs amount');
        return this.toBytes(true, true);
    }
    combine(other) {
        for (const k of [
            'PSBTVersion',
            'version',
            'lockTime'
        ]){
            if (this.opts[k] !== other.opts[k]) {
                throw new Error("Transaction/combine: different ".concat(k, " this=").concat(this.opts[k], " other=").concat(other.opts[k]));
            }
        }
        for (const k of [
            'inputs',
            'outputs'
        ]){
            if (this[k].length !== other[k].length) {
                throw new Error("Transaction/combine: different ".concat(k, " length this=").concat(this[k].length, " other=").concat(other[k].length));
            }
        }
        const thisUnsigned = this.global.unsignedTx ? script_js_1.RawOldTx.encode(this.global.unsignedTx) : P.EMPTY;
        const otherUnsigned = other.global.unsignedTx ? script_js_1.RawOldTx.encode(other.global.unsignedTx) : P.EMPTY;
        if (!(0, utils_js_1.equalBytes)(thisUnsigned, otherUnsigned)) throw new Error("Transaction/combine: different unsigned tx");
        this.global = psbt.mergeKeyMap(psbt.PSBTGlobal, this.global, other.global);
        for(let i = 0; i < this.inputs.length; i++)this.updateInput(i, other.inputs[i], true);
        for(let i = 0; i < this.outputs.length; i++)this.updateOutput(i, other.outputs[i], true);
        return this;
    }
    clone() {
        // deepClone probably faster, but this enforces that encoding is valid
        return Transaction.fromPSBT(this.toPSBT(this.opts.PSBTVersion), this.opts);
    }
    constructor(opts = {}){
        this.global = {};
        this.inputs = []; // use getInput()
        this.outputs = []; // use getOutput()
        const _opts = this.opts = validateOpts(opts);
        // Merge with global structure of PSBTv2
        if (_opts.lockTime !== exports.DEFAULT_LOCKTIME) this.global.fallbackLocktime = _opts.lockTime;
        this.global.txVersion = _opts.version;
    }
}
exports.Transaction = Transaction;
function PSBTCombine(psbts) {
    if (!psbts || !Array.isArray(psbts) || !psbts.length) throw new Error('PSBTCombine: wrong PSBT list');
    const tx = Transaction.fromPSBT(psbts[0]);
    for(let i = 1; i < psbts.length; i++)tx.combine(Transaction.fromPSBT(psbts[i]));
    return tx.toPSBT();
}
// Copy-pasted from bip32 derive, maybe do something like 'bip32.parsePath'?
const HARDENED_OFFSET = 0x80000000;
function bip32Path(path) {
    const out = [];
    if (!/^[mM]'?/.test(path)) throw new Error('Path must start with "m" or "M"');
    if (/^[mM]'?$/.test(path)) return out;
    const parts = path.replace(/^[mM]'?\//, '').split('/');
    for (const c of parts){
        const m = /^(\d+)('?)$/.exec(c);
        if (!m || m.length !== 3) throw new Error("Invalid child index: ".concat(c));
        let idx = +m[1];
        if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) throw new Error('Invalid index');
        // hardened key
        if (m[2] === "'") idx += HARDENED_OFFSET;
        out.push(idx);
    }
    return out;
} //# sourceMappingURL=transaction.js.map
}),
"[project]/node_modules/@scure/btc-signer/psbt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RawPSBTV2 = exports.RawPSBTV0 = exports._DebugPSBT = exports._RawPSBTV2 = exports._RawPSBTV0 = exports.PSBTOutputCoder = exports.PSBTInputCoder = exports.PSBTOutputUnsignedKeys = exports.PSBTOutput = exports.PSBTInputUnsignedKeys = exports.PSBTInputFinalKeys = exports.PSBTInput = exports.PSBTGlobal = exports.TaprootControlBlock = void 0;
exports.cleanPSBTFields = cleanPSBTFields;
exports.mergeKeyMap = mergeKeyMap;
const base_1 = __turbopack_context__.r("[project]/node_modules/@scure/base/lib/index.js [app-client] (ecmascript)");
const P = __turbopack_context__.r("[project]/node_modules/micro-packed/lib/index.js [app-client] (ecmascript)");
const script_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/script.js [app-client] (ecmascript)");
const transaction_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/transaction.js [app-client] (ecmascript)"); // circular
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
// PSBT BIP174, BIP370, BIP371
// Can be 33 or 64 bytes
const PubKeyECDSA = P.validate(P.bytes(null), (pub)=>(0, utils_js_1.validatePubkey)(pub, utils_js_1.PubT.ecdsa));
const PubKeySchnorr = P.validate(P.bytes(32), (pub)=>(0, utils_js_1.validatePubkey)(pub, utils_js_1.PubT.schnorr));
const SignatureSchnorr = P.validate(P.bytes(null), (sig)=>{
    if (sig.length !== 64 && sig.length !== 65) throw new Error('Schnorr signature should be 64 or 65 bytes long');
    return sig;
});
const BIP32Der = P.struct({
    fingerprint: P.U32BE,
    path: P.array(null, P.U32LE)
});
const TaprootBIP32Der = P.struct({
    hashes: P.array(script_js_1.CompactSizeLen, P.bytes(32)),
    der: BIP32Der
});
// The 78 byte serialized extended public key as defined by BIP 32.
const GlobalXPUB = P.bytes(78);
const tapScriptSigKey = P.struct({
    pubKey: PubKeySchnorr,
    leafHash: P.bytes(32)
});
// Complex structure for PSBT fields
// <control byte with leaf version and parity bit> <internal key p> <C> <E> <AB>
const _TaprootControlBlock = P.struct({
    version: P.U8,
    internalKey: P.bytes(32),
    merklePath: P.array(null, P.bytes(32))
});
exports.TaprootControlBlock = P.validate(_TaprootControlBlock, (cb)=>{
    if (cb.merklePath.length > 128) throw new Error('TaprootControlBlock: merklePath should be of length 0..128 (inclusive)');
    return cb;
});
// {<8-bit uint depth> <8-bit uint leaf version> <compact size uint scriptlen> <bytes script>}*
const tapTree = P.array(null, P.struct({
    depth: P.U8,
    version: P.U8,
    script: script_js_1.VarBytes
}));
const BytesInf = P.bytes(null); // Bytes will conflict with Bytes type
const Bytes20 = P.bytes(20);
const Bytes32 = P.bytes(32);
// versionsRequiringExclusing = !versionsAllowsInclusion (as set)
// {name: [tag, keyCoder, valueCoder, versionsRequiringInclusion, versionsRequiringExclusing, versionsAllowsInclusion, silentIgnore]}
// SilentIgnore: we use some v2 fields for v1 representation too, so we just clean them before serialize
// Tables from BIP-0174 (https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)
// prettier-ignore
exports.PSBTGlobal = {
    unsignedTx: [
        0x00,
        false,
        script_js_1.RawOldTx,
        [
            0
        ],
        [
            0
        ],
        false
    ],
    xpub: [
        0x01,
        GlobalXPUB,
        BIP32Der,
        [],
        [
            0,
            2
        ],
        false
    ],
    txVersion: [
        0x02,
        false,
        P.U32LE,
        [
            2
        ],
        [
            2
        ],
        false
    ],
    fallbackLocktime: [
        0x03,
        false,
        P.U32LE,
        [],
        [
            2
        ],
        false
    ],
    inputCount: [
        0x04,
        false,
        script_js_1.CompactSizeLen,
        [
            2
        ],
        [
            2
        ],
        false
    ],
    outputCount: [
        0x05,
        false,
        script_js_1.CompactSizeLen,
        [
            2
        ],
        [
            2
        ],
        false
    ],
    txModifiable: [
        0x06,
        false,
        P.U8,
        [],
        [
            2
        ],
        false
    ],
    version: [
        0xfb,
        false,
        P.U32LE,
        [],
        [
            0,
            2
        ],
        false
    ],
    proprietary: [
        0xfc,
        BytesInf,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ]
};
// prettier-ignore
exports.PSBTInput = {
    nonWitnessUtxo: [
        0x00,
        false,
        script_js_1.RawTx,
        [],
        [
            0,
            2
        ],
        false
    ],
    witnessUtxo: [
        0x01,
        false,
        script_js_1.RawOutput,
        [],
        [
            0,
            2
        ],
        false
    ],
    partialSig: [
        0x02,
        PubKeyECDSA,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    sighashType: [
        0x03,
        false,
        P.U32LE,
        [],
        [
            0,
            2
        ],
        false
    ],
    redeemScript: [
        0x04,
        false,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    witnessScript: [
        0x05,
        false,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    bip32Derivation: [
        0x06,
        PubKeyECDSA,
        BIP32Der,
        [],
        [
            0,
            2
        ],
        false
    ],
    finalScriptSig: [
        0x07,
        false,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    finalScriptWitness: [
        0x08,
        false,
        script_js_1.RawWitness,
        [],
        [
            0,
            2
        ],
        false
    ],
    porCommitment: [
        0x09,
        false,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    ripemd160: [
        0x0a,
        Bytes20,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    sha256: [
        0x0b,
        Bytes32,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    hash160: [
        0x0c,
        Bytes20,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    hash256: [
        0x0d,
        Bytes32,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    txid: [
        0x0e,
        false,
        Bytes32,
        [
            2
        ],
        [
            2
        ],
        true
    ],
    index: [
        0x0f,
        false,
        P.U32LE,
        [
            2
        ],
        [
            2
        ],
        true
    ],
    sequence: [
        0x10,
        false,
        P.U32LE,
        [],
        [
            2
        ],
        true
    ],
    requiredTimeLocktime: [
        0x11,
        false,
        P.U32LE,
        [],
        [
            2
        ],
        false
    ],
    requiredHeightLocktime: [
        0x12,
        false,
        P.U32LE,
        [],
        [
            2
        ],
        false
    ],
    tapKeySig: [
        0x13,
        false,
        SignatureSchnorr,
        [],
        [
            0,
            2
        ],
        false
    ],
    tapScriptSig: [
        0x14,
        tapScriptSigKey,
        SignatureSchnorr,
        [],
        [
            0,
            2
        ],
        false
    ],
    tapLeafScript: [
        0x15,
        exports.TaprootControlBlock,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    tapBip32Derivation: [
        0x16,
        Bytes32,
        TaprootBIP32Der,
        [],
        [
            0,
            2
        ],
        false
    ],
    tapInternalKey: [
        0x17,
        false,
        PubKeySchnorr,
        [],
        [
            0,
            2
        ],
        false
    ],
    tapMerkleRoot: [
        0x18,
        false,
        Bytes32,
        [],
        [
            0,
            2
        ],
        false
    ],
    proprietary: [
        0xfc,
        BytesInf,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ]
};
// All other keys removed when finalizing
exports.PSBTInputFinalKeys = [
    'txid',
    'sequence',
    'index',
    'witnessUtxo',
    'nonWitnessUtxo',
    'finalScriptSig',
    'finalScriptWitness',
    'unknown'
];
// Can be modified even on signed input
exports.PSBTInputUnsignedKeys = [
    'partialSig',
    'finalScriptSig',
    'finalScriptWitness',
    'tapKeySig',
    'tapScriptSig'
];
// prettier-ignore
exports.PSBTOutput = {
    redeemScript: [
        0x00,
        false,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    witnessScript: [
        0x01,
        false,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ],
    bip32Derivation: [
        0x02,
        PubKeyECDSA,
        BIP32Der,
        [],
        [
            0,
            2
        ],
        false
    ],
    amount: [
        0x03,
        false,
        P.I64LE,
        [
            2
        ],
        [
            2
        ],
        true
    ],
    script: [
        0x04,
        false,
        BytesInf,
        [
            2
        ],
        [
            2
        ],
        true
    ],
    tapInternalKey: [
        0x05,
        false,
        PubKeySchnorr,
        [],
        [
            0,
            2
        ],
        false
    ],
    tapTree: [
        0x06,
        false,
        tapTree,
        [],
        [
            0,
            2
        ],
        false
    ],
    tapBip32Derivation: [
        0x07,
        PubKeySchnorr,
        TaprootBIP32Der,
        [],
        [
            0,
            2
        ],
        false
    ],
    proprietary: [
        0xfc,
        BytesInf,
        BytesInf,
        [],
        [
            0,
            2
        ],
        false
    ]
};
// Can be modified even on signed input
exports.PSBTOutputUnsignedKeys = [];
const PSBTKeyPair = P.array(P.NULL, P.struct({
    //  <key> := <keylen> <keytype> <keydata> WHERE keylen = len(keytype)+len(keydata)
    key: P.prefix(script_js_1.CompactSizeLen, P.struct({
        type: script_js_1.CompactSizeLen,
        key: P.bytes(null)
    })),
    //  <value> := <valuelen> <valuedata>
    value: P.bytes(script_js_1.CompactSizeLen)
}));
function PSBTKeyInfo(info) {
    const [type, kc, vc, reqInc, allowInc, silentIgnore] = info;
    return {
        type,
        kc,
        vc,
        reqInc,
        allowInc,
        silentIgnore
    };
}
const PSBTUnknownKey = P.struct({
    type: script_js_1.CompactSizeLen,
    key: P.bytes(null)
});
// Key cannot be 'unknown', value coder cannot be array for elements with empty key
function PSBTKeyMap(psbtEnum) {
    // -> Record<type, [keyName, ...coders]>
    const byType = {};
    for(const k in psbtEnum){
        const [num, kc, vc] = psbtEnum[k];
        byType[num] = [
            k,
            kc,
            vc
        ];
    }
    return P.wrap({
        encodeStream: (w, value)=>{
            let out = [];
            // Because we use order of psbtEnum, keymap is sorted here
            for(const name in psbtEnum){
                const val = value[name];
                if (val === undefined) continue;
                const [type, kc, vc] = psbtEnum[name];
                if (!kc) {
                    out.push({
                        key: {
                            type,
                            key: P.EMPTY
                        },
                        value: vc.encode(val)
                    });
                } else {
                    // Low level interface, returns keys as is (with duplicates). Useful for debug
                    const kv = val.map((param)=>{
                        let [k, v] = param;
                        return [
                            kc.encode(k),
                            vc.encode(v)
                        ];
                    });
                    // sort by keys
                    kv.sort((a, b)=>(0, utils_js_1.compareBytes)(a[0], b[0]));
                    for (const [key, value] of kv)out.push({
                        key: {
                            key,
                            type
                        },
                        value
                    });
                }
            }
            if (value.unknown) {
                value.unknown.sort((a, b)=>(0, utils_js_1.compareBytes)(a[0].key, b[0].key));
                for (const [k, v] of value.unknown)out.push({
                    key: k,
                    value: v
                });
            }
            PSBTKeyPair.encodeStream(w, out);
        },
        decodeStream: (r)=>{
            const raw = PSBTKeyPair.decodeStream(r);
            const out = {};
            const noKey = {};
            for (const elm of raw){
                let name = 'unknown';
                let key = elm.key.key;
                let value = elm.value;
                if (byType[elm.key.type]) {
                    const [_name, kc, vc] = byType[elm.key.type];
                    name = _name;
                    if (!kc && key.length) {
                        throw new Error("PSBT: Non-empty key for ".concat(name, " (key=").concat(base_1.hex.encode(key), " value=").concat(base_1.hex.encode(value)));
                    }
                    key = kc ? kc.decode(key) : undefined;
                    value = vc.decode(value);
                    if (!kc) {
                        if (out[name]) throw new Error("PSBT: Same keys: ".concat(name, " (key=").concat(key, " value=").concat(value, ")"));
                        out[name] = value;
                        noKey[name] = true;
                        continue;
                    }
                } else {
                    // For unknown: add key type inside key
                    key = {
                        type: elm.key.type,
                        key: elm.key.key
                    };
                }
                // Only keyed elements at this point
                if (noKey[name]) throw new Error("PSBT: Key type with empty key and no key=".concat(name, " val=").concat(value));
                if (!out[name]) out[name] = [];
                out[name].push([
                    key,
                    value
                ]);
            }
            return out;
        }
    });
}
exports.PSBTInputCoder = P.validate(PSBTKeyMap(exports.PSBTInput), (i)=>{
    if (i.finalScriptWitness && !i.finalScriptWitness.length) throw new Error('validateInput: empty finalScriptWitness');
    //if (i.finalScriptSig && !i.finalScriptSig.length) throw new Error('validateInput: empty finalScriptSig');
    if (i.partialSig && !i.partialSig.length) throw new Error('Empty partialSig');
    if (i.partialSig) for (const [k] of i.partialSig)(0, utils_js_1.validatePubkey)(k, utils_js_1.PubT.ecdsa);
    if (i.bip32Derivation) for (const [k] of i.bip32Derivation)(0, utils_js_1.validatePubkey)(k, utils_js_1.PubT.ecdsa);
    // Locktime = unsigned little endian integer greater than or equal to 500000000 representing
    if (i.requiredTimeLocktime !== undefined && i.requiredTimeLocktime < 500000000) throw new Error("validateInput: wrong timeLocktime=".concat(i.requiredTimeLocktime));
    // unsigned little endian integer greater than 0 and less than 500000000
    if (i.requiredHeightLocktime !== undefined && (i.requiredHeightLocktime <= 0 || i.requiredHeightLocktime >= 500000000)) throw new Error("validateInput: wrong heighLocktime=".concat(i.requiredHeightLocktime));
    if (i.nonWitnessUtxo && i.index !== undefined) {
        const last = i.nonWitnessUtxo.outputs.length - 1;
        if (i.index > last) throw new Error("validateInput: index(".concat(i.index, ") not in nonWitnessUtxo"));
        const prevOut = i.nonWitnessUtxo.outputs[i.index];
        if (i.witnessUtxo && (!(0, utils_js_1.equalBytes)(i.witnessUtxo.script, prevOut.script) || i.witnessUtxo.amount !== prevOut.amount)) throw new Error('validateInput: witnessUtxo different from nonWitnessUtxo');
    }
    if (i.tapLeafScript) {
        // tap leaf version appears here twice: in control block and at the end of script
        for (const [k, v] of i.tapLeafScript){
            if ((k.version & 254) !== v[v.length - 1]) throw new Error('validateInput: tapLeafScript version mimatch');
            if (v[v.length - 1] & 1) throw new Error('validateInput: tapLeafScript version has parity bit!');
        }
    }
    // Validate txid for nonWitnessUtxo is correct
    if (i.nonWitnessUtxo && i.index !== undefined && i.txid) {
        const outputs = i.nonWitnessUtxo.outputs;
        if (outputs.length - 1 < i.index) throw new Error('nonWitnessUtxo: incorect output index');
        // At this point, we are using previous tx output to create new input.
        // Script safety checks are unnecessary:
        // - User has no control over previous tx. If somebody send money in same tx
        //   as unspendable output, we still want user able to spend money
        // - We still want some checks to notify user about possible errors early
        //   in case user wants to use wrong input by mistake
        // - Worst case: tx will be rejected by nodes. Still better than disallowing user
        //   to spend real input, no matter how broken it looks
        const tx = transaction_js_1.Transaction.fromRaw(script_js_1.RawTx.encode(i.nonWitnessUtxo), {
            allowUnknownOutputs: true,
            disableScriptCheck: true,
            allowUnknownInputs: true
        });
        const txid = base_1.hex.encode(i.txid);
        // PSBTv2 vectors have non-final tx in inputs
        if (tx.isFinal && tx.id !== txid) throw new Error("nonWitnessUtxo: wrong txid, exp=".concat(txid, " got=").concat(tx.id));
    }
    return i;
});
exports.PSBTOutputCoder = P.validate(PSBTKeyMap(exports.PSBTOutput), (o)=>{
    if (o.bip32Derivation) for (const [k] of o.bip32Derivation)(0, utils_js_1.validatePubkey)(k, utils_js_1.PubT.ecdsa);
    return o;
});
const PSBTGlobalCoder = P.validate(PSBTKeyMap(exports.PSBTGlobal), (g)=>{
    const version = g.version || 0;
    if (version === 0) {
        if (!g.unsignedTx) throw new Error('PSBTv0: missing unsignedTx');
        for (const inp of g.unsignedTx.inputs)if (inp.finalScriptSig && inp.finalScriptSig.length) throw new Error('PSBTv0: input scriptSig found in unsignedTx');
    }
    return g;
});
exports._RawPSBTV0 = P.struct({
    magic: P.magic(P.string(new Uint8Array([
        0xff
    ])), 'psbt'),
    global: PSBTGlobalCoder,
    inputs: P.array('global/unsignedTx/inputs/length', exports.PSBTInputCoder),
    outputs: P.array(null, exports.PSBTOutputCoder)
});
exports._RawPSBTV2 = P.struct({
    magic: P.magic(P.string(new Uint8Array([
        0xff
    ])), 'psbt'),
    global: PSBTGlobalCoder,
    inputs: P.array('global/inputCount', exports.PSBTInputCoder),
    outputs: P.array('global/outputCount', exports.PSBTOutputCoder)
});
exports._DebugPSBT = P.struct({
    magic: P.magic(P.string(new Uint8Array([
        0xff
    ])), 'psbt'),
    items: P.array(null, P.apply(P.array(P.NULL, P.tuple([
        P.hex(script_js_1.CompactSizeLen),
        P.bytes(script_js_1.CompactSize)
    ])), P.coders.dict()))
});
function validatePSBTFields(version, info, lst) {
    for(const k in lst){
        if (k === 'unknown') continue;
        if (!info[k]) continue;
        const { allowInc } = PSBTKeyInfo(info[k]);
        if (!allowInc.includes(version)) throw new Error("PSBTv".concat(version, ": field ").concat(k, " is not allowed"));
    }
    for(const k in info){
        const { reqInc } = PSBTKeyInfo(info[k]);
        if (reqInc.includes(version) && lst[k] === undefined) throw new Error("PSBTv".concat(version, ": missing required field ").concat(k));
    }
}
function cleanPSBTFields(version, info, lst) {
    const out = {};
    for(const _k in lst){
        const k = _k;
        if (k !== 'unknown') {
            if (!info[k]) continue;
            const { allowInc, silentIgnore } = PSBTKeyInfo(info[k]);
            if (!allowInc.includes(version)) {
                if (silentIgnore) continue;
                throw new Error("Failed to serialize in PSBTv".concat(version, ": ").concat(k, " but versions allows inclusion=").concat(allowInc));
            }
        }
        out[k] = lst[k];
    }
    return out;
}
function validatePSBT(tx) {
    const version = tx && tx.global && tx.global.version || 0;
    validatePSBTFields(version, exports.PSBTGlobal, tx.global);
    for (const i of tx.inputs)validatePSBTFields(version, exports.PSBTInput, i);
    for (const o of tx.outputs)validatePSBTFields(version, exports.PSBTOutput, o);
    // We allow only one empty element at the end of map (compat with bitcoinjs-lib bug)
    const inputCount = !version ? tx.global.unsignedTx.inputs.length : tx.global.inputCount;
    if (tx.inputs.length < inputCount) throw new Error('Not enough inputs');
    const inputsLeft = tx.inputs.slice(inputCount);
    if (inputsLeft.length > 1 || inputsLeft.length && Object.keys(inputsLeft[0]).length) throw new Error("Unexpected inputs left in tx=".concat(inputsLeft));
    // Same for inputs
    const outputCount = !version ? tx.global.unsignedTx.outputs.length : tx.global.outputCount;
    if (tx.outputs.length < outputCount) throw new Error('Not outputs inputs');
    const outputsLeft = tx.outputs.slice(outputCount);
    if (outputsLeft.length > 1 || outputsLeft.length && Object.keys(outputsLeft[0]).length) throw new Error("Unexpected outputs left in tx=".concat(outputsLeft));
    return tx;
}
function mergeKeyMap(psbtEnum, val, cur, allowedFields) {
    const res = {
        ...cur,
        ...val
    };
    // All arguments can be provided as hex
    for(const k in psbtEnum){
        const key = k;
        const [_, kC, vC] = psbtEnum[key];
        const cannotChange = allowedFields && !allowedFields.includes(k);
        if (val[k] === undefined && k in val) {
            if (cannotChange) throw new Error("Cannot remove signed field=".concat(k));
            delete res[k];
        } else if (kC) {
            const oldKV = cur && cur[k] ? cur[k] : [];
            let newKV = val[key];
            if (newKV) {
                if (!Array.isArray(newKV)) throw new Error("keyMap(".concat(k, "): KV pairs should be [k, v][]"));
                // Decode hex in k-v
                newKV = newKV.map((val)=>{
                    if (val.length !== 2) throw new Error("keyMap(".concat(k, "): KV pairs should be [k, v][]"));
                    return [
                        typeof val[0] === 'string' ? kC.decode(base_1.hex.decode(val[0])) : val[0],
                        typeof val[1] === 'string' ? vC.decode(base_1.hex.decode(val[1])) : val[1]
                    ];
                });
                const map = {};
                const add = (kStr, k, v)=>{
                    if (map[kStr] === undefined) {
                        map[kStr] = [
                            k,
                            v
                        ];
                        return;
                    }
                    const oldVal = base_1.hex.encode(vC.encode(map[kStr][1]));
                    const newVal = base_1.hex.encode(vC.encode(v));
                    if (oldVal !== newVal) throw new Error("keyMap(".concat(key, "): same key=").concat(kStr, " oldVal=").concat(oldVal, " newVal=").concat(newVal));
                };
                for (const [k, v] of oldKV){
                    const kStr = base_1.hex.encode(kC.encode(k));
                    add(kStr, k, v);
                }
                for (const [k, v] of newKV){
                    const kStr = base_1.hex.encode(kC.encode(k));
                    // undefined removes previous value
                    if (v === undefined) {
                        if (cannotChange) throw new Error("Cannot remove signed field=".concat(key, "/").concat(k));
                        delete map[kStr];
                    } else add(kStr, k, v);
                }
                res[key] = Object.values(map);
            }
        } else if (typeof res[k] === 'string') {
            res[k] = vC.decode(base_1.hex.decode(res[k]));
        } else if (cannotChange && k in val && cur && cur[k] !== undefined) {
            if (!(0, utils_js_1.equalBytes)(vC.encode(val[k]), vC.encode(cur[k]))) throw new Error("Cannot change signed field=".concat(k));
        }
    }
    // Remove unknown keys
    for(const k in res)if (!psbtEnum[k]) delete res[k];
    return res;
}
exports.RawPSBTV0 = P.validate(exports._RawPSBTV0, validatePSBT);
exports.RawPSBTV2 = P.validate(exports._RawPSBTV2, validatePSBT); //# sourceMappingURL=psbt.js.map
}),
"[project]/node_modules/@scure/btc-signer/payment.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._sortPubkeys = exports.p2tr_pk = exports.p2tr_ns = exports.tapLeafHash = exports.TAP_LEAF_VERSION = exports.p2ms = exports.p2wpkh = exports.p2wsh = exports.p2sh = exports.p2pkh = exports.p2pk = exports.OutScript = void 0;
exports.checkScript = checkScript;
exports.taprootListToTree = taprootListToTree;
exports.p2tr = p2tr;
exports.combinations = combinations;
exports.p2tr_ms = p2tr_ms;
exports.getAddress = getAddress;
exports.multisig = multisig;
exports.sortedMultisig = sortedMultisig;
exports.WIF = WIF;
exports.Address = Address;
const base_1 = __turbopack_context__.r("[project]/node_modules/@scure/base/lib/index.js [app-client] (ecmascript)");
const P = __turbopack_context__.r("[project]/node_modules/micro-packed/lib/index.js [app-client] (ecmascript)");
const psbt_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/psbt.js [app-client] (ecmascript)");
const script_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/script.js [app-client] (ecmascript)");
const u = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
const OutP2A = {
    encode (from) {
        if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1]) || base_1.hex.encode(from[1]) !== '4e73') return;
        return {
            type: 'p2a',
            script: script_js_1.Script.encode(from)
        };
    },
    decode: (to)=>{
        if (to.type !== 'p2a') return;
        return [
            1,
            base_1.hex.decode('4e73')
        ];
    }
};
function isValidPubkey(pub, type) {
    try {
        u.validatePubkey(pub, type);
        return true;
    } catch (e) {
        return false;
    }
}
const OutPK = {
    encode (from) {
        if (from.length !== 2 || !u.isBytes(from[0]) || !isValidPubkey(from[0], u.PubT.ecdsa) || from[1] !== 'CHECKSIG') return;
        return {
            type: 'pk',
            pubkey: from[0]
        };
    },
    decode: (to)=>to.type === 'pk' ? [
            to.pubkey,
            'CHECKSIG'
        ] : undefined
};
const OutPKH = {
    encode (from) {
        if (from.length !== 5 || from[0] !== 'DUP' || from[1] !== 'HASH160' || !u.isBytes(from[2])) return;
        if (from[3] !== 'EQUALVERIFY' || from[4] !== 'CHECKSIG') return;
        return {
            type: 'pkh',
            hash: from[2]
        };
    },
    decode: (to)=>to.type === 'pkh' ? [
            'DUP',
            'HASH160',
            to.hash,
            'EQUALVERIFY',
            'CHECKSIG'
        ] : undefined
};
const OutSH = {
    encode (from) {
        if (from.length !== 3 || from[0] !== 'HASH160' || !u.isBytes(from[1]) || from[2] !== 'EQUAL') return;
        return {
            type: 'sh',
            hash: from[1]
        };
    },
    decode: (to)=>to.type === 'sh' ? [
            'HASH160',
            to.hash,
            'EQUAL'
        ] : undefined
};
const OutWSH = {
    encode (from) {
        if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1])) return;
        if (from[1].length !== 32) return;
        return {
            type: 'wsh',
            hash: from[1]
        };
    },
    decode: (to)=>to.type === 'wsh' ? [
            0,
            to.hash
        ] : undefined
};
const OutWPKH = {
    encode (from) {
        if (from.length !== 2 || from[0] !== 0 || !u.isBytes(from[1])) return;
        if (from[1].length !== 20) return;
        return {
            type: 'wpkh',
            hash: from[1]
        };
    },
    decode: (to)=>to.type === 'wpkh' ? [
            0,
            to.hash
        ] : undefined
};
const OutMS = {
    encode (from) {
        const last = from.length - 1;
        if (from[last] !== 'CHECKMULTISIG') return;
        const m = from[0];
        const n = from[last - 1];
        if (typeof m !== 'number' || typeof n !== 'number') return;
        const pubkeys = from.slice(1, -2);
        if (n !== pubkeys.length) return;
        for (const pub of pubkeys)if (!u.isBytes(pub)) return;
        return {
            type: 'ms',
            m,
            pubkeys: pubkeys
        }; // we don't need n, since it is the same as pubkeys
    },
    // checkmultisig(n, ..pubkeys, m)
    decode: (to)=>to.type === 'ms' ? [
            to.m,
            ...to.pubkeys,
            to.pubkeys.length,
            'CHECKMULTISIG'
        ] : undefined
};
const OutTR = {
    encode (from) {
        if (from.length !== 2 || from[0] !== 1 || !u.isBytes(from[1])) return;
        return {
            type: 'tr',
            pubkey: from[1]
        };
    },
    decode: (to)=>to.type === 'tr' ? [
            1,
            to.pubkey
        ] : undefined
};
const OutTRNS = {
    encode (from) {
        const last = from.length - 1;
        if (from[last] !== 'CHECKSIG') return;
        const pubkeys = [];
        // On error return, since it can be different script
        for(let i = 0; i < last; i++){
            const elm = from[i];
            if (i & 1) {
                if (elm !== 'CHECKSIGVERIFY' || i === last - 1) return;
                continue;
            }
            if (!u.isBytes(elm)) return;
            pubkeys.push(elm);
        }
        return {
            type: 'tr_ns',
            pubkeys
        };
    },
    decode: (to)=>{
        if (to.type !== 'tr_ns') return;
        const out = [];
        for(let i = 0; i < to.pubkeys.length - 1; i++)out.push(to.pubkeys[i], 'CHECKSIGVERIFY');
        out.push(to.pubkeys[to.pubkeys.length - 1], 'CHECKSIG');
        return out;
    }
};
const OutTRMS = {
    encode (from) {
        const last = from.length - 1;
        if (from[last] !== 'NUMEQUAL' || from[1] !== 'CHECKSIG') return;
        const pubkeys = [];
        const m = (0, script_js_1.OpToNum)(from[last - 1]);
        if (typeof m !== 'number') return;
        for(let i = 0; i < last - 1; i++){
            const elm = from[i];
            if (i & 1) {
                if (elm !== (i === 1 ? 'CHECKSIG' : 'CHECKSIGADD')) throw new Error('OutScript.encode/tr_ms: wrong element');
                continue;
            }
            if (!u.isBytes(elm)) throw new Error('OutScript.encode/tr_ms: wrong key element');
            pubkeys.push(elm);
        }
        return {
            type: 'tr_ms',
            pubkeys,
            m
        };
    },
    decode: (to)=>{
        if (to.type !== 'tr_ms') return;
        const out = [
            to.pubkeys[0],
            'CHECKSIG'
        ];
        for(let i = 1; i < to.pubkeys.length; i++)out.push(to.pubkeys[i], 'CHECKSIGADD');
        out.push(to.m, 'NUMEQUAL');
        return out;
    }
};
const OutUnknown = {
    encode (from) {
        return {
            type: 'unknown',
            script: script_js_1.Script.encode(from)
        };
    },
    decode: (to)=>to.type === 'unknown' ? script_js_1.Script.decode(to.script) : undefined
};
// /Payments
const OutScripts = [
    OutP2A,
    OutPK,
    OutPKH,
    OutSH,
    OutWSH,
    OutWPKH,
    OutMS,
    OutTR,
    OutTRNS,
    OutTRMS,
    OutUnknown
];
// TODO: we can support user supplied output scripts now
// - addOutScript
// - removeOutScript
// - We can do that as log we modify array in-place
// - Actually is very hard, since there is sign/finalize logic
const _OutScript = P.apply(script_js_1.Script, P.coders.match(OutScripts));
// We can validate this once, because of packed & coders
exports.OutScript = P.validate(_OutScript, (i)=>{
    if (i.type === 'pk' && !isValidPubkey(i.pubkey, u.PubT.ecdsa)) throw new Error('OutScript/pk: wrong key');
    if ((i.type === 'pkh' || i.type === 'sh' || i.type === 'wpkh') && (!u.isBytes(i.hash) || i.hash.length !== 20)) throw new Error("OutScript/".concat(i.type, ": wrong hash"));
    if (i.type === 'wsh' && (!u.isBytes(i.hash) || i.hash.length !== 32)) throw new Error("OutScript/wsh: wrong hash");
    if (i.type === 'tr' && (!u.isBytes(i.pubkey) || !isValidPubkey(i.pubkey, u.PubT.schnorr))) throw new Error('OutScript/tr: wrong taproot public key');
    if (i.type === 'ms' || i.type === 'tr_ns' || i.type === 'tr_ms') {
        if (!Array.isArray(i.pubkeys)) throw new Error('OutScript/multisig: wrong pubkeys array');
    }
    if (i.type === 'ms') {
        const n = i.pubkeys.length;
        for (const p of i.pubkeys)if (!isValidPubkey(p, u.PubT.ecdsa)) throw new Error('OutScript/multisig: wrong pubkey');
        if (i.m <= 0 || n > 16 || i.m > n) throw new Error('OutScript/multisig: invalid params');
    }
    if (i.type === 'tr_ns' || i.type === 'tr_ms') {
        for (const p of i.pubkeys)if (!isValidPubkey(p, u.PubT.schnorr)) throw new Error("OutScript/".concat(i.type, ": wrong pubkey"));
    }
    if (i.type === 'tr_ms') {
        const n = i.pubkeys.length;
        if (i.m <= 0 || n > 999 || i.m > n) throw new Error('OutScript/tr_ms: invalid params');
    }
    return i;
});
// Basic sanity check for scripts
function checkWSH(s, witnessScript) {
    if (!u.equalBytes(s.hash, u.sha256(witnessScript))) throw new Error('checkScript: wsh wrong witnessScript hash');
    const w = exports.OutScript.decode(witnessScript);
    if (w.type === 'tr' || w.type === 'tr_ns' || w.type === 'tr_ms') throw new Error("checkScript: P2".concat(w.type, " cannot be wrapped in P2SH"));
    if (w.type === 'wpkh' || w.type === 'sh') throw new Error("checkScript: P2".concat(w.type, " cannot be wrapped in P2WSH"));
}
function checkScript(script, redeemScript, witnessScript) {
    if (script) {
        const s = exports.OutScript.decode(script);
        // ms||pk maybe work, but there will be no address, hard to spend
        if (s.type === 'tr_ns' || s.type === 'tr_ms' || s.type === 'ms' || s.type == 'pk') throw new Error("checkScript: non-wrapped ".concat(s.type));
        if (s.type === 'sh' && redeemScript) {
            if (!u.equalBytes(s.hash, u.hash160(redeemScript))) throw new Error('checkScript: sh wrong redeemScript hash');
            const r = exports.OutScript.decode(redeemScript);
            if (r.type === 'tr' || r.type === 'tr_ns' || r.type === 'tr_ms') throw new Error("checkScript: P2".concat(r.type, " cannot be wrapped in P2SH"));
            // Not sure if this unspendable, but we cannot represent this via PSBT
            if (r.type === 'sh') throw new Error('checkScript: P2SH cannot be wrapped in P2SH');
        }
        if (s.type === 'wsh' && witnessScript) checkWSH(s, witnessScript);
    }
    if (redeemScript) {
        const r = exports.OutScript.decode(redeemScript);
        if (r.type === 'wsh' && witnessScript) checkWSH(r, witnessScript);
    }
}
function uniqPubkey(pubkeys) {
    const map = {};
    for (const pub of pubkeys){
        const key = base_1.hex.encode(pub);
        if (map[key]) throw new Error("Multisig: non-uniq pubkey: ".concat(pubkeys.map(base_1.hex.encode)));
        map[key] = true;
    }
}
// @ts-ignore
const p2pk = function(pubkey) {
    let network = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : utils_js_1.NETWORK;
    // network is unused
    if (!isValidPubkey(pubkey, u.PubT.ecdsa)) throw new Error('P2PK: invalid publicKey');
    return {
        type: 'pk',
        script: exports.OutScript.encode({
            type: 'pk',
            pubkey
        })
    };
};
exports.p2pk = p2pk;
const p2pkh = function(publicKey) {
    let network = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : utils_js_1.NETWORK;
    if (!isValidPubkey(publicKey, u.PubT.ecdsa)) throw new Error('P2PKH: invalid publicKey');
    const hash = u.hash160(publicKey);
    return {
        type: 'pkh',
        script: exports.OutScript.encode({
            type: 'pkh',
            hash
        }),
        address: Address(network).encode({
            type: 'pkh',
            hash
        })
    };
};
exports.p2pkh = p2pkh;
const p2sh = function(child) {
    let network = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : utils_js_1.NETWORK;
    // It is already tested inside noble-hashes and checkScript
    const cs = child.script;
    if (!u.isBytes(cs)) throw new Error("Wrong script: ".concat(typeof child.script, ", expected Uint8Array"));
    const hash = u.hash160(cs);
    const script = exports.OutScript.encode({
        type: 'sh',
        hash
    });
    checkScript(script, cs, child.witnessScript);
    const res = {
        type: 'sh',
        redeemScript: cs,
        script: exports.OutScript.encode({
            type: 'sh',
            hash
        }),
        address: Address(network).encode({
            type: 'sh',
            hash
        })
    };
    if (child.witnessScript) res.witnessScript = child.witnessScript;
    return res;
};
exports.p2sh = p2sh;
const p2wsh = function(child) {
    let network = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : utils_js_1.NETWORK;
    const cs = child.script;
    if (!u.isBytes(cs)) throw new Error("Wrong script: ".concat(typeof cs, ", expected Uint8Array"));
    const hash = u.sha256(cs);
    const script = exports.OutScript.encode({
        type: 'wsh',
        hash
    });
    checkScript(script, undefined, cs);
    return {
        type: 'wsh',
        witnessScript: cs,
        script: exports.OutScript.encode({
            type: 'wsh',
            hash
        }),
        address: Address(network).encode({
            type: 'wsh',
            hash
        })
    };
};
exports.p2wsh = p2wsh;
const p2wpkh = function(publicKey) {
    let network = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : utils_js_1.NETWORK;
    if (!isValidPubkey(publicKey, u.PubT.ecdsa)) throw new Error('P2WPKH: invalid publicKey');
    if (publicKey.length === 65) throw new Error('P2WPKH: uncompressed public key');
    const hash = u.hash160(publicKey);
    return {
        type: 'wpkh',
        script: exports.OutScript.encode({
            type: 'wpkh',
            hash
        }),
        address: Address(network).encode({
            type: 'wpkh',
            hash
        })
    };
};
exports.p2wpkh = p2wpkh;
const p2ms = function(m, pubkeys) {
    let allowSamePubkeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!allowSamePubkeys) uniqPubkey(pubkeys);
    return {
        type: 'ms',
        script: exports.OutScript.encode({
            type: 'ms',
            pubkeys,
            m
        })
    };
};
exports.p2ms = p2ms;
function checkTaprootScript(script, internalPubKey) {
    let allowUnknownOutputs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, customScripts = arguments.length > 3 ? arguments[3] : void 0;
    const out = exports.OutScript.decode(script);
    if (out.type === 'unknown') {
        // NOTE: this check should be before allowUnknownOutputs, otherwise it will
        // disable custom. All custom scripts for taproot should have prefix 'tr_'
        if (customScripts) {
            const cs = P.apply(script_js_1.Script, P.coders.match(customScripts));
            const c = cs.decode(script);
            if (c !== undefined) {
                if (typeof c.type !== 'string' || !c.type.startsWith('tr_')) throw new Error("P2TR: invalid custom type=".concat(c.type));
                return;
            }
        }
        if (allowUnknownOutputs) return;
    }
    if (![
        'tr_ns',
        'tr_ms'
    ].includes(out.type)) throw new Error("P2TR: invalid leaf script=".concat(out.type));
    const outms = out;
    if (!allowUnknownOutputs && outms.pubkeys) {
        for (const p of outms.pubkeys){
            if (u.equalBytes(p, u.TAPROOT_UNSPENDABLE_KEY)) throw new Error('Unspendable taproot key in leaf script');
            // It's likely a mistake at this point:
            // 1. p2tr(A, p2tr_ns(2, [A, B])) == p2tr(A, p2tr_pk(B)) (A or B key)
            // but will take more space and fees.
            // 2. For multi-sig p2tr(A, p2tr_ns(2, [A, B, C])) it's probably a security issue:
            // User creates 2 of 3 multisig of keys [A, B, C],
            // but key A always can spend whole output without signatures from other keys.
            // p2tr(A, p2tr_ns(2, [B, C, D])) is ok: A or (B and C) or (B and D) or (C and D)
            if (u.equalBytes(p, internalPubKey)) {
                throw new Error('Using P2TR with leaf script with same key as internal key is not supported');
            }
        }
    }
}
// Helper for generating binary tree from list, with weights
function taprootListToTree(taprootList) {
    // Clone input in order to not corrupt it
    const lst = Array.from(taprootList);
    // We have at least 2 elements => can create branch
    while(lst.length >= 2){
        // Sort: elements with smallest weight are in the end of queue
        lst.sort((a, b)=>(b.weight || 1) - (a.weight || 1));
        const b = lst.pop();
        const a = lst.pop();
        const weight = ((a === null || a === void 0 ? void 0 : a.weight) || 1) + ((b === null || b === void 0 ? void 0 : b.weight) || 1);
        lst.push({
            weight,
            // Unwrap children array
            // TODO: Very hard to remove any here
            childs: [
                (a === null || a === void 0 ? void 0 : a.childs) || a,
                (b === null || b === void 0 ? void 0 : b.childs) || b
            ]
        });
    }
    // At this point there is always 1 element in lst
    const last = lst[0];
    return (last === null || last === void 0 ? void 0 : last.childs) || last;
}
function taprootAddPath(tree) {
    let path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    if (!tree) throw new Error("taprootAddPath: empty tree");
    if (tree.type === 'leaf') return {
        ...tree,
        path
    };
    if (tree.type !== 'branch') throw new Error("taprootAddPath: wrong type=".concat(tree));
    return {
        ...tree,
        path,
        // Left element has right hash in path and otherwise
        left: taprootAddPath(tree.left, [
            tree.right.hash,
            ...path
        ]),
        right: taprootAddPath(tree.right, [
            tree.left.hash,
            ...path
        ])
    };
}
function taprootWalkTree(tree) {
    if (!tree) throw new Error("taprootAddPath: empty tree");
    if (tree.type === 'leaf') return [
        tree
    ];
    if (tree.type !== 'branch') throw new Error("taprootWalkTree: wrong type=".concat(tree));
    return [
        ...taprootWalkTree(tree.left),
        ...taprootWalkTree(tree.right)
    ];
}
function taprootHashTree(tree, internalPubKey) {
    let allowUnknownOutputs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, customScripts = arguments.length > 3 ? arguments[3] : void 0;
    if (!tree) throw new Error('taprootHashTree: empty tree');
    if (Array.isArray(tree) && tree.length === 1) tree = tree[0];
    // Terminal node (leaf)
    if (!Array.isArray(tree)) {
        const { leafVersion: version, script: leafScript } = tree;
        // Earliest tree walk where we can validate tapScripts
        if (tree.tapLeafScript || tree.tapMerkleRoot && !u.equalBytes(tree.tapMerkleRoot, P.EMPTY)) throw new Error('P2TR: tapRoot leafScript cannot have tree');
        const script = typeof leafScript === 'string' ? base_1.hex.decode(leafScript) : leafScript;
        if (!u.isBytes(script)) throw new Error("checkScript: wrong script type=".concat(script));
        checkTaprootScript(script, internalPubKey, allowUnknownOutputs, customScripts);
        return {
            type: 'leaf',
            version,
            script,
            hash: (0, exports.tapLeafHash)(script, version)
        };
    }
    // If tree / branch is not binary tree, convert it
    if (tree.length !== 2) tree = taprootListToTree(tree);
    if (tree.length !== 2) throw new Error('hashTree: non binary tree!');
    // branch
    // Both nodes should exist
    const left = taprootHashTree(tree[0], internalPubKey, allowUnknownOutputs, customScripts);
    const right = taprootHashTree(tree[1], internalPubKey, allowUnknownOutputs, customScripts);
    // We cannot swap left/right here, since it will change structure of tree
    let [lH, rH] = [
        left.hash,
        right.hash
    ];
    if (u.compareBytes(rH, lH) === -1) [lH, rH] = [
        rH,
        lH
    ];
    return {
        type: 'branch',
        left,
        right,
        hash: u.tagSchnorr('TapBranch', lH, rH)
    };
}
exports.TAP_LEAF_VERSION = 0xc0;
const tapLeafHash = function(script) {
    let version = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : exports.TAP_LEAF_VERSION;
    return u.tagSchnorr('TapLeaf', new Uint8Array([
        version
    ]), script_js_1.VarBytes.encode(script));
};
exports.tapLeafHash = tapLeafHash;
// Works as key OR tree.
// If we only have tree, need to add unspendable key, otherwise
// complex multisig wallet can be spent by owner of key only. See TAPROOT_UNSPENDABLE_KEY
function p2tr(internalPubKey, tree) {
    let network = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : utils_js_1.NETWORK, allowUnknownOutputs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, customScripts = arguments.length > 4 ? arguments[4] : void 0;
    // Unspendable
    if (!internalPubKey && !tree) throw new Error('p2tr: should have pubKey or scriptTree (or both)');
    const pubKey = typeof internalPubKey === 'string' ? base_1.hex.decode(internalPubKey) : internalPubKey || u.TAPROOT_UNSPENDABLE_KEY;
    if (!isValidPubkey(pubKey, u.PubT.schnorr)) throw new Error('p2tr: non-schnorr pubkey');
    let hashedTree = tree ? taprootAddPath(taprootHashTree(tree, pubKey, allowUnknownOutputs, customScripts)) : undefined;
    const tapMerkleRoot = hashedTree ? hashedTree.hash : undefined;
    const [tweakedPubkey, parity] = u.taprootTweakPubkey(pubKey, tapMerkleRoot || P.EMPTY);
    let leaves;
    if (hashedTree) {
        leaves = taprootWalkTree(hashedTree).map((l)=>({
                ...l,
                controlBlock: psbt_js_1.TaprootControlBlock.encode({
                    version: (l.version || exports.TAP_LEAF_VERSION) + parity,
                    internalKey: pubKey,
                    merklePath: l.path
                })
            }));
    }
    let tapLeafScript;
    if (leaves) {
        tapLeafScript = leaves.map((l)=>[
                psbt_js_1.TaprootControlBlock.decode(l.controlBlock),
                u.concatBytes(l.script, new Uint8Array([
                    l.version || exports.TAP_LEAF_VERSION
                ]))
            ]);
    }
    const res = {
        type: 'tr',
        script: exports.OutScript.encode({
            type: 'tr',
            pubkey: tweakedPubkey
        }),
        address: Address(network).encode({
            type: 'tr',
            pubkey: tweakedPubkey
        }),
        // For tests
        tweakedPubkey,
        // PSBT stuff
        tapInternalKey: pubKey
    };
    // Just in case someone would want to select a specific script
    if (leaves) res.leaves = leaves;
    if (tapLeafScript) res.tapLeafScript = tapLeafScript;
    if (tapMerkleRoot) res.tapMerkleRoot = tapMerkleRoot;
    return res;
}
// Returns all combinations of size M from lst
function combinations(m, list) {
    const res = [];
    if (!Array.isArray(list)) throw new Error('combinations: lst arg should be array');
    const n = list.length;
    if (m > n) throw new Error('combinations: m > lst.length, no combinations possible');
    /*
    Basically works as M nested loops like:
    for (;idx[0]<lst.length;idx[0]++) for (idx[1]=idx[0]+1;idx[1]<lst.length;idx[1]++)
    but since we cannot create nested loops dynamically, we unroll it to a single loop
    */ const idx = Array.from({
        length: m
    }, (_, i)=>i);
    const last = idx.length - 1;
    main: for(;;){
        res.push(idx.map((i)=>list[i]));
        idx[last] += 1;
        let i = last;
        // Propagate increment
        // idx[i] cannot be bigger than n-m+i, otherwise last elements in right part will overflow
        for(; i >= 0 && idx[i] > n - m + i; i--){
            idx[i] = 0;
            // Overflow in idx[0], break
            if (i === 0) break main;
            idx[i - 1] += 1;
        }
        // Propagate: idx[i+1] = idx[idx]+1
        for(i += 1; i < idx.length; i++)idx[i] = idx[i - 1] + 1;
    }
    return res;
}
/**
 * M-of-N multi-leaf wallet via p2tr_ns. If m == n, single script is emitted.
 * Takes O(n^2) if m != n. 99-of-100 is ok, 5-of-100 is not.
 * `2-of-[A,B,C] => [A,B] | [A,C] | [B,C]`
 */ const p2tr_ns = function(m, pubkeys) {
    let allowSamePubkeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!allowSamePubkeys) uniqPubkey(pubkeys);
    return combinations(m, pubkeys).map((i)=>({
            type: 'tr_ns',
            script: exports.OutScript.encode({
                type: 'tr_ns',
                pubkeys: i
            })
        }));
};
exports.p2tr_ns = p2tr_ns;
// Taproot public key (case of p2tr_ns)
const p2tr_pk = (pubkey)=>(0, exports.p2tr_ns)(1, [
        pubkey
    ], undefined)[0];
exports.p2tr_pk = p2tr_pk;
function p2tr_ms(m, pubkeys) {
    let allowSamePubkeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!allowSamePubkeys) uniqPubkey(pubkeys);
    return {
        type: 'tr_ms',
        script: exports.OutScript.encode({
            type: 'tr_ms',
            pubkeys,
            m
        })
    };
}
// Simple pubkey address, without complex scripts
function getAddress(type, privKey) {
    let network = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : utils_js_1.NETWORK;
    if (type === 'tr') {
        return p2tr(u.pubSchnorr(privKey), undefined, network).address;
    }
    const pubKey = u.pubECDSA(privKey);
    if (type === 'pkh') return (0, exports.p2pkh)(pubKey, network).address;
    if (type === 'wpkh') return (0, exports.p2wpkh)(pubKey, network).address;
    throw new Error("getAddress: unknown type=".concat(type));
}
const _sortPubkeys = (pubkeys)=>Array.from(pubkeys).sort(u.compareBytes);
exports._sortPubkeys = _sortPubkeys;
function multisig(m, pubkeys) {
    let sorted = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, witness = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, network = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : utils_js_1.NETWORK;
    const ms = (0, exports.p2ms)(m, sorted ? (0, exports._sortPubkeys)(pubkeys) : pubkeys);
    return witness ? (0, exports.p2wsh)(ms, network) : (0, exports.p2sh)(ms, network);
}
function sortedMultisig(m, pubkeys) {
    let witness = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, network = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : utils_js_1.NETWORK;
    return multisig(m, pubkeys, true, witness, network);
}
const base58check = (0, base_1.createBase58check)(u.sha256);
function validateWitness(version, data) {
    if (data.length < 2 || data.length > 40) throw new Error('Witness: invalid length');
    if (version > 16) throw new Error('Witness: invalid version');
    if (version === 0 && !(data.length === 20 || data.length === 32)) throw new Error('Witness: invalid length for version');
}
function programToWitness(version, data) {
    let network = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : utils_js_1.NETWORK;
    validateWitness(version, data);
    const coder = version === 0 ? base_1.bech32 : base_1.bech32m;
    return coder.encode(network.bech32, [
        version
    ].concat(coder.toWords(data)));
}
function formatKey(hashed, prefix) {
    return base58check.encode(u.concatBytes(Uint8Array.from(prefix), hashed));
}
function WIF() {
    let network = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : utils_js_1.NETWORK;
    return {
        encode (privKey) {
            const compressed = u.concatBytes(privKey, new Uint8Array([
                0x01
            ]));
            return formatKey(compressed.subarray(0, 33), [
                network.wif
            ]);
        },
        decode (wif) {
            let parsed = base58check.decode(wif);
            if (parsed[0] !== network.wif) throw new Error('Wrong WIF prefix');
            parsed = parsed.subarray(1);
            // Check what it is. Compressed flag?
            if (parsed.length !== 33) throw new Error('Wrong WIF length');
            if (parsed[32] !== 0x01) throw new Error('Wrong WIF postfix');
            return parsed.subarray(0, -1);
        }
    };
}
// Returns OutType, which can be used to create outscript
function Address() {
    let network = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : utils_js_1.NETWORK;
    return {
        encode (from) {
            const { type } = from;
            if (type === 'wpkh') return programToWitness(0, from.hash, network);
            else if (type === 'wsh') return programToWitness(0, from.hash, network);
            else if (type === 'tr') return programToWitness(1, from.pubkey, network);
            else if (type === 'pkh') return formatKey(from.hash, [
                network.pubKeyHash
            ]);
            else if (type === 'sh') return formatKey(from.hash, [
                network.scriptHash
            ]);
            throw new Error("Unknown address type=".concat(type));
        },
        decode (address) {
            if (address.length < 14 || address.length > 74) throw new Error('Invalid address length');
            // Bech32
            if (network.bech32 && address.toLowerCase().startsWith("".concat(network.bech32, "1"))) {
                let res;
                try {
                    res = base_1.bech32.decode(address);
                    if (res.words[0] !== 0) throw new Error("bech32: wrong version=".concat(res.words[0]));
                } catch (_) {
                    // Starting from version 1 it is decoded as bech32m
                    res = base_1.bech32m.decode(address);
                    if (res.words[0] === 0) throw new Error("bech32m: wrong version=".concat(res.words[0]));
                }
                if (res.prefix !== network.bech32) throw new Error("wrong bech32 prefix=".concat(res.prefix));
                const [version, ...program] = res.words;
                const data = base_1.bech32.fromWords(program);
                validateWitness(version, data);
                if (version === 0 && data.length === 32) return {
                    type: 'wsh',
                    hash: data
                };
                else if (version === 0 && data.length === 20) return {
                    type: 'wpkh',
                    hash: data
                };
                else if (version === 1 && data.length === 32) return {
                    type: 'tr',
                    pubkey: data
                };
                else throw new Error('Unknown witness program');
            }
            const data = base58check.decode(address);
            if (data.length !== 21) throw new Error('Invalid base58 address');
            // Pay To Public Key Hash
            if (data[0] === network.pubKeyHash) {
                return {
                    type: 'pkh',
                    hash: data.slice(1)
                };
            } else if (data[0] === network.scriptHash) {
                return {
                    type: 'sh',
                    hash: data.slice(1)
                };
            }
            throw new Error("Invalid address prefix=".concat(data[0]));
        }
    };
} //# sourceMappingURL=payment.js.map
}),
"[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._Estimator = exports._cmpBig = exports.SigHash = exports.PSBTCombine = exports.DEFAULT_SEQUENCE = exports.Decimal = exports.bip32Path = exports.TaprootControlBlock = exports._DebugPSBT = exports.WIF = exports.taprootListToTree = exports.sortedMultisig = exports.OutScript = exports.getAddress = exports.combinations = exports.Address = exports._sortPubkeys = exports.utils = exports.selectUTXO = exports.getInputType = exports.TEST_NETWORK = exports.TAPROOT_UNSPENDABLE_KEY = exports.NETWORK = exports.Transaction = exports.ScriptNum = exports.Script = exports.RawWitness = exports.RawTx = exports.OP = exports.MAX_SCRIPT_BYTE_LENGTH = exports.CompactSize = exports.p2wsh = exports.p2wpkh = exports.p2tr_pk = exports.p2tr_ns = exports.p2tr_ms = exports.p2tr = exports.p2sh = exports.p2pkh = exports.p2pk = exports.p2ms = exports.multisig = void 0;
/*! scure-btc-signer - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
// should multisig be exported as classicMultisig?
// prettier-ignore
var payment_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/payment.js [app-client] (ecmascript)");
Object.defineProperty(exports, "multisig", {
    enumerable: true,
    get: function() {
        return payment_js_1.multisig;
    }
});
Object.defineProperty(exports, "p2ms", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2ms;
    }
});
Object.defineProperty(exports, "p2pk", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2pk;
    }
});
Object.defineProperty(exports, "p2pkh", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2pkh;
    }
});
Object.defineProperty(exports, "p2sh", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2sh;
    }
});
Object.defineProperty(exports, "p2tr", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2tr;
    }
});
Object.defineProperty(exports, "p2tr_ms", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2tr_ms;
    }
});
Object.defineProperty(exports, "p2tr_ns", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2tr_ns;
    }
});
Object.defineProperty(exports, "p2tr_pk", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2tr_pk;
    }
});
Object.defineProperty(exports, "p2wpkh", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2wpkh;
    }
});
Object.defineProperty(exports, "p2wsh", {
    enumerable: true,
    get: function() {
        return payment_js_1.p2wsh;
    }
});
var script_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/script.js [app-client] (ecmascript)");
Object.defineProperty(exports, "CompactSize", {
    enumerable: true,
    get: function() {
        return script_js_1.CompactSize;
    }
});
Object.defineProperty(exports, "MAX_SCRIPT_BYTE_LENGTH", {
    enumerable: true,
    get: function() {
        return script_js_1.MAX_SCRIPT_BYTE_LENGTH;
    }
});
Object.defineProperty(exports, "OP", {
    enumerable: true,
    get: function() {
        return script_js_1.OP;
    }
});
Object.defineProperty(exports, "RawTx", {
    enumerable: true,
    get: function() {
        return script_js_1.RawTx;
    }
});
Object.defineProperty(exports, "RawWitness", {
    enumerable: true,
    get: function() {
        return script_js_1.RawWitness;
    }
});
Object.defineProperty(exports, "Script", {
    enumerable: true,
    get: function() {
        return script_js_1.Script;
    }
});
Object.defineProperty(exports, "ScriptNum", {
    enumerable: true,
    get: function() {
        return script_js_1.ScriptNum;
    }
});
var transaction_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/transaction.js [app-client] (ecmascript)");
Object.defineProperty(exports, "Transaction", {
    enumerable: true,
    get: function() {
        return transaction_js_1.Transaction;
    }
});
var utils_js_2 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
Object.defineProperty(exports, "NETWORK", {
    enumerable: true,
    get: function() {
        return utils_js_2.NETWORK;
    }
});
Object.defineProperty(exports, "TAPROOT_UNSPENDABLE_KEY", {
    enumerable: true,
    get: function() {
        return utils_js_2.TAPROOT_UNSPENDABLE_KEY;
    }
});
Object.defineProperty(exports, "TEST_NETWORK", {
    enumerable: true,
    get: function() {
        return utils_js_2.TEST_NETWORK;
    }
});
var utxo_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utxo.js [app-client] (ecmascript)");
Object.defineProperty(exports, "getInputType", {
    enumerable: true,
    get: function() {
        return utxo_js_1.getInputType;
    }
});
Object.defineProperty(exports, "selectUTXO", {
    enumerable: true,
    get: function() {
        return utxo_js_1.selectUTXO;
    }
});
exports.utils = {
    isBytes: utils_js_1.isBytes,
    concatBytes: utils_js_1.concatBytes,
    compareBytes: utils_js_1.compareBytes,
    pubSchnorr: utils_js_1.pubSchnorr,
    randomPrivateKeyBytes: utils_js_1.randomPrivateKeyBytes,
    taprootTweakPubkey: utils_js_1.taprootTweakPubkey
};
var payment_js_2 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/payment.js [app-client] (ecmascript)"); // remove
Object.defineProperty(exports, "_sortPubkeys", {
    enumerable: true,
    get: function() {
        return payment_js_2._sortPubkeys;
    }
});
Object.defineProperty(exports, "Address", {
    enumerable: true,
    get: function() {
        return payment_js_2.Address;
    }
});
Object.defineProperty(exports, "combinations", {
    enumerable: true,
    get: function() {
        return payment_js_2.combinations;
    }
});
Object.defineProperty(exports, "getAddress", {
    enumerable: true,
    get: function() {
        return payment_js_2.getAddress;
    }
});
Object.defineProperty(exports, "OutScript", {
    enumerable: true,
    get: function() {
        return payment_js_2.OutScript;
    }
});
Object.defineProperty(exports, "sortedMultisig", {
    enumerable: true,
    get: function() {
        return payment_js_2.sortedMultisig;
    }
});
Object.defineProperty(exports, "taprootListToTree", {
    enumerable: true,
    get: function() {
        return payment_js_2.taprootListToTree;
    }
});
Object.defineProperty(exports, "WIF", {
    enumerable: true,
    get: function() {
        return payment_js_2.WIF;
    }
});
var psbt_js_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/psbt.js [app-client] (ecmascript)"); // remove
Object.defineProperty(exports, "_DebugPSBT", {
    enumerable: true,
    get: function() {
        return psbt_js_1._DebugPSBT;
    }
});
Object.defineProperty(exports, "TaprootControlBlock", {
    enumerable: true,
    get: function() {
        return psbt_js_1.TaprootControlBlock;
    }
});
var transaction_js_2 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/transaction.js [app-client] (ecmascript)"); // remove
Object.defineProperty(exports, "bip32Path", {
    enumerable: true,
    get: function() {
        return transaction_js_2.bip32Path;
    }
});
Object.defineProperty(exports, "Decimal", {
    enumerable: true,
    get: function() {
        return transaction_js_2.Decimal;
    }
});
Object.defineProperty(exports, "DEFAULT_SEQUENCE", {
    enumerable: true,
    get: function() {
        return transaction_js_2.DEFAULT_SEQUENCE;
    }
});
Object.defineProperty(exports, "PSBTCombine", {
    enumerable: true,
    get: function() {
        return transaction_js_2.PSBTCombine;
    }
});
Object.defineProperty(exports, "SigHash", {
    enumerable: true,
    get: function() {
        return transaction_js_2.SigHash;
    }
});
var utxo_js_2 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utxo.js [app-client] (ecmascript)");
Object.defineProperty(exports, "_cmpBig", {
    enumerable: true,
    get: function() {
        return utxo_js_2._cmpBig;
    }
});
Object.defineProperty(exports, "_Estimator", {
    enumerable: true,
    get: function() {
        return utxo_js_2._Estimator;
    }
}); //# sourceMappingURL=index.js.map
}),
]);

//# sourceMappingURL=node_modules_%40scure_btc-signer_8b59456c._.js.map