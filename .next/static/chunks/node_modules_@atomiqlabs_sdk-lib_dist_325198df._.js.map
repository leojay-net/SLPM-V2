{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/errors/RequestError.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OutOfBoundsError = exports.RequestError = void 0;\r\n/**\r\n * An error returned by the intermediary in a http response\r\n */\r\nclass RequestError extends Error {\r\n    constructor(msg, httpCode) {\r\n        try {\r\n            const parsed = JSON.parse(msg);\r\n            if (parsed.msg != null)\r\n                msg = parsed.msg;\r\n        }\r\n        catch (e) { }\r\n        super(msg);\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, RequestError.prototype);\r\n        this.httpCode = httpCode;\r\n    }\r\n    static parse(msg, httpCode) {\r\n        try {\r\n            const parsed = JSON.parse(msg);\r\n            msg = parsed.msg;\r\n            if (parsed.code === 20003 || parsed.code === 20004) {\r\n                return new OutOfBoundsError(parsed.msg, httpCode, BigInt(parsed.data.min), BigInt(parsed.data.max));\r\n            }\r\n        }\r\n        catch (e) { }\r\n        return new RequestError(msg, httpCode);\r\n    }\r\n}\r\nexports.RequestError = RequestError;\r\n/**\r\n * An error indicating out of bounds (amount too high or too low) on swap initialization\r\n */\r\nclass OutOfBoundsError extends RequestError {\r\n    constructor(msg, httpCode, min, max) {\r\n        super(msg, httpCode);\r\n        this.max = max;\r\n        this.min = min;\r\n        Object.setPrototypeOf(this, OutOfBoundsError.prototype);\r\n    }\r\n}\r\nexports.OutOfBoundsError = OutOfBoundsError;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,gBAAgB,GAAG,QAAQ,YAAY,GAAG,KAAK;AACvD;;CAEC,GACD,MAAM,qBAAqB;IAavB,OAAO,MAAM,GAAG,EAAE,QAAQ,EAAE;QACxB,IAAI;YACA,MAAM,SAAS,KAAK,KAAK,CAAC;YAC1B,MAAM,OAAO,GAAG;YAChB,IAAI,OAAO,IAAI,KAAK,SAAS,OAAO,IAAI,KAAK,OAAO;gBAChD,OAAO,IAAI,iBAAiB,OAAO,GAAG,EAAE,UAAU,OAAO,OAAO,IAAI,CAAC,GAAG,GAAG,OAAO,OAAO,IAAI,CAAC,GAAG;YACrG;QACJ,EACA,OAAO,GAAG,CAAE;QACZ,OAAO,IAAI,aAAa,KAAK;IACjC;IAtBA,YAAY,GAAG,EAAE,QAAQ,CAAE;QACvB,IAAI;YACA,MAAM,SAAS,KAAK,KAAK,CAAC;YAC1B,IAAI,OAAO,GAAG,IAAI,MACd,MAAM,OAAO,GAAG;QACxB,EACA,OAAO,GAAG,CAAE;QACZ,KAAK,CAAC;QACN,gCAAgC;QAChC,OAAO,cAAc,CAAC,IAAI,EAAE,aAAa,SAAS;QAClD,IAAI,CAAC,QAAQ,GAAG;IACpB;AAYJ;AACA,QAAQ,YAAY,GAAG;AACvB;;CAEC,GACD,MAAM,yBAAyB;IAC3B,YAAY,GAAG,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,CAAE;QACjC,KAAK,CAAC,KAAK;QACX,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,GAAG,GAAG;QACX,OAAO,cAAc,CAAC,IAAI,EAAE,iBAAiB,SAAS;IAC1D;AACJ;AACA,QAAQ,gBAAgB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/Utils.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.randomBytes = exports.toCoinselectAddressType = exports.toOutputScript = exports.bigIntCompare = exports.bigIntMax = exports.bigIntMin = exports.timeoutSignal = exports.timeoutPromise = exports.httpPost = exports.httpGet = exports.fetchWithTimeout = exports.tryWithRetries = exports.extendAbortController = exports.mapToArray = exports.objectMap = exports.promiseAny = exports.getLogger = void 0;\r\nconst RequestError_1 = require(\"../errors/RequestError\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst utils_1 = require(\"@noble/hashes/utils\");\r\nfunction isConstructor(fn) {\r\n    return (typeof fn === 'function' &&\r\n        fn.prototype != null &&\r\n        fn.prototype.constructor === fn);\r\n}\r\nfunction isConstructorArray(fnArr) {\r\n    return Array.isArray(fnArr) && fnArr.every(isConstructor);\r\n}\r\n/**\r\n * Checks whether the passed error is allowed to pass through\r\n *\r\n * @param e Error in question\r\n * @param errorAllowed Allowed errors as defined as a callback function, specific error type, or an array of error types\r\n */\r\nfunction checkError(e, errorAllowed) {\r\n    if (isConstructorArray(errorAllowed))\r\n        return errorAllowed.find(error => e instanceof error) != null;\r\n    if (isConstructor(errorAllowed))\r\n        return e instanceof errorAllowed;\r\n    return errorAllowed(e);\r\n}\r\nfunction getLogger(prefix) {\r\n    return {\r\n        debug: (msg, ...args) => global.atomiqLogLevel >= 3 && console.debug(prefix + msg, ...args),\r\n        info: (msg, ...args) => global.atomiqLogLevel >= 2 && console.info(prefix + msg, ...args),\r\n        warn: (msg, ...args) => (global.atomiqLogLevel == null || global.atomiqLogLevel >= 1) && console.warn(prefix + msg, ...args),\r\n        error: (msg, ...args) => (global.atomiqLogLevel == null || global.atomiqLogLevel >= 0) && console.error(prefix + msg, ...args)\r\n    };\r\n}\r\nexports.getLogger = getLogger;\r\nconst logger = getLogger(\"Utils: \");\r\n/**\r\n * Returns a promise that resolves when any of the passed promises resolves, and rejects if all the underlying\r\n *  promises fail with an array of errors returned by the respective promises\r\n *\r\n * @param promises\r\n */\r\nfunction promiseAny(promises) {\r\n    return new Promise((resolve, reject) => {\r\n        let numRejected = 0;\r\n        const rejectReasons = Array(promises.length);\r\n        promises.forEach((promise, index) => {\r\n            promise.then((val) => {\r\n                if (resolve != null)\r\n                    resolve(val);\r\n                resolve = null;\r\n            }).catch(err => {\r\n                rejectReasons[index] = err;\r\n                numRejected++;\r\n                if (numRejected === promises.length) {\r\n                    reject(rejectReasons);\r\n                }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.promiseAny = promiseAny;\r\n/**\r\n * Maps a JS object to another JS object based on the translation function, the translation function is called for every\r\n *  property (value/key) of the old object and returns the new value of for this property\r\n *\r\n * @param obj\r\n * @param translator\r\n */\r\nfunction objectMap(obj, translator) {\r\n    const resp = {};\r\n    for (let key in obj) {\r\n        resp[key] = translator(obj[key], key);\r\n    }\r\n    return resp;\r\n}\r\nexports.objectMap = objectMap;\r\n/**\r\n * Maps the entries from the map to the array using the translator function\r\n *\r\n * @param map\r\n * @param translator\r\n */\r\nfunction mapToArray(map, translator) {\r\n    const arr = Array(map.size);\r\n    let pointer = 0;\r\n    for (let entry of map.entries()) {\r\n        arr[pointer++] = translator(entry[0], entry[1]);\r\n    }\r\n    return arr;\r\n}\r\nexports.mapToArray = mapToArray;\r\n/**\r\n * Creates a new abort controller that will abort if the passed abort signal aborts\r\n *\r\n * @param abortSignal\r\n */\r\nfunction extendAbortController(abortSignal) {\r\n    const _abortController = new AbortController();\r\n    if (abortSignal != null) {\r\n        abortSignal.throwIfAborted();\r\n        abortSignal.onabort = () => _abortController.abort(abortSignal.reason);\r\n    }\r\n    return _abortController;\r\n}\r\nexports.extendAbortController = extendAbortController;\r\n/**\r\n * Runs the passed function multiple times if it fails\r\n *\r\n * @param func A callback for executing the action\r\n * @param func.retryCount Count of the current retry, starting from 0 for original request and increasing\r\n * @param retryPolicy Retry policy\r\n * @param retryPolicy.maxRetries How many retries to attempt in total\r\n * @param retryPolicy.delay How long should the delay be\r\n * @param retryPolicy.exponential Whether to use exponentially increasing delays\r\n * @param errorAllowed A callback for determining whether a given error is allowed, and we should therefore not retry\r\n * @param abortSignal\r\n * @returns Result of the action executing callback\r\n */\r\nasync function tryWithRetries(func, retryPolicy, errorAllowed, abortSignal) {\r\n    retryPolicy = retryPolicy || {};\r\n    retryPolicy.maxRetries = retryPolicy.maxRetries || 5;\r\n    retryPolicy.delay = retryPolicy.delay || 500;\r\n    retryPolicy.exponential = retryPolicy.exponential == null ? true : retryPolicy.exponential;\r\n    let err = null;\r\n    for (let i = 0; i < retryPolicy.maxRetries; i++) {\r\n        try {\r\n            return await func(i);\r\n        }\r\n        catch (e) {\r\n            if (errorAllowed != null && checkError(e, errorAllowed))\r\n                throw e;\r\n            err = e;\r\n            logger.warn(\"tryWithRetries(): Error on try number: \" + i, e);\r\n        }\r\n        if (abortSignal != null && abortSignal.aborted)\r\n            throw (abortSignal.reason || new Error(\"Aborted\"));\r\n        if (i !== retryPolicy.maxRetries - 1) {\r\n            await timeoutPromise(retryPolicy.exponential ? retryPolicy.delay * Math.pow(2, i) : retryPolicy.delay, abortSignal);\r\n        }\r\n    }\r\n    throw err;\r\n}\r\nexports.tryWithRetries = tryWithRetries;\r\n/**\r\n * Mimics fetch API byt adds a timeout to the request\r\n *\r\n * @param input\r\n * @param init\r\n */\r\nfunction fetchWithTimeout(input, init) {\r\n    if (init == null)\r\n        init = {};\r\n    if (init.timeout != null)\r\n        init.signal = timeoutSignal(init.timeout, new Error(\"Network request timed out\"), init.signal);\r\n    return fetch(input, init).catch(e => {\r\n        if (e.name === \"AbortError\") {\r\n            throw init.signal.reason;\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    });\r\n}\r\nexports.fetchWithTimeout = fetchWithTimeout;\r\n/**\r\n * Sends an HTTP GET request through a fetch API, handles non 200 response codes as errors\r\n * @param url Send request to this URL\r\n * @param timeout Timeout (in milliseconds) for the request to conclude\r\n * @param abortSignal\r\n * @param allowNon200 Whether to allow non-200 status code HTTP responses\r\n * @throws {RequestError} if non 200 response code was returned or body cannot be parsed\r\n */\r\nasync function httpGet(url, timeout, abortSignal, allowNon200 = false) {\r\n    const init = {\r\n        method: \"GET\",\r\n        timeout,\r\n        signal: abortSignal\r\n    };\r\n    const response = await fetchWithTimeout(url, init);\r\n    if (response.status !== 200) {\r\n        let resp;\r\n        try {\r\n            resp = await response.text();\r\n        }\r\n        catch (e) {\r\n            throw new RequestError_1.RequestError(response.statusText, response.status);\r\n        }\r\n        if (allowNon200) {\r\n            try {\r\n                return JSON.parse(resp);\r\n            }\r\n            catch (e) { }\r\n        }\r\n        throw RequestError_1.RequestError.parse(resp, response.status);\r\n    }\r\n    return await response.json();\r\n}\r\nexports.httpGet = httpGet;\r\n/**\r\n * Sends an HTTP POST request through a fetch API, handles non 200 response codes as errors\r\n * @param url Send request to this URL\r\n * @param body A HTTP request body to send to the server\r\n * @param timeout Timeout (in milliseconds) for the request to conclude\r\n * @param abortSignal\r\n * @throws {RequestError} if non 200 response code was returned\r\n */\r\nasync function httpPost(url, body, timeout, abortSignal) {\r\n    const init = {\r\n        method: \"POST\",\r\n        timeout,\r\n        body: JSON.stringify(body),\r\n        headers: { 'Content-Type': 'application/json' },\r\n        signal: abortSignal\r\n    };\r\n    const response = timeout == null ? await fetch(url, init) : await fetchWithTimeout(url, init);\r\n    if (response.status !== 200) {\r\n        let resp;\r\n        try {\r\n            resp = await response.text();\r\n        }\r\n        catch (e) {\r\n            throw new RequestError_1.RequestError(response.statusText, response.status);\r\n        }\r\n        throw RequestError_1.RequestError.parse(resp, response.status);\r\n    }\r\n    return await response.json();\r\n}\r\nexports.httpPost = httpPost;\r\n/**\r\n * Returns a promise that resolves after given amount seconds\r\n *\r\n * @param timeout how many milliseconds to wait for\r\n * @param abortSignal\r\n */\r\nfunction timeoutPromise(timeout, abortSignal) {\r\n    return new Promise((resolve, reject) => {\r\n        if (abortSignal != null && abortSignal.aborted) {\r\n            reject(abortSignal.reason);\r\n            return;\r\n        }\r\n        let abortSignalListener;\r\n        let timeoutHandle = setTimeout(() => {\r\n            if (abortSignalListener != null)\r\n                abortSignal.removeEventListener(\"abort\", abortSignalListener);\r\n            resolve();\r\n        }, timeout);\r\n        if (abortSignal != null) {\r\n            abortSignal.addEventListener(\"abort\", abortSignalListener = () => {\r\n                if (timeoutHandle != null)\r\n                    clearTimeout(timeoutHandle);\r\n                timeoutHandle = null;\r\n                reject(abortSignal.reason);\r\n            });\r\n        }\r\n    });\r\n}\r\nexports.timeoutPromise = timeoutPromise;\r\n/**\r\n * Returns an abort signal that aborts after a specified timeout in milliseconds\r\n *\r\n * @param timeout Milliseconds to wait\r\n * @param abortReason Abort with this abort reason\r\n * @param abortSignal Abort signal to extend\r\n */\r\nfunction timeoutSignal(timeout, abortReason, abortSignal) {\r\n    if (timeout == null)\r\n        return abortSignal;\r\n    const abortController = new AbortController();\r\n    const timeoutHandle = setTimeout(() => abortController.abort(abortReason || new Error(\"Timed out\")), timeout);\r\n    if (abortSignal != null) {\r\n        abortSignal.addEventListener(\"abort\", () => {\r\n            clearTimeout(timeoutHandle);\r\n            abortController.abort(abortSignal.reason);\r\n        });\r\n    }\r\n    return abortController.signal;\r\n}\r\nexports.timeoutSignal = timeoutSignal;\r\nfunction bigIntMin(a, b) {\r\n    return a > b ? b : a;\r\n}\r\nexports.bigIntMin = bigIntMin;\r\nfunction bigIntMax(a, b) {\r\n    return b > a ? b : a;\r\n}\r\nexports.bigIntMax = bigIntMax;\r\nfunction bigIntCompare(a, b) {\r\n    return a > b ? 1 : a === b ? 0 : -1;\r\n}\r\nexports.bigIntCompare = bigIntCompare;\r\nfunction toOutputScript(network, address) {\r\n    const outputScript = (0, btc_signer_1.Address)(network).decode(address);\r\n    switch (outputScript.type) {\r\n        case \"pkh\":\r\n        case \"sh\":\r\n        case \"wpkh\":\r\n        case \"wsh\":\r\n            return buffer_1.Buffer.from(btc_signer_1.OutScript.encode({\r\n                type: outputScript.type,\r\n                hash: outputScript.hash\r\n            }));\r\n        case \"tr\":\r\n            return buffer_1.Buffer.from(btc_signer_1.OutScript.encode({\r\n                type: \"tr\",\r\n                pubkey: outputScript.pubkey\r\n            }));\r\n    }\r\n}\r\nexports.toOutputScript = toOutputScript;\r\nfunction toCoinselectAddressType(outputScript) {\r\n    const data = btc_signer_1.OutScript.decode(outputScript);\r\n    switch (data.type) {\r\n        case \"pkh\":\r\n            return \"p2pkh\";\r\n        case \"sh\":\r\n            return \"p2sh-p2wpkh\";\r\n        case \"wpkh\":\r\n            return \"p2wpkh\";\r\n        case \"wsh\":\r\n            return \"p2wsh\";\r\n        case \"tr\":\r\n            return \"p2tr\";\r\n    }\r\n    throw new Error(\"Unrecognized address type!\");\r\n}\r\nexports.toCoinselectAddressType = toCoinselectAddressType;\r\nfunction randomBytes(bytesLength) {\r\n    return buffer_1.Buffer.from((0, utils_1.randomBytes)(bytesLength));\r\n}\r\nexports.randomBytes = randomBytes;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 381, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/mempool/synchronizer/MempoolBtcRelaySynchronizer.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MempoolBtcRelaySynchronizer = void 0;\r\nconst Utils_1 = require(\"../../../utils/Utils\");\r\nconst logger = (0, Utils_1.getLogger)(\"MempoolBtcRelaySynchronizer: \");\r\nclass MempoolBtcRelaySynchronizer {\r\n    constructor(btcRelay, bitcoinRpc) {\r\n        this.btcRelay = btcRelay;\r\n        this.bitcoinRpc = bitcoinRpc;\r\n    }\r\n    async syncToLatestTxs(signer, feeRate) {\r\n        const tipData = await this.btcRelay.getTipData();\r\n        let cacheData = {\r\n            forkId: 0,\r\n            lastStoredHeader: null,\r\n            tx: null,\r\n            computedCommitedHeaders: null\r\n        };\r\n        const { resultStoredHeader, resultBitcoinHeader } = await this.btcRelay.retrieveLatestKnownBlockLog();\r\n        cacheData.lastStoredHeader = resultStoredHeader;\r\n        if (resultStoredHeader.getBlockheight() < tipData.blockheight)\r\n            cacheData.forkId = -1; //Indicate that we will be submitting blocks to fork\r\n        let spvTipBlockHeader = resultBitcoinHeader;\r\n        const btcRelayTipBlockHash = spvTipBlockHeader.getHash();\r\n        logger.debug(\"Retrieved stored header with commitment: \", cacheData.lastStoredHeader);\r\n        logger.debug(\"SPV tip bitcoin RPC block header: \", spvTipBlockHeader);\r\n        let spvTipBlockHeight = spvTipBlockHeader.height;\r\n        const txsList = [];\r\n        const blockHeaderMap = {\r\n            [resultBitcoinHeader.getHeight()]: resultBitcoinHeader\r\n        };\r\n        const computedHeaderMap = {\r\n            [resultStoredHeader.getBlockheight()]: resultStoredHeader\r\n        };\r\n        let startForkId = null;\r\n        let forkFee = feeRate;\r\n        let mainFee = feeRate;\r\n        const saveHeaders = async (headerCache) => {\r\n            if (cacheData.forkId === -1) {\r\n                if (mainFee == null)\r\n                    mainFee = await this.btcRelay.getMainFeeRate(signer);\r\n                cacheData = await this.btcRelay.saveNewForkHeaders(signer, headerCache, cacheData.lastStoredHeader, tipData.chainWork, mainFee);\r\n            }\r\n            else if (cacheData.forkId === 0) {\r\n                if (mainFee == null)\r\n                    mainFee = await this.btcRelay.getMainFeeRate(signer);\r\n                cacheData = await this.btcRelay.saveMainHeaders(signer, headerCache, cacheData.lastStoredHeader, mainFee);\r\n            }\r\n            else {\r\n                if (forkFee == null)\r\n                    forkFee = await this.btcRelay.getForkFeeRate(signer, cacheData.forkId);\r\n                cacheData = await this.btcRelay.saveForkHeaders(signer, headerCache, cacheData.lastStoredHeader, cacheData.forkId, tipData.chainWork, forkFee);\r\n            }\r\n            if (cacheData.forkId !== -1 && cacheData.forkId !== 0)\r\n                startForkId = cacheData.forkId;\r\n            txsList.push(cacheData.tx);\r\n            for (let storedHeader of cacheData.computedCommitedHeaders) {\r\n                computedHeaderMap[storedHeader.getBlockheight()] = storedHeader;\r\n            }\r\n        };\r\n        let retrievedHeaders = null;\r\n        let headerCache = [];\r\n        while (retrievedHeaders == null || retrievedHeaders.length > 0) {\r\n            retrievedHeaders = await this.bitcoinRpc.getPast15Blocks(spvTipBlockHeight + 15);\r\n            let startIndex = retrievedHeaders.findIndex(val => val.height === spvTipBlockHeight);\r\n            if (startIndex === -1)\r\n                startIndex = retrievedHeaders.length; //Start from the last block\r\n            for (let i = startIndex - 1; i >= 0; i--) {\r\n                const header = retrievedHeaders[i];\r\n                blockHeaderMap[header.height] = header;\r\n                headerCache.push(header);\r\n                if (cacheData.forkId === 0 ?\r\n                    headerCache.length >= this.btcRelay.maxHeadersPerTx :\r\n                    headerCache.length >= this.btcRelay.maxForkHeadersPerTx) {\r\n                    await saveHeaders(headerCache);\r\n                    headerCache = [];\r\n                }\r\n            }\r\n            if (retrievedHeaders.length > 0) {\r\n                if (spvTipBlockHeight === retrievedHeaders[0].height)\r\n                    break; //Already at the tip\r\n                spvTipBlockHeight = retrievedHeaders[0].height;\r\n                await (0, Utils_1.timeoutPromise)(1000);\r\n            }\r\n        }\r\n        if (headerCache.length > 0)\r\n            await saveHeaders(headerCache);\r\n        if (cacheData.forkId !== 0) {\r\n            throw new Error(\"Unable to synchronize on-chain bitcoin light client! Not enough chainwork at connected RPC.\");\r\n        }\r\n        return {\r\n            txs: txsList,\r\n            targetCommitedHeader: cacheData.lastStoredHeader,\r\n            blockHeaderMap,\r\n            computedHeaderMap,\r\n            btcRelayTipCommitedHeader: resultStoredHeader,\r\n            btcRelayTipBlockHeader: resultBitcoinHeader,\r\n            latestBlockHeader: spvTipBlockHeader,\r\n            startForkId\r\n        };\r\n    }\r\n}\r\nexports.MempoolBtcRelaySynchronizer = MempoolBtcRelaySynchronizer;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 477, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/mempool/MempoolApi.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MempoolApi = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst RequestError_1 = require(\"../../errors/RequestError\");\r\nclass MempoolApi {\r\n    /**\r\n     * Returns api url that should be operational\r\n     *\r\n     * @private\r\n     */\r\n    getOperationalApi() {\r\n        return this.backends.find(e => e.operational === true);\r\n    }\r\n    /**\r\n     * Returns api urls that are maybe operational, in case none is considered operational returns all of the price\r\n     *  apis such that they can be tested again whether they are operational\r\n     *\r\n     * @private\r\n     */\r\n    getMaybeOperationalApis() {\r\n        let operational = this.backends.filter(e => e.operational === true || e.operational === null);\r\n        if (operational.length === 0) {\r\n            this.backends.forEach(e => e.operational = null);\r\n            operational = this.backends;\r\n        }\r\n        return operational;\r\n    }\r\n    /**\r\n     * Sends a GET or POST request to the mempool api, handling the non-200 responses as errors & throwing\r\n     *\r\n     * @param url\r\n     * @param path\r\n     * @param responseType\r\n     * @param type\r\n     * @param body\r\n     */\r\n    async _request(url, path, responseType, type = \"GET\", body) {\r\n        const response = await (0, Utils_1.fetchWithTimeout)(url + path, {\r\n            method: type,\r\n            timeout: this.timeout,\r\n            body: typeof (body) === \"string\" ? body : JSON.stringify(body)\r\n        });\r\n        if (response.status !== 200) {\r\n            let resp;\r\n            try {\r\n                resp = await response.text();\r\n            }\r\n            catch (e) {\r\n                throw new RequestError_1.RequestError(response.statusText, response.status);\r\n            }\r\n            throw RequestError_1.RequestError.parse(resp, response.status);\r\n        }\r\n        if (responseType === \"str\")\r\n            return await response.text();\r\n        return await response.json();\r\n    }\r\n    /**\r\n     * Sends request in parallel to multiple maybe operational api urls\r\n     *\r\n     * @param path\r\n     * @param responseType\r\n     * @param type\r\n     * @param body\r\n     * @private\r\n     */\r\n    async requestFromMaybeOperationalUrls(path, responseType, type = \"GET\", body) {\r\n        try {\r\n            return await (0, Utils_1.promiseAny)(this.getMaybeOperationalApis().map(obj => (async () => {\r\n                try {\r\n                    const result = await this._request(obj.url, path, responseType, type, body);\r\n                    obj.operational = true;\r\n                    return result;\r\n                }\r\n                catch (e) {\r\n                    //Only mark as non operational on 5xx server errors!\r\n                    if (e instanceof RequestError_1.RequestError && Math.floor(e.httpCode / 100) !== 5) {\r\n                        obj.operational = true;\r\n                        throw e;\r\n                    }\r\n                    else {\r\n                        obj.operational = false;\r\n                        throw e;\r\n                    }\r\n                }\r\n            })()));\r\n        }\r\n        catch (e) {\r\n            throw e.find(err => err instanceof RequestError_1.RequestError && Math.floor(err.httpCode / 100) !== 5) || e[0];\r\n        }\r\n    }\r\n    /**\r\n     * Sends a request to mempool API, first tries to use the operational API (if any) and if that fails it falls back\r\n     *  to using maybe operational price APIs\r\n     *\r\n     * @param path\r\n     * @param responseType\r\n     * @param type\r\n     * @param body\r\n     * @private\r\n     */\r\n    async request(path, responseType, type = \"GET\", body) {\r\n        return (0, Utils_1.tryWithRetries)(() => {\r\n            const operationalPriceApi = this.getOperationalApi();\r\n            if (operationalPriceApi != null) {\r\n                return this._request(operationalPriceApi.url, path, responseType, type, body).catch(err => {\r\n                    //Only retry on 5xx server errors!\r\n                    if (err instanceof RequestError_1.RequestError && Math.floor(err.httpCode / 100) !== 5)\r\n                        throw err;\r\n                    operationalPriceApi.operational = false;\r\n                    return this.requestFromMaybeOperationalUrls(path, responseType, type, body);\r\n                });\r\n            }\r\n            return this.requestFromMaybeOperationalUrls(path, responseType, type, body);\r\n        }, null, (err) => err instanceof RequestError_1.RequestError && Math.floor(err.httpCode / 100) !== 5);\r\n    }\r\n    constructor(url, timeout) {\r\n        url = url ?? \"https://mempool.space/testnet/api/\";\r\n        if (Array.isArray(url)) {\r\n            this.backends = url.map(val => {\r\n                return { url: val, operational: null };\r\n            });\r\n        }\r\n        else {\r\n            this.backends = [\r\n                { url: url, operational: null }\r\n            ];\r\n        }\r\n        this.timeout = timeout;\r\n    }\r\n    /**\r\n     * Returns information about a specific lightning network node as identified by the public key (in hex encoding)\r\n     *\r\n     * @param pubkey\r\n     */\r\n    getLNNodeInfo(pubkey) {\r\n        return this.request(\"v1/lightning/nodes/\" + pubkey, \"obj\").catch((e) => {\r\n            if (e.message === \"This node does not exist, or our node is not seeing it yet\")\r\n                return null;\r\n            throw e;\r\n        });\r\n    }\r\n    /**\r\n     * Returns on-chain transaction as identified by its txId\r\n     *\r\n     * @param txId\r\n     */\r\n    getTransaction(txId) {\r\n        return this.request(\"tx/\" + txId, \"obj\").catch((e) => {\r\n            if (e.message === \"Transaction not found\")\r\n                return null;\r\n            throw e;\r\n        });\r\n    }\r\n    /**\r\n     * Returns raw binary encoded bitcoin transaction, also strips the witness data from the transaction\r\n     *\r\n     * @param txId\r\n     */\r\n    async getRawTransaction(txId) {\r\n        const rawTransaction = await this.request(\"tx/\" + txId + \"/hex\", \"str\").catch((e) => {\r\n            if (e.message === \"Transaction not found\")\r\n                return null;\r\n            throw e;\r\n        });\r\n        return rawTransaction == null ? null : buffer_1.Buffer.from(rawTransaction, \"hex\");\r\n    }\r\n    /**\r\n     * Returns confirmed & unconfirmed balance of the specific bitcoin address\r\n     *\r\n     * @param address\r\n     */\r\n    async getAddressBalances(address) {\r\n        const jsonBody = await this.request(\"address/\" + address, \"obj\");\r\n        const confirmedInput = BigInt(jsonBody.chain_stats.funded_txo_sum);\r\n        const confirmedOutput = BigInt(jsonBody.chain_stats.spent_txo_sum);\r\n        const unconfirmedInput = BigInt(jsonBody.mempool_stats.funded_txo_sum);\r\n        const unconfirmedOutput = BigInt(jsonBody.mempool_stats.spent_txo_sum);\r\n        return {\r\n            confirmedBalance: confirmedInput - confirmedOutput,\r\n            unconfirmedBalance: unconfirmedInput - unconfirmedOutput\r\n        };\r\n    }\r\n    /**\r\n     * Returns CPFP (children pays for parent) data for a given transaction\r\n     *\r\n     * @param txId\r\n     */\r\n    getCPFPData(txId) {\r\n        return this.request(\"v1/cpfp/\" + txId, \"obj\");\r\n    }\r\n    /**\r\n     * Returns UTXOs (unspent transaction outputs) for a given address\r\n     *\r\n     * @param address\r\n     */\r\n    async getAddressUTXOs(address) {\r\n        let jsonBody = await this.request(\"address/\" + address + \"/utxo\", \"obj\");\r\n        jsonBody.forEach(e => e.value = BigInt(e.value));\r\n        return jsonBody;\r\n    }\r\n    /**\r\n     * Returns current on-chain bitcoin fees\r\n     */\r\n    getFees() {\r\n        return this.request(\"v1/fees/recommended\", \"obj\");\r\n    }\r\n    /**\r\n     * Returns all transactions for a given address\r\n     *\r\n     * @param address\r\n     */\r\n    getAddressTransactions(address) {\r\n        return this.request(\"address/\" + address + \"/txs\", \"obj\");\r\n    }\r\n    /**\r\n     * Returns expected pending (mempool) blocks\r\n     */\r\n    getPendingBlocks() {\r\n        return this.request(\"v1/fees/mempool-blocks\", \"obj\");\r\n    }\r\n    /**\r\n     * Returns the blockheight of the current bitcoin blockchain's tip\r\n     */\r\n    async getTipBlockHeight() {\r\n        const response = await this.request(\"blocks/tip/height\", \"str\");\r\n        return parseInt(response);\r\n    }\r\n    /**\r\n     * Returns the bitcoin blockheader as identified by its blockhash\r\n     *\r\n     * @param blockhash\r\n     */\r\n    getBlockHeader(blockhash) {\r\n        return this.request(\"block/\" + blockhash, \"obj\");\r\n    }\r\n    /**\r\n     * Returns the block status\r\n     *\r\n     * @param blockhash\r\n     */\r\n    getBlockStatus(blockhash) {\r\n        return this.request(\"block/\" + blockhash + \"/status\", \"obj\");\r\n    }\r\n    /**\r\n     * Returns the transaction's proof (merkle proof)\r\n     *\r\n     * @param txId\r\n     */\r\n    getTransactionProof(txId) {\r\n        return this.request(\"tx/\" + txId + \"/merkle-proof\", \"obj\");\r\n    }\r\n    /**\r\n     * Returns the transaction's proof (merkle proof)\r\n     *\r\n     * @param txId\r\n     */\r\n    getOutspends(txId) {\r\n        return this.request(\"tx/\" + txId + \"/outspends\", \"obj\");\r\n    }\r\n    /**\r\n     * Returns blockhash of a block at a specific blockheight\r\n     *\r\n     * @param height\r\n     */\r\n    getBlockHash(height) {\r\n        return this.request(\"block-height/\" + height, \"str\");\r\n    }\r\n    /**\r\n     * Returns past 15 blockheaders before (and including) the specified height\r\n     *\r\n     * @param endHeight\r\n     */\r\n    getPast15BlockHeaders(endHeight) {\r\n        return this.request(\"v1/blocks/\" + endHeight, \"obj\");\r\n    }\r\n    /**\r\n     * Sends raw hex encoded bitcoin transaction\r\n     *\r\n     * @param transactionHex\r\n     */\r\n    sendTransaction(transactionHex) {\r\n        return this.request(\"tx\", \"str\", \"POST\", transactionHex);\r\n    }\r\n}\r\nexports.MempoolApi = MempoolApi;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 746, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/mempool/MempoolBitcoinBlock.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MempoolBitcoinBlock = void 0;\r\nclass MempoolBitcoinBlock {\r\n    constructor(obj) {\r\n        this.id = obj.id;\r\n        this.height = obj.height;\r\n        this.version = obj.version;\r\n        this.timestamp = obj.timestamp;\r\n        this.tx_count = obj.tx_count;\r\n        this.size = obj.size;\r\n        this.weight = obj.weight;\r\n        this.merkle_root = obj.merkle_root;\r\n        this.previousblockhash = obj.previousblockhash;\r\n        this.mediantime = obj.mediantime;\r\n        this.nonce = obj.nonce;\r\n        this.bits = obj.bits;\r\n        this.difficulty = obj.difficulty;\r\n    }\r\n    getHeight() {\r\n        return this.height;\r\n    }\r\n    getHash() {\r\n        return this.id;\r\n    }\r\n    getMerkleRoot() {\r\n        return this.merkle_root;\r\n    }\r\n    getNbits() {\r\n        return this.bits;\r\n    }\r\n    getNonce() {\r\n        return this.nonce;\r\n    }\r\n    getPrevBlockhash() {\r\n        return this.previousblockhash;\r\n    }\r\n    getTimestamp() {\r\n        return this.timestamp;\r\n    }\r\n    getVersion() {\r\n        return this.version;\r\n    }\r\n    getChainWork() {\r\n        throw new Error(\"Unsupported\");\r\n    }\r\n}\r\nexports.MempoolBitcoinBlock = MempoolBitcoinBlock;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,mBAAmB,GAAG,KAAK;AACnC,MAAM;IAgBF,YAAY;QACR,OAAO,IAAI,CAAC,MAAM;IACtB;IACA,UAAU;QACN,OAAO,IAAI,CAAC,EAAE;IAClB;IACA,gBAAgB;QACZ,OAAO,IAAI,CAAC,WAAW;IAC3B;IACA,WAAW;QACP,OAAO,IAAI,CAAC,IAAI;IACpB;IACA,WAAW;QACP,OAAO,IAAI,CAAC,KAAK;IACrB;IACA,mBAAmB;QACf,OAAO,IAAI,CAAC,iBAAiB;IACjC;IACA,eAAe;QACX,OAAO,IAAI,CAAC,SAAS;IACzB;IACA,aAAa;QACT,OAAO,IAAI,CAAC,OAAO;IACvB;IACA,eAAe;QACX,MAAM,IAAI,MAAM;IACpB;IAzCA,YAAY,GAAG,CAAE;QACb,IAAI,CAAC,EAAE,GAAG,IAAI,EAAE;QAChB,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM;QACxB,IAAI,CAAC,OAAO,GAAG,IAAI,OAAO;QAC1B,IAAI,CAAC,SAAS,GAAG,IAAI,SAAS;QAC9B,IAAI,CAAC,QAAQ,GAAG,IAAI,QAAQ;QAC5B,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI;QACpB,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM;QACxB,IAAI,CAAC,WAAW,GAAG,IAAI,WAAW;QAClC,IAAI,CAAC,iBAAiB,GAAG,IAAI,iBAAiB;QAC9C,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU;QAChC,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK;QACtB,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI;QACpB,IAAI,CAAC,UAAU,GAAG,IAAI,UAAU;IACpC;AA4BJ;AACA,QAAQ,mBAAmB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 799, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/mempool/MempoolBitcoinRpc.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MempoolBitcoinRpc = void 0;\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst MempoolBitcoinBlock_1 = require(\"./MempoolBitcoinBlock\");\r\nconst MempoolApi_1 = require(\"./MempoolApi\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst sha2_1 = require(\"@noble/hashes/sha2\");\r\nconst BITCOIN_BLOCKTIME = 600 * 1000;\r\nconst BITCOIN_BLOCKSIZE = 1024 * 1024;\r\nfunction bitcoinTxToBtcTx(btcTx) {\r\n    return {\r\n        locktime: btcTx.lockTime,\r\n        version: btcTx.version,\r\n        blockhash: null,\r\n        confirmations: 0,\r\n        txid: buffer_1.Buffer.from((0, sha2_1.sha256)((0, sha2_1.sha256)(btcTx.toBytes(true, false)))).reverse().toString(\"hex\"),\r\n        hex: buffer_1.Buffer.from(btcTx.toBytes(true, false)).toString(\"hex\"),\r\n        raw: buffer_1.Buffer.from(btcTx.toBytes(true, true)).toString(\"hex\"),\r\n        vsize: btcTx.isFinal ? btcTx.vsize : null,\r\n        outs: Array.from({ length: btcTx.outputsLength }, (_, i) => i).map((index) => {\r\n            const output = btcTx.getOutput(index);\r\n            return {\r\n                value: Number(output.amount),\r\n                n: index,\r\n                scriptPubKey: {\r\n                    asm: btc_signer_1.Script.decode(output.script).map(val => typeof (val) === \"object\" ? buffer_1.Buffer.from(val).toString(\"hex\") : val.toString()).join(\" \"),\r\n                    hex: buffer_1.Buffer.from(output.script).toString(\"hex\")\r\n                }\r\n            };\r\n        }),\r\n        ins: Array.from({ length: btcTx.inputsLength }, (_, i) => i).map(index => {\r\n            const input = btcTx.getInput(index);\r\n            return {\r\n                txid: buffer_1.Buffer.from(input.txid).toString(\"hex\"),\r\n                vout: input.index,\r\n                scriptSig: {\r\n                    asm: btc_signer_1.Script.decode(input.finalScriptSig).map(val => typeof (val) === \"object\" ? buffer_1.Buffer.from(val).toString(\"hex\") : val.toString()).join(\" \"),\r\n                    hex: buffer_1.Buffer.from(input.finalScriptSig).toString(\"hex\")\r\n                },\r\n                sequence: input.sequence,\r\n                txinwitness: input.finalScriptWitness == null ? [] : input.finalScriptWitness.map(witness => buffer_1.Buffer.from(witness).toString(\"hex\"))\r\n            };\r\n        })\r\n    };\r\n}\r\nclass MempoolBitcoinRpc {\r\n    constructor(urlOrMempoolApi) {\r\n        this.api = urlOrMempoolApi instanceof MempoolApi_1.MempoolApi ? urlOrMempoolApi : new MempoolApi_1.MempoolApi(urlOrMempoolApi);\r\n    }\r\n    /**\r\n     * Returns a txo hash for a specific transaction vout\r\n     *\r\n     * @param vout\r\n     * @private\r\n     */\r\n    static getTxoHash(vout) {\r\n        return buffer_1.Buffer.from((0, sha2_1.sha256)(buffer_1.Buffer.concat([\r\n            base_1.BigIntBufferUtils.toBuffer(BigInt(vout.value), \"le\", 8),\r\n            buffer_1.Buffer.from(vout.scriptpubkey, \"hex\")\r\n        ])));\r\n    }\r\n    /**\r\n     * Returns delay in milliseconds till an unconfirmed transaction is expected to confirm, returns -1\r\n     *  if the transaction won't confirm any time soon\r\n     *\r\n     * @param feeRate\r\n     * @private\r\n     */\r\n    async getTimeTillConfirmation(feeRate) {\r\n        const mempoolBlocks = await this.api.getPendingBlocks();\r\n        const mempoolBlockIndex = mempoolBlocks.findIndex(block => block.feeRange[0] <= feeRate);\r\n        if (mempoolBlockIndex === -1)\r\n            return -1;\r\n        //Last returned block is usually an aggregate (or a stack) of multiple btc blocks, if tx falls in this block\r\n        // and the last returned block really is an aggregate one (size bigger than BITCOIN_BLOCKSIZE) we return -1\r\n        if (mempoolBlockIndex + 1 === mempoolBlocks.length &&\r\n            mempoolBlocks[mempoolBlocks.length - 1].blockVSize > BITCOIN_BLOCKSIZE)\r\n            return -1;\r\n        return (mempoolBlockIndex + 1) * BITCOIN_BLOCKTIME;\r\n    }\r\n    /**\r\n     * Returns an estimate after which time the tx will confirm with the required amount of confirmations,\r\n     *  confirmationDelay of -1 means the transaction won't confirm in the near future\r\n     *\r\n     * @param tx\r\n     * @param requiredConfirmations\r\n     * @private\r\n     *\r\n     * @returns estimated confirmation delay, -1 if the transaction won't confirm in the near future, null if the\r\n     *  transaction was replaced or was confirmed in the meantime\r\n     */\r\n    async getConfirmationDelay(tx, requiredConfirmations) {\r\n        if (tx.confirmations > requiredConfirmations)\r\n            return 0;\r\n        if (tx.confirmations === 0) {\r\n            //Get CPFP data\r\n            const cpfpData = await this.api.getCPFPData(tx.txid);\r\n            if (cpfpData.effectiveFeePerVsize == null) {\r\n                //Transaction is either confirmed in the meantime, or replaced\r\n                return null;\r\n            }\r\n            let confirmationDelay = (await this.getTimeTillConfirmation(cpfpData.effectiveFeePerVsize));\r\n            if (confirmationDelay !== -1)\r\n                confirmationDelay += (requiredConfirmations - 1) * BITCOIN_BLOCKTIME;\r\n            return confirmationDelay;\r\n        }\r\n        return ((requiredConfirmations - tx.confirmations) * BITCOIN_BLOCKTIME);\r\n    }\r\n    /**\r\n     * Converts mempool API's transaction to BtcTx object\r\n     * @param tx Transaction to convert\r\n     * @param getRaw If the raw transaction field should be filled (requires one more network request)\r\n     * @private\r\n     */\r\n    async toBtcTx(tx, getRaw = true) {\r\n        const rawTx = !getRaw ? null : await this.api.getRawTransaction(tx.txid);\r\n        let confirmations = 0;\r\n        if (tx.status != null && tx.status.confirmed) {\r\n            const blockheight = await this.api.getTipBlockHeight();\r\n            confirmations = blockheight - tx.status.block_height + 1;\r\n        }\r\n        let strippedRawTx;\r\n        if (rawTx != null) {\r\n            //Strip witness data\r\n            const btcTx = btc_signer_1.Transaction.fromRaw(rawTx, {\r\n                allowLegacyWitnessUtxo: true,\r\n                allowUnknownInputs: true,\r\n                allowUnknownOutputs: true,\r\n                disableScriptCheck: true\r\n            });\r\n            strippedRawTx = buffer_1.Buffer.from(btcTx.toBytes(true, false)).toString(\"hex\");\r\n        }\r\n        return {\r\n            locktime: tx.locktime,\r\n            version: tx.version,\r\n            blockheight: tx.status?.block_height,\r\n            blockhash: tx.status?.block_hash,\r\n            confirmations,\r\n            txid: tx.txid,\r\n            vsize: tx.weight / 4,\r\n            hex: strippedRawTx,\r\n            raw: rawTx == null ? null : rawTx.toString(\"hex\"),\r\n            outs: tx.vout.map((e, index) => {\r\n                return {\r\n                    value: e.value,\r\n                    n: index,\r\n                    scriptPubKey: {\r\n                        hex: e.scriptpubkey,\r\n                        asm: e.scriptpubkey_asm\r\n                    }\r\n                };\r\n            }),\r\n            ins: tx.vin.map(e => {\r\n                return {\r\n                    txid: e.txid,\r\n                    vout: e.vout,\r\n                    scriptSig: {\r\n                        hex: e.scriptsig,\r\n                        asm: e.scriptsig_asm\r\n                    },\r\n                    sequence: e.sequence,\r\n                    txinwitness: e.witness\r\n                };\r\n            }),\r\n        };\r\n    }\r\n    getTipHeight() {\r\n        return this.api.getTipBlockHeight();\r\n    }\r\n    async getBlockHeader(blockhash) {\r\n        return new MempoolBitcoinBlock_1.MempoolBitcoinBlock(await this.api.getBlockHeader(blockhash));\r\n    }\r\n    async getMerkleProof(txId, blockhash) {\r\n        const proof = await this.api.getTransactionProof(txId);\r\n        return {\r\n            reversedTxId: buffer_1.Buffer.from(txId, \"hex\").reverse(),\r\n            pos: proof.pos,\r\n            merkle: proof.merkle.map(e => buffer_1.Buffer.from(e, \"hex\").reverse()),\r\n            blockheight: proof.block_height\r\n        };\r\n    }\r\n    async getTransaction(txId) {\r\n        const tx = await this.api.getTransaction(txId);\r\n        if (tx == null)\r\n            return null;\r\n        return await this.toBtcTx(tx);\r\n    }\r\n    async isInMainChain(blockhash) {\r\n        const blockStatus = await this.api.getBlockStatus(blockhash);\r\n        return blockStatus.in_best_chain;\r\n    }\r\n    getBlockhash(height) {\r\n        return this.api.getBlockHash(height);\r\n    }\r\n    getBlockWithTransactions(blockhash) {\r\n        throw new Error(\"Unsupported.\");\r\n    }\r\n    async getSyncInfo() {\r\n        const tipHeight = await this.api.getTipBlockHeight();\r\n        return {\r\n            verificationProgress: 1,\r\n            blocks: tipHeight,\r\n            headers: tipHeight,\r\n            ibd: false\r\n        };\r\n    }\r\n    async getPast15Blocks(height) {\r\n        return (await this.api.getPast15BlockHeaders(height)).map(blockHeader => new MempoolBitcoinBlock_1.MempoolBitcoinBlock(blockHeader));\r\n    }\r\n    async checkAddressTxos(address, txoHash) {\r\n        const allTxs = await this.api.getAddressTransactions(address);\r\n        const relevantTxs = allTxs\r\n            .map(tx => {\r\n            return {\r\n                tx,\r\n                vout: tx.vout.findIndex(vout => MempoolBitcoinRpc.getTxoHash(vout).equals(txoHash))\r\n            };\r\n        })\r\n            .filter(obj => obj.vout >= 0)\r\n            .sort((a, b) => {\r\n            if (a.tx.status.confirmed && !b.tx.status.confirmed)\r\n                return -1;\r\n            if (!a.tx.status.confirmed && b.tx.status.confirmed)\r\n                return 1;\r\n            if (a.tx.status.confirmed && b.tx.status.confirmed)\r\n                return a.tx.status.block_height - b.tx.status.block_height;\r\n            return 0;\r\n        });\r\n        if (relevantTxs.length === 0)\r\n            return null;\r\n        return {\r\n            tx: await this.toBtcTx(relevantTxs[0].tx, false),\r\n            vout: relevantTxs[0].vout\r\n        };\r\n    }\r\n    /**\r\n     * Waits till the address receives a transaction containing a specific txoHash\r\n     *\r\n     * @param address\r\n     * @param txoHash\r\n     * @param requiredConfirmations\r\n     * @param stateUpdateCbk\r\n     * @param abortSignal\r\n     * @param intervalSeconds\r\n     */\r\n    async waitForAddressTxo(address, txoHash, requiredConfirmations, stateUpdateCbk, abortSignal, intervalSeconds) {\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        while (abortSignal == null || !abortSignal.aborted) {\r\n            await (0, Utils_1.timeoutPromise)((intervalSeconds || 5) * 1000, abortSignal);\r\n            const result = await this.checkAddressTxos(address, txoHash);\r\n            if (result == null) {\r\n                stateUpdateCbk(null, null, null, null);\r\n                continue;\r\n            }\r\n            const confirmationDelay = await this.getConfirmationDelay(result.tx, requiredConfirmations);\r\n            if (confirmationDelay == null)\r\n                continue;\r\n            if (stateUpdateCbk != null)\r\n                stateUpdateCbk(result.tx.confirmations, result.tx.txid, result.vout, confirmationDelay);\r\n            if (confirmationDelay === 0)\r\n                return result;\r\n        }\r\n        abortSignal.throwIfAborted();\r\n    }\r\n    async waitForTransaction(txId, requiredConfirmations, stateUpdateCbk, abortSignal, intervalSeconds) {\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        while (abortSignal == null || !abortSignal.aborted) {\r\n            await (0, Utils_1.timeoutPromise)((intervalSeconds || 5) * 1000, abortSignal);\r\n            const result = await this.getTransaction(txId);\r\n            if (result == null) {\r\n                stateUpdateCbk(null, null, null);\r\n                continue;\r\n            }\r\n            const confirmationDelay = await this.getConfirmationDelay(result, requiredConfirmations);\r\n            if (confirmationDelay == null)\r\n                continue;\r\n            if (stateUpdateCbk != null)\r\n                stateUpdateCbk(result.confirmations, result.txid, confirmationDelay);\r\n            if (confirmationDelay === 0)\r\n                return result;\r\n        }\r\n        abortSignal.throwIfAborted();\r\n    }\r\n    async getLNNodeLiquidity(pubkey) {\r\n        const nodeInfo = await this.api.getLNNodeInfo(pubkey);\r\n        return {\r\n            publicKey: nodeInfo.public_key,\r\n            capacity: BigInt(nodeInfo.capacity),\r\n            numChannels: nodeInfo.active_channel_count\r\n        };\r\n    }\r\n    sendRawTransaction(rawTx) {\r\n        return this.api.sendTransaction(rawTx);\r\n    }\r\n    sendRawPackage(rawTx) {\r\n        throw new Error(\"Unsupported\");\r\n    }\r\n    async isSpent(utxo, confirmed) {\r\n        const [txId, voutStr] = utxo.split(\":\");\r\n        const vout = parseInt(voutStr);\r\n        const outspends = await this.api.getOutspends(txId);\r\n        if (outspends[vout] == null)\r\n            return true;\r\n        if (confirmed) {\r\n            return outspends[vout].spent && outspends[vout].status.confirmed;\r\n        }\r\n        return outspends[vout].spent;\r\n    }\r\n    parseTransaction(rawTx) {\r\n        const btcTx = btc_signer_1.Transaction.fromRaw(buffer_1.Buffer.from(rawTx, \"hex\"), {\r\n            allowLegacyWitnessUtxo: true,\r\n            allowUnknownInputs: true,\r\n            allowUnknownOutputs: true,\r\n            disableScriptCheck: true\r\n        });\r\n        return Promise.resolve(bitcoinTxToBtcTx(btcTx));\r\n    }\r\n    getEffectiveFeeRate(btcTx) {\r\n        throw new Error(\"Unsupported.\");\r\n    }\r\n    async getFeeRate() {\r\n        return (await this.api.getFees()).fastestFee;\r\n    }\r\n    getAddressBalances(address) {\r\n        return this.api.getAddressBalances(address);\r\n    }\r\n    async getAddressUTXOs(address) {\r\n        return (await this.api.getAddressUTXOs(address)).map(val => ({\r\n            txid: val.txid,\r\n            vout: val.vout,\r\n            confirmed: val.status.confirmed,\r\n            block_height: val.status.block_height,\r\n            block_hash: val.status.block_hash,\r\n            block_time: val.status.block_time,\r\n            value: val.value\r\n        }));\r\n    }\r\n    getCPFPData(txId) {\r\n        return this.api.getCPFPData(txId);\r\n    }\r\n}\r\nexports.MempoolBitcoinRpc = MempoolBitcoinRpc;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1130, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/BitcoinRpcWithAddressIndex.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1137, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/LightningNetworkApi.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1144, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/wallet/IBitcoinWallet.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.isIBitcoinWallet = void 0;\r\nfunction isIBitcoinWallet(val) {\r\n    return val !== null &&\r\n        typeof (val.sendTransaction) === \"function\" &&\r\n        typeof (val.fundPsbt) === \"function\" &&\r\n        typeof (val.signPsbt) === \"function\" &&\r\n        typeof (val.getFeeRate) === \"function\" &&\r\n        typeof (val.getTransactionFee) === \"function\" &&\r\n        typeof (val.getFundedPsbtFee) === \"function\" &&\r\n        typeof (val.getReceiveAddress) === \"function\" &&\r\n        typeof (val.getBalance) === \"function\" &&\r\n        typeof (val.getSpendableBalance) === \"function\";\r\n}\r\nexports.isIBitcoinWallet = isIBitcoinWallet;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,gBAAgB,GAAG,KAAK;AAChC,SAAS,iBAAiB,GAAG;IACzB,OAAO,QAAQ,QACX,OAAQ,IAAI,eAAe,KAAM,cACjC,OAAQ,IAAI,QAAQ,KAAM,cAC1B,OAAQ,IAAI,QAAQ,KAAM,cAC1B,OAAQ,IAAI,UAAU,KAAM,cAC5B,OAAQ,IAAI,iBAAiB,KAAM,cACnC,OAAQ,IAAI,gBAAgB,KAAM,cAClC,OAAQ,IAAI,iBAAiB,KAAM,cACnC,OAAQ,IAAI,UAAU,KAAM,cAC5B,OAAQ,IAAI,mBAAmB,KAAM;AAC7C;AACA,QAAQ,gBAAgB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1156, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/coinselect2/utils.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.utils = exports.DUST_THRESHOLDS = void 0;\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst logger = (0, Utils_1.getLogger)(\"CoinSelect: \");\r\n// baseline estimates, used to improve performance\r\nconst TX_EMPTY_SIZE = 4 + 1 + 1 + 4;\r\nconst TX_INPUT_BASE = 32 + 4 + 1 + 4;\r\nconst WITNESS_OVERHEAD = 2 / 4;\r\nconst P2WPKH_WITNESS = (1 + 1 + 72 + 1 + 33) / 4;\r\nconst P2TR_WITNESS = (1 + 1 + 65) / 4;\r\nconst TX_INPUT_PUBKEYHASH = 107;\r\nconst TX_INPUT_P2SH_P2WPKH = 23 + P2WPKH_WITNESS + 1;\r\nconst TX_INPUT_P2WPKH = 0 + P2WPKH_WITNESS;\r\nconst TX_INPUT_P2WSH = 0 + (1 + 1 + 64) / 4;\r\nconst TX_INPUT_P2TR = 0 + P2TR_WITNESS;\r\nconst TX_OUTPUT_BASE = 8 + 1;\r\nconst TX_OUTPUT_PUBKEYHASH = 25;\r\nconst TX_OUTPUT_P2SH_P2WPKH = 23;\r\nconst TX_OUTPUT_P2WPKH = 22;\r\nconst TX_OUTPUT_P2WSH = 34;\r\nconst TX_OUTPUT_P2TR = 34;\r\nconst INPUT_BYTES = {\r\n    \"p2sh-p2wpkh\": TX_INPUT_P2SH_P2WPKH,\r\n    \"p2wpkh\": TX_INPUT_P2WPKH,\r\n    \"p2tr\": TX_INPUT_P2TR,\r\n    \"p2pkh\": TX_INPUT_PUBKEYHASH,\r\n    \"p2wsh\": TX_INPUT_P2WSH\r\n};\r\nfunction inputBytes(input) {\r\n    return TX_INPUT_BASE + (input.script ? input.script.length : INPUT_BYTES[input.type]);\r\n}\r\nconst OUTPUT_BYTES = {\r\n    \"p2sh-p2wpkh\": TX_OUTPUT_P2SH_P2WPKH,\r\n    \"p2wpkh\": TX_OUTPUT_P2WPKH,\r\n    \"p2tr\": TX_OUTPUT_P2TR,\r\n    \"p2pkh\": TX_OUTPUT_PUBKEYHASH,\r\n    \"p2wsh\": TX_OUTPUT_P2WSH\r\n};\r\nfunction outputBytes(output) {\r\n    return TX_OUTPUT_BASE + (output.script ? output.script.length : OUTPUT_BYTES[output.type]);\r\n}\r\nexports.DUST_THRESHOLDS = {\r\n    \"p2sh-p2wpkh\": 540,\r\n    \"p2wpkh\": 294,\r\n    \"p2tr\": 330,\r\n    \"p2pkh\": 546,\r\n    \"p2wsh\": 330\r\n};\r\nfunction dustThreshold(output) {\r\n    return exports.DUST_THRESHOLDS[output.type];\r\n}\r\nfunction transactionBytes(inputs, outputs, changeType) {\r\n    let size = TX_EMPTY_SIZE;\r\n    let isSegwit = false;\r\n    if (changeType !== \"p2pkh\") {\r\n        size += WITNESS_OVERHEAD;\r\n        let isSegwit = true;\r\n    }\r\n    for (let input of inputs) {\r\n        if (!isSegwit && (input.type !== \"p2pkh\")) {\r\n            isSegwit = true;\r\n            size += WITNESS_OVERHEAD;\r\n        }\r\n        size += inputBytes(input);\r\n    }\r\n    for (let output of outputs) {\r\n        size += outputBytes(output);\r\n    }\r\n    return Math.ceil(size);\r\n}\r\nfunction uintOrNaN(v) {\r\n    if (typeof v !== 'number')\r\n        return NaN;\r\n    if (!isFinite(v))\r\n        return NaN;\r\n    if (Math.floor(v) !== v)\r\n        return NaN;\r\n    if (v < 0)\r\n        return NaN;\r\n    return v;\r\n}\r\nfunction sumForgiving(range) {\r\n    return range.reduce((a, x) => a + (isFinite(x.value) ? x.value : 0), 0);\r\n}\r\nfunction sumOrNaN(range) {\r\n    return range.reduce((a, x) => a + uintOrNaN(x.value), 0);\r\n}\r\nfunction finalize(inputs, outputs, feeRate, changeType, cpfpAddFee = 0) {\r\n    const bytesAccum = transactionBytes(inputs, outputs, changeType);\r\n    logger.debug(\"finalize(): Transaction bytes: \", bytesAccum);\r\n    const feeAfterExtraOutput = (feeRate * (bytesAccum + outputBytes({ type: changeType }))) + cpfpAddFee;\r\n    logger.debug(\"finalize(): TX fee after adding change output: \", feeAfterExtraOutput);\r\n    const remainderAfterExtraOutput = Math.floor(sumOrNaN(inputs) - (sumOrNaN(outputs) + feeAfterExtraOutput));\r\n    logger.debug(\"finalize(): Leaves change (changeType=\" + changeType + \") value: \", remainderAfterExtraOutput);\r\n    // is it worth a change output?\r\n    if (remainderAfterExtraOutput >= dustThreshold({ type: changeType })) {\r\n        outputs = outputs.concat({ value: remainderAfterExtraOutput, type: changeType });\r\n    }\r\n    const fee = sumOrNaN(inputs) - sumOrNaN(outputs);\r\n    logger.debug(\"finalize(): Re-calculated total fee: \", fee);\r\n    if (!isFinite(fee))\r\n        return { fee: (feeRate * bytesAccum) + cpfpAddFee };\r\n    return {\r\n        inputs: inputs,\r\n        outputs: outputs,\r\n        fee: fee\r\n    };\r\n}\r\nexports.utils = {\r\n    dustThreshold: dustThreshold,\r\n    finalize: finalize,\r\n    inputBytes: inputBytes,\r\n    outputBytes: outputBytes,\r\n    sumOrNaN: sumOrNaN,\r\n    sumForgiving: sumForgiving,\r\n    transactionBytes: transactionBytes,\r\n    uintOrNaN: uintOrNaN\r\n};\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1285, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/coinselect2/accumulative.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.accumulative = void 0;\r\nconst utils_1 = require(\"./utils\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst logger = (0, Utils_1.getLogger)(\"CoinSelect: \");\r\n// add inputs until we reach or surpass the target value (or deplete)\r\n// worst-case: O(n)\r\nfunction accumulative(utxos, outputs, feeRate, type, requiredInputs) {\r\n    if (!isFinite(utils_1.utils.uintOrNaN(feeRate)))\r\n        return null;\r\n    const inputs = requiredInputs == null ? [] : [...requiredInputs];\r\n    let bytesAccum = utils_1.utils.transactionBytes(inputs, outputs, type);\r\n    let fee = feeRate * bytesAccum;\r\n    let cpfpAddFee = 0;\r\n    let inAccum = utils_1.utils.sumOrNaN(inputs);\r\n    const outAccum = utils_1.utils.sumOrNaN(outputs);\r\n    logger.debug(\"accumulative(): total output: \", outAccum);\r\n    for (let i = 0; i < utxos.length; ++i) {\r\n        const utxo = utxos[i];\r\n        const utxoBytes = utils_1.utils.inputBytes(utxo);\r\n        const utxoFee = feeRate * utxoBytes;\r\n        const utxoValue = utils_1.utils.uintOrNaN(utxo.value);\r\n        let cpfpFee = 0;\r\n        if (utxo.cpfp != null && utxo.cpfp.txEffectiveFeeRate < feeRate)\r\n            cpfpFee = Math.ceil(utxo.cpfp.txVsize * (feeRate - utxo.cpfp.txEffectiveFeeRate));\r\n        // skip detrimental input\r\n        if (utxoFee + cpfpFee > utxo.value) {\r\n            logger.debug(\"accumulative(\" + i + \"): Skipping detrimental output, cpfpFee: \" + cpfpFee + \" utxoFee: \" + utxoFee + \" value: \" + utxo.value);\r\n            if (i === utxos.length - 1)\r\n                return { fee: (feeRate * (bytesAccum + utxoBytes)) + cpfpAddFee + cpfpFee };\r\n            continue;\r\n        }\r\n        bytesAccum += utxoBytes;\r\n        inAccum += utxoValue;\r\n        cpfpAddFee += cpfpFee;\r\n        inputs.push(utxo);\r\n        fee = Math.ceil((feeRate * bytesAccum) + cpfpAddFee);\r\n        logger.debug(\"accumulative(\" + i + \"): total fee: \", fee);\r\n        logger.debug(\"accumulative(\" + i + \"): input value: \", inAccum);\r\n        logger.debug(\"accumulative(\" + i + \"): cpfpAddFee: \", cpfpAddFee);\r\n        // go again?\r\n        if (inAccum < outAccum + fee)\r\n            continue;\r\n        logger.debug(\"accumulative(\" + i + \"): Finalizing transaction, inputs: \", inputs);\r\n        logger.debug(\"accumulative(\" + i + \"): Finalizing transaction, outputs: \", outputs);\r\n        logger.debug(\"accumulative(\" + i + \"): Finalizing transaction, feeRate: \", feeRate);\r\n        return utils_1.utils.finalize(inputs, outputs, feeRate, type, cpfpAddFee);\r\n    }\r\n    return { fee };\r\n}\r\nexports.accumulative = accumulative;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,YAAY,GAAG,KAAK;AAC5B,MAAM;AACN,MAAM;AACN,MAAM,SAAS,CAAC,GAAG,QAAQ,SAAS,EAAE;AACtC,qEAAqE;AACrE,mBAAmB;AACnB,SAAS,aAAa,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc;IAC/D,IAAI,CAAC,SAAS,QAAQ,KAAK,CAAC,SAAS,CAAC,WAClC,OAAO;IACX,MAAM,SAAS,kBAAkB,OAAO,EAAE,GAAG;WAAI;KAAe;IAChE,IAAI,aAAa,QAAQ,KAAK,CAAC,gBAAgB,CAAC,QAAQ,SAAS;IACjE,IAAI,MAAM,UAAU;IACpB,IAAI,aAAa;IACjB,IAAI,UAAU,QAAQ,KAAK,CAAC,QAAQ,CAAC;IACrC,MAAM,WAAW,QAAQ,KAAK,CAAC,QAAQ,CAAC;IACxC,OAAO,KAAK,CAAC,kCAAkC;IAC/C,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,EAAG;QACnC,MAAM,OAAO,KAAK,CAAC,EAAE;QACrB,MAAM,YAAY,QAAQ,KAAK,CAAC,UAAU,CAAC;QAC3C,MAAM,UAAU,UAAU;QAC1B,MAAM,YAAY,QAAQ,KAAK,CAAC,SAAS,CAAC,KAAK,KAAK;QACpD,IAAI,UAAU;QACd,IAAI,KAAK,IAAI,IAAI,QAAQ,KAAK,IAAI,CAAC,kBAAkB,GAAG,SACpD,UAAU,KAAK,IAAI,CAAC,KAAK,IAAI,CAAC,OAAO,GAAG,CAAC,UAAU,KAAK,IAAI,CAAC,kBAAkB;QACnF,yBAAyB;QACzB,IAAI,UAAU,UAAU,KAAK,KAAK,EAAE;YAChC,OAAO,KAAK,CAAC,kBAAkB,IAAI,8CAA8C,UAAU,eAAe,UAAU,aAAa,KAAK,KAAK;YAC3I,IAAI,MAAM,MAAM,MAAM,GAAG,GACrB,OAAO;gBAAE,KAAK,AAAC,UAAU,CAAC,aAAa,SAAS,IAAK,aAAa;YAAQ;YAC9E;QACJ;QACA,cAAc;QACd,WAAW;QACX,cAAc;QACd,OAAO,IAAI,CAAC;QACZ,MAAM,KAAK,IAAI,CAAC,AAAC,UAAU,aAAc;QACzC,OAAO,KAAK,CAAC,kBAAkB,IAAI,kBAAkB;QACrD,OAAO,KAAK,CAAC,kBAAkB,IAAI,oBAAoB;QACvD,OAAO,KAAK,CAAC,kBAAkB,IAAI,mBAAmB;QACtD,YAAY;QACZ,IAAI,UAAU,WAAW,KACrB;QACJ,OAAO,KAAK,CAAC,kBAAkB,IAAI,uCAAuC;QAC1E,OAAO,KAAK,CAAC,kBAAkB,IAAI,wCAAwC;QAC3E,OAAO,KAAK,CAAC,kBAAkB,IAAI,wCAAwC;QAC3E,OAAO,QAAQ,KAAK,CAAC,QAAQ,CAAC,QAAQ,SAAS,SAAS,MAAM;IAClE;IACA,OAAO;QAAE;IAAI;AACjB;AACA,QAAQ,YAAY,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1344, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/coinselect2/blackjack.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.blackjack = void 0;\r\nconst utils_1 = require(\"./utils\");\r\n// add inputs until we reach or surpass the target value (or deplete)\r\n// worst-case: O(n)\r\nfunction blackjack(utxos, outputs, feeRate, type, requiredInputs) {\r\n    if (!isFinite(utils_1.utils.uintOrNaN(feeRate)))\r\n        return null;\r\n    const inputs = requiredInputs == null ? [] : [...requiredInputs];\r\n    let bytesAccum = utils_1.utils.transactionBytes(inputs, outputs, type);\r\n    let inAccum = utils_1.utils.sumOrNaN(inputs);\r\n    let cpfpAddFee = 0;\r\n    const outAccum = utils_1.utils.sumOrNaN(outputs);\r\n    const threshold = utils_1.utils.dustThreshold({ type });\r\n    for (let i = 0; i < utxos.length; ++i) {\r\n        const input = utxos[i];\r\n        const inputBytes = utils_1.utils.inputBytes(input);\r\n        let cpfpFee = 0;\r\n        if (input.cpfp != null && input.cpfp.txEffectiveFeeRate < feeRate)\r\n            cpfpFee = Math.ceil(input.cpfp.txVsize * (feeRate - input.cpfp.txEffectiveFeeRate));\r\n        const fee = Math.ceil((feeRate * (bytesAccum + inputBytes)) + cpfpAddFee + cpfpFee);\r\n        const inputValue = utils_1.utils.uintOrNaN(input.value);\r\n        // would it waste value?\r\n        if ((inAccum + inputValue) > (outAccum + fee + threshold))\r\n            continue;\r\n        bytesAccum += inputBytes;\r\n        inAccum += inputValue;\r\n        cpfpAddFee += cpfpFee;\r\n        inputs.push(input);\r\n        // go again?\r\n        if (inAccum < outAccum + fee)\r\n            continue;\r\n        return utils_1.utils.finalize(inputs, outputs, feeRate, type, cpfpAddFee);\r\n    }\r\n    return { fee: (feeRate * bytesAccum) + cpfpAddFee };\r\n}\r\nexports.blackjack = blackjack;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,SAAS,GAAG,KAAK;AACzB,MAAM;AACN,qEAAqE;AACrE,mBAAmB;AACnB,SAAS,UAAU,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc;IAC5D,IAAI,CAAC,SAAS,QAAQ,KAAK,CAAC,SAAS,CAAC,WAClC,OAAO;IACX,MAAM,SAAS,kBAAkB,OAAO,EAAE,GAAG;WAAI;KAAe;IAChE,IAAI,aAAa,QAAQ,KAAK,CAAC,gBAAgB,CAAC,QAAQ,SAAS;IACjE,IAAI,UAAU,QAAQ,KAAK,CAAC,QAAQ,CAAC;IACrC,IAAI,aAAa;IACjB,MAAM,WAAW,QAAQ,KAAK,CAAC,QAAQ,CAAC;IACxC,MAAM,YAAY,QAAQ,KAAK,CAAC,aAAa,CAAC;QAAE;IAAK;IACrD,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,EAAG;QACnC,MAAM,QAAQ,KAAK,CAAC,EAAE;QACtB,MAAM,aAAa,QAAQ,KAAK,CAAC,UAAU,CAAC;QAC5C,IAAI,UAAU;QACd,IAAI,MAAM,IAAI,IAAI,QAAQ,MAAM,IAAI,CAAC,kBAAkB,GAAG,SACtD,UAAU,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,OAAO,GAAG,CAAC,UAAU,MAAM,IAAI,CAAC,kBAAkB;QACrF,MAAM,MAAM,KAAK,IAAI,CAAC,AAAC,UAAU,CAAC,aAAa,UAAU,IAAK,aAAa;QAC3E,MAAM,aAAa,QAAQ,KAAK,CAAC,SAAS,CAAC,MAAM,KAAK;QACtD,wBAAwB;QACxB,IAAI,AAAC,UAAU,aAAe,WAAW,MAAM,WAC3C;QACJ,cAAc;QACd,WAAW;QACX,cAAc;QACd,OAAO,IAAI,CAAC;QACZ,YAAY;QACZ,IAAI,UAAU,WAAW,KACrB;QACJ,OAAO,QAAQ,KAAK,CAAC,QAAQ,CAAC,QAAQ,SAAS,SAAS,MAAM;IAClE;IACA,OAAO;QAAE,KAAK,AAAC,UAAU,aAAc;IAAW;AACtD;AACA,QAAQ,SAAS,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1389, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/coinselect2/index.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.maxSendable = exports.coinSelect = exports.DUST_THRESHOLDS = void 0;\r\nconst accumulative_1 = require(\"./accumulative\");\r\nconst blackjack_1 = require(\"./blackjack\");\r\nconst utils_1 = require(\"./utils\");\r\nObject.defineProperty(exports, \"DUST_THRESHOLDS\", { enumerable: true, get: function () { return utils_1.DUST_THRESHOLDS; } });\r\n// order by descending value, minus the inputs approximate fee\r\nfunction utxoScore(x, feeRate) {\r\n    let valueAfterFee = x.value - (feeRate * utils_1.utils.inputBytes(x));\r\n    if (x.cpfp != null && x.cpfp.txEffectiveFeeRate < feeRate)\r\n        valueAfterFee -= x.cpfp.txVsize * (feeRate - x.cpfp.txEffectiveFeeRate);\r\n    return valueAfterFee;\r\n}\r\nfunction coinSelect(utxos, outputs, feeRate, type, requiredInputs) {\r\n    // order by descending value, minus the inputs approximate fee\r\n    utxos = utxos.sort((a, b) => {\r\n        // if(a.cpfp!=null && b.cpfp==null) return 1;\r\n        // if(a.cpfp==null && b.cpfp!=null) return -1;\r\n        return utxoScore(b, feeRate) - utxoScore(a, feeRate);\r\n    });\r\n    // attempt to use the blackjack strategy first (no change output)\r\n    const base = (0, blackjack_1.blackjack)(utxos, outputs, feeRate, type, requiredInputs);\r\n    if (base.inputs)\r\n        return base;\r\n    // else, try the accumulative strategy\r\n    return (0, accumulative_1.accumulative)(utxos, outputs, feeRate, type, requiredInputs);\r\n}\r\nexports.coinSelect = coinSelect;\r\nfunction maxSendable(utxos, output, feeRate, requiredInputs, additionalOutputs) {\r\n    if (!isFinite(utils_1.utils.uintOrNaN(feeRate)))\r\n        return null;\r\n    const outputs = additionalOutputs ?? [];\r\n    const inputs = requiredInputs ?? [];\r\n    let bytesAccum = utils_1.utils.transactionBytes(inputs, outputs.concat([output]), null);\r\n    let cpfpAddFee = 0;\r\n    let inAccum = utils_1.utils.sumOrNaN(inputs);\r\n    let outAccum = utils_1.utils.sumOrNaN(outputs);\r\n    for (let i = 0; i < utxos.length; ++i) {\r\n        const utxo = utxos[i];\r\n        const utxoBytes = utils_1.utils.inputBytes(utxo);\r\n        const utxoFee = feeRate * utxoBytes;\r\n        let cpfpFee = 0;\r\n        if (utxo.cpfp != null && utxo.cpfp.txEffectiveFeeRate < feeRate)\r\n            cpfpFee = utxo.cpfp.txVsize * (feeRate - utxo.cpfp.txEffectiveFeeRate);\r\n        const utxoValue = utils_1.utils.uintOrNaN(utxo.value);\r\n        // skip detrimental input\r\n        if (utxoFee + cpfpFee > utxo.value) {\r\n            continue;\r\n        }\r\n        bytesAccum += utxoBytes;\r\n        inAccum += utxoValue;\r\n        cpfpAddFee += cpfpFee;\r\n        inputs.push(utxo);\r\n    }\r\n    const fee = (feeRate * bytesAccum) + cpfpAddFee;\r\n    const outputValue = inAccum - fee - outAccum;\r\n    const dustThreshold = utils_1.DUST_THRESHOLDS[output.type];\r\n    if (outputValue < dustThreshold)\r\n        return {\r\n            fee,\r\n            value: 0\r\n        };\r\n    return {\r\n        fee,\r\n        value: outputValue\r\n    };\r\n}\r\nexports.maxSendable = maxSendable;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,WAAW,GAAG,QAAQ,UAAU,GAAG,QAAQ,eAAe,GAAG,KAAK;AAC1E,MAAM;AACN,MAAM;AACN,MAAM;AACN,OAAO,cAAc,CAAC,SAAS,mBAAmB;IAAE,YAAY;IAAM,KAAK;QAAc,OAAO,QAAQ,eAAe;IAAE;AAAE;AAC3H,8DAA8D;AAC9D,SAAS,UAAU,CAAC,EAAE,OAAO;IACzB,IAAI,gBAAgB,EAAE,KAAK,GAAI,UAAU,QAAQ,KAAK,CAAC,UAAU,CAAC;IAClE,IAAI,EAAE,IAAI,IAAI,QAAQ,EAAE,IAAI,CAAC,kBAAkB,GAAG,SAC9C,iBAAiB,EAAE,IAAI,CAAC,OAAO,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,kBAAkB;IAC1E,OAAO;AACX;AACA,SAAS,WAAW,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc;IAC7D,8DAA8D;IAC9D,QAAQ,MAAM,IAAI,CAAC,CAAC,GAAG;QACnB,6CAA6C;QAC7C,8CAA8C;QAC9C,OAAO,UAAU,GAAG,WAAW,UAAU,GAAG;IAChD;IACA,iEAAiE;IACjE,MAAM,OAAO,CAAC,GAAG,YAAY,SAAS,EAAE,OAAO,SAAS,SAAS,MAAM;IACvE,IAAI,KAAK,MAAM,EACX,OAAO;IACX,sCAAsC;IACtC,OAAO,CAAC,GAAG,eAAe,YAAY,EAAE,OAAO,SAAS,SAAS,MAAM;AAC3E;AACA,QAAQ,UAAU,GAAG;AACrB,SAAS,YAAY,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,cAAc,EAAE,iBAAiB;IAC1E,IAAI,CAAC,SAAS,QAAQ,KAAK,CAAC,SAAS,CAAC,WAClC,OAAO;IACX,MAAM,UAAU,8BAAA,+BAAA,oBAAqB,EAAE;IACvC,MAAM,SAAS,2BAAA,4BAAA,iBAAkB,EAAE;IACnC,IAAI,aAAa,QAAQ,KAAK,CAAC,gBAAgB,CAAC,QAAQ,QAAQ,MAAM,CAAC;QAAC;KAAO,GAAG;IAClF,IAAI,aAAa;IACjB,IAAI,UAAU,QAAQ,KAAK,CAAC,QAAQ,CAAC;IACrC,IAAI,WAAW,QAAQ,KAAK,CAAC,QAAQ,CAAC;IACtC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,EAAG;QACnC,MAAM,OAAO,KAAK,CAAC,EAAE;QACrB,MAAM,YAAY,QAAQ,KAAK,CAAC,UAAU,CAAC;QAC3C,MAAM,UAAU,UAAU;QAC1B,IAAI,UAAU;QACd,IAAI,KAAK,IAAI,IAAI,QAAQ,KAAK,IAAI,CAAC,kBAAkB,GAAG,SACpD,UAAU,KAAK,IAAI,CAAC,OAAO,GAAG,CAAC,UAAU,KAAK,IAAI,CAAC,kBAAkB;QACzE,MAAM,YAAY,QAAQ,KAAK,CAAC,SAAS,CAAC,KAAK,KAAK;QACpD,yBAAyB;QACzB,IAAI,UAAU,UAAU,KAAK,KAAK,EAAE;YAChC;QACJ;QACA,cAAc;QACd,WAAW;QACX,cAAc;QACd,OAAO,IAAI,CAAC;IAChB;IACA,MAAM,MAAM,AAAC,UAAU,aAAc;IACrC,MAAM,cAAc,UAAU,MAAM;IACpC,MAAM,gBAAgB,QAAQ,eAAe,CAAC,OAAO,IAAI,CAAC;IAC1D,IAAI,cAAc,eACd,OAAO;QACH;QACA,OAAO;IACX;IACJ,OAAO;QACH;QACA,OAAO;IACX;AACJ;AACA,QAAQ,WAAW,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1465, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/wallet/BitcoinWallet.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BitcoinWallet = exports.identifyAddressType = void 0;\r\nconst coinselect2_1 = require(\"../coinselect2\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nfunction identifyAddressType(address, network) {\r\n    switch ((0, btc_signer_1.Address)(network).decode(address).type) {\r\n        case \"pkh\":\r\n            return \"p2pkh\";\r\n        case \"wpkh\":\r\n            return \"p2wpkh\";\r\n        case \"tr\":\r\n            return \"p2tr\";\r\n        case \"sh\":\r\n            return \"p2sh-p2wpkh\";\r\n        case \"wsh\":\r\n            return \"p2wsh\";\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nexports.identifyAddressType = identifyAddressType;\r\nconst logger = (0, Utils_1.getLogger)(\"BitcoinWallet: \");\r\nclass BitcoinWallet {\r\n    constructor(mempoolApi, network, feeMultiplier = 1.25, feeOverride) {\r\n        this.rpc = mempoolApi;\r\n        this.network = network;\r\n        this.feeMultiplier = feeMultiplier;\r\n        this.feeOverride = feeOverride;\r\n    }\r\n    async getFeeRate() {\r\n        if (this.feeOverride != null) {\r\n            return this.feeOverride;\r\n        }\r\n        return Math.floor((await this.rpc.getFeeRate()) * this.feeMultiplier);\r\n    }\r\n    _sendTransaction(rawHex) {\r\n        return this.rpc.sendRawTransaction(rawHex);\r\n    }\r\n    _getBalance(address) {\r\n        return this.rpc.getAddressBalances(address);\r\n    }\r\n    async _getUtxoPool(sendingAddress, sendingAddressType) {\r\n        const utxos = await this.rpc.getAddressUTXOs(sendingAddress);\r\n        let totalSpendable = 0;\r\n        const outputScript = (0, Utils_1.toOutputScript)(this.network, sendingAddress);\r\n        const utxoPool = [];\r\n        for (let utxo of utxos) {\r\n            const value = Number(utxo.value);\r\n            totalSpendable += value;\r\n            utxoPool.push({\r\n                vout: utxo.vout,\r\n                txId: utxo.txid,\r\n                value: value,\r\n                type: sendingAddressType,\r\n                outputScript: outputScript,\r\n                address: sendingAddress,\r\n                cpfp: !utxo.confirmed ? await this.rpc.getCPFPData(utxo.txid).then((result) => {\r\n                    if (result.effectiveFeePerVsize == null)\r\n                        return null;\r\n                    return {\r\n                        txVsize: result.adjustedVsize,\r\n                        txEffectiveFeeRate: result.effectiveFeePerVsize\r\n                    };\r\n                }) : null,\r\n                confirmed: utxo.confirmed\r\n            });\r\n        }\r\n        logger.debug(\"_getUtxoPool(): Total spendable value: \" + totalSpendable + \" num utxos: \" + utxoPool.length);\r\n        return utxoPool;\r\n    }\r\n    async _getPsbt(sendingAccounts, recipient, amount, feeRate) {\r\n        const psbt = new btc_signer_1.Transaction({ PSBTVersion: 0 });\r\n        psbt.addOutput({\r\n            amount: BigInt(amount),\r\n            script: (0, Utils_1.toOutputScript)(this.network, recipient)\r\n        });\r\n        return this._fundPsbt(sendingAccounts, psbt, feeRate);\r\n    }\r\n    async _fundPsbt(sendingAccounts, psbt, feeRate) {\r\n        if (feeRate == null)\r\n            feeRate = await this.getFeeRate();\r\n        const utxoPool = (await Promise.all(sendingAccounts.map(acc => this._getUtxoPool(acc.address, acc.addressType)))).flat();\r\n        logger.debug(\"_fundPsbt(): fee rate: \" + feeRate + \" utxo pool: \", utxoPool);\r\n        const accountPubkeys = {};\r\n        sendingAccounts.forEach(acc => accountPubkeys[acc.address] = acc.pubkey);\r\n        const requiredInputs = [];\r\n        for (let i = 0; i < psbt.inputsLength; i++) {\r\n            const input = psbt.getInput(i);\r\n            let amount = input.witnessUtxo != null ? input.witnessUtxo.amount : input.nonWitnessUtxo.outputs[input.index].amount;\r\n            let script = input.witnessUtxo != null ? input.witnessUtxo.script : input.nonWitnessUtxo.outputs[input.index].script;\r\n            requiredInputs.push({\r\n                txId: buffer_1.Buffer.from(input.txid).toString('hex'),\r\n                vout: input.index,\r\n                value: Number(amount),\r\n                type: (0, Utils_1.toCoinselectAddressType)(script)\r\n            });\r\n        }\r\n        const targets = [];\r\n        for (let i = 0; i < psbt.outputsLength; i++) {\r\n            const output = psbt.getOutput(i);\r\n            targets.push({\r\n                value: Number(output.amount),\r\n                script: buffer_1.Buffer.from(output.script)\r\n            });\r\n        }\r\n        logger.debug(\"_fundPsbt(): Coinselect targets: \", targets);\r\n        let coinselectResult = (0, coinselect2_1.coinSelect)(utxoPool, targets, feeRate, sendingAccounts[0].addressType, requiredInputs);\r\n        logger.debug(\"_fundPsbt(): Coinselect result: \", coinselectResult);\r\n        if (coinselectResult.inputs == null || coinselectResult.outputs == null) {\r\n            return {\r\n                psbt: null,\r\n                fee: coinselectResult.fee,\r\n                inputAddressIndexes: null\r\n            };\r\n        }\r\n        // Remove in/outs that are already in the PSBT\r\n        coinselectResult.inputs.splice(0, psbt.inputsLength);\r\n        coinselectResult.outputs.splice(0, psbt.outputsLength);\r\n        const inputAddressIndexes = {};\r\n        coinselectResult.inputs.forEach((input, index) => {\r\n            inputAddressIndexes[input.address] ??= [];\r\n            inputAddressIndexes[input.address].push(index);\r\n        });\r\n        const formattedInputs = await Promise.all(coinselectResult.inputs.map(async (input) => {\r\n            switch (input.type) {\r\n                case \"p2tr\":\r\n                    const parsed = (0, btc_signer_1.p2tr)(buffer_1.Buffer.from(accountPubkeys[input.address], \"hex\"));\r\n                    return {\r\n                        txid: input.txId,\r\n                        index: input.vout,\r\n                        witnessUtxo: {\r\n                            script: input.outputScript,\r\n                            amount: BigInt(input.value)\r\n                        },\r\n                        tapInternalKey: parsed.tapInternalKey,\r\n                        tapMerkleRoot: parsed.tapMerkleRoot,\r\n                        tapLeafScript: parsed.tapLeafScript\r\n                    };\r\n                case \"p2wpkh\":\r\n                    return {\r\n                        txid: input.txId,\r\n                        index: input.vout,\r\n                        witnessUtxo: {\r\n                            script: input.outputScript,\r\n                            amount: BigInt(input.value)\r\n                        },\r\n                        sighashType: 0x01\r\n                    };\r\n                case \"p2sh-p2wpkh\":\r\n                    return {\r\n                        txid: input.txId,\r\n                        index: input.vout,\r\n                        witnessUtxo: {\r\n                            script: input.outputScript,\r\n                            amount: BigInt(input.value)\r\n                        },\r\n                        redeemScript: (0, btc_signer_1.p2wpkh)(buffer_1.Buffer.from(accountPubkeys[input.address], \"hex\"), this.network).script,\r\n                        sighashType: 0x01\r\n                    };\r\n                case \"p2pkh\":\r\n                    return {\r\n                        txid: input.txId,\r\n                        index: input.vout,\r\n                        nonWitnessUtxo: (await this.rpc.getTransaction(input.txId)).raw,\r\n                        sighashType: 0x01\r\n                    };\r\n            }\r\n        }));\r\n        formattedInputs.forEach(input => psbt.addInput(input));\r\n        coinselectResult.outputs.forEach(output => {\r\n            if (output.script == null && output.address == null) {\r\n                //Change output\r\n                psbt.addOutput({\r\n                    script: (0, Utils_1.toOutputScript)(this.network, sendingAccounts[0].address),\r\n                    amount: BigInt(Math.floor(output.value))\r\n                });\r\n            }\r\n            else {\r\n                psbt.addOutput({\r\n                    script: output.script ?? (0, Utils_1.toOutputScript)(this.network, output.address),\r\n                    amount: BigInt(output.value)\r\n                });\r\n            }\r\n        });\r\n        return {\r\n            psbt,\r\n            fee: coinselectResult.fee,\r\n            inputAddressIndexes\r\n        };\r\n    }\r\n    async _getSpendableBalance(sendingAccounts, psbt, feeRate) {\r\n        feeRate ??= await this.getFeeRate();\r\n        const utxoPool = (await Promise.all(sendingAccounts.map(acc => this._getUtxoPool(acc.address, acc.addressType)))).flat();\r\n        const requiredInputs = [];\r\n        if (psbt != null)\r\n            for (let i = 0; i < psbt.inputsLength; i++) {\r\n                const input = psbt.getInput(i);\r\n                let amount = input.witnessUtxo != null ? input.witnessUtxo.amount : input.nonWitnessUtxo.outputs[input.index].amount;\r\n                let script = input.witnessUtxo != null ? input.witnessUtxo.script : input.nonWitnessUtxo.outputs[input.index].script;\r\n                requiredInputs.push({\r\n                    txId: buffer_1.Buffer.from(input.txid).toString('hex'),\r\n                    vout: input.index,\r\n                    value: Number(amount),\r\n                    type: (0, Utils_1.toCoinselectAddressType)(script)\r\n                });\r\n            }\r\n        const additionalOutputs = [];\r\n        if (psbt != null)\r\n            for (let i = 0; i < psbt.outputsLength; i++) {\r\n                const output = psbt.getOutput(i);\r\n                additionalOutputs.push({\r\n                    value: Number(output.amount),\r\n                    script: buffer_1.Buffer.from(output.script)\r\n                });\r\n            }\r\n        const target = btc_signer_1.OutScript.encode({\r\n            type: \"wsh\",\r\n            hash: (0, Utils_1.randomBytes)(32)\r\n        });\r\n        let coinselectResult = (0, coinselect2_1.maxSendable)(utxoPool, { script: buffer_1.Buffer.from(target), type: \"p2wsh\" }, feeRate, requiredInputs, additionalOutputs);\r\n        logger.debug(\"_getSpendableBalance(): Max spendable result: \", coinselectResult);\r\n        return {\r\n            feeRate: feeRate,\r\n            balance: BigInt(Math.floor(coinselectResult.value)),\r\n            totalFee: coinselectResult.fee\r\n        };\r\n    }\r\n}\r\nexports.BitcoinWallet = BitcoinWallet;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1705, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/btc/wallet/SingleAddressBitcoinWallet.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SingleAddressBitcoinWallet = void 0;\r\nconst utils_1 = require(\"@scure/btc-signer/utils\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst BitcoinWallet_1 = require(\"./BitcoinWallet\");\r\nclass SingleAddressBitcoinWallet extends BitcoinWallet_1.BitcoinWallet {\r\n    constructor(mempoolApi, network, addressDataOrWIF, feeMultiplier = 1.25, feeOverride) {\r\n        super(mempoolApi, network, feeMultiplier, feeOverride);\r\n        if (typeof (addressDataOrWIF) === \"string\") {\r\n            try {\r\n                this.privKey = (0, btc_signer_1.WIF)(network).decode(addressDataOrWIF);\r\n            }\r\n            catch (e) {\r\n                this.privKey = (0, btc_signer_1.WIF)().decode(addressDataOrWIF);\r\n            }\r\n            this.pubkey = (0, utils_1.pubECDSA)(this.privKey);\r\n            this.address = (0, btc_signer_1.getAddress)(\"wpkh\", this.privKey, network);\r\n        }\r\n        else {\r\n            this.address = addressDataOrWIF.address;\r\n            this.pubkey = buffer_1.Buffer.from(addressDataOrWIF.publicKey, \"hex\");\r\n        }\r\n        this.addressType = (0, BitcoinWallet_1.identifyAddressType)(this.address, network);\r\n    }\r\n    toBitcoinWalletAccounts() {\r\n        return [{\r\n                pubkey: buffer_1.Buffer.from(this.pubkey).toString(\"hex\"), address: this.address, addressType: this.addressType\r\n            }];\r\n    }\r\n    async sendTransaction(address, amount, feeRate) {\r\n        if (!this.privKey)\r\n            throw new Error(\"Not supported.\");\r\n        const { psbt } = await super._getPsbt(this.toBitcoinWalletAccounts(), address, Number(amount), feeRate);\r\n        psbt.sign(this.privKey);\r\n        psbt.finalize();\r\n        const txHex = buffer_1.Buffer.from(psbt.extract()).toString(\"hex\");\r\n        return await super._sendTransaction(txHex);\r\n    }\r\n    async fundPsbt(inputPsbt, feeRate) {\r\n        const { psbt } = await super._fundPsbt(this.toBitcoinWalletAccounts(), inputPsbt, feeRate);\r\n        if (psbt == null) {\r\n            throw new Error(\"Not enough balance!\");\r\n        }\r\n        return psbt;\r\n    }\r\n    async signPsbt(psbt, signInputs) {\r\n        if (!this.privKey)\r\n            throw new Error(\"Not supported.\");\r\n        for (let signInput of signInputs) {\r\n            psbt.signIdx(this.privKey, signInput);\r\n        }\r\n        return psbt;\r\n    }\r\n    async getTransactionFee(address, amount, feeRate) {\r\n        const { psbt, fee } = await super._getPsbt(this.toBitcoinWalletAccounts(), address, Number(amount), feeRate);\r\n        if (psbt == null)\r\n            return null;\r\n        return fee;\r\n    }\r\n    async getFundedPsbtFee(basePsbt, feeRate) {\r\n        const { psbt, fee } = await super._fundPsbt(this.toBitcoinWalletAccounts(), basePsbt, feeRate);\r\n        if (psbt == null)\r\n            return null;\r\n        return fee;\r\n    }\r\n    getReceiveAddress() {\r\n        return this.address;\r\n    }\r\n    getBalance() {\r\n        return this._getBalance(this.address);\r\n    }\r\n    getSpendableBalance(psbt, feeRate) {\r\n        return this._getSpendableBalance([{ address: this.address, addressType: this.addressType }], psbt, feeRate);\r\n    }\r\n    static generateRandomPrivateKey(network) {\r\n        return (0, btc_signer_1.WIF)(network).encode((0, utils_1.randomPrivateKeyBytes)());\r\n    }\r\n}\r\nexports.SingleAddressBitcoinWallet = SingleAddressBitcoinWallet;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1794, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IntermediaryError = void 0;\r\n/**\r\n * An error or inconsistency in the intermediary's returned data, this will blacklist the intermediary\r\n */\r\nclass IntermediaryError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, IntermediaryError.prototype);\r\n    }\r\n}\r\nexports.IntermediaryError = IntermediaryError;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,iBAAiB,GAAG,KAAK;AACjC;;CAEC,GACD,MAAM,0BAA0B;IAC5B,YAAY,GAAG,CAAE;QACb,KAAK,CAAC;QACN,gCAAgC;QAChC,OAAO,cAAc,CAAC,IAAI,EAAE,kBAAkB,SAAS;IAC3D;AACJ;AACA,QAAQ,iBAAiB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1812, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/errors/PaymentAuthError.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PaymentAuthError = void 0;\r\n/**\r\n * An error when the payment authorization returned by the intermediary is invalid\r\n */\r\nclass PaymentAuthError extends Error {\r\n    constructor(msg, code, data) {\r\n        super(msg);\r\n        this.data = data;\r\n        this.code = code;\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, PaymentAuthError.prototype);\r\n    }\r\n    getCode() {\r\n        return this.code;\r\n    }\r\n    getData() {\r\n        return this.data;\r\n    }\r\n}\r\nexports.PaymentAuthError = PaymentAuthError;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,gBAAgB,GAAG,KAAK;AAChC;;CAEC,GACD,MAAM,yBAAyB;IAQ3B,UAAU;QACN,OAAO,IAAI,CAAC,IAAI;IACpB;IACA,UAAU;QACN,OAAO,IAAI,CAAC,IAAI;IACpB;IAZA,YAAY,GAAG,EAAE,IAAI,EAAE,IAAI,CAAE;QACzB,KAAK,CAAC;QACN,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,IAAI,GAAG;QACZ,gCAAgC;QAChC,OAAO,cAAc,CAAC,IAAI,EAAE,iBAAiB,SAAS;IAC1D;AAOJ;AACA,QAAQ,gBAAgB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1838, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/errors/UserError.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UserError = void 0;\r\n/**\r\n * An error on the user side, such as invalid address provided\r\n */\r\nclass UserError extends Error {\r\n    constructor(msg) {\r\n        super(msg);\r\n        // Set the prototype explicitly.\r\n        Object.setPrototypeOf(this, UserError.prototype);\r\n    }\r\n}\r\nexports.UserError = UserError;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,SAAS,GAAG,KAAK;AACzB;;CAEC,GACD,MAAM,kBAAkB;IACpB,YAAY,GAAG,CAAE;QACb,KAAK,CAAC;QACN,gCAAgC;QAChC,OAAO,cAAc,CAAC,IAAI,EAAE,UAAU,SAAS;IACnD;AACJ;AACA,QAAQ,SAAS,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1856, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SwapType = void 0;\r\nvar SwapType;\r\n(function (SwapType) {\r\n    SwapType[SwapType[\"FROM_BTC\"] = 0] = \"FROM_BTC\";\r\n    SwapType[SwapType[\"FROM_BTCLN\"] = 1] = \"FROM_BTCLN\";\r\n    SwapType[SwapType[\"TO_BTC\"] = 2] = \"TO_BTC\";\r\n    SwapType[SwapType[\"TO_BTCLN\"] = 3] = \"TO_BTCLN\";\r\n    SwapType[SwapType[\"TRUSTED_FROM_BTC\"] = 4] = \"TRUSTED_FROM_BTC\";\r\n    SwapType[SwapType[\"TRUSTED_FROM_BTCLN\"] = 5] = \"TRUSTED_FROM_BTCLN\";\r\n    SwapType[SwapType[\"SPV_VAULT_FROM_BTC\"] = 6] = \"SPV_VAULT_FROM_BTC\";\r\n})(SwapType = exports.SwapType || (exports.SwapType = {}));\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,QAAQ,GAAG,KAAK;AACxB,IAAI;AACJ,CAAC,SAAU,QAAQ;IACf,QAAQ,CAAC,QAAQ,CAAC,WAAW,GAAG,EAAE,GAAG;IACrC,QAAQ,CAAC,QAAQ,CAAC,aAAa,GAAG,EAAE,GAAG;IACvC,QAAQ,CAAC,QAAQ,CAAC,SAAS,GAAG,EAAE,GAAG;IACnC,QAAQ,CAAC,QAAQ,CAAC,WAAW,GAAG,EAAE,GAAG;IACrC,QAAQ,CAAC,QAAQ,CAAC,mBAAmB,GAAG,EAAE,GAAG;IAC7C,QAAQ,CAAC,QAAQ,CAAC,qBAAqB,GAAG,EAAE,GAAG;IAC/C,QAAQ,CAAC,QAAQ,CAAC,qBAAqB,GAAG,EAAE,GAAG;AACnD,CAAC,EAAE,WAAW,QAAQ,QAAQ,IAAI,CAAC,QAAQ,QAAQ,GAAG,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1874, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/intermediaries/Intermediary.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Intermediary = void 0;\r\nconst SwapType_1 = require(\"../swaps/enums/SwapType\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nclass Intermediary {\r\n    constructor(url, addresses, services, reputation = {}) {\r\n        this.reputation = {};\r\n        this.liquidity = {};\r\n        this.url = url;\r\n        this.addresses = addresses;\r\n        this.services = services;\r\n        this.reputation = reputation;\r\n        this.swapBounds = {};\r\n        for (let _swapType in this.services) {\r\n            const swapType = parseInt(_swapType);\r\n            const serviceInfo = this.services[_swapType];\r\n            const btcBounds = { min: BigInt(serviceInfo.min), max: BigInt(serviceInfo.max) };\r\n            const isSend = swapType === SwapType_1.SwapType.TO_BTC || swapType === SwapType_1.SwapType.TO_BTCLN;\r\n            this.swapBounds[swapType] = {};\r\n            for (let chainIdentifier in serviceInfo.chainTokens) {\r\n                this.swapBounds[swapType][chainIdentifier] = {};\r\n                for (let tokenAddress of serviceInfo.chainTokens[chainIdentifier]) {\r\n                    this.swapBounds[swapType][chainIdentifier][tokenAddress] = {\r\n                        input: isSend ? { min: null, max: null } : btcBounds,\r\n                        output: !isSend ? { min: null, max: null } : btcBounds,\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getSwapLimits(swapType, chainId, tokenAddress) {\r\n        return this.swapBounds[swapType]?.[chainId]?.[tokenAddress];\r\n    }\r\n    /**\r\n     * Returns tokens supported by the intermediary, optionally constrained to the specific swap types\r\n     *\r\n     * @param chainIdentifier\r\n     * @param swapTypesArr\r\n     * @private\r\n     */\r\n    getSupportedTokens(chainIdentifier, swapTypesArr = [\r\n        SwapType_1.SwapType.TO_BTC,\r\n        SwapType_1.SwapType.TO_BTCLN,\r\n        SwapType_1.SwapType.FROM_BTC,\r\n        SwapType_1.SwapType.FROM_BTCLN,\r\n        SwapType_1.SwapType.SPV_VAULT_FROM_BTC\r\n    ]) {\r\n        const swapTypes = new Set(swapTypesArr);\r\n        let tokens = new Set();\r\n        swapTypes.forEach((swapType) => {\r\n            if (this.services[swapType] != null &&\r\n                this.services[swapType].chainTokens != null &&\r\n                this.services[swapType].chainTokens[chainIdentifier] != null)\r\n                this.services[swapType].chainTokens[chainIdentifier].forEach(token => tokens.add(token));\r\n        });\r\n        return tokens;\r\n    }\r\n    /**\r\n     * Fetches, returns and saves the reputation of the intermediary, either for all or just for a single token\r\n     *\r\n     * @param chainIdentifier\r\n     * @param swapContract\r\n     * @param tokens\r\n     * @param abortSignal\r\n     */\r\n    async getReputation(chainIdentifier, swapContract, tokens, abortSignal) {\r\n        const checkReputationTokens = tokens == null ?\r\n            this.getSupportedTokens(chainIdentifier, [SwapType_1.SwapType.TO_BTC, SwapType_1.SwapType.TO_BTCLN]) :\r\n            new Set(tokens);\r\n        const promises = [];\r\n        const reputation = {};\r\n        for (let token of checkReputationTokens) {\r\n            promises.push((0, Utils_1.tryWithRetries)(() => swapContract.getIntermediaryReputation(this.getAddress(chainIdentifier), token), null, null, abortSignal).then(result => {\r\n                reputation[token] = result;\r\n            }));\r\n        }\r\n        await Promise.all(promises);\r\n        this.reputation ??= {};\r\n        this.reputation[chainIdentifier] ??= {};\r\n        for (let key in reputation) {\r\n            this.reputation[chainIdentifier][key] = reputation[key];\r\n        }\r\n        return reputation;\r\n    }\r\n    /**\r\n     * Fetches, returns and saves the liquidity of the intermediaryfor a specific token\r\n     *\r\n     * @param chainIdentifier\r\n     * @param swapContract\r\n     * @param token\r\n     * @param abortSignal\r\n     */\r\n    async getLiquidity(chainIdentifier, swapContract, token, abortSignal) {\r\n        const result = await (0, Utils_1.tryWithRetries)(() => swapContract.getBalance(this.getAddress(chainIdentifier), token, true), null, null, abortSignal);\r\n        this.liquidity ??= {};\r\n        this.liquidity[chainIdentifier] ??= {};\r\n        this.liquidity[chainIdentifier][token] = result;\r\n        return result;\r\n    }\r\n    supportsChain(chainIdentifier) {\r\n        if (this.addresses[chainIdentifier] == null)\r\n            return false;\r\n        return this.getSupportedTokens(chainIdentifier).size !== 0;\r\n    }\r\n    getAddress(chainIdentifier) {\r\n        return this.addresses[chainIdentifier];\r\n    }\r\n}\r\nexports.Intermediary = Intermediary;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,YAAY,GAAG,KAAK;AAC5B,MAAM;AACN,MAAM;AACN,MAAM;IA0BF,cAAc,QAAQ,EAAE,OAAO,EAAE,YAAY,EAAE;YACpC,mCAAA;QAAP,QAAO,4BAAA,IAAI,CAAC,UAAU,CAAC,SAAS,cAAzB,iDAAA,oCAAA,yBAA2B,CAAC,QAAQ,cAApC,wDAAA,iCAAsC,CAAC,aAAa;IAC/D;IACA;;;;;;KAMC,GACD,mBAAmB,eAAe,EAM/B;YANiC,eAAA,iEAAe;YAC/C,WAAW,QAAQ,CAAC,MAAM;YAC1B,WAAW,QAAQ,CAAC,QAAQ;YAC5B,WAAW,QAAQ,CAAC,QAAQ;YAC5B,WAAW,QAAQ,CAAC,UAAU;YAC9B,WAAW,QAAQ,CAAC,kBAAkB;SACzC;QACG,MAAM,YAAY,IAAI,IAAI;QAC1B,IAAI,SAAS,IAAI;QACjB,UAAU,OAAO,CAAC,CAAC;YACf,IAAI,IAAI,CAAC,QAAQ,CAAC,SAAS,IAAI,QAC3B,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,IAAI,QACvC,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,gBAAgB,IAAI,MACxD,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,WAAW,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAA,QAAS,OAAO,GAAG,CAAC;QACzF;QACA,OAAO;IACX;IACA;;;;;;;KAOC,GACD,MAAM,cAAc,eAAe,EAAE,YAAY,EAAE,MAAM,EAAE,WAAW,EAAE;YAapE,kBAAgB;QAZhB,MAAM,wBAAwB,UAAU,OACpC,IAAI,CAAC,kBAAkB,CAAC,iBAAiB;YAAC,WAAW,QAAQ,CAAC,MAAM;YAAE,WAAW,QAAQ,CAAC,QAAQ;SAAC,IACnG,IAAI,IAAI;QACZ,MAAM,WAAW,EAAE;QACnB,MAAM,aAAa,CAAC;QACpB,KAAK,IAAI,SAAS,sBAAuB;YACrC,SAAS,IAAI,CAAC,CAAC,GAAG,QAAQ,cAAc,EAAE,IAAM,aAAa,yBAAyB,CAAC,IAAI,CAAC,UAAU,CAAC,kBAAkB,QAAQ,MAAM,MAAM,aAAa,IAAI,CAAC,CAAA;gBAC3J,UAAU,CAAC,MAAM,GAAG;YACxB;QACJ;QACA,MAAM,QAAQ,GAAG,CAAC;;QAClB,qBAAA,IAAI,CAAC,2EAAL,IAAI,CAAC,aAAe,CAAC;;QACrB,MAAA,mBAAA,IAAI,CAAC,UAAU,CAAA,CAAC,mBAAA,gBAAgB,iCAAhC,gBAAe,CAAC,iBAAgB,GAAK,CAAC;QACtC,IAAK,IAAI,OAAO,WAAY;YACxB,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI;QAC3D;QACA,OAAO;IACX;IACA;;;;;;;KAOC,GACD,MAAM,aAAa,eAAe,EAAE,YAAY,EAAE,KAAK,EAAE,WAAW,EAAE;YAGlE,iBAAe;QAFf,MAAM,SAAS,MAAM,CAAC,GAAG,QAAQ,cAAc,EAAE,IAAM,aAAa,UAAU,CAAC,IAAI,CAAC,UAAU,CAAC,kBAAkB,OAAO,OAAO,MAAM,MAAM;;QAC3I,oBAAA,IAAI,CAAC,wEAAL,IAAI,CAAC,YAAc,CAAC;;QACpB,MAAA,kBAAA,IAAI,CAAC,SAAS,CAAA,CAAC,mBAAA,gBAAgB,iCAA/B,eAAc,CAAC,iBAAgB,GAAK,CAAC;QACrC,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,MAAM,GAAG;QACzC,OAAO;IACX;IACA,cAAc,eAAe,EAAE;QAC3B,IAAI,IAAI,CAAC,SAAS,CAAC,gBAAgB,IAAI,MACnC,OAAO;QACX,OAAO,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,IAAI,KAAK;IAC7D;IACA,WAAW,eAAe,EAAE;QACxB,OAAO,IAAI,CAAC,SAAS,CAAC,gBAAgB;IAC1C;IArGA,YAAY,GAAG,EAAE,SAAS,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC,CAAE;QACnD,IAAI,CAAC,UAAU,GAAG,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,CAAC;QAClB,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,UAAU,GAAG,CAAC;QACnB,IAAK,IAAI,aAAa,IAAI,CAAC,QAAQ,CAAE;YACjC,MAAM,WAAW,SAAS;YAC1B,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC,UAAU;YAC5C,MAAM,YAAY;gBAAE,KAAK,OAAO,YAAY,GAAG;gBAAG,KAAK,OAAO,YAAY,GAAG;YAAE;YAC/E,MAAM,SAAS,aAAa,WAAW,QAAQ,CAAC,MAAM,IAAI,aAAa,WAAW,QAAQ,CAAC,QAAQ;YACnG,IAAI,CAAC,UAAU,CAAC,SAAS,GAAG,CAAC;YAC7B,IAAK,IAAI,mBAAmB,YAAY,WAAW,CAAE;gBACjD,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,gBAAgB,GAAG,CAAC;gBAC9C,KAAK,IAAI,gBAAgB,YAAY,WAAW,CAAC,gBAAgB,CAAE;oBAC/D,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,gBAAgB,CAAC,aAAa,GAAG;wBACvD,OAAO,SAAS;4BAAE,KAAK;4BAAM,KAAK;wBAAK,IAAI;wBAC3C,QAAQ,CAAC,SAAS;4BAAE,KAAK;4BAAM,KAAK;wBAAK,IAAI;oBACjD;gBACJ;YACJ;QACJ;IACJ;AA8EJ;AACA,QAAQ,YAAY,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2000, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/paramcoders/SchemaVerifier.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.verifySchema = exports.verifyField = exports.isOptionalField = exports.FieldTypeEnum = exports.parseBigInt = void 0;\r\nfunction parseBigInt(str) {\r\n    if (str == null)\r\n        return null;\r\n    if (typeof (str) !== \"string\" && typeof (str) !== \"number\")\r\n        return null;\r\n    try {\r\n        return BigInt(str);\r\n    }\r\n    catch (e) {\r\n        return null;\r\n    }\r\n}\r\nexports.parseBigInt = parseBigInt;\r\nvar FieldTypeEnum;\r\n(function (FieldTypeEnum) {\r\n    FieldTypeEnum[FieldTypeEnum[\"String\"] = 0] = \"String\";\r\n    FieldTypeEnum[FieldTypeEnum[\"Boolean\"] = 1] = \"Boolean\";\r\n    FieldTypeEnum[FieldTypeEnum[\"Number\"] = 2] = \"Number\";\r\n    FieldTypeEnum[FieldTypeEnum[\"BigInt\"] = 3] = \"BigInt\";\r\n    FieldTypeEnum[FieldTypeEnum[\"Any\"] = 4] = \"Any\";\r\n    FieldTypeEnum[FieldTypeEnum[\"StringOptional\"] = 100] = \"StringOptional\";\r\n    FieldTypeEnum[FieldTypeEnum[\"BooleanOptional\"] = 101] = \"BooleanOptional\";\r\n    FieldTypeEnum[FieldTypeEnum[\"NumberOptional\"] = 102] = \"NumberOptional\";\r\n    FieldTypeEnum[FieldTypeEnum[\"BigIntOptional\"] = 103] = \"BigIntOptional\";\r\n    FieldTypeEnum[FieldTypeEnum[\"AnyOptional\"] = 104] = \"AnyOptional\";\r\n})(FieldTypeEnum = exports.FieldTypeEnum || (exports.FieldTypeEnum = {}));\r\nfunction isAllOptional(schema) {\r\n    for (let key in schema) {\r\n        if (!isOptionalField(schema[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isOptionalField(type) {\r\n    if (typeof (type) === \"function\")\r\n        return type(undefined) != null;\r\n    if (typeof (type) === \"object\")\r\n        return isAllOptional(type);\r\n    return type >= 100;\r\n}\r\nexports.isOptionalField = isOptionalField;\r\nfunction verifyField(fieldType, val) {\r\n    const type = fieldType;\r\n    if (typeof (type) === \"function\") {\r\n        const result = type(val);\r\n        if (result == null)\r\n            return;\r\n        return result;\r\n    }\r\n    if (val == null && isOptionalField(type)) {\r\n        return null;\r\n    }\r\n    if (type === FieldTypeEnum.Any || type === FieldTypeEnum.AnyOptional) {\r\n        return val;\r\n    }\r\n    else if (type === FieldTypeEnum.Boolean || type === FieldTypeEnum.BooleanOptional) {\r\n        if (typeof (val) !== \"boolean\")\r\n            return;\r\n        return val;\r\n    }\r\n    else if (type === FieldTypeEnum.Number || type === FieldTypeEnum.NumberOptional) {\r\n        if (typeof (val) !== \"number\")\r\n            return;\r\n        if (isNaN(val))\r\n            return;\r\n        return val;\r\n    }\r\n    else if (type === FieldTypeEnum.BigInt || type === FieldTypeEnum.BigIntOptional) {\r\n        const result = parseBigInt(val);\r\n        if (result == null)\r\n            return;\r\n        return result;\r\n    }\r\n    else if (type === FieldTypeEnum.String || type === FieldTypeEnum.StringOptional) {\r\n        if (typeof (val) !== \"string\")\r\n            return;\r\n        return val;\r\n    }\r\n    else {\r\n        //Probably another request schema\r\n        const result = verifySchema(val, type);\r\n        if (result == null)\r\n            return;\r\n        return result;\r\n    }\r\n}\r\nexports.verifyField = verifyField;\r\nfunction verifySchema(req, schema) {\r\n    if (req == null)\r\n        return null;\r\n    const resultSchema = {};\r\n    for (let fieldName in schema) {\r\n        const val = req[fieldName];\r\n        const type = schema[fieldName];\r\n        if (typeof (type) === \"function\") {\r\n            const result = type(val);\r\n            if (result == null)\r\n                return null;\r\n            resultSchema[fieldName] = result;\r\n            continue;\r\n        }\r\n        if (val == null && isOptionalField(type)) {\r\n            resultSchema[fieldName] = null;\r\n            continue;\r\n        }\r\n        if (type === FieldTypeEnum.Any || type === FieldTypeEnum.AnyOptional) {\r\n            resultSchema[fieldName] = val;\r\n        }\r\n        else if (type === FieldTypeEnum.Boolean || type === FieldTypeEnum.BooleanOptional) {\r\n            if (typeof (val) !== \"boolean\")\r\n                return null;\r\n            resultSchema[fieldName] = val;\r\n        }\r\n        else if (type === FieldTypeEnum.Number || type === FieldTypeEnum.NumberOptional) {\r\n            if (typeof (val) !== \"number\")\r\n                return null;\r\n            if (isNaN(val))\r\n                return null;\r\n            resultSchema[fieldName] = val;\r\n        }\r\n        else if (type === FieldTypeEnum.BigInt || type === FieldTypeEnum.BigIntOptional) {\r\n            const result = parseBigInt(val);\r\n            if (result == null)\r\n                return null;\r\n            resultSchema[fieldName] = result;\r\n        }\r\n        else if (type === FieldTypeEnum.String || type === FieldTypeEnum.StringOptional) {\r\n            if (typeof (val) !== \"string\")\r\n                return null;\r\n            resultSchema[fieldName] = val;\r\n        }\r\n        else {\r\n            //Probably another request schema\r\n            const result = verifySchema(val, type);\r\n            if (result == null)\r\n                return null;\r\n            resultSchema[fieldName] = result;\r\n        }\r\n    }\r\n    return resultSchema;\r\n}\r\nexports.verifySchema = verifySchema;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2119, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/paramcoders/ParamEncoder.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParamEncoder = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nclass ParamEncoder {\r\n    constructor(write, end) {\r\n        this.writeFN = write;\r\n        this.endFN = end;\r\n    }\r\n    /**\r\n     * Write a set of parameters to the underlying sink\r\n     *\r\n     * @param data\r\n     */\r\n    writeParams(data) {\r\n        const serialized = buffer_1.Buffer.from(JSON.stringify(data));\r\n        const frameLengthBuffer = buffer_1.Buffer.alloc(4);\r\n        frameLengthBuffer.writeUint32LE(serialized.length);\r\n        return this.writeFN(buffer_1.Buffer.concat([\r\n            frameLengthBuffer,\r\n            serialized\r\n        ]));\r\n    }\r\n    /**\r\n     * Cancels the underlying sink and encoder\r\n     */\r\n    end() {\r\n        return this.endFN();\r\n    }\r\n}\r\nexports.ParamEncoder = ParamEncoder;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,YAAY,GAAG,KAAK;AAC5B,MAAM;AACN,MAAM;IAKF;;;;KAIC,GACD,YAAY,IAAI,EAAE;QACd,MAAM,aAAa,SAAS,MAAM,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC;QACvD,MAAM,oBAAoB,SAAS,MAAM,CAAC,KAAK,CAAC;QAChD,kBAAkB,aAAa,CAAC,WAAW,MAAM;QACjD,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,MAAM,CAAC,MAAM,CAAC;YACvC;YACA;SACH;IACL;IACA;;KAEC,GACD,MAAM;QACF,OAAO,IAAI,CAAC,KAAK;IACrB;IAvBA,YAAY,KAAK,EAAE,GAAG,CAAE;QACpB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG;IACjB;AAqBJ;AACA,QAAQ,YAAY,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2153, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/paramcoders/client/StreamParamEncoder.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.StreamParamEncoder = void 0;\r\nconst ParamEncoder_1 = require(\"../ParamEncoder\");\r\nclass StreamParamEncoder extends ParamEncoder_1.ParamEncoder {\r\n    constructor() {\r\n        let stream = new TransformStream();\r\n        let writeStream = stream.writable.getWriter();\r\n        writeStream.closed.then(() => this.closed = true);\r\n        super(writeStream.write.bind(writeStream), () => {\r\n            if (this.closed)\r\n                return Promise.resolve();\r\n            this.closed = true;\r\n            return writeStream.close();\r\n        });\r\n        this.closed = false;\r\n        this.stream = stream;\r\n    }\r\n    /**\r\n     * Returns the readable stream to be passed to the fetch API\r\n     */\r\n    getReadableStream() {\r\n        return this.stream.readable;\r\n    }\r\n}\r\nexports.StreamParamEncoder = StreamParamEncoder;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,kBAAkB,GAAG,KAAK;AAClC,MAAM;AACN,MAAM,2BAA2B,eAAe,YAAY;IAcxD;;KAEC,GACD,oBAAoB;QAChB,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ;IAC/B;IAlBA,aAAc;QACV,IAAI,SAAS,IAAI;QACjB,IAAI,cAAc,OAAO,QAAQ,CAAC,SAAS;QAC3C,YAAY,MAAM,CAAC,IAAI,CAAC,IAAM,IAAI,CAAC,MAAM,GAAG;QAC5C,KAAK,CAAC,YAAY,KAAK,CAAC,IAAI,CAAC,cAAc;YACvC,IAAI,IAAI,CAAC,MAAM,EACX,OAAO,QAAQ,OAAO;YAC1B,IAAI,CAAC,MAAM,GAAG;YACd,OAAO,YAAY,KAAK;QAC5B;QACA,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;IAClB;AAOJ;AACA,QAAQ,kBAAkB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2182, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/paramcoders/ParamDecoder.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ParamDecoder = void 0;\r\nconst buffer_1 = require(\"buffer\");\r\nclass ParamDecoder {\r\n    constructor() {\r\n        this.frameHeader = null;\r\n        this.frameData = [];\r\n        this.frameDataLength = 0;\r\n        this.closed = false;\r\n        this.params = {};\r\n    }\r\n    /**\r\n     * Called when a frame is fully ready such that it can be parsed\r\n     *\r\n     * @param data Frame data\r\n     * @private\r\n     */\r\n    onFrameRead(data) {\r\n        const obj = JSON.parse(data.toString());\r\n        for (let key in obj) {\r\n            if (this.params[key] == null) {\r\n                this.params[key] = {\r\n                    promise: Promise.resolve(obj[key]),\r\n                    resolve: null,\r\n                    reject: null\r\n                };\r\n            }\r\n            else {\r\n                if (this.params[key].resolve != null) {\r\n                    this.params[key].resolve(obj[key]);\r\n                    this.params[key].resolve = null;\r\n                    this.params[key].reject = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Called when data is read from the underlying source\r\n     *\r\n     * @param data Data that has been read from the underlying source\r\n     * @protected\r\n     */\r\n    onData(data) {\r\n        let leavesBuffer = data;\r\n        while (leavesBuffer != null && leavesBuffer.length > 0) {\r\n            if (this.frameHeader == null) {\r\n                if (leavesBuffer.length <= 4) {\r\n                    this.frameHeader = leavesBuffer;\r\n                    leavesBuffer = null;\r\n                }\r\n                else {\r\n                    this.frameHeader = leavesBuffer.subarray(0, 4);\r\n                    leavesBuffer = leavesBuffer.subarray(4);\r\n                }\r\n            }\r\n            else if (this.frameHeader.length < 4) {\r\n                const requiredLen = 4 - this.frameHeader.length;\r\n                if (leavesBuffer.length <= requiredLen) {\r\n                    this.frameHeader = buffer_1.Buffer.concat([this.frameHeader, leavesBuffer]);\r\n                    leavesBuffer = null;\r\n                }\r\n                else {\r\n                    this.frameHeader = buffer_1.Buffer.concat([this.frameHeader, leavesBuffer.subarray(0, requiredLen)]);\r\n                    leavesBuffer = leavesBuffer.subarray(requiredLen);\r\n                }\r\n            }\r\n            if (leavesBuffer == null)\r\n                continue;\r\n            if (this.frameHeader == null || this.frameHeader.length < 4)\r\n                continue;\r\n            const frameLength = this.frameHeader.readUint32LE();\r\n            const requiredLen = frameLength - this.frameDataLength;\r\n            if (leavesBuffer.length <= requiredLen) {\r\n                this.frameData.push(leavesBuffer);\r\n                this.frameDataLength += leavesBuffer.length;\r\n                leavesBuffer = null;\r\n            }\r\n            else {\r\n                this.frameData.push(leavesBuffer.subarray(0, requiredLen));\r\n                this.frameDataLength += requiredLen;\r\n                leavesBuffer = leavesBuffer.subarray(requiredLen);\r\n            }\r\n            if (frameLength === this.frameDataLength) {\r\n                //Message read success\r\n                this.onFrameRead(buffer_1.Buffer.concat(this.frameData));\r\n                this.frameHeader = null;\r\n                this.frameData = [];\r\n                this.frameDataLength = 0;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Called when the underlying source ends/closes/cancels\r\n     * @protected\r\n     */\r\n    onEnd() {\r\n        for (let key in this.params) {\r\n            if (this.params[key].reject != null) {\r\n                this.params[key].reject(new Error(\"EOF before field seen!\"));\r\n            }\r\n        }\r\n        this.closed = true;\r\n    }\r\n    /**\r\n     * Called when an error happens with the underlying stream\r\n     *\r\n     * @param e Error\r\n     * @protected\r\n     */\r\n    onError(e) {\r\n        for (let key in this.params) {\r\n            if (this.params[key].reject != null) {\r\n                this.params[key].reject(e);\r\n            }\r\n        }\r\n        this.closed = true;\r\n    }\r\n    getParam(key) {\r\n        if (this.params[key] == null) {\r\n            if (this.closed)\r\n                return Promise.reject(new Error(\"Stream already closed without param received!\"));\r\n            let resolve;\r\n            let reject;\r\n            const promise = new Promise((_resolve, _reject) => {\r\n                resolve = _resolve;\r\n                reject = _reject;\r\n            });\r\n            this.params[key] = {\r\n                resolve,\r\n                reject,\r\n                promise\r\n            };\r\n        }\r\n        return this.params[key].promise;\r\n    }\r\n}\r\nexports.ParamDecoder = ParamDecoder;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2319, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/paramcoders/client/ResponseParamDecoder.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ResponseParamDecoder = void 0;\r\nconst ParamDecoder_1 = require(\"../ParamDecoder\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst Utils_1 = require(\"../../Utils\");\r\nconst logger = (0, Utils_1.getLogger)(\"ResponseParamDecoder: \");\r\nclass ResponseParamDecoder extends ParamDecoder_1.ParamDecoder {\r\n    constructor(resp, abortSignal) {\r\n        super();\r\n        this.abortSignal = abortSignal;\r\n        try {\r\n            //Read from stream\r\n            this.reader = resp.body.getReader();\r\n            this.readResponse();\r\n        }\r\n        catch (e) {\r\n            //Read in one piece\r\n            resp.arrayBuffer().then(respBuffer => {\r\n                super.onData(buffer_1.Buffer.from(respBuffer));\r\n                super.onEnd();\r\n            }).catch(e => {\r\n                super.onError(e);\r\n            });\r\n        }\r\n        if (abortSignal != null)\r\n            abortSignal.addEventListener(\"abort\", () => {\r\n                super.onError(abortSignal.reason);\r\n                if (!this.reader.closed)\r\n                    this.reader.cancel(abortSignal.reason);\r\n            });\r\n    }\r\n    /**\r\n     * Keeps reading the response until the reader closes\r\n     * @private\r\n     */\r\n    async readResponse() {\r\n        while (true) {\r\n            const readResp = await this.reader.read().catch(e => {\r\n                logger.error(\"readResponse(): Error reading response: \", e);\r\n                return null;\r\n            });\r\n            if (this.abortSignal != null && this.abortSignal.aborted)\r\n                return;\r\n            if (readResp == null || readResp.done) {\r\n                super.onEnd();\r\n                return;\r\n            }\r\n            super.onData(buffer_1.Buffer.from(readResp.value));\r\n        }\r\n    }\r\n}\r\nexports.ResponseParamDecoder = ResponseParamDecoder;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,oBAAoB,GAAG,KAAK;AACpC,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,SAAS,CAAC,GAAG,QAAQ,SAAS,EAAE;AACtC,MAAM,6BAA6B,eAAe,YAAY;IAyB1D;;;KAGC,GACD,MAAM,eAAe;QACjB,MAAO,KAAM;YACT,MAAM,WAAW,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,KAAK,CAAC,CAAA;gBAC5C,OAAO,KAAK,CAAC,4CAA4C;gBACzD,OAAO;YACX;YACA,IAAI,IAAI,CAAC,WAAW,IAAI,QAAQ,IAAI,CAAC,WAAW,CAAC,OAAO,EACpD;YACJ,IAAI,YAAY,QAAQ,SAAS,IAAI,EAAE;gBACnC,KAAK,CAAC;gBACN;YACJ;YACA,KAAK,CAAC,OAAO,SAAS,MAAM,CAAC,IAAI,CAAC,SAAS,KAAK;QACpD;IACJ;IA1CA,YAAY,IAAI,EAAE,WAAW,CAAE;QAC3B,KAAK;QACL,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI;YACA,kBAAkB;YAClB,IAAI,CAAC,MAAM,GAAG,KAAK,IAAI,CAAC,SAAS;YACjC,IAAI,CAAC,YAAY;QACrB,EACA,OAAO,GAAG;YACN,mBAAmB;YACnB,KAAK,WAAW,GAAG,IAAI,CAAC,CAAA;gBACpB,KAAK,CAAC,OAAO,SAAS,MAAM,CAAC,IAAI,CAAC;gBAClC,KAAK,CAAC;YACV,GAAG,KAAK,CAAC,CAAA;gBACL,KAAK,CAAC,QAAQ;YAClB;QACJ;QACA,IAAI,eAAe,MACf,YAAY,gBAAgB,CAAC,SAAS;YAClC,KAAK,CAAC,QAAQ,YAAY,MAAM;YAChC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EACnB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,YAAY,MAAM;QAC7C;IACR;AAoBJ;AACA,QAAQ,oBAAoB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2372, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/paramcoders/client/StreamingFetchPromise.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.streamingFetchPromise = void 0;\r\nconst SchemaVerifier_1 = require(\"../SchemaVerifier\");\r\nconst RequestError_1 = require(\"../../../errors/RequestError\");\r\nconst Utils_1 = require(\"../../Utils\");\r\nconst StreamParamEncoder_1 = require(\"./StreamParamEncoder\");\r\nconst ResponseParamDecoder_1 = require(\"./ResponseParamDecoder\");\r\nconst logger = (0, Utils_1.getLogger)(\"StreamingFetch: \");\r\n//https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests#feature_detection\r\nconst supportsRequestStreams = (() => {\r\n    try {\r\n        let duplexAccessed = false;\r\n        const request = new Request('https://example.com/', {\r\n            body: new ReadableStream(),\r\n            method: 'POST',\r\n            get duplex() {\r\n                duplexAccessed = true;\r\n                return 'half';\r\n            },\r\n        });\r\n        const hasContentType = request.headers.has('Content-Type');\r\n        return duplexAccessed && !hasContentType;\r\n    }\r\n    catch (e) {\r\n        logger.error(\"supportsRequestStreams: Error checking environment support for HTTP request stream\", e);\r\n        return false;\r\n    }\r\n})();\r\nlogger.info(\"Environment supports request stream: \" + supportsRequestStreams);\r\n/**\r\n * Sends a POST request to the specified URL in a streaming request/response mode\r\n *\r\n * @param url URL to send the request to\r\n * @param body An object containing properties that should be sent to the server, can be Promise or any\r\n * @param schema Schema of the response that should be received from the server\r\n * @param timeout Timeout in millseconds for the request to succeed & all its response properties to resolve\r\n * @param signal Abort signal\r\n * @param streamRequest Whether the request should be streamed or not\r\n * @throws {RequestError} When the response code is not 200\r\n */\r\nasync function streamingFetchPromise(url, body, schema, timeout, signal, streamRequest) {\r\n    if (streamRequest == null)\r\n        streamRequest = supportsRequestStreams;\r\n    if (timeout != null)\r\n        signal = (0, Utils_1.timeoutSignal)(timeout, new Error(\"Network request timed out\"), signal);\r\n    const init = {\r\n        method: \"POST\",\r\n        headers: {}\r\n    };\r\n    const startTime = Date.now();\r\n    const immediateValues = {};\r\n    const promises = [];\r\n    if (!streamRequest) {\r\n        for (let key in body) {\r\n            if (body[key] instanceof Promise) {\r\n                promises.push(body[key].then((val) => {\r\n                    immediateValues[key] = val;\r\n                }));\r\n            }\r\n            else {\r\n                immediateValues[key] = body[key];\r\n            }\r\n        }\r\n        try {\r\n            await Promise.all(promises);\r\n        }\r\n        catch (e) {\r\n            e._inputPromiseError = true;\r\n            throw e;\r\n        }\r\n        if (signal != null)\r\n            signal.throwIfAborted();\r\n        logger.debug(url + \": Sending request (\" + (Date.now() - startTime) + \"ms) (non-streaming): \", immediateValues);\r\n        init.body = JSON.stringify(immediateValues);\r\n        init.headers['content-type'] = \"application/json\";\r\n    }\r\n    else {\r\n        const outputStream = new StreamParamEncoder_1.StreamParamEncoder();\r\n        let hasPromiseInBody = false;\r\n        for (let key in body) {\r\n            if (body[key] instanceof Promise) {\r\n                promises.push(body[key].then((val) => {\r\n                    logger.debug(url + \": Send param (\" + (Date.now() - startTime) + \"ms) (streaming): \", { [key]: val });\r\n                    return outputStream.writeParams({\r\n                        [key]: val\r\n                    });\r\n                }));\r\n                hasPromiseInBody = true;\r\n            }\r\n            else {\r\n                immediateValues[key] = body[key];\r\n            }\r\n        }\r\n        if (hasPromiseInBody) {\r\n            init.body = outputStream.getReadableStream();\r\n            init.headers['content-type'] = \"application/x-multiple-json\";\r\n            init.duplex = \"half\";\r\n            logger.debug(url + \": Sending request (\" + (Date.now() - startTime) + \"ms) (streaming): \", immediateValues);\r\n            promises.push(outputStream.writeParams(immediateValues));\r\n            const abortController = (0, Utils_1.extendAbortController)(signal);\r\n            signal = abortController.signal;\r\n            Promise.all(promises).then(() => outputStream.end()).catch(e => {\r\n                e._inputPromiseError = true;\r\n                abortController.abort(e);\r\n            });\r\n            signal.addEventListener(\"abort\", () => outputStream.end());\r\n        }\r\n        else {\r\n            logger.debug(url + \": Sending request (\" + (Date.now() - startTime) + \"ms) (non-streaming): \", immediateValues);\r\n            init.body = JSON.stringify(immediateValues);\r\n            init.headers['content-type'] = \"application/json\";\r\n        }\r\n    }\r\n    if (signal != null)\r\n        init.signal = signal;\r\n    init.headers['accept'] = \"application/x-multiple-json\";\r\n    const resp = await fetch(url, init).catch(e => {\r\n        if (init.signal != null && e.name === \"AbortError\") {\r\n            throw init.signal.reason;\r\n        }\r\n        else {\r\n            if (e.message != null)\r\n                e.message += streamRequest ? \" (streaming req)\" : \" (non streaming req)\";\r\n            throw e;\r\n        }\r\n    });\r\n    logger.debug(url + \": Response status (\" + (Date.now() - startTime) + \"ms) \" + (streamRequest ? \"(streaming req)\" : \"(non streaming req)\") + \": \", resp.status);\r\n    if (resp.status !== 200) {\r\n        let respTxt;\r\n        try {\r\n            respTxt = await resp.text();\r\n        }\r\n        catch (e) {\r\n            throw new RequestError_1.RequestError(resp.statusText, resp.status);\r\n        }\r\n        throw new RequestError_1.RequestError(respTxt, resp.status);\r\n    }\r\n    if (resp.headers.get(\"content-type\") !== \"application/x-multiple-json\") {\r\n        const respBody = await resp.json();\r\n        logger.debug(url + \": Response read (\" + (Date.now() - startTime) + \"ms) (non streaming resp): \", respBody);\r\n        return (0, Utils_1.objectMap)(schema, (schemaValue, key) => {\r\n            const value = respBody[key];\r\n            const result = (0, SchemaVerifier_1.verifyField)(schemaValue, value);\r\n            if (result === undefined) {\r\n                return Promise.reject(new Error(\"Invalid field value\"));\r\n            }\r\n            else {\r\n                return Promise.resolve(result);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        const decoder = new ResponseParamDecoder_1.ResponseParamDecoder(resp, init.signal);\r\n        return (0, Utils_1.objectMap)(schema, (schemaValue, key) => decoder.getParam(key).catch(e => {\r\n            if ((0, SchemaVerifier_1.isOptionalField)(schemaValue))\r\n                return undefined;\r\n            throw e;\r\n        }).then(value => {\r\n            logger.debug(url + \": Response frame read (\" + (Date.now() - startTime) + \"ms) (streaming resp): \", { [key]: value });\r\n            const result = (0, SchemaVerifier_1.verifyField)(schemaValue, value);\r\n            if (result === undefined) {\r\n                return Promise.reject(new Error(\"Invalid field value\"));\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }));\r\n    }\r\n}\r\nexports.streamingFetchPromise = streamingFetchPromise;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2534, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IntermediaryAPI = exports.PaymentAuthorizationResponseCodes = exports.RefundAuthorizationResponseCodes = void 0;\r\nconst RequestError_1 = require(\"../errors/RequestError\");\r\nconst SchemaVerifier_1 = require(\"../utils/paramcoders/SchemaVerifier\");\r\nconst StreamingFetchPromise_1 = require(\"../utils/paramcoders/client/StreamingFetchPromise\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nvar RefundAuthorizationResponseCodes;\r\n(function (RefundAuthorizationResponseCodes) {\r\n    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes[\"EXPIRED\"] = 20010] = \"EXPIRED\";\r\n    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes[\"REFUND_DATA\"] = 20000] = \"REFUND_DATA\";\r\n    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes[\"NOT_FOUND\"] = 20007] = \"NOT_FOUND\";\r\n    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes[\"PENDING\"] = 20008] = \"PENDING\";\r\n    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes[\"PAID\"] = 20006] = \"PAID\";\r\n})(RefundAuthorizationResponseCodes = exports.RefundAuthorizationResponseCodes || (exports.RefundAuthorizationResponseCodes = {}));\r\nvar PaymentAuthorizationResponseCodes;\r\n(function (PaymentAuthorizationResponseCodes) {\r\n    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes[\"AUTH_DATA\"] = 10000] = \"AUTH_DATA\";\r\n    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes[\"EXPIRED\"] = 10001] = \"EXPIRED\";\r\n    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes[\"PAID\"] = 10002] = \"PAID\";\r\n    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes[\"PENDING\"] = 10003] = \"PENDING\";\r\n    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes[\"ALREADY_COMMITTED\"] = 10004] = \"ALREADY_COMMITTED\";\r\n})(PaymentAuthorizationResponseCodes = exports.PaymentAuthorizationResponseCodes || (exports.PaymentAuthorizationResponseCodes = {}));\r\nconst SwapResponseSchema = {\r\n    data: SchemaVerifier_1.FieldTypeEnum.Any,\r\n    prefix: SchemaVerifier_1.FieldTypeEnum.String,\r\n    timeout: SchemaVerifier_1.FieldTypeEnum.String,\r\n    signature: SchemaVerifier_1.FieldTypeEnum.String\r\n};\r\n/////////////////////////\r\n///// To BTC\r\nconst ToBTCResponseSchema = {\r\n    amount: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    address: SchemaVerifier_1.FieldTypeEnum.String,\r\n    satsPervByte: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    networkFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    totalFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    total: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    minRequiredExpiry: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    ...SwapResponseSchema\r\n};\r\n/////////////////////////\r\n///// To BTCLN\r\nconst ToBTCLNResponseSchema = {\r\n    maxFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    total: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    confidence: SchemaVerifier_1.FieldTypeEnum.Number,\r\n    address: SchemaVerifier_1.FieldTypeEnum.String,\r\n    routingFeeSats: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    ...SwapResponseSchema\r\n};\r\nconst ToBTCLNPrepareExactInSchema = {\r\n    amount: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    reqId: SchemaVerifier_1.FieldTypeEnum.String\r\n};\r\n/////////////////////////\r\n///// From BTC\r\nconst FromBTCResponseSchema = {\r\n    amount: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    btcAddress: SchemaVerifier_1.FieldTypeEnum.String,\r\n    address: SchemaVerifier_1.FieldTypeEnum.String,\r\n    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    total: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    confirmations: SchemaVerifier_1.FieldTypeEnum.NumberOptional,\r\n    ...SwapResponseSchema\r\n};\r\n/////////////////////////\r\n///// From BTCLN\r\nconst FromBTCLNResponseSchema = {\r\n    pr: SchemaVerifier_1.FieldTypeEnum.String,\r\n    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    total: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    intermediaryKey: SchemaVerifier_1.FieldTypeEnum.String,\r\n    securityDeposit: SchemaVerifier_1.FieldTypeEnum.BigInt\r\n};\r\n/////////////////////////\r\n///// Spv vault from BTC\r\nconst SpvFromBTCPrepareResponseSchema = {\r\n    quoteId: SchemaVerifier_1.FieldTypeEnum.String,\r\n    expiry: SchemaVerifier_1.FieldTypeEnum.Number,\r\n    address: SchemaVerifier_1.FieldTypeEnum.String,\r\n    vaultId: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    vaultBtcAddress: SchemaVerifier_1.FieldTypeEnum.String,\r\n    btcAddress: SchemaVerifier_1.FieldTypeEnum.String,\r\n    btcUtxo: SchemaVerifier_1.FieldTypeEnum.String,\r\n    btcFeeRate: SchemaVerifier_1.FieldTypeEnum.Number,\r\n    btcAmount: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    btcAmountSwap: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    btcAmountGas: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    total: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    totalGas: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    totalFeeBtc: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    swapFeeBtc: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    gasSwapFeeBtc: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    gasSwapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    callerFeeShare: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    frontingFeeShare: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    executionFeeShare: SchemaVerifier_1.FieldTypeEnum.BigInt\r\n};\r\nconst SpvFromBTCInitResponseSchema = {\r\n    txId: SchemaVerifier_1.FieldTypeEnum.String\r\n};\r\nclass IntermediaryAPI {\r\n    /**\r\n     * Returns the information about a specific intermediary\r\n     *\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     * @throws {Error} If the supplied nonce doesn't match the response\r\n     */\r\n    static async getIntermediaryInfo(baseUrl, timeout, abortSignal) {\r\n        const nonce = (0, Utils_1.randomBytes)(32).toString(\"hex\");\r\n        const response = await (0, Utils_1.httpPost)(baseUrl + \"/info\", {\r\n            nonce,\r\n        }, timeout, abortSignal);\r\n        const info = JSON.parse(response.envelope);\r\n        if (nonce !== info.nonce)\r\n            throw new Error(\"Invalid response - nonce\");\r\n        return response;\r\n    }\r\n    /**\r\n     * Returns the information about an outcome of the To BTC swap\r\n     *\r\n     * @param url URL of the intermediary\r\n     * @param paymentHash Payment hash of the swap\r\n     * @param sequence Swap's sequence number\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static async getRefundAuthorization(url, paymentHash, sequence, timeout, abortSignal) {\r\n        return (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(url + \"/getRefundAuthorization\" +\r\n            \"?paymentHash=\" + encodeURIComponent(paymentHash) +\r\n            \"&sequence=\" + encodeURIComponent(sequence.toString(10)), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);\r\n    }\r\n    /**\r\n     * Returns the information about the payment of the From BTCLN swaps\r\n     *\r\n     * @param url URL of the intermediary\r\n     * @param paymentHash Payment hash of the swap\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static async getPaymentAuthorization(url, paymentHash, timeout, abortSignal) {\r\n        return (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(url + \"/getInvoicePaymentAuth\" +\r\n            \"?paymentHash=\" + encodeURIComponent(paymentHash), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);\r\n    }\r\n    /**\r\n     * Initiate To BTC swap with an intermediary\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static initToBTC(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {\r\n        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + \"/tobtc/payInvoice?chain=\" + encodeURIComponent(chainIdentifier), {\r\n            ...init.additionalParams,\r\n            address: init.btcAddress,\r\n            amount: init.amount.toString(10),\r\n            exactIn: init.exactIn,\r\n            confirmationTarget: init.confirmationTarget,\r\n            confirmations: init.confirmations,\r\n            nonce: init.nonce.toString(10),\r\n            token: init.token,\r\n            offerer: init.offerer,\r\n            feeRate: init.feeRate\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,\r\n            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        return {\r\n            signDataPrefetch: responseBodyPromise.then(responseBody => responseBody.signDataPrefetch),\r\n            response: responseBodyPromise.then((responseBody) => Promise.all([\r\n                responseBody.code,\r\n                responseBody.msg,\r\n                responseBody.data,\r\n            ])).then(([code, msg, data]) => {\r\n                if (code !== 20000) {\r\n                    throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n                }\r\n                return (0, SchemaVerifier_1.verifySchema)(data, ToBTCResponseSchema);\r\n            })\r\n        };\r\n    }\r\n    /**\r\n     * Initiate From BTC swap with an intermediary\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param depositToken\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static initFromBTC(chainIdentifier, baseUrl, depositToken, init, timeout, abortSignal, streamRequest) {\r\n        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + \"/frombtc/getAddress?chain=\" + encodeURIComponent(chainIdentifier) + \"&depositToken=\" + encodeURIComponent(depositToken), {\r\n            ...init.additionalParams,\r\n            address: init.claimer,\r\n            amount: init.amount.toString(10),\r\n            token: init.token,\r\n            exactOut: init.exactOut,\r\n            sequence: init.sequence.toString(10),\r\n            claimerBounty: init.claimerBounty.then(claimerBounty => {\r\n                return {\r\n                    feePerBlock: claimerBounty.feePerBlock.toString(10),\r\n                    safetyFactor: claimerBounty.safetyFactor,\r\n                    startTimestamp: claimerBounty.startTimestamp.toString(10),\r\n                    addBlock: claimerBounty.addBlock,\r\n                    addFee: claimerBounty.addFee.toString(10)\r\n                };\r\n            }),\r\n            feeRate: init.feeRate\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,\r\n            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        return {\r\n            signDataPrefetch: responseBodyPromise.then(responseBody => responseBody.signDataPrefetch),\r\n            response: responseBodyPromise.then((responseBody) => Promise.all([\r\n                responseBody.code,\r\n                responseBody.msg,\r\n                responseBody.data,\r\n            ])).then(([code, msg, data]) => {\r\n                if (code !== 20000) {\r\n                    throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n                }\r\n                return (0, SchemaVerifier_1.verifySchema)(data, FromBTCResponseSchema);\r\n            })\r\n        };\r\n    }\r\n    /**\r\n     * Initiate From BTCLN swap with an intermediary\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param depositToken\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static initFromBTCLN(chainIdentifier, baseUrl, depositToken, init, timeout, abortSignal, streamRequest) {\r\n        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + \"/frombtcln/createInvoice?chain=\" + encodeURIComponent(chainIdentifier) + \"&depositToken=\" + encodeURIComponent(depositToken), {\r\n            ...init.additionalParams,\r\n            paymentHash: init.paymentHash.toString(\"hex\"),\r\n            amount: init.amount.toString(),\r\n            address: init.claimer,\r\n            token: init.token,\r\n            descriptionHash: init.descriptionHash == null ? null : init.descriptionHash.toString(\"hex\"),\r\n            exactOut: init.exactOut,\r\n            feeRate: init.feeRate\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,\r\n            lnPublicKey: SchemaVerifier_1.FieldTypeEnum.StringOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        return {\r\n            lnPublicKey: responseBodyPromise.then(responseBody => responseBody.lnPublicKey),\r\n            response: responseBodyPromise.then((responseBody) => Promise.all([\r\n                responseBody.code,\r\n                responseBody.msg,\r\n                responseBody.data,\r\n            ])).then(([code, msg, data]) => {\r\n                if (code !== 20000) {\r\n                    throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n                }\r\n                return (0, SchemaVerifier_1.verifySchema)(data, FromBTCLNResponseSchema);\r\n            })\r\n        };\r\n    }\r\n    /**\r\n     * Initiate To BTCLN swap with an intermediary\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static initToBTCLN(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {\r\n        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + \"/tobtcln/payInvoice?chain=\" + encodeURIComponent(chainIdentifier), {\r\n            exactIn: false,\r\n            ...init.additionalParams,\r\n            pr: init.pr,\r\n            maxFee: init.maxFee.toString(10),\r\n            expiryTimestamp: init.expiryTimestamp.toString(10),\r\n            token: init.token,\r\n            offerer: init.offerer,\r\n            feeRate: init.feeRate,\r\n            amount: null\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,\r\n            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        return {\r\n            signDataPrefetch: responseBodyPromise.then(responseBody => responseBody.signDataPrefetch),\r\n            response: responseBodyPromise.then((responseBody) => Promise.all([\r\n                responseBody.code,\r\n                responseBody.msg,\r\n                responseBody.data,\r\n            ])).then(([code, msg, data]) => {\r\n                if (code !== 20000) {\r\n                    throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n                }\r\n                return (0, SchemaVerifier_1.verifySchema)(data, ToBTCLNResponseSchema);\r\n            })\r\n        };\r\n    }\r\n    /**\r\n     * Initiate To BTCLN exact in swap with an intermediary\r\n     *\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static async initToBTCLNExactIn(baseUrl, init, timeout, abortSignal, streamRequest) {\r\n        const responseBody = await (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + \"/tobtcln/payInvoiceExactIn\", {\r\n            ...init.additionalParams,\r\n            pr: init.pr,\r\n            reqId: init.reqId,\r\n            feeRate: init.feeRate\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        const [code, msg, data] = await Promise.all([\r\n            responseBody.code,\r\n            responseBody.msg,\r\n            responseBody.data,\r\n        ]);\r\n        if (code !== 20000)\r\n            throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n        return (0, SchemaVerifier_1.verifySchema)(data, ToBTCLNResponseSchema);\r\n    }\r\n    /**\r\n     * Prepare To BTCLN exact in swap with an intermediary\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static prepareToBTCLNExactIn(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {\r\n        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + \"/tobtcln/payInvoice?chain=\" + encodeURIComponent(chainIdentifier), {\r\n            exactIn: true,\r\n            ...init.additionalParams,\r\n            pr: init.pr,\r\n            maxFee: init.maxFee.toString(10),\r\n            expiryTimestamp: init.expiryTimestamp.toString(10),\r\n            token: init.token,\r\n            offerer: init.offerer,\r\n            amount: init.amount.toString(10)\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,\r\n            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        return {\r\n            signDataPrefetch: responseBodyPromise.then(responseBody => responseBody.signDataPrefetch),\r\n            response: responseBodyPromise.then((responseBody) => Promise.all([\r\n                responseBody.code,\r\n                responseBody.msg,\r\n                responseBody.data,\r\n            ])).then(([code, msg, data]) => {\r\n                if (code !== 20000) {\r\n                    throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n                }\r\n                return (0, SchemaVerifier_1.verifySchema)(data, ToBTCLNPrepareExactInSchema);\r\n            })\r\n        };\r\n    }\r\n    /**\r\n     * Prepare From BTC swap via new spv vault swaps with an intermediary\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base URL of the intermediary\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static prepareSpvFromBTC(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {\r\n        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + \"/frombtc_spv/getQuote?chain=\" + encodeURIComponent(chainIdentifier), {\r\n            exactOut: init.exactOut,\r\n            ...init.additionalParams,\r\n            address: init.address,\r\n            amount: init.amount.toString(10),\r\n            token: init.token,\r\n            gasAmount: init.gasAmount.toString(10),\r\n            gasToken: init.gasToken,\r\n            frontingFeeRate: init.frontingFeeRate.toString(10),\r\n            callerFeeRate: init.callerFeeRate.then(val => val.toString(10))\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        return responseBodyPromise.then((responseBody) => Promise.all([\r\n            responseBody.code,\r\n            responseBody.msg,\r\n            responseBody.data,\r\n        ])).then(([code, msg, data]) => {\r\n            if (code !== 20000) {\r\n                throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n            }\r\n            return (0, SchemaVerifier_1.verifySchema)(data, SpvFromBTCPrepareResponseSchema);\r\n        });\r\n    }\r\n    /**\r\n     * Prepare From BTC swap via new spv vault swaps with an intermediary\r\n     *\r\n     * @param chainIdentifier\r\n     * @param url\r\n     * @param init Swap initialization parameters\r\n     * @param timeout Timeout in milliseconds for the HTTP request\r\n     * @param abortSignal\r\n     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect\r\n     *\r\n     * @throws {RequestError} If non-200 http response code is returned\r\n     */\r\n    static initSpvFromBTC(chainIdentifier, url, init, timeout, abortSignal, streamRequest) {\r\n        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(url + \"/postQuote?chain=\" + encodeURIComponent(chainIdentifier), {\r\n            quoteId: init.quoteId,\r\n            psbtHex: init.psbtHex\r\n        }, {\r\n            code: SchemaVerifier_1.FieldTypeEnum.Number,\r\n            msg: SchemaVerifier_1.FieldTypeEnum.String,\r\n            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional\r\n        }, timeout, abortSignal, streamRequest);\r\n        return responseBodyPromise.then((responseBody) => Promise.all([\r\n            responseBody.code,\r\n            responseBody.msg,\r\n            responseBody.data,\r\n        ])).then(([code, msg, data]) => {\r\n            if (code !== 20000) {\r\n                throw RequestError_1.RequestError.parse(JSON.stringify({ code, msg, data }), 400);\r\n            }\r\n            return (0, SchemaVerifier_1.verifySchema)(data, SpvFromBTCInitResponseSchema);\r\n        });\r\n    }\r\n}\r\nexports.IntermediaryAPI = IntermediaryAPI;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3045, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryDiscovery.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IntermediaryDiscovery = exports.SwapHandlerType = void 0;\r\nconst Intermediary_1 = require(\"./Intermediary\");\r\nconst SwapType_1 = require(\"../swaps/enums/SwapType\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst events_1 = require(\"events\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst IntermediaryAPI_1 = require(\"./IntermediaryAPI\");\r\nvar SwapHandlerType;\r\n(function (SwapHandlerType) {\r\n    SwapHandlerType[\"TO_BTC\"] = \"TO_BTC\";\r\n    SwapHandlerType[\"FROM_BTC\"] = \"FROM_BTC\";\r\n    SwapHandlerType[\"TO_BTCLN\"] = \"TO_BTCLN\";\r\n    SwapHandlerType[\"FROM_BTCLN\"] = \"FROM_BTCLN\";\r\n    SwapHandlerType[\"FROM_BTC_TRUSTED\"] = \"FROM_BTC_TRUSTED\";\r\n    SwapHandlerType[\"FROM_BTCLN_TRUSTED\"] = \"FROM_BTCLN_TRUSTED\";\r\n    SwapHandlerType[\"FROM_BTC_SPV\"] = \"FROM_BTC_SPV\";\r\n})(SwapHandlerType = exports.SwapHandlerType || (exports.SwapHandlerType = {}));\r\n/**\r\n * Converts SwapHandlerType (represented as string & used in REST API communication with intermediaries) to regular\r\n *  SwapType\r\n *\r\n * @param swapHandlerType\r\n */\r\nfunction swapHandlerTypeToSwapType(swapHandlerType) {\r\n    switch (swapHandlerType) {\r\n        case SwapHandlerType.FROM_BTC:\r\n            return SwapType_1.SwapType.FROM_BTC;\r\n        case SwapHandlerType.TO_BTC:\r\n            return SwapType_1.SwapType.TO_BTC;\r\n        case SwapHandlerType.FROM_BTCLN:\r\n            return SwapType_1.SwapType.FROM_BTCLN;\r\n        case SwapHandlerType.TO_BTCLN:\r\n            return SwapType_1.SwapType.TO_BTCLN;\r\n        case SwapHandlerType.FROM_BTC_TRUSTED:\r\n            return SwapType_1.SwapType.TRUSTED_FROM_BTC;\r\n        case SwapHandlerType.FROM_BTCLN_TRUSTED:\r\n            return SwapType_1.SwapType.TRUSTED_FROM_BTCLN;\r\n        case SwapHandlerType.FROM_BTC_SPV:\r\n            return SwapType_1.SwapType.SPV_VAULT_FROM_BTC;\r\n    }\r\n}\r\n/**\r\n * A default intermediary comparator, only takes to announced fee into consideration\r\n *\r\n * @param swapType\r\n * @param tokenAddress\r\n * @param swapAmount\r\n */\r\nfunction getIntermediaryComparator(swapType, tokenAddress, swapAmount) {\r\n    if (swapType === SwapType_1.SwapType.TO_BTC) {\r\n        //TODO: Also take reputation into account\r\n    }\r\n    return (a, b) => {\r\n        if (swapAmount == null) {\r\n            return a.services[swapType].swapFeePPM - b.services[swapType].swapFeePPM;\r\n        }\r\n        else {\r\n            const feeA = BigInt(a.services[swapType].swapBaseFee) + (swapAmount * BigInt(a.services[swapType].swapFeePPM) / 1000000n);\r\n            const feeB = BigInt(b.services[swapType].swapBaseFee) + (swapAmount * BigInt(b.services[swapType].swapFeePPM) / 1000000n);\r\n            return feeA - feeB > 0n ? 1 : feeA === feeB ? 0 : -1;\r\n        }\r\n    };\r\n}\r\nconst logger = (0, Utils_1.getLogger)(\"IntermediaryDiscovery: \");\r\nconst REGISTRY_URL = \"https://api.github.com/repos/adambor/SolLightning-registry/contents/registry.json?ref=main\";\r\n//To allow for legacy responses from not-yet updated LPs\r\nconst DEFAULT_CHAIN = \"SOLANA\";\r\nclass IntermediaryDiscovery extends events_1.EventEmitter {\r\n    constructor(swapContracts, registryUrl = REGISTRY_URL, nodeUrls, httpRequestTimeout) {\r\n        super();\r\n        this.intermediaries = [];\r\n        this.swapContracts = swapContracts;\r\n        this.registryUrl = registryUrl;\r\n        this.overrideNodeUrls = nodeUrls;\r\n        this.httpRequestTimeout = httpRequestTimeout;\r\n    }\r\n    /**\r\n     * Fetches the URLs of swap intermediaries from registry or from a pre-defined array of node urls\r\n     *\r\n     * @param abortSignal\r\n     */\r\n    async getIntermediaryUrls(abortSignal) {\r\n        if (this.overrideNodeUrls != null && this.overrideNodeUrls.length > 0) {\r\n            return this.overrideNodeUrls;\r\n        }\r\n        const response = await (0, Utils_1.httpGet)(this.registryUrl, this.httpRequestTimeout, abortSignal);\r\n        const content = response.content.replace(new RegExp(\"\\\\n\", \"g\"), \"\");\r\n        return JSON.parse(buffer_1.Buffer.from(content, \"base64\").toString());\r\n    }\r\n    /**\r\n     * Returns data as reported by a specific node (as identified by its URL)\r\n     *\r\n     * @param url\r\n     * @param abortSignal\r\n     */\r\n    async getNodeInfo(url, abortSignal) {\r\n        const response = await (0, Utils_1.tryWithRetries)(() => IntermediaryAPI_1.IntermediaryAPI.getIntermediaryInfo(url, this.httpRequestTimeout, abortSignal), { maxRetries: 3, delay: 100, exponential: true }, undefined, abortSignal);\r\n        const addresses = {};\r\n        for (let chain in response.chains) {\r\n            if (this.swapContracts[chain] != null) {\r\n                const { signature, address } = response.chains[chain];\r\n                try {\r\n                    await (0, Utils_1.tryWithRetries)(() => this.swapContracts[chain].isValidDataSignature(buffer_1.Buffer.from(response.envelope), signature, address), { maxRetries: 3, delay: 100, exponential: true }, base_1.SignatureVerificationError, abortSignal);\r\n                    addresses[chain] = address;\r\n                }\r\n                catch (e) {\r\n                    logger.warn(\"Failed to verify \" + chain + \" signature for intermediary: \" + url);\r\n                }\r\n            }\r\n        }\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        //Handle legacy responses\r\n        const info = JSON.parse(response.envelope);\r\n        for (let swapType in info.services) {\r\n            const serviceData = info.services[swapType];\r\n            if (serviceData.chainTokens == null)\r\n                serviceData.chainTokens = {\r\n                    [DEFAULT_CHAIN]: serviceData.tokens\r\n                };\r\n            for (let chain in serviceData.chainTokens) {\r\n                if (addresses[chain] == null)\r\n                    delete serviceData.chainTokens[chain];\r\n            }\r\n        }\r\n        return {\r\n            addresses,\r\n            info\r\n        };\r\n    }\r\n    async loadIntermediary(url, abortSignal) {\r\n        try {\r\n            const nodeInfo = await this.getNodeInfo(url, abortSignal);\r\n            const services = {};\r\n            for (let key in nodeInfo.info.services) {\r\n                services[swapHandlerTypeToSwapType(key)] = nodeInfo.info.services[key];\r\n            }\r\n            return new Intermediary_1.Intermediary(url, nodeInfo.addresses, services);\r\n        }\r\n        catch (e) {\r\n            logger.warn(\"fetchIntermediaries(): Error contacting intermediary \" + url + \": \", e);\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Fetches data about all intermediaries in the network, pinging every one of them and ensuring they are online\r\n     *\r\n     * @param abortSignal\r\n     * @private\r\n     * @throws {Error} When no online intermediary was found\r\n     */\r\n    async fetchIntermediaries(abortSignal) {\r\n        const urls = await this.getIntermediaryUrls(abortSignal);\r\n        logger.debug(\"fetchIntermediaries(): Pinging intermediaries: \", urls.join());\r\n        const promises = urls.map(url => this.loadIntermediary(url, abortSignal));\r\n        const activeNodes = (await Promise.all(promises)).filter(intermediary => intermediary != null);\r\n        if (activeNodes.length === 0)\r\n            throw new Error(\"No online intermediary found!\");\r\n        return activeNodes;\r\n    }\r\n    /**\r\n     * Returns the intermediary at the provided URL, either from the already fetched list of LPs or fetches the data on-demand\r\n     *\r\n     * @param url\r\n     */\r\n    getIntermediary(url) {\r\n        const foundLp = this.intermediaries.find(lp => lp.url === url);\r\n        if (foundLp != null)\r\n            return Promise.resolve(foundLp);\r\n        return this.loadIntermediary(url);\r\n    }\r\n    /**\r\n     * Reloads the saves a list of intermediaries\r\n     * @param abortSignal\r\n     */\r\n    async reloadIntermediaries(abortSignal) {\r\n        const fetchedIntermediaries = await (0, Utils_1.tryWithRetries)(() => this.fetchIntermediaries(abortSignal), null, null, abortSignal);\r\n        this.intermediaries = fetchedIntermediaries;\r\n        this.emit(\"added\", fetchedIntermediaries);\r\n        logger.info(\"reloadIntermediaries(): Using active intermediaries: \", fetchedIntermediaries.map(lp => lp.url).join());\r\n    }\r\n    /**\r\n     * Initializes the discovery by fetching/reloading intermediaries\r\n     *\r\n     * @param abortSignal\r\n     */\r\n    init(abortSignal) {\r\n        logger.info(\"init(): Initializing with registryUrl: \" + this.registryUrl + \" intermediary array: \" + (this.overrideNodeUrls || []).join());\r\n        return this.reloadIntermediaries(abortSignal);\r\n    }\r\n    getMultichainSwapBounds() {\r\n        const bounds = {};\r\n        this.intermediaries.forEach(intermediary => {\r\n            for (let swapType in intermediary.services) {\r\n                const swapService = intermediary.services[swapType];\r\n                bounds[swapType] ??= {};\r\n                const multichainBounds = bounds[swapType];\r\n                for (let chainId in swapService.chainTokens) {\r\n                    multichainBounds[chainId] ??= {};\r\n                    const tokenBounds = multichainBounds[chainId];\r\n                    for (let token of swapService.chainTokens[chainId]) {\r\n                        const tokenMinMax = tokenBounds[token];\r\n                        if (tokenMinMax == null) {\r\n                            tokenBounds[token] = {\r\n                                min: BigInt(swapService.min),\r\n                                max: BigInt(swapService.max)\r\n                            };\r\n                        }\r\n                        else {\r\n                            tokenMinMax.min = (0, Utils_1.bigIntMin)(tokenMinMax.min, BigInt(swapService.min));\r\n                            tokenMinMax.max = (0, Utils_1.bigIntMax)(tokenMinMax.max, BigInt(swapService.max));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Returns aggregate swap bounds (in sats - BTC) as indicated by the intermediaries\r\n     */\r\n    getSwapBounds(chainIdentifier) {\r\n        const bounds = {};\r\n        this.intermediaries.forEach(intermediary => {\r\n            for (let swapType in intermediary.services) {\r\n                const swapService = intermediary.services[swapType];\r\n                if (bounds[swapType] == null)\r\n                    bounds[swapType] = {};\r\n                const tokenBounds = bounds[swapType];\r\n                if (swapService.chainTokens != null && swapService.chainTokens[chainIdentifier] != null) {\r\n                    for (let token of swapService.chainTokens[chainIdentifier]) {\r\n                        const tokenMinMax = tokenBounds[token];\r\n                        if (tokenMinMax == null) {\r\n                            tokenBounds[token] = {\r\n                                min: BigInt(swapService.min),\r\n                                max: BigInt(swapService.max)\r\n                            };\r\n                        }\r\n                        else {\r\n                            tokenMinMax.min = (0, Utils_1.bigIntMin)(tokenMinMax.min, BigInt(swapService.min));\r\n                            tokenMinMax.max = (0, Utils_1.bigIntMax)(tokenMinMax.max, BigInt(swapService.max));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return bounds;\r\n    }\r\n    /**\r\n     * Returns the aggregate swap minimum (in sats - BTC) for a specific swap type & token\r\n     *  as indicated by the intermediaries\r\n     *\r\n     * @param chainIdentifier\r\n     * @param swapType\r\n     * @param token\r\n     */\r\n    getSwapMinimum(chainIdentifier, swapType, token) {\r\n        const tokenStr = token.toString();\r\n        return this.intermediaries.reduce((prevMin, intermediary) => {\r\n            const swapService = intermediary.services[swapType];\r\n            if (swapService != null &&\r\n                swapService.chainTokens != null &&\r\n                swapService.chainTokens[chainIdentifier] != null &&\r\n                swapService.chainTokens[chainIdentifier].includes(tokenStr))\r\n                return prevMin == null ? swapService.min : Math.min(prevMin, swapService.min);\r\n            return prevMin;\r\n        }, null);\r\n    }\r\n    /**\r\n     * Returns the aggregate swap maximum (in sats - BTC) for a specific swap type & token\r\n     *  as indicated by the intermediaries\r\n     *\r\n     * @param chainIdentifier\r\n     * @param swapType\r\n     * @param token\r\n     */\r\n    getSwapMaximum(chainIdentifier, swapType, token) {\r\n        const tokenStr = token.toString();\r\n        return this.intermediaries.reduce((prevMax, intermediary) => {\r\n            const swapService = intermediary.services[swapType];\r\n            if (swapService != null &&\r\n                swapService.chainTokens != null &&\r\n                swapService.chainTokens[chainIdentifier] != null &&\r\n                swapService.chainTokens[chainIdentifier].includes(tokenStr))\r\n                return prevMax == null ? swapService.max : Math.max(prevMax, swapService.max);\r\n            return prevMax;\r\n        }, null);\r\n    }\r\n    /**\r\n     * Returns swap candidates for a specific swap type & token address\r\n     *\r\n     * @param chainIdentifier\r\n     * @param swapType\r\n     * @param tokenAddress\r\n     * @param amount Amount to be swapped in sats - BTC\r\n     * @param count How many intermediaries to return at most\r\n     */\r\n    getSwapCandidates(chainIdentifier, swapType, tokenAddress, amount, count) {\r\n        const candidates = this.intermediaries.filter(e => {\r\n            const swapService = e.services[swapType];\r\n            if (swapService == null)\r\n                return false;\r\n            if (amount != null && amount < BigInt(swapService.min))\r\n                return false;\r\n            if (amount != null && amount > BigInt(swapService.max))\r\n                return false;\r\n            if (swapService.chainTokens == null)\r\n                return false;\r\n            if (swapService.chainTokens[chainIdentifier] == null)\r\n                return false;\r\n            if (!swapService.chainTokens[chainIdentifier].includes(tokenAddress.toString()))\r\n                return false;\r\n            return true;\r\n        });\r\n        candidates.sort(getIntermediaryComparator(swapType, tokenAddress, amount));\r\n        if (count == null) {\r\n            return candidates;\r\n        }\r\n        else {\r\n            return candidates.slice(0, count);\r\n        }\r\n    }\r\n    /**\r\n     * Removes a specific intermediary from the list of active intermediaries (used for blacklisting)\r\n     *\r\n     * @param intermediary\r\n     */\r\n    removeIntermediary(intermediary) {\r\n        const index = this.intermediaries.indexOf(intermediary);\r\n        if (index >= 0) {\r\n            logger.info(\"removeIntermediary(): Removing intermediary: \" + intermediary.url);\r\n            this.intermediaries.splice(index, 1);\r\n            this.emit(\"removed\", [intermediary]);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.IntermediaryDiscovery = IntermediaryDiscovery;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3367, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/abstract/ISwapPrice.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ISwapPrice = exports.isPriceInfoType = void 0;\r\nfunction isPriceInfoType(obj) {\r\n    return obj != null &&\r\n        typeof (obj.isValid) === \"boolean\" &&\r\n        typeof (obj.differencePPM) === \"bigint\" &&\r\n        typeof (obj.satsBaseFee) === \"bigint\" &&\r\n        typeof (obj.feePPM) === \"bigint\" &&\r\n        typeof (obj.realPriceUSatPerToken) === \"bigint\" &&\r\n        typeof (obj.swapPriceUSatPerToken) === \"bigint\";\r\n}\r\nexports.isPriceInfoType = isPriceInfoType;\r\nclass ISwapPrice {\r\n    constructor(maxAllowedFeeDifferencePPM) {\r\n        this.maxAllowedFeeDifferencePPM = maxAllowedFeeDifferencePPM;\r\n    }\r\n    /**\r\n     * Recomputes pricing info without fetching the current price\r\n     *\r\n     * @param chainIdentifier\r\n     * @param amountSats\r\n     * @param satsBaseFee\r\n     * @param feePPM\r\n     * @param paidToken\r\n     * @param token\r\n     */\r\n    recomputePriceInfoSend(chainIdentifier, amountSats, satsBaseFee, feePPM, paidToken, token) {\r\n        const totalSats = (amountSats * (1000000n + feePPM) / 1000000n)\r\n            + satsBaseFee;\r\n        const totalUSats = totalSats * 1000000n;\r\n        const swapPriceUSatPerToken = totalUSats * (10n ** BigInt(this.getDecimals(chainIdentifier, token))) / paidToken;\r\n        return {\r\n            isValid: true,\r\n            differencePPM: 0n,\r\n            satsBaseFee,\r\n            feePPM,\r\n            realPriceUSatPerToken: this.shouldIgnore(chainIdentifier, token) ? null : swapPriceUSatPerToken,\r\n            swapPriceUSatPerToken\r\n        };\r\n    }\r\n    /**\r\n     * Checks whether the swap amounts are valid given the current market rate for a given pair\r\n     *\r\n     * @param chainIdentifier\r\n     * @param amountSats Amount of sats (BTC) to be received from the swap\r\n     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary\r\n     * @param feePPM PPM fee rate as reported by the intermediary\r\n     * @param paidToken Amount of token to be paid to the swap\r\n     * @param token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice Already pre-fetched price\r\n     */\r\n    async isValidAmountSend(chainIdentifier, amountSats, satsBaseFee, feePPM, paidToken, token, abortSignal, preFetchedPrice) {\r\n        const totalSats = (amountSats * (1000000n + feePPM) / 1000000n)\r\n            + satsBaseFee;\r\n        const totalUSats = totalSats * 1000000n;\r\n        const swapPriceUSatPerToken = totalUSats * (10n ** BigInt(this.getDecimals(chainIdentifier, token))) / paidToken;\r\n        if (this.shouldIgnore(chainIdentifier, token))\r\n            return {\r\n                isValid: true,\r\n                differencePPM: 0n,\r\n                satsBaseFee,\r\n                feePPM,\r\n                realPriceUSatPerToken: null,\r\n                swapPriceUSatPerToken\r\n            };\r\n        const calculatedAmtInToken = await this.getFromBtcSwapAmount(chainIdentifier, totalSats, token, abortSignal, preFetchedPrice);\r\n        const realPriceUSatPerToken = totalUSats * (10n ** BigInt(this.getDecimals(chainIdentifier, token))) / calculatedAmtInToken;\r\n        const difference = paidToken - calculatedAmtInToken; //Will be >0 if we need to pay more than we should've\r\n        const differencePPM = difference * 1000000n / calculatedAmtInToken;\r\n        return {\r\n            isValid: differencePPM <= this.maxAllowedFeeDifferencePPM,\r\n            differencePPM,\r\n            satsBaseFee,\r\n            feePPM,\r\n            realPriceUSatPerToken,\r\n            swapPriceUSatPerToken\r\n        };\r\n    }\r\n    /**\r\n     * Recomputes pricing info without fetching the current price\r\n     *\r\n     * @param chainIdentifier\r\n     * @param amountSats\r\n     * @param satsBaseFee\r\n     * @param feePPM\r\n     * @param receiveToken\r\n     * @param token\r\n     */\r\n    recomputePriceInfoReceive(chainIdentifier, amountSats, satsBaseFee, feePPM, receiveToken, token) {\r\n        const totalSats = (amountSats * (1000000n - feePPM) / 1000000n)\r\n            - satsBaseFee;\r\n        const totalUSats = totalSats * 1000000n;\r\n        const swapPriceUSatPerToken = totalUSats * (10n ** BigInt(this.getDecimals(chainIdentifier, token))) / receiveToken;\r\n        return {\r\n            isValid: true,\r\n            differencePPM: 0n,\r\n            satsBaseFee,\r\n            feePPM,\r\n            realPriceUSatPerToken: this.shouldIgnore(chainIdentifier, token) ? null : swapPriceUSatPerToken,\r\n            swapPriceUSatPerToken\r\n        };\r\n    }\r\n    /**\r\n     * Checks whether the swap amounts are valid given the current market rate for a given pair\r\n     *\r\n     * @param chainIdentifier\r\n     * @param amountSats Amount of sats (BTC) to be paid to the swap\r\n     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary\r\n     * @param feePPM PPM fee rate as reported by the intermediary\r\n     * @param receiveToken Amount of token to be received from the swap\r\n     * @param token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice Already pre-fetched price\r\n     */\r\n    async isValidAmountReceive(chainIdentifier, amountSats, satsBaseFee, feePPM, receiveToken, token, abortSignal, preFetchedPrice) {\r\n        const totalSats = (amountSats * (1000000n - feePPM) / 1000000n)\r\n            - satsBaseFee;\r\n        const totalUSats = totalSats * 1000000n;\r\n        const swapPriceUSatPerToken = totalUSats * (10n ** BigInt(this.getDecimals(chainIdentifier, token))) / receiveToken;\r\n        if (this.shouldIgnore(chainIdentifier, token))\r\n            return {\r\n                isValid: true,\r\n                differencePPM: 0n,\r\n                satsBaseFee,\r\n                feePPM,\r\n                realPriceUSatPerToken: null,\r\n                swapPriceUSatPerToken\r\n            };\r\n        const calculatedAmtInToken = await this.getFromBtcSwapAmount(chainIdentifier, totalSats, token, abortSignal, preFetchedPrice);\r\n        const realPriceUSatPerToken = totalUSats * (10n ** BigInt(this.getDecimals(chainIdentifier, token))) / calculatedAmtInToken;\r\n        const difference = calculatedAmtInToken - receiveToken; //Will be >0 if we receive less than we should've\r\n        const differencePPM = difference * 100000n / calculatedAmtInToken;\r\n        return {\r\n            isValid: differencePPM <= this.maxAllowedFeeDifferencePPM,\r\n            differencePPM,\r\n            satsBaseFee,\r\n            feePPM,\r\n            realPriceUSatPerToken,\r\n            swapPriceUSatPerToken\r\n        };\r\n    }\r\n    preFetchPrice(chainIdentifier, token, abortSignal) {\r\n        return this.getPrice(chainIdentifier, token, abortSignal);\r\n    }\r\n    preFetchUsdPrice(abortSignal) {\r\n        return this.getUsdPrice(abortSignal);\r\n    }\r\n    /**\r\n     * Returns amount of {toToken} that are equivalent to {fromAmount} satoshis\r\n     *\r\n     * @param chainIdentifier\r\n     * @param fromAmount        Amount of satoshis\r\n     * @param toToken           Token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice\r\n     * @throws {Error} when token is not found\r\n     */\r\n    async getFromBtcSwapAmount(chainIdentifier, fromAmount, toToken, abortSignal, preFetchedPrice) {\r\n        if (this.getDecimals(chainIdentifier, toToken.toString()) == null)\r\n            throw new Error(\"Token not found!\");\r\n        const price = preFetchedPrice || await this.getPrice(chainIdentifier, toToken, abortSignal);\r\n        return fromAmount\r\n            * (10n ** BigInt(this.getDecimals(chainIdentifier, toToken.toString())))\r\n            * (1000000n) //To usat\r\n            / (price);\r\n    }\r\n    /**\r\n     * Returns amount of satoshis that are equivalent to {fromAmount} of {fromToken}\r\n     *\r\n     * @param chainIdentifier\r\n     * @param fromAmount Amount of the token\r\n     * @param fromToken Token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice Pre-fetched swap price if available\r\n     * @throws {Error} when token is not found\r\n     */\r\n    async getToBtcSwapAmount(chainIdentifier, fromAmount, fromToken, abortSignal, preFetchedPrice) {\r\n        if (this.getDecimals(chainIdentifier, fromToken.toString()) == null)\r\n            throw new Error(\"Token not found\");\r\n        const price = preFetchedPrice || await this.getPrice(chainIdentifier, fromToken, abortSignal);\r\n        return fromAmount\r\n            * price\r\n            / 1000000n\r\n            / (10n ** BigInt(this.getDecimals(chainIdentifier, fromToken.toString())));\r\n    }\r\n    /**\r\n     * Returns whether the token should be ignored and pricing for it not calculated\r\n     * @param chainIdentifier\r\n     * @param tokenAddress\r\n     * @throws {Error} if token is not found\r\n     */\r\n    shouldIgnore(chainIdentifier, tokenAddress) {\r\n        const coin = this.getDecimals(chainIdentifier, tokenAddress.toString());\r\n        if (coin == null)\r\n            throw new Error(\"Token not found\");\r\n        return coin === -1;\r\n    }\r\n    async getBtcUsdValue(btcSats, abortSignal, preFetchedPrice) {\r\n        return Number(btcSats) * (preFetchedPrice || await this.getUsdPrice(abortSignal));\r\n    }\r\n    async getTokenUsdValue(chainId, tokenAmount, token, abortSignal, preFetchedPrice) {\r\n        const [btcAmount, usdPrice] = await Promise.all([\r\n            this.getToBtcSwapAmount(chainId, tokenAmount, token, abortSignal),\r\n            preFetchedPrice == null ? this.preFetchUsdPrice(abortSignal) : Promise.resolve(preFetchedPrice)\r\n        ]);\r\n        return Number(btcAmount) * usdPrice;\r\n    }\r\n    getUsdValue(amount, token, abortSignal, preFetchedUsdPrice) {\r\n        if (token.chain === \"BTC\") {\r\n            return this.getBtcUsdValue(amount, abortSignal, preFetchedUsdPrice);\r\n        }\r\n        else {\r\n            return this.getTokenUsdValue(token.chainId, amount, token.address, abortSignal, preFetchedUsdPrice);\r\n        }\r\n    }\r\n}\r\nexports.ISwapPrice = ISwapPrice;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,UAAU,GAAG,QAAQ,eAAe,GAAG,KAAK;AACpD,SAAS,gBAAgB,GAAG;IACxB,OAAO,OAAO,QACV,OAAQ,IAAI,OAAO,KAAM,aACzB,OAAQ,IAAI,aAAa,KAAM,YAC/B,OAAQ,IAAI,WAAW,KAAM,YAC7B,OAAQ,IAAI,MAAM,KAAM,YACxB,OAAQ,IAAI,qBAAqB,KAAM,YACvC,OAAQ,IAAI,qBAAqB,KAAM;AAC/C;AACA,QAAQ,eAAe,GAAG;AAC1B,MAAM;IAIF;;;;;;;;;KASC,GACD,uBAAuB,eAAe,EAAE,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE;QACvF,MAAM,YAAY,AAAC,aAAa,CAAC,QAAQ,GAAG,MAAM,IAAI,QAAQ,GACxD;QACN,MAAM,aAAa,YAAY,QAAQ;QACvC,MAAM,wBAAwB,aAAc,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAW;QACvG,OAAO;YACH,SAAS;YACT,eAAe,EAAE;YACjB;YACA;YACA,uBAAuB,IAAI,CAAC,YAAY,CAAC,iBAAiB,SAAS,OAAO;YAC1E;QACJ;IACJ;IACA;;;;;;;;;;;KAWC,GACD,MAAM,kBAAkB,eAAe,EAAE,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE;QACtH,MAAM,YAAY,AAAC,aAAa,CAAC,QAAQ,GAAG,MAAM,IAAI,QAAQ,GACxD;QACN,MAAM,aAAa,YAAY,QAAQ;QACvC,MAAM,wBAAwB,aAAc,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAW;QACvG,IAAI,IAAI,CAAC,YAAY,CAAC,iBAAiB,QACnC,OAAO;YACH,SAAS;YACT,eAAe,EAAE;YACjB;YACA;YACA,uBAAuB;YACvB;QACJ;QACJ,MAAM,uBAAuB,MAAM,IAAI,CAAC,oBAAoB,CAAC,iBAAiB,WAAW,OAAO,aAAa;QAC7G,MAAM,wBAAwB,aAAc,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAW;QACvG,MAAM,aAAa,YAAY,sBAAsB,qDAAqD;QAC1G,MAAM,gBAAgB,aAAa,QAAQ,GAAG;QAC9C,OAAO;YACH,SAAS,iBAAiB,IAAI,CAAC,0BAA0B;YACzD;YACA;YACA;YACA;YACA;QACJ;IACJ;IACA;;;;;;;;;KASC,GACD,0BAA0B,eAAe,EAAE,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,YAAY,EAAE,KAAK,EAAE;QAC7F,MAAM,YAAY,AAAC,aAAa,CAAC,QAAQ,GAAG,MAAM,IAAI,QAAQ,GACxD;QACN,MAAM,aAAa,YAAY,QAAQ;QACvC,MAAM,wBAAwB,aAAc,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAW;QACvG,OAAO;YACH,SAAS;YACT,eAAe,EAAE;YACjB;YACA;YACA,uBAAuB,IAAI,CAAC,YAAY,CAAC,iBAAiB,SAAS,OAAO;YAC1E;QACJ;IACJ;IACA;;;;;;;;;;;KAWC,GACD,MAAM,qBAAqB,eAAe,EAAE,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,YAAY,EAAE,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE;QAC5H,MAAM,YAAY,AAAC,aAAa,CAAC,QAAQ,GAAG,MAAM,IAAI,QAAQ,GACxD;QACN,MAAM,aAAa,YAAY,QAAQ;QACvC,MAAM,wBAAwB,aAAc,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAW;QACvG,IAAI,IAAI,CAAC,YAAY,CAAC,iBAAiB,QACnC,OAAO;YACH,SAAS;YACT,eAAe,EAAE;YACjB;YACA;YACA,uBAAuB;YACvB;QACJ;QACJ,MAAM,uBAAuB,MAAM,IAAI,CAAC,oBAAoB,CAAC,iBAAiB,WAAW,OAAO,aAAa;QAC7G,MAAM,wBAAwB,aAAc,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAW;QACvG,MAAM,aAAa,uBAAuB,cAAc,iDAAiD;QACzG,MAAM,gBAAgB,aAAa,OAAO,GAAG;QAC7C,OAAO;YACH,SAAS,iBAAiB,IAAI,CAAC,0BAA0B;YACzD;YACA;YACA;YACA;YACA;QACJ;IACJ;IACA,cAAc,eAAe,EAAE,KAAK,EAAE,WAAW,EAAE;QAC/C,OAAO,IAAI,CAAC,QAAQ,CAAC,iBAAiB,OAAO;IACjD;IACA,iBAAiB,WAAW,EAAE;QAC1B,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B;IACA;;;;;;;;;KASC,GACD,MAAM,qBAAqB,eAAe,EAAE,UAAU,EAAE,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE;QAC3F,IAAI,IAAI,CAAC,WAAW,CAAC,iBAAiB,QAAQ,QAAQ,OAAO,MACzD,MAAM,IAAI,MAAM;QACpB,MAAM,QAAQ,mBAAmB,MAAM,IAAI,CAAC,QAAQ,CAAC,iBAAiB,SAAS;QAC/E,OAAO,aACA,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,QAAQ,QAAQ,OAChE,QAAQ,GACR;IACX;IACA;;;;;;;;;KASC,GACD,MAAM,mBAAmB,eAAe,EAAE,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE,eAAe,EAAE;QAC3F,IAAI,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAU,QAAQ,OAAO,MAC3D,MAAM,IAAI,MAAM;QACpB,MAAM,QAAQ,mBAAmB,MAAM,IAAI,CAAC,QAAQ,CAAC,iBAAiB,WAAW;QACjF,OAAO,aACD,QACA,QAAQ,GACP,GAAG,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,UAAU,QAAQ;IAC7E;IACA;;;;;KAKC,GACD,aAAa,eAAe,EAAE,YAAY,EAAE;QACxC,MAAM,OAAO,IAAI,CAAC,WAAW,CAAC,iBAAiB,aAAa,QAAQ;QACpE,IAAI,QAAQ,MACR,MAAM,IAAI,MAAM;QACpB,OAAO,SAAS,CAAC;IACrB;IACA,MAAM,eAAe,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE;QACxD,OAAO,OAAO,WAAW,CAAC,mBAAmB,MAAM,IAAI,CAAC,WAAW,CAAC,YAAY;IACpF;IACA,MAAM,iBAAiB,OAAO,EAAE,WAAW,EAAE,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE;QAC9E,MAAM,CAAC,WAAW,SAAS,GAAG,MAAM,QAAQ,GAAG,CAAC;YAC5C,IAAI,CAAC,kBAAkB,CAAC,SAAS,aAAa,OAAO;YACrD,mBAAmB,OAAO,IAAI,CAAC,gBAAgB,CAAC,eAAe,QAAQ,OAAO,CAAC;SAClF;QACD,OAAO,OAAO,aAAa;IAC/B;IACA,YAAY,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,kBAAkB,EAAE;QACxD,IAAI,MAAM,KAAK,KAAK,OAAO;YACvB,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,aAAa;QACpD,OACK;YACD,OAAO,IAAI,CAAC,gBAAgB,CAAC,MAAM,OAAO,EAAE,QAAQ,MAAM,OAAO,EAAE,aAAa;QACpF;IACJ;IA1MA,YAAY,0BAA0B,CAAE;QACpC,IAAI,CAAC,0BAA0B,GAAG;IACtC;AAyMJ;AACA,QAAQ,UAAU,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3562, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/abstract/ICachedSwapPrice.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ICachedSwapPrice = void 0;\r\nconst ISwapPrice_1 = require(\"./ISwapPrice\");\r\nconst DEFAULT_CACHE_DURATION = 10000;\r\nclass ICachedSwapPrice extends ISwapPrice_1.ISwapPrice {\r\n    constructor(maxAllowedFeeDiffPPM, cacheTimeout) {\r\n        super(maxAllowedFeeDiffPPM);\r\n        this.cache = {};\r\n        this.cacheTimeout = cacheTimeout || DEFAULT_CACHE_DURATION;\r\n    }\r\n    getPrice(chainIdentifier, tokenAddress, abortSignal) {\r\n        const token = tokenAddress.toString();\r\n        const chainCache = this.cache[chainIdentifier];\r\n        if (chainCache != null) {\r\n            const cachedValue = chainCache[token];\r\n            if (cachedValue != null && cachedValue.expiry > Date.now()) {\r\n                //Cache still fresh\r\n                return cachedValue.price.catch(e => this.fetchPrice(chainIdentifier, token, abortSignal));\r\n            }\r\n        }\r\n        //Refresh cache\r\n        const thisFetch = this.fetchPrice(chainIdentifier, token);\r\n        this.cache[chainIdentifier] ??= {};\r\n        this.cache[chainIdentifier][token] = {\r\n            price: thisFetch,\r\n            expiry: Date.now() + this.cacheTimeout\r\n        };\r\n        thisFetch.catch(e => {\r\n            if (this.cache[chainIdentifier] != null &&\r\n                this.cache[chainIdentifier][token] != null &&\r\n                this.cache[chainIdentifier][token].price === thisFetch)\r\n                delete this.cache[token];\r\n            throw e;\r\n        });\r\n        return thisFetch;\r\n    }\r\n    /**\r\n     * Returns BTC price in USD (sats/USD)\r\n     *\r\n     * @param abortSignal\r\n     * @throws {Error} if token is not found\r\n     */\r\n    getUsdPrice(abortSignal) {\r\n        if (this.usdCache != null && this.usdCache.expiry > Date.now()) {\r\n            //Cache still fresh\r\n            return this.usdCache.price.catch(e => this.fetchUsdPrice(abortSignal));\r\n        }\r\n        //Refresh cache\r\n        const thisFetch = this.fetchUsdPrice();\r\n        this.usdCache = {\r\n            price: thisFetch,\r\n            expiry: Date.now() + this.cacheTimeout\r\n        };\r\n        thisFetch.catch(e => {\r\n            if (this.usdCache != null &&\r\n                this.usdCache.price === thisFetch)\r\n                delete this.usdCache;\r\n            throw e;\r\n        });\r\n        return thisFetch;\r\n    }\r\n}\r\nexports.ICachedSwapPrice = ICachedSwapPrice;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,gBAAgB,GAAG,KAAK;AAChC,MAAM;AACN,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB,aAAa,UAAU;IAMlD,SAAS,eAAe,EAAE,YAAY,EAAE,WAAW,EAAE;YAYjD,aAAW;QAXX,MAAM,QAAQ,aAAa,QAAQ;QACnC,MAAM,aAAa,IAAI,CAAC,KAAK,CAAC,gBAAgB;QAC9C,IAAI,cAAc,MAAM;YACpB,MAAM,cAAc,UAAU,CAAC,MAAM;YACrC,IAAI,eAAe,QAAQ,YAAY,MAAM,GAAG,KAAK,GAAG,IAAI;gBACxD,mBAAmB;gBACnB,OAAO,YAAY,KAAK,CAAC,KAAK,CAAC,CAAA,IAAK,IAAI,CAAC,UAAU,CAAC,iBAAiB,OAAO;YAChF;QACJ;QACA,eAAe;QACf,MAAM,YAAY,IAAI,CAAC,UAAU,CAAC,iBAAiB;;QACnD,MAAA,cAAA,IAAI,CAAC,KAAK,CAAA,CAAC,mBAAA,gBAAgB,iCAA3B,WAAU,CAAC,iBAAgB,GAAK,CAAC;QACjC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAM,GAAG;YACjC,OAAO;YACP,QAAQ,KAAK,GAAG,KAAK,IAAI,CAAC,YAAY;QAC1C;QACA,UAAU,KAAK,CAAC,CAAA;YACZ,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,IAAI,QAC/B,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAM,IAAI,QACtC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,MAAM,CAAC,KAAK,KAAK,WAC7C,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM;YAC5B,MAAM;QACV;QACA,OAAO;IACX;IACA;;;;;KAKC,GACD,YAAY,WAAW,EAAE;QACrB,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,KAAK,GAAG,IAAI;YAC5D,mBAAmB;YACnB,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA,IAAK,IAAI,CAAC,aAAa,CAAC;QAC7D;QACA,eAAe;QACf,MAAM,YAAY,IAAI,CAAC,aAAa;QACpC,IAAI,CAAC,QAAQ,GAAG;YACZ,OAAO;YACP,QAAQ,KAAK,GAAG,KAAK,IAAI,CAAC,YAAY;QAC1C;QACA,UAAU,KAAK,CAAC,CAAA;YACZ,IAAI,IAAI,CAAC,QAAQ,IAAI,QACjB,IAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,WACxB,OAAO,IAAI,CAAC,QAAQ;YACxB,MAAM;QACV;QACA,OAAO;IACX;IAvDA,YAAY,oBAAoB,EAAE,YAAY,CAAE;QAC5C,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG,CAAC;QACd,IAAI,CAAC,YAAY,GAAG,gBAAgB;IACxC;AAoDJ;AACA,QAAQ,gBAAgB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3627, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/abstract/IPriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IPriceProvider = void 0;\r\nclass IPriceProvider {\r\n    constructor(coins) {\r\n        this.coinsMap = {};\r\n        for (let coinData of coins) {\r\n            if (coinData.coinId == null)\r\n                continue;\r\n            for (let chainId in coinData.chains) {\r\n                const { address, decimals } = coinData.chains[chainId];\r\n                this.coinsMap[chainId] ??= {};\r\n                this.coinsMap[chainId][address.toString()] = {\r\n                    coinId: coinData.coinId,\r\n                    decimals\r\n                };\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns coin price in uSat (microSat)\r\n     *\r\n     * @param chainIdentifier\r\n     * @param token\r\n     * @param abortSignal\r\n     * @throws {Error} if token is not found\r\n     */\r\n    getPrice(chainIdentifier, token, abortSignal) {\r\n        let tokenAddress = token.toString();\r\n        const chainTokens = this.coinsMap[chainIdentifier];\r\n        if (chainTokens == null)\r\n            throw new Error(\"Chain not found\");\r\n        const coin = chainTokens[tokenAddress];\r\n        if (coin == null)\r\n            throw new Error(\"Token not found\");\r\n        if (coin.coinId.startsWith(\"$fixed-\")) {\r\n            const amt = parseFloat(coin.coinId.substring(7));\r\n            return Promise.resolve(BigInt(Math.floor(amt * 1000000).toString(10)));\r\n        }\r\n        return this.fetchPrice(coin, abortSignal);\r\n    }\r\n    /**\r\n     * Returns coin price in uSat (microSat)\r\n     *\r\n     * @param abortSignal\r\n     * @throws {Error} if token is not found\r\n     */\r\n    getUsdPrice(abortSignal) {\r\n        return this.fetchUsdPrice(abortSignal);\r\n    }\r\n    /**\r\n     * Returns the decimal places of the specified token, or -1 if token should be ignored, returns null if\r\n     *  token is not found\r\n     *\r\n     * @param chainIdentifier\r\n     * @param token\r\n     * @protected\r\n     * @throws {Error} If token is not found\r\n     */\r\n    getDecimals(chainIdentifier, token) {\r\n        const chainTokens = this.coinsMap[chainIdentifier];\r\n        if (chainTokens == null)\r\n            throw new Error(\"Chain not found\");\r\n        const coin = chainTokens[token.toString()];\r\n        if (coin == null)\r\n            throw new Error(\"Token not found\");\r\n        return coin.coinId === \"$ignore\" ? -1 : coin.decimals;\r\n    }\r\n}\r\nexports.IPriceProvider = IPriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,cAAc,GAAG,KAAK;AAC9B,MAAM;IAgBF;;;;;;;KAOC,GACD,SAAS,eAAe,EAAE,KAAK,EAAE,WAAW,EAAE;QAC1C,IAAI,eAAe,MAAM,QAAQ;QACjC,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC,gBAAgB;QAClD,IAAI,eAAe,MACf,MAAM,IAAI,MAAM;QACpB,MAAM,OAAO,WAAW,CAAC,aAAa;QACtC,IAAI,QAAQ,MACR,MAAM,IAAI,MAAM;QACpB,IAAI,KAAK,MAAM,CAAC,UAAU,CAAC,YAAY;YACnC,MAAM,MAAM,WAAW,KAAK,MAAM,CAAC,SAAS,CAAC;YAC7C,OAAO,QAAQ,OAAO,CAAC,OAAO,KAAK,KAAK,CAAC,MAAM,SAAS,QAAQ,CAAC;QACrE;QACA,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM;IACjC;IACA;;;;;KAKC,GACD,YAAY,WAAW,EAAE;QACrB,OAAO,IAAI,CAAC,aAAa,CAAC;IAC9B;IACA;;;;;;;;KAQC,GACD,YAAY,eAAe,EAAE,KAAK,EAAE;QAChC,MAAM,cAAc,IAAI,CAAC,QAAQ,CAAC,gBAAgB;QAClD,IAAI,eAAe,MACf,MAAM,IAAI,MAAM;QACpB,MAAM,OAAO,WAAW,CAAC,MAAM,QAAQ,GAAG;QAC1C,IAAI,QAAQ,MACR,MAAM,IAAI,MAAM;QACpB,OAAO,KAAK,MAAM,KAAK,YAAY,CAAC,IAAI,KAAK,QAAQ;IACzD;IA/DA,YAAY,KAAK,CAAE;QACf,IAAI,CAAC,QAAQ,GAAG,CAAC;QACjB,KAAK,IAAI,YAAY,MAAO;YACxB,IAAI,SAAS,MAAM,IAAI,MACnB;YACJ,IAAK,IAAI,WAAW,SAAS,MAAM,CAAE;oBAEjC,gBAAc;gBADd,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAG,SAAS,MAAM,CAAC,QAAQ;;gBACtD,MAAA,iBAAA,IAAI,CAAC,QAAQ,CAAA,CAAC,WAAA,QAAQ,iCAAtB,cAAa,CAAC,SAAQ,GAAK,CAAC;gBAC5B,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,QAAQ,GAAG,GAAG;oBACzC,QAAQ,SAAS,MAAM;oBACvB;gBACJ;YACJ;QACJ;IACJ;AAkDJ;AACA,QAAQ,cAAc,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3696, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/abstract/HttpPriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HttpPriceProvider = void 0;\r\nconst IPriceProvider_1 = require(\"../../abstract/IPriceProvider\");\r\nclass HttpPriceProvider extends IPriceProvider_1.IPriceProvider {\r\n    constructor(coinsMap, url, httpRequestTimeout) {\r\n        super(coinsMap);\r\n        this.url = url;\r\n        this.httpRequestTimeout = httpRequestTimeout;\r\n    }\r\n}\r\nexports.HttpPriceProvider = HttpPriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,iBAAiB,GAAG,KAAK;AACjC,MAAM;AACN,MAAM,0BAA0B,iBAAiB,cAAc;IAC3D,YAAY,QAAQ,EAAE,GAAG,EAAE,kBAAkB,CAAE;QAC3C,KAAK,CAAC;QACN,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,kBAAkB,GAAG;IAC9B;AACJ;AACA,QAAQ,iBAAiB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3713, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/abstract/ExchangePriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ExchangePriceProvider = void 0;\r\nconst HttpPriceProvider_1 = require(\"./HttpPriceProvider\");\r\nclass ExchangePriceProvider extends HttpPriceProvider_1.HttpPriceProvider {\r\n    async fetchPrice(token, abortSignal) {\r\n        const pairs = token.coinId.split(\";\");\r\n        const prices = await Promise.all(pairs.map(pair => {\r\n            let invert = pair.startsWith(\"!\");\r\n            if (invert)\r\n                pair = pair.substring(1);\r\n            return this.fetchPair(pair, abortSignal).then(value => invert ? 1 / value : value);\r\n        }));\r\n        const price = prices.reduce((previousValue, currentValue) => previousValue * currentValue, 1);\r\n        return BigInt(Math.floor(price * 100000000000000));\r\n    }\r\n}\r\nexports.ExchangePriceProvider = ExchangePriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,qBAAqB,GAAG,KAAK;AACrC,MAAM;AACN,MAAM,8BAA8B,oBAAoB,iBAAiB;IACrE,MAAM,WAAW,KAAK,EAAE,WAAW,EAAE;QACjC,MAAM,QAAQ,MAAM,MAAM,CAAC,KAAK,CAAC;QACjC,MAAM,SAAS,MAAM,QAAQ,GAAG,CAAC,MAAM,GAAG,CAAC,CAAA;YACvC,IAAI,SAAS,KAAK,UAAU,CAAC;YAC7B,IAAI,QACA,OAAO,KAAK,SAAS,CAAC;YAC1B,OAAO,IAAI,CAAC,SAAS,CAAC,MAAM,aAAa,IAAI,CAAC,CAAA,QAAS,SAAS,IAAI,QAAQ;QAChF;QACA,MAAM,QAAQ,OAAO,MAAM,CAAC,CAAC,eAAe,eAAiB,gBAAgB,cAAc;QAC3F,OAAO,OAAO,KAAK,KAAK,CAAC,QAAQ;IACrC;AACJ;AACA,QAAQ,qBAAqB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3735, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/BinancePriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.BinancePriceProvider = void 0;\r\nconst ExchangePriceProvider_1 = require(\"./abstract/ExchangePriceProvider\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nclass BinancePriceProvider extends ExchangePriceProvider_1.ExchangePriceProvider {\r\n    constructor(coinsMap, url = \"https://api.binance.com/api/v3\", httpRequestTimeout) {\r\n        super(coinsMap, url, httpRequestTimeout);\r\n    }\r\n    async fetchPair(pair, abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/ticker/price?symbol=\" + pair, this.httpRequestTimeout, abortSignal);\r\n        return parseFloat(response.price);\r\n    }\r\n    async fetchUsdPrice(abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/ticker/price?symbol=BTCUSDC\", this.httpRequestTimeout, abortSignal);\r\n        return parseFloat(response.price) / 100000000;\r\n    }\r\n}\r\nexports.BinancePriceProvider = BinancePriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,oBAAoB,GAAG,KAAK;AACpC,MAAM;AACN,MAAM;AACN,MAAM,6BAA6B,wBAAwB,qBAAqB;IAI5E,MAAM,UAAU,IAAI,EAAE,WAAW,EAAE;QAC/B,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,0BAA0B,MAAM,IAAI,CAAC,kBAAkB,EAAE;QAChH,OAAO,WAAW,SAAS,KAAK;IACpC;IACA,MAAM,cAAc,WAAW,EAAE;QAC7B,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,gCAAgC,IAAI,CAAC,kBAAkB,EAAE;QAChH,OAAO,WAAW,SAAS,KAAK,IAAI;IACxC;IAVA,YAAY,QAAQ,EAAE,MAAM,gCAAgC,EAAE,kBAAkB,CAAE;QAC9E,KAAK,CAAC,UAAU,KAAK;IACzB;AASJ;AACA,QAAQ,oBAAoB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3759, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/CoinGeckoPriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CoinGeckoPriceProvider = void 0;\r\nconst HttpPriceProvider_1 = require(\"./abstract/HttpPriceProvider\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nclass CoinGeckoPriceProvider extends HttpPriceProvider_1.HttpPriceProvider {\r\n    constructor(coinsMap, url = \"https://api.coingecko.com/api/v3\", httpRequestTimeout) {\r\n        super(coinsMap, url, httpRequestTimeout);\r\n    }\r\n    async fetchPrice(token, abortSignal) {\r\n        let response = await (0, Utils_1.httpGet)(this.url + \"/simple/price?ids=\" + token.coinId + \"&vs_currencies=sats&precision=6\", this.httpRequestTimeout, abortSignal);\r\n        return BigInt(response[token.coinId].sats * 1000000);\r\n    }\r\n    async fetchUsdPrice(abortSignal) {\r\n        let response = await (0, Utils_1.httpGet)(this.url + \"/simple/price?ids=bitcoin&vs_currencies=usd&precision=9\", this.httpRequestTimeout, abortSignal);\r\n        return response[\"bitcoin\"].usd / 100000000;\r\n    }\r\n}\r\nexports.CoinGeckoPriceProvider = CoinGeckoPriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,sBAAsB,GAAG,KAAK;AACtC,MAAM;AACN,MAAM;AACN,MAAM,+BAA+B,oBAAoB,iBAAiB;IAItE,MAAM,WAAW,KAAK,EAAE,WAAW,EAAE;QACjC,IAAI,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,uBAAuB,MAAM,MAAM,GAAG,mCAAmC,IAAI,CAAC,kBAAkB,EAAE;QACvJ,OAAO,OAAO,QAAQ,CAAC,MAAM,MAAM,CAAC,CAAC,IAAI,GAAG;IAChD;IACA,MAAM,cAAc,WAAW,EAAE;QAC7B,IAAI,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,2DAA2D,IAAI,CAAC,kBAAkB,EAAE;QACzI,OAAO,QAAQ,CAAC,UAAU,CAAC,GAAG,GAAG;IACrC;IAVA,YAAY,QAAQ,EAAE,MAAM,kCAAkC,EAAE,kBAAkB,CAAE;QAChF,KAAK,CAAC,UAAU,KAAK;IACzB;AASJ;AACA,QAAQ,sBAAsB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3783, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/CoinPaprikaPriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CoinPaprikaPriceProvider = void 0;\r\nconst HttpPriceProvider_1 = require(\"./abstract/HttpPriceProvider\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nclass CoinPaprikaPriceProvider extends HttpPriceProvider_1.HttpPriceProvider {\r\n    constructor(coinsMap, url = \"https://api.coinpaprika.com/v1\", httpRequestTimeout) {\r\n        super(coinsMap, url, httpRequestTimeout);\r\n    }\r\n    async fetchPrice(token, abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/tickers/\" + token.coinId + \"?quotes=BTC\", this.httpRequestTimeout, abortSignal);\r\n        return BigInt(Math.floor(response.quotes.BTC.price * 100000000000000));\r\n    }\r\n    async fetchUsdPrice(abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/tickers/btc-bitcoin?quotes=USD\", this.httpRequestTimeout, abortSignal);\r\n        return response.quotes.USD.price / 100000000;\r\n    }\r\n}\r\nexports.CoinPaprikaPriceProvider = CoinPaprikaPriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,wBAAwB,GAAG,KAAK;AACxC,MAAM;AACN,MAAM;AACN,MAAM,iCAAiC,oBAAoB,iBAAiB;IAIxE,MAAM,WAAW,KAAK,EAAE,WAAW,EAAE;QACjC,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,cAAc,MAAM,MAAM,GAAG,eAAe,IAAI,CAAC,kBAAkB,EAAE;QAC5H,OAAO,OAAO,KAAK,KAAK,CAAC,SAAS,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG;IACzD;IACA,MAAM,cAAc,WAAW,EAAE;QAC7B,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,mCAAmC,IAAI,CAAC,kBAAkB,EAAE;QACnH,OAAO,SAAS,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG;IACvC;IAVA,YAAY,QAAQ,EAAE,MAAM,gCAAgC,EAAE,kBAAkB,CAAE;QAC9E,KAAK,CAAC,UAAU,KAAK;IACzB;AASJ;AACA,QAAQ,wBAAwB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3807, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/OKXPriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OKXPriceProvider = void 0;\r\nconst ExchangePriceProvider_1 = require(\"./abstract/ExchangePriceProvider\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nclass OKXPriceProvider extends ExchangePriceProvider_1.ExchangePriceProvider {\r\n    constructor(coinsMap, url = \"https://www.okx.com/api/v5\", httpRequestTimeout) {\r\n        super(coinsMap, url, httpRequestTimeout);\r\n    }\r\n    async fetchPair(pair, abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/market/index-tickers?instId=\" + pair, this.httpRequestTimeout, abortSignal);\r\n        return parseFloat(response.data[0].idxPx);\r\n    }\r\n    async fetchUsdPrice(abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/market/index-tickers?instId=BTC-USD\", this.httpRequestTimeout, abortSignal);\r\n        return parseFloat(response.data[0].idxPx) / 100000000;\r\n    }\r\n}\r\nexports.OKXPriceProvider = OKXPriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,gBAAgB,GAAG,KAAK;AAChC,MAAM;AACN,MAAM;AACN,MAAM,yBAAyB,wBAAwB,qBAAqB;IAIxE,MAAM,UAAU,IAAI,EAAE,WAAW,EAAE;QAC/B,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,kCAAkC,MAAM,IAAI,CAAC,kBAAkB,EAAE;QACxH,OAAO,WAAW,SAAS,IAAI,CAAC,EAAE,CAAC,KAAK;IAC5C;IACA,MAAM,cAAc,WAAW,EAAE;QAC7B,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,wCAAwC,IAAI,CAAC,kBAAkB,EAAE;QACxH,OAAO,WAAW,SAAS,IAAI,CAAC,EAAE,CAAC,KAAK,IAAI;IAChD;IAVA,YAAY,QAAQ,EAAE,MAAM,4BAA4B,EAAE,kBAAkB,CAAE;QAC1E,KAAK,CAAC,UAAU,KAAK;IACzB;AASJ;AACA,QAAQ,gBAAgB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3831, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/CustomPriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CustomPriceProvider = void 0;\r\nconst IPriceProvider_1 = require(\"../abstract/IPriceProvider\");\r\nclass CustomPriceProvider extends IPriceProvider_1.IPriceProvider {\r\n    constructor(coinsMap, getUsdPriceFn) {\r\n        super(coinsMap);\r\n        this.getUsdPriceFn = getUsdPriceFn;\r\n    }\r\n    async fetchPrice(token, abortSignal) {\r\n        const [btcPrice, tokenPrice] = await this.getUsdPriceFn([\"BTC\", token.coinId], abortSignal);\r\n        const priceInBtc = tokenPrice / btcPrice;\r\n        return BigInt(Math.floor(priceInBtc * 100000000 * 1000000));\r\n    }\r\n    async fetchUsdPrice(abortSignal) {\r\n        const [btcPrice] = await this.getUsdPriceFn([\"BTC\"], abortSignal);\r\n        return btcPrice / 100000000;\r\n    }\r\n}\r\nexports.CustomPriceProvider = CustomPriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,mBAAmB,GAAG,KAAK;AACnC,MAAM;AACN,MAAM,4BAA4B,iBAAiB,cAAc;IAK7D,MAAM,WAAW,KAAK,EAAE,WAAW,EAAE;QACjC,MAAM,CAAC,UAAU,WAAW,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC;YAAC;YAAO,MAAM,MAAM;SAAC,EAAE;QAC/E,MAAM,aAAa,aAAa;QAChC,OAAO,OAAO,KAAK,KAAK,CAAC,aAAa,YAAY;IACtD;IACA,MAAM,cAAc,WAAW,EAAE;QAC7B,MAAM,CAAC,SAAS,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC;YAAC;SAAM,EAAE;QACrD,OAAO,WAAW;IACtB;IAZA,YAAY,QAAQ,EAAE,aAAa,CAAE;QACjC,KAAK,CAAC;QACN,IAAI,CAAC,aAAa,GAAG;IACzB;AAUJ;AACA,QAAQ,mBAAmB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3861, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/providers/KrakenPriceProvider.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.KrakenPriceProvider = void 0;\r\nconst ExchangePriceProvider_1 = require(\"./abstract/ExchangePriceProvider\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nclass KrakenPriceProvider extends ExchangePriceProvider_1.ExchangePriceProvider {\r\n    constructor(coinsMap, url = \"https://api.kraken.com/0\", httpRequestTimeout) {\r\n        super(coinsMap, url, httpRequestTimeout);\r\n    }\r\n    async fetchPair(pair, abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/public/Ticker?pair=\" + pair, this.httpRequestTimeout, abortSignal);\r\n        return parseFloat(response.result[pair].c[0]);\r\n    }\r\n    async fetchUsdPrice(abortSignal) {\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/public/Ticker?pair=XBTUSDC\", this.httpRequestTimeout, abortSignal);\r\n        return parseFloat(response.result[\"XBTUSDC\"].c[0]) / 100000000;\r\n    }\r\n    async fetchPrice(token, abortSignal) {\r\n        const pairs = token.coinId.split(\";\");\r\n        const response = await (0, Utils_1.httpGet)(this.url + \"/public/Ticker?pair=\" + pairs.map(val => val.startsWith(\"!\") ? val.substring(1) : val).join(\",\"), this.httpRequestTimeout, abortSignal);\r\n        const prices = pairs.map(pair => {\r\n            let invert = pair.startsWith(\"!\");\r\n            if (invert)\r\n                pair = pair.substring(1);\r\n            const value = parseFloat(response.result[pair].c[0]);\r\n            return invert ? 1 / value : value;\r\n        });\r\n        const price = prices.reduce((previousValue, currentValue) => previousValue * currentValue, 1);\r\n        return BigInt(Math.floor(price * 100000000000000));\r\n    }\r\n}\r\nexports.KrakenPriceProvider = KrakenPriceProvider;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,mBAAmB,GAAG,KAAK;AACnC,MAAM;AACN,MAAM;AACN,MAAM,4BAA4B,wBAAwB,qBAAqB;IAI3E,MAAM,UAAU,IAAI,EAAE,WAAW,EAAE;QAC/B,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,yBAAyB,MAAM,IAAI,CAAC,kBAAkB,EAAE;QAC/G,OAAO,WAAW,SAAS,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;IAChD;IACA,MAAM,cAAc,WAAW,EAAE;QAC7B,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,+BAA+B,IAAI,CAAC,kBAAkB,EAAE;QAC/G,OAAO,WAAW,SAAS,MAAM,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,IAAI;IACzD;IACA,MAAM,WAAW,KAAK,EAAE,WAAW,EAAE;QACjC,MAAM,QAAQ,MAAM,MAAM,CAAC,KAAK,CAAC;QACjC,MAAM,WAAW,MAAM,CAAC,GAAG,QAAQ,OAAO,EAAE,IAAI,CAAC,GAAG,GAAG,yBAAyB,MAAM,GAAG,CAAC,CAAA,MAAO,IAAI,UAAU,CAAC,OAAO,IAAI,SAAS,CAAC,KAAK,KAAK,IAAI,CAAC,MAAM,IAAI,CAAC,kBAAkB,EAAE;QACnL,MAAM,SAAS,MAAM,GAAG,CAAC,CAAA;YACrB,IAAI,SAAS,KAAK,UAAU,CAAC;YAC7B,IAAI,QACA,OAAO,KAAK,SAAS,CAAC;YAC1B,MAAM,QAAQ,WAAW,SAAS,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE;YACnD,OAAO,SAAS,IAAI,QAAQ;QAChC;QACA,MAAM,QAAQ,OAAO,MAAM,CAAC,CAAC,eAAe,eAAiB,gBAAgB,cAAc;QAC3F,OAAO,OAAO,KAAK,KAAK,CAAC,QAAQ;IACrC;IAvBA,YAAY,QAAQ,EAAE,MAAM,0BAA0B,EAAE,kBAAkB,CAAE;QACxE,KAAK,CAAC,UAAU,KAAK;IACzB;AAsBJ;AACA,QAAQ,mBAAmB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3897, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/RedundantSwapPrice.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RedundantSwapPrice = void 0;\r\nconst BinancePriceProvider_1 = require(\"./providers/BinancePriceProvider\");\r\nconst OKXPriceProvider_1 = require(\"./providers/OKXPriceProvider\");\r\nconst CoinGeckoPriceProvider_1 = require(\"./providers/CoinGeckoPriceProvider\");\r\nconst CoinPaprikaPriceProvider_1 = require(\"./providers/CoinPaprikaPriceProvider\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst ICachedSwapPrice_1 = require(\"./abstract/ICachedSwapPrice\");\r\nconst RequestError_1 = require(\"../errors/RequestError\");\r\nconst KrakenPriceProvider_1 = require(\"./providers/KrakenPriceProvider\");\r\nconst logger = (0, Utils_1.getLogger)(\"RedundantSwapPrice: \");\r\n/**\r\n * Swap price API using multiple price sources, handles errors on the APIs and automatically switches between them, such\r\n *  that there always is a functional API\r\n */\r\nclass RedundantSwapPrice extends ICachedSwapPrice_1.ICachedSwapPrice {\r\n    static createFromTokenMap(maxAllowedFeeDiffPPM, assets, cacheTimeout) {\r\n        const priceApis = [\r\n            new BinancePriceProvider_1.BinancePriceProvider(assets.map(coinData => {\r\n                return {\r\n                    coinId: coinData.binancePair,\r\n                    chains: coinData.chains\r\n                };\r\n            })),\r\n            new OKXPriceProvider_1.OKXPriceProvider(assets.map(coinData => {\r\n                return {\r\n                    coinId: coinData.okxPair,\r\n                    chains: coinData.chains\r\n                };\r\n            })),\r\n            new CoinGeckoPriceProvider_1.CoinGeckoPriceProvider(assets.map(coinData => {\r\n                return {\r\n                    coinId: coinData.coinGeckoCoinId,\r\n                    chains: coinData.chains\r\n                };\r\n            })),\r\n            new CoinPaprikaPriceProvider_1.CoinPaprikaPriceProvider(assets.map(coinData => {\r\n                return {\r\n                    coinId: coinData.coinPaprikaCoinId,\r\n                    chains: coinData.chains\r\n                };\r\n            })),\r\n            new KrakenPriceProvider_1.KrakenPriceProvider(assets.map(coinData => {\r\n                return {\r\n                    coinId: coinData.krakenPair,\r\n                    chains: coinData.chains\r\n                };\r\n            }))\r\n        ];\r\n        return new RedundantSwapPrice(maxAllowedFeeDiffPPM, assets, priceApis, cacheTimeout);\r\n    }\r\n    constructor(maxAllowedFeeDiffPPM, coinsDecimals, priceApis, cacheTimeout) {\r\n        super(maxAllowedFeeDiffPPM, cacheTimeout);\r\n        this.coinsDecimals = {};\r\n        for (let coinData of coinsDecimals) {\r\n            for (let chainId in coinData.chains) {\r\n                const { address, decimals } = coinData.chains[chainId];\r\n                this.coinsDecimals[chainId] ??= {};\r\n                this.coinsDecimals[chainId][address.toString()] = decimals;\r\n            }\r\n        }\r\n        this.priceApis = priceApis.map(api => {\r\n            return {\r\n                priceApi: api,\r\n                operational: null\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Returns price api that should be operational\r\n     *\r\n     * @private\r\n     */\r\n    getOperationalPriceApi() {\r\n        return this.priceApis.find(e => e.operational === true);\r\n    }\r\n    /**\r\n     * Returns price apis that are maybe operational, in case none is considered operational returns all of the price\r\n     *  apis such that they can be tested again whether they are operational\r\n     *\r\n     * @private\r\n     */\r\n    getMaybeOperationalPriceApis() {\r\n        let operational = this.priceApis.filter(e => e.operational === true || e.operational === null);\r\n        if (operational.length === 0) {\r\n            this.priceApis.forEach(e => e.operational = null);\r\n            operational = this.priceApis;\r\n        }\r\n        return operational;\r\n    }\r\n    /**\r\n     * Fetches price in parallel from multiple maybe operational price APIs\r\n     *\r\n     * @param chainIdentifier\r\n     * @param token\r\n     * @param abortSignal\r\n     * @private\r\n     */\r\n    async fetchPriceFromMaybeOperationalPriceApis(chainIdentifier, token, abortSignal) {\r\n        try {\r\n            return await (0, Utils_1.promiseAny)(this.getMaybeOperationalPriceApis().map(obj => (async () => {\r\n                try {\r\n                    const price = await obj.priceApi.getPrice(chainIdentifier, token, abortSignal);\r\n                    logger.debug(\"fetchPrice(): Price from \" + obj.priceApi.constructor.name + \": \", price.toString(10));\r\n                    obj.operational = true;\r\n                    return price;\r\n                }\r\n                catch (e) {\r\n                    if (abortSignal != null)\r\n                        abortSignal.throwIfAborted();\r\n                    obj.operational = false;\r\n                    throw e;\r\n                }\r\n            })()));\r\n        }\r\n        catch (e) {\r\n            if (abortSignal != null)\r\n                abortSignal.throwIfAborted();\r\n            throw e.find(err => !(err instanceof RequestError_1.RequestError)) || e[0];\r\n        }\r\n    }\r\n    /**\r\n     * Fetches the prices, first tries to use the operational price API (if any) and if that fails it falls back\r\n     *  to using maybe operational price APIs\r\n     *\r\n     * @param chainIdentifier\r\n     * @param token\r\n     * @param abortSignal\r\n     * @private\r\n     */\r\n    fetchPrice(chainIdentifier, token, abortSignal) {\r\n        return (0, Utils_1.tryWithRetries)(async () => {\r\n            const operationalPriceApi = this.getOperationalPriceApi();\r\n            if (operationalPriceApi != null) {\r\n                try {\r\n                    return await operationalPriceApi.priceApi.getPrice(chainIdentifier, token, abortSignal);\r\n                }\r\n                catch (err) {\r\n                    if (abortSignal != null)\r\n                        abortSignal.throwIfAborted();\r\n                    operationalPriceApi.operational = false;\r\n                    return await this.fetchPriceFromMaybeOperationalPriceApis(chainIdentifier, token, abortSignal);\r\n                }\r\n            }\r\n            return await this.fetchPriceFromMaybeOperationalPriceApis(chainIdentifier, token, abortSignal);\r\n        }, null, RequestError_1.RequestError, abortSignal);\r\n    }\r\n    getDecimals(chainIdentifier, token) {\r\n        if (this.coinsDecimals[chainIdentifier] == null)\r\n            return null;\r\n        return this.coinsDecimals[chainIdentifier][token.toString()];\r\n    }\r\n    /**\r\n     * Fetches BTC price in USD in parallel from multiple maybe operational price APIs\r\n     *\r\n     * @param abortSignal\r\n     * @private\r\n     */\r\n    async fetchUsdPriceFromMaybeOperationalPriceApis(abortSignal) {\r\n        try {\r\n            return await (0, Utils_1.promiseAny)(this.getMaybeOperationalPriceApis().map(obj => (async () => {\r\n                try {\r\n                    const price = await obj.priceApi.getUsdPrice(abortSignal);\r\n                    logger.debug(\"fetchPrice(): USD price from \" + obj.priceApi.constructor.name + \": \", price.toString(10));\r\n                    obj.operational = true;\r\n                    return price;\r\n                }\r\n                catch (e) {\r\n                    if (abortSignal != null)\r\n                        abortSignal.throwIfAborted();\r\n                    obj.operational = false;\r\n                    throw e;\r\n                }\r\n            })()));\r\n        }\r\n        catch (e) {\r\n            if (abortSignal != null)\r\n                abortSignal.throwIfAborted();\r\n            throw e.find(err => !(err instanceof RequestError_1.RequestError)) || e[0];\r\n        }\r\n    }\r\n    fetchUsdPrice(abortSignal) {\r\n        return (0, Utils_1.tryWithRetries)(() => {\r\n            const operationalPriceApi = this.getOperationalPriceApi();\r\n            if (operationalPriceApi != null) {\r\n                return operationalPriceApi.priceApi.getUsdPrice(abortSignal).catch(err => {\r\n                    if (abortSignal != null)\r\n                        abortSignal.throwIfAborted();\r\n                    operationalPriceApi.operational = false;\r\n                    return this.fetchUsdPriceFromMaybeOperationalPriceApis(abortSignal);\r\n                });\r\n            }\r\n            return this.fetchUsdPriceFromMaybeOperationalPriceApis(abortSignal);\r\n        }, null, RequestError_1.RequestError, abortSignal);\r\n    }\r\n}\r\nexports.RedundantSwapPrice = RedundantSwapPrice;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4084, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/SingleSwapPrice.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SingleSwapPrice = void 0;\r\nconst ICachedSwapPrice_1 = require(\"./abstract/ICachedSwapPrice\");\r\n/**\r\n * Swap price API using single price source\r\n */\r\nclass SingleSwapPrice extends ICachedSwapPrice_1.ICachedSwapPrice {\r\n    constructor(maxAllowedFeeDiffPPM, priceProvider, cacheTimeout) {\r\n        super(maxAllowedFeeDiffPPM, cacheTimeout);\r\n        this.priceProvider = priceProvider;\r\n    }\r\n    /**\r\n     * Fetch price in uSats (micro sats) for a given token against BTC\r\n     *\r\n     * @param chainIdentifier\r\n     * @param token\r\n     * @param abortSignal\r\n     * @protected\r\n     * @returns token price in uSats (micro sats)\r\n     */\r\n    fetchPrice(chainIdentifier, token, abortSignal) {\r\n        return this.priceProvider.getPrice(chainIdentifier, token, abortSignal);\r\n    }\r\n    /**\r\n     * Returns the decimal places of the specified token, or -1 if token should be ignored, returns null if\r\n     *  token is not found\r\n     *\r\n     * @param chainIdentifier\r\n     * @param token\r\n     * @protected\r\n     */\r\n    getDecimals(chainIdentifier, token) {\r\n        return this.priceProvider.getDecimals(chainIdentifier, token.toString());\r\n    }\r\n    fetchUsdPrice(abortSignal) {\r\n        return this.priceProvider.getUsdPrice(abortSignal);\r\n    }\r\n}\r\nexports.SingleSwapPrice = SingleSwapPrice;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,eAAe,GAAG,KAAK;AAC/B,MAAM;AACN;;CAEC,GACD,MAAM,wBAAwB,mBAAmB,gBAAgB;IAK7D;;;;;;;;KAQC,GACD,WAAW,eAAe,EAAE,KAAK,EAAE,WAAW,EAAE;QAC5C,OAAO,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,iBAAiB,OAAO;IAC/D;IACA;;;;;;;KAOC,GACD,YAAY,eAAe,EAAE,KAAK,EAAE;QAChC,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC,iBAAiB,MAAM,QAAQ;IACzE;IACA,cAAc,WAAW,EAAE;QACvB,OAAO,IAAI,CAAC,aAAa,CAAC,WAAW,CAAC;IAC1C;IA7BA,YAAY,oBAAoB,EAAE,aAAa,EAAE,YAAY,CAAE;QAC3D,KAAK,CAAC,sBAAsB;QAC5B,IAAI,CAAC,aAAa,GAAG;IACzB;AA2BJ;AACA,QAAQ,eAAe,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4126, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/prices/SwapPriceWithChain.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SwapPriceWithChain = void 0;\r\nclass SwapPriceWithChain {\r\n    constructor(swapPrice, chainIdentifier) {\r\n        this.swapPrice = swapPrice;\r\n        this.chainIdentifier = chainIdentifier;\r\n    }\r\n    /**\r\n     * Checks whether the swap amounts are valid given the current market rate for a given pair\r\n     *\r\n     * @param amountSats Amount of sats (BTC) to be received from the swap\r\n     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary\r\n     * @param feePPM PPM fee rate as reported by the intermediary\r\n     * @param paidToken Amount of token to be paid to the swap\r\n     * @param token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice Already pre-fetched price\r\n     */\r\n    async isValidAmountSend(amountSats, satsBaseFee, feePPM, paidToken, token, abortSignal, preFetchedPrice) {\r\n        return this.swapPrice.isValidAmountSend(this.chainIdentifier, amountSats, satsBaseFee, feePPM, paidToken, token, abortSignal, preFetchedPrice);\r\n    }\r\n    /**\r\n     * Checks whether the swap amounts are valid given the current market rate for a given pair\r\n     *\r\n     * @param amountSats Amount of sats (BTC) to be paid to the swap\r\n     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary\r\n     * @param feePPM PPM fee rate as reported by the intermediary\r\n     * @param receiveToken Amount of token to be received from the swap\r\n     * @param token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice Already pre-fetched price\r\n     */\r\n    async isValidAmountReceive(amountSats, satsBaseFee, feePPM, receiveToken, token, abortSignal, preFetchedPrice) {\r\n        return this.swapPrice.isValidAmountReceive(this.chainIdentifier, amountSats, satsBaseFee, feePPM, receiveToken, token, abortSignal, preFetchedPrice);\r\n    }\r\n    preFetchPrice(token, abortSignal) {\r\n        return this.swapPrice.preFetchPrice(this.chainIdentifier, token, abortSignal);\r\n    }\r\n    preFetchUsdPrice(abortSignal) {\r\n        return this.swapPrice.preFetchUsdPrice(abortSignal);\r\n    }\r\n    /**\r\n     * Returns amount of {toToken} that are equivalent to {fromAmount} satoshis\r\n     *\r\n     * @param fromAmount        Amount of satoshis\r\n     * @param toToken           Token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice\r\n     * @throws {Error} when token is not found\r\n     */\r\n    async getFromBtcSwapAmount(fromAmount, toToken, abortSignal, preFetchedPrice) {\r\n        return this.swapPrice.getFromBtcSwapAmount(this.chainIdentifier, fromAmount, toToken, abortSignal, preFetchedPrice);\r\n    }\r\n    /**\r\n     * Returns amount of satoshis that are equivalent to {fromAmount} of {fromToken}\r\n     *\r\n     * @param fromAmount Amount of the token\r\n     * @param fromToken Token\r\n     * @param abortSignal\r\n     * @param preFetchedPrice Pre-fetched swap price if available\r\n     * @throws {Error} when token is not found\r\n     */\r\n    async getToBtcSwapAmount(fromAmount, fromToken, abortSignal, preFetchedPrice) {\r\n        return this.swapPrice.getToBtcSwapAmount(this.chainIdentifier, fromAmount, fromToken, abortSignal, preFetchedPrice);\r\n    }\r\n    /**\r\n     * Returns whether the token should be ignored and pricing for it not calculated\r\n     *\r\n     * @param tokenAddress\r\n     * @throws {Error} if token is not found\r\n     */\r\n    shouldIgnore(tokenAddress) {\r\n        return this.swapPrice.shouldIgnore(this.chainIdentifier, tokenAddress);\r\n    }\r\n    async getBtcUsdValue(btcSats, abortSignal, preFetchedPrice) {\r\n        return this.swapPrice.getBtcUsdValue(btcSats, abortSignal, preFetchedPrice);\r\n    }\r\n    async getTokenUsdValue(tokenAmount, token, abortSignal, preFetchedPrice) {\r\n        return this.swapPrice.getTokenUsdValue(this.chainIdentifier, tokenAmount, token, abortSignal, preFetchedPrice);\r\n    }\r\n    getUsdValue(amount, token, abortSignal, preFetchedUsdPrice) {\r\n        return this.swapPrice.getUsdValue(amount, token, abortSignal, preFetchedUsdPrice);\r\n    }\r\n}\r\nexports.SwapPriceWithChain = SwapPriceWithChain;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,kBAAkB,GAAG,KAAK;AAClC,MAAM;IAKF;;;;;;;;;;KAUC,GACD,MAAM,kBAAkB,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE;QACrG,OAAO,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,aAAa,QAAQ,WAAW,OAAO,aAAa;IAClI;IACA;;;;;;;;;;KAUC,GACD,MAAM,qBAAqB,UAAU,EAAE,WAAW,EAAE,MAAM,EAAE,YAAY,EAAE,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE;QAC3G,OAAO,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,aAAa,QAAQ,cAAc,OAAO,aAAa;IACxI;IACA,cAAc,KAAK,EAAE,WAAW,EAAE;QAC9B,OAAO,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO;IACrE;IACA,iBAAiB,WAAW,EAAE;QAC1B,OAAO,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC;IAC3C;IACA;;;;;;;;KAQC,GACD,MAAM,qBAAqB,UAAU,EAAE,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE;QAC1E,OAAO,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,SAAS,aAAa;IACvG;IACA;;;;;;;;KAQC,GACD,MAAM,mBAAmB,UAAU,EAAE,SAAS,EAAE,WAAW,EAAE,eAAe,EAAE;QAC1E,OAAO,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,IAAI,CAAC,eAAe,EAAE,YAAY,WAAW,aAAa;IACvG;IACA;;;;;KAKC,GACD,aAAa,YAAY,EAAE;QACvB,OAAO,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,eAAe,EAAE;IAC7D;IACA,MAAM,eAAe,OAAO,EAAE,WAAW,EAAE,eAAe,EAAE;QACxD,OAAO,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,SAAS,aAAa;IAC/D;IACA,MAAM,iBAAiB,WAAW,EAAE,KAAK,EAAE,WAAW,EAAE,eAAe,EAAE;QACrE,OAAO,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,eAAe,EAAE,aAAa,OAAO,aAAa;IAClG;IACA,YAAY,MAAM,EAAE,KAAK,EAAE,WAAW,EAAE,kBAAkB,EAAE;QACxD,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,OAAO,aAAa;IAClE;IA/EA,YAAY,SAAS,EAAE,eAAe,CAAE;QACpC,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,eAAe,GAAG;IAC3B;AA6EJ;AACA,QAAQ,kBAAkB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4212, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/Tokens.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.toTokenAmount = exports.toDecimal = exports.fromDecimal = exports.isToken = exports.isSCToken = exports.BitcoinTokens = exports.isBtcToken = void 0;\r\nfunction isBtcToken(obj) {\r\n    return typeof (obj) === \"object\" &&\r\n        obj.chain === \"BTC\" &&\r\n        typeof (obj.lightning) === \"boolean\" &&\r\n        typeof (obj.ticker) === \"string\" &&\r\n        typeof (obj.decimals) === \"number\" &&\r\n        typeof (obj.name) === \"string\";\r\n}\r\nexports.isBtcToken = isBtcToken;\r\nexports.BitcoinTokens = {\r\n    BTC: {\r\n        chain: \"BTC\",\r\n        lightning: false,\r\n        ticker: \"BTC\",\r\n        decimals: 8,\r\n        name: \"Bitcoin (on-chain L1)\"\r\n    },\r\n    BTCLN: {\r\n        chain: \"BTC\",\r\n        lightning: true,\r\n        ticker: \"BTC\",\r\n        decimals: 8,\r\n        name: \"Bitcoin (lightning L2)\"\r\n    }\r\n};\r\nfunction isSCToken(obj) {\r\n    return typeof (obj) === \"object\" &&\r\n        obj.chain === \"SC\" &&\r\n        typeof (obj.chainId) === \"string\" &&\r\n        typeof (obj.address) === \"string\" &&\r\n        typeof (obj.ticker) === \"string\" &&\r\n        typeof (obj.decimals) === \"number\" &&\r\n        typeof (obj.name) === \"string\";\r\n}\r\nexports.isSCToken = isSCToken;\r\nfunction isToken(obj) {\r\n    return isBtcToken(obj) || isSCToken(obj);\r\n}\r\nexports.isToken = isToken;\r\nfunction fromDecimal(amount, decimalCount) {\r\n    if (amount.includes(\".\")) {\r\n        const [before, after] = amount.split(\".\");\r\n        if (decimalCount < 0) {\r\n            return BigInt(before.substring(0, before.length + decimalCount));\r\n        }\r\n        if (after.length > decimalCount) {\r\n            //Cut the last digits\r\n            return BigInt((before === \"0\" ? \"\" : before) + after.substring(0, decimalCount));\r\n        }\r\n        return BigInt((before === \"0\" ? \"\" : before) + after.padEnd(decimalCount, \"0\"));\r\n    }\r\n    else {\r\n        if (decimalCount < 0) {\r\n            return BigInt(amount.substring(0, amount.length + decimalCount));\r\n        }\r\n        else {\r\n            return BigInt(amount + \"0\".repeat(decimalCount));\r\n        }\r\n    }\r\n}\r\nexports.fromDecimal = fromDecimal;\r\nfunction toDecimal(amount, decimalCount, cut, displayDecimals) {\r\n    if (decimalCount <= 0) {\r\n        return amount.toString(10) + \"0\".repeat(-decimalCount);\r\n    }\r\n    const amountStr = amount.toString(10).padStart(decimalCount + 1, \"0\");\r\n    const splitPoint = amountStr.length - decimalCount;\r\n    const decimalPart = amountStr.substring(splitPoint, amountStr.length);\r\n    let cutTo = decimalPart.length;\r\n    if (cut && cutTo > 0) {\r\n        for (let i = decimalPart.length - 1; i--; i >= 0) {\r\n            if (decimalPart.charAt(i) === \"0\") {\r\n                cutTo = i;\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        if (cutTo === 0)\r\n            cutTo = 1;\r\n    }\r\n    if (displayDecimals === 0)\r\n        return amountStr.substring(0, splitPoint);\r\n    if (displayDecimals != null && cutTo > displayDecimals)\r\n        cutTo = displayDecimals;\r\n    return amountStr.substring(0, splitPoint) + \".\" + decimalPart.substring(0, cutTo);\r\n}\r\nexports.toDecimal = toDecimal;\r\nfunction toTokenAmount(amount, token, prices) {\r\n    if (amount == null)\r\n        return null;\r\n    let amountStr = toDecimal(amount, token.decimals, undefined, token.displayDecimals);\r\n    return {\r\n        rawAmount: amount,\r\n        amount: amountStr,\r\n        _amount: parseFloat(amountStr),\r\n        token,\r\n        usdValue: (abortSignal, preFetchedUsdPrice) => prices.getUsdValue(amount, token, abortSignal, preFetchedUsdPrice),\r\n        toString: () => amountStr + \" \" + token.ticker\r\n    };\r\n}\r\nexports.toTokenAmount = toTokenAmount;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4302, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/enums/SwapDirection.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SwapDirection = void 0;\r\nvar SwapDirection;\r\n(function (SwapDirection) {\r\n    SwapDirection[SwapDirection[\"FROM_BTC\"] = 0] = \"FROM_BTC\";\r\n    SwapDirection[SwapDirection[\"TO_BTC\"] = 1] = \"TO_BTC\";\r\n})(SwapDirection = exports.SwapDirection || (exports.SwapDirection = {}));\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,aAAa,GAAG,KAAK;AAC7B,IAAI;AACJ,CAAC,SAAU,aAAa;IACpB,aAAa,CAAC,aAAa,CAAC,WAAW,GAAG,EAAE,GAAG;IAC/C,aAAa,CAAC,aAAa,CAAC,SAAS,GAAG,EAAE,GAAG;AACjD,CAAC,EAAE,gBAAgB,QAAQ,aAAa,IAAI,CAAC,QAAQ,aAAa,GAAG,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4315, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/ISwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ISwap = exports.ppmToPercentage = exports.isISwapInit = void 0;\r\nconst SwapType_1 = require(\"./enums/SwapType\");\r\nconst events_1 = require(\"events\");\r\nconst ISwapPrice_1 = require(\"../prices/abstract/ISwapPrice\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst SwapDirection_1 = require(\"./enums/SwapDirection\");\r\nfunction isISwapInit(obj) {\r\n    return typeof obj === 'object' &&\r\n        obj != null &&\r\n        (0, ISwapPrice_1.isPriceInfoType)(obj.pricingInfo) &&\r\n        typeof obj.url === 'string' &&\r\n        typeof obj.expiry === 'number' &&\r\n        typeof (obj.swapFee) === \"bigint\" &&\r\n        (obj.swapFeeBtc == null || typeof (obj.swapFeeBtc) === \"bigint\") &&\r\n        (typeof obj.exactIn === 'boolean');\r\n}\r\nexports.isISwapInit = isISwapInit;\r\nfunction ppmToPercentage(ppm) {\r\n    if (ppm == null)\r\n        return null;\r\n    const percentage = Number(ppm) / 10000;\r\n    return {\r\n        ppm,\r\n        decimal: Number(ppm) / 1000000,\r\n        percentage: percentage,\r\n        toString: (decimals) => (decimals != null ? percentage.toFixed(decimals) : percentage) + \"%\"\r\n    };\r\n}\r\nexports.ppmToPercentage = ppmToPercentage;\r\nclass ISwap {\r\n    constructor(wrapper, swapInitOrObj) {\r\n        this.currentVersion = 1;\r\n        this.initiated = false;\r\n        /**\r\n         * Event emitter emitting \"swapState\" event when swap's state changes\r\n         */\r\n        this.events = new events_1.EventEmitter();\r\n        this.chainIdentifier = wrapper.chainIdentifier;\r\n        this.wrapper = wrapper;\r\n        if (isISwapInit(swapInitOrObj)) {\r\n            Object.assign(this, swapInitOrObj);\r\n            this.version = this.currentVersion;\r\n            this.createdAt = Date.now();\r\n            this.randomNonce = (0, Utils_1.randomBytes)(16).toString(\"hex\");\r\n        }\r\n        else {\r\n            this.expiry = swapInitOrObj.expiry;\r\n            this.url = swapInitOrObj.url;\r\n            this.state = swapInitOrObj.state;\r\n            this.pricingInfo = {\r\n                isValid: swapInitOrObj._isValid,\r\n                differencePPM: swapInitOrObj._differencePPM == null ? null : BigInt(swapInitOrObj._differencePPM),\r\n                satsBaseFee: swapInitOrObj._satsBaseFee == null ? null : BigInt(swapInitOrObj._satsBaseFee),\r\n                feePPM: swapInitOrObj._feePPM == null ? null : BigInt(swapInitOrObj._feePPM),\r\n                realPriceUSatPerToken: swapInitOrObj._realPriceUSatPerToken == null ? null : BigInt(swapInitOrObj._realPriceUSatPerToken),\r\n                swapPriceUSatPerToken: swapInitOrObj._swapPriceUSatPerToken == null ? null : BigInt(swapInitOrObj._swapPriceUSatPerToken),\r\n            };\r\n            this.swapFee = swapInitOrObj.swapFee == null ? null : BigInt(swapInitOrObj.swapFee);\r\n            this.swapFeeBtc = swapInitOrObj.swapFeeBtc == null ? null : BigInt(swapInitOrObj.swapFeeBtc);\r\n            this.version = swapInitOrObj.version;\r\n            this.initiated = swapInitOrObj.initiated;\r\n            this.exactIn = swapInitOrObj.exactIn;\r\n            this.createdAt = swapInitOrObj.createdAt ?? swapInitOrObj.expiry;\r\n            this.randomNonce = swapInitOrObj.randomNonce;\r\n        }\r\n        if (this.version !== this.currentVersion) {\r\n            this.upgradeVersion();\r\n        }\r\n        if (this.initiated == null)\r\n            this.initiated = true;\r\n    }\r\n    /**\r\n     * Waits till the swap reaches a specific state\r\n     *\r\n     * @param targetState The state to wait for\r\n     * @param type Whether to wait for the state exactly or also to a state with a higher number\r\n     * @param abortSignal\r\n     * @protected\r\n     */\r\n    waitTillState(targetState, type = \"eq\", abortSignal) {\r\n        return new Promise((resolve, reject) => {\r\n            let listener;\r\n            listener = (swap) => {\r\n                if (type === \"eq\" ? swap.state === targetState : type === \"gte\" ? swap.state >= targetState : swap.state != targetState) {\r\n                    resolve();\r\n                    this.events.removeListener(\"swapState\", listener);\r\n                }\r\n            };\r\n            this.events.on(\"swapState\", listener);\r\n            if (abortSignal != null)\r\n                abortSignal.addEventListener(\"abort\", () => {\r\n                    this.events.removeListener(\"swapState\", listener);\r\n                    reject(abortSignal.reason);\r\n                });\r\n        });\r\n    }\r\n    //////////////////////////////\r\n    //// Pricing\r\n    tryRecomputeSwapPrice() {\r\n        if (this.pricingInfo.swapPriceUSatPerToken == null) {\r\n            if (this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC) {\r\n                const input = this.getInput();\r\n                this.pricingInfo = this.wrapper.prices.recomputePriceInfoSend(this.chainIdentifier, this.getOutput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, input.rawAmount, input.token.address);\r\n            }\r\n            else {\r\n                const output = this.getOutput();\r\n                this.pricingInfo = this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier, this.getInput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, output.rawAmount, output.token.address);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Re-fetches & revalidates the price data\r\n     */\r\n    async refreshPriceData() {\r\n        if (this.pricingInfo == null)\r\n            return null;\r\n        if (this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC) {\r\n            const input = this.getInput();\r\n            this.pricingInfo = await this.wrapper.prices.isValidAmountSend(this.chainIdentifier, this.getOutput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, input.rawAmount, input.token.address);\r\n        }\r\n        else {\r\n            const output = this.getOutput();\r\n            this.pricingInfo = await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier, this.getInput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, output.rawAmount, output.token.address);\r\n        }\r\n    }\r\n    /**\r\n     * Checks if the pricing for the swap is valid, according to max allowed price difference set in the ISwapPrice\r\n     */\r\n    hasValidPrice() {\r\n        return this.pricingInfo == null ? null : this.pricingInfo.isValid;\r\n    }\r\n    /**\r\n     * Returns pricing info about the swap\r\n     */\r\n    getPriceInfo() {\r\n        const swapPrice = this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC ?\r\n            100000000000000 / Number(this.pricingInfo.swapPriceUSatPerToken) :\r\n            Number(this.pricingInfo.swapPriceUSatPerToken) / 100000000000000;\r\n        const marketPrice = this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC ?\r\n            100000000000000 / Number(this.pricingInfo.realPriceUSatPerToken) :\r\n            Number(this.pricingInfo.swapPriceUSatPerToken) / 100000000000000;\r\n        return {\r\n            marketPrice,\r\n            swapPrice,\r\n            difference: ppmToPercentage(this.pricingInfo.differencePPM)\r\n        };\r\n    }\r\n    /**\r\n     * @param signer Signer to check with this swap's initiator\r\n     * @throws {Error} When signer's address doesn't match with the swap's initiator one\r\n     */\r\n    checkSigner(signer) {\r\n        if ((typeof (signer) === \"string\" ? signer : signer.getAddress()) !== this._getInitiator())\r\n            throw new Error(\"Invalid signer provided!\");\r\n    }\r\n    isInitiated() {\r\n        return this.initiated;\r\n    }\r\n    _setInitiated() {\r\n        this.initiated = true;\r\n    }\r\n    /**\r\n     * Returns quote expiry in UNIX millis\r\n     */\r\n    getQuoteExpiry() {\r\n        return this.expiry;\r\n    }\r\n    /**\r\n     * Returns the type of the swap\r\n     */\r\n    getType() {\r\n        return this.TYPE;\r\n    }\r\n    /**\r\n     * Returns the direction of the swap\r\n     */\r\n    getDirection() {\r\n        return this.TYPE === SwapType_1.SwapType.TO_BTC || this.TYPE === SwapType_1.SwapType.TO_BTCLN ? SwapDirection_1.SwapDirection.TO_BTC : SwapDirection_1.SwapDirection.FROM_BTC;\r\n    }\r\n    /**\r\n     * Returns the current state of the swap\r\n     */\r\n    getState() {\r\n        return this.state;\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        if (this.pricingInfo == null)\r\n            return {};\r\n        return {\r\n            id: this.getId(),\r\n            type: this.getType(),\r\n            escrowHash: this._getEscrowHash(),\r\n            initiator: this._getInitiator(),\r\n            _isValid: this.pricingInfo.isValid,\r\n            _differencePPM: this.pricingInfo.differencePPM == null ? null : this.pricingInfo.differencePPM.toString(10),\r\n            _satsBaseFee: this.pricingInfo.satsBaseFee == null ? null : this.pricingInfo.satsBaseFee.toString(10),\r\n            _feePPM: this.pricingInfo.feePPM == null ? null : this.pricingInfo.feePPM.toString(10),\r\n            _realPriceUSatPerToken: this.pricingInfo.realPriceUSatPerToken == null ? null : this.pricingInfo.realPriceUSatPerToken.toString(10),\r\n            _swapPriceUSatPerToken: this.pricingInfo.swapPriceUSatPerToken == null ? null : this.pricingInfo.swapPriceUSatPerToken.toString(10),\r\n            state: this.state,\r\n            url: this.url,\r\n            swapFee: this.swapFee == null ? null : this.swapFee.toString(10),\r\n            swapFeeBtc: this.swapFeeBtc == null ? null : this.swapFeeBtc.toString(10),\r\n            expiry: this.expiry,\r\n            version: this.version,\r\n            initiated: this.initiated,\r\n            exactIn: this.exactIn,\r\n            createdAt: this.createdAt,\r\n            randomNonce: this.randomNonce\r\n        };\r\n    }\r\n    _save() {\r\n        if (this.isQuoteExpired()) {\r\n            return this.wrapper.removeSwapData(this);\r\n        }\r\n        else {\r\n            return this.wrapper.saveSwapData(this);\r\n        }\r\n    }\r\n    async _saveAndEmit(state) {\r\n        if (state != null)\r\n            this.state = state;\r\n        await this._save();\r\n        this._emitEvent();\r\n    }\r\n    //////////////////////////////\r\n    //// Events\r\n    _emitEvent() {\r\n        this.wrapper.events.emit(\"swapState\", this);\r\n        this.events.emit(\"swapState\", this);\r\n    }\r\n}\r\nexports.ISwap = ISwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4527, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/IAddressSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4534, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/ISwapWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ISwapWrapper = void 0;\r\nconst events_1 = require(\"events\");\r\nconst IntermediaryError_1 = require(\"../errors/IntermediaryError\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nclass ISwapWrapper {\r\n    /**\r\n     * @param chainIdentifier\r\n     * @param unifiedStorage\r\n     * @param unifiedChainEvents\r\n     * @param chain\r\n     * @param contract Underlying contract handling the swaps\r\n     * @param prices Swap pricing handler\r\n     * @param tokens Chain specific token data\r\n     * @param swapDataDeserializer Deserializer for SwapData\r\n     * @param options\r\n     * @param events Instance to use for emitting events\r\n     */\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events) {\r\n        this.logger = (0, Utils_1.getLogger)(this.constructor.name + \": \");\r\n        this.pendingSwaps = new Map();\r\n        this.isInitialized = false;\r\n        this.tickInterval = null;\r\n        this.unifiedStorage = unifiedStorage;\r\n        this.unifiedChainEvents = unifiedChainEvents;\r\n        this.chainIdentifier = chainIdentifier;\r\n        this.chain = chain;\r\n        this.prices = prices;\r\n        this.events = events || new events_1.EventEmitter();\r\n        this.options = options;\r\n        this.tokens = {};\r\n        for (let tokenData of tokens) {\r\n            const chainData = tokenData.chains[chainIdentifier];\r\n            if (chainData == null)\r\n                continue;\r\n            this.tokens[chainData.address] = {\r\n                chain: \"SC\",\r\n                chainId: this.chainIdentifier,\r\n                address: chainData.address,\r\n                decimals: chainData.decimals,\r\n                ticker: tokenData.ticker,\r\n                name: tokenData.name,\r\n                displayDecimals: chainData.displayDecimals\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Pre-fetches swap price for a given swap\r\n     *\r\n     * @param amountData\r\n     * @param abortSignal\r\n     * @protected\r\n     * @returns Price of the token in uSats (micro sats)\r\n     */\r\n    preFetchPrice(amountData, abortSignal) {\r\n        return this.prices.preFetchPrice(this.chainIdentifier, amountData.token, abortSignal).catch(e => {\r\n            this.logger.error(\"preFetchPrice(): Error: \", e);\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies returned  price for swaps\r\n     *\r\n     * @param lpServiceData Service data for the service in question (TO_BTCLN, TO_BTC, etc.) of the given intermediary\r\n     * @param send Whether this is a send (SOL -> SC) or receive (BTC -> SC) swap\r\n     * @param amountSats Amount in BTC\r\n     * @param amountToken Amount in token\r\n     * @param token Token used in the swap\r\n     * @param feeData Fee data as returned by the intermediary\r\n     * @param pricePrefetchPromise Price pre-fetch promise\r\n     * @param abortSignal\r\n     * @protected\r\n     * @returns Price info object\r\n     * @throws {IntermediaryError} if the calculated fee is too high\r\n     */\r\n    async verifyReturnedPrice(lpServiceData, send, amountSats, amountToken, token, feeData, pricePrefetchPromise = Promise.resolve(null), abortSignal) {\r\n        const swapBaseFee = BigInt(lpServiceData.swapBaseFee);\r\n        const swapFeePPM = BigInt(lpServiceData.swapFeePPM);\r\n        if (send)\r\n            amountToken = amountToken - feeData.networkFee;\r\n        const isValidAmount = await (send ?\r\n            this.prices.isValidAmountSend(this.chainIdentifier, amountSats, swapBaseFee, swapFeePPM, amountToken, token, abortSignal, await pricePrefetchPromise) :\r\n            this.prices.isValidAmountReceive(this.chainIdentifier, amountSats, swapBaseFee, swapFeePPM, amountToken, token, abortSignal, await pricePrefetchPromise));\r\n        if (!isValidAmount.isValid)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Fee too high\");\r\n        return isValidAmount;\r\n    }\r\n    /**\r\n     * Initializes the swap wrapper, needs to be called before any other action can be taken\r\n     */\r\n    async init(noTimers = false, noCheckPastSwaps = false) {\r\n        if (this.isInitialized)\r\n            return;\r\n        const hasEventListener = this.processEvent != null;\r\n        //Save events received in the meantime into the event queue and process them only after we've checked and\r\n        // processed all the past swaps\r\n        let eventQueue = [];\r\n        const initListener = (event, swap) => {\r\n            eventQueue.push({ event, swap });\r\n            return Promise.resolve();\r\n        };\r\n        if (hasEventListener)\r\n            this.unifiedChainEvents.registerListener(this.TYPE, initListener, this.swapDeserializer.bind(null, this));\r\n        if (!noCheckPastSwaps)\r\n            await this.checkPastSwaps();\r\n        if (hasEventListener) {\r\n            //Process accumulated event queue\r\n            for (let event of eventQueue) {\r\n                await this.processEvent(event.event, event.swap);\r\n            }\r\n            //Register the correct event handler\r\n            this.unifiedChainEvents.unregisterListener(this.TYPE);\r\n            this.unifiedChainEvents.registerListener(this.TYPE, this.processEvent.bind(this), this.swapDeserializer.bind(null, this));\r\n        }\r\n        if (!noTimers)\r\n            this.startTickInterval();\r\n        // this.logger.info(\"init(): Swap wrapper initialized\");\r\n        this.isInitialized = true;\r\n    }\r\n    startTickInterval() {\r\n        if (this.tickSwapState == null || this.tickSwapState.length === 0)\r\n            return;\r\n        this.tickInterval = setInterval(() => {\r\n            this.tick();\r\n        }, 1000);\r\n    }\r\n    async checkPastSwaps(pastSwaps) {\r\n        if (pastSwaps == null)\r\n            pastSwaps = await this.unifiedStorage.query([[{ key: \"type\", value: this.TYPE }, { key: \"state\", value: this.pendingSwapStates }]], (val) => new this.swapDeserializer(this, val));\r\n        //Check past swaps\r\n        const changedSwaps = [];\r\n        const removeSwaps = [];\r\n        await Promise.all(pastSwaps.map((swap) => swap._sync(false).then(changed => {\r\n            if (swap.isQuoteExpired()) {\r\n                removeSwaps.push(swap);\r\n                this.logger.debug(\"init(): Removing expired swap: \" + swap.getId());\r\n            }\r\n            else {\r\n                if (changed)\r\n                    changedSwaps.push(swap);\r\n            }\r\n        }).catch(e => this.logger.error(\"init(): Error when checking swap \" + swap.getId() + \": \", e))));\r\n        await this.unifiedStorage.removeAll(removeSwaps);\r\n        await this.unifiedStorage.saveAll(changedSwaps);\r\n    }\r\n    async tick(swaps) {\r\n        if (swaps == null)\r\n            swaps = await this.unifiedStorage.query([[{ key: \"type\", value: this.TYPE }, { key: \"state\", value: this.tickSwapState }]], (val) => new this.swapDeserializer(this, val));\r\n        for (let pendingSwap of this.pendingSwaps.values()) {\r\n            const value = pendingSwap.deref();\r\n            if (value != null)\r\n                value._tick(true);\r\n        }\r\n        swaps.forEach(value => {\r\n            value._tick(true);\r\n        });\r\n    }\r\n    saveSwapData(swap) {\r\n        if (!swap.isInitiated()) {\r\n            this.logger.debug(\"saveSwapData(): Swap \" + swap.getId() + \" not initiated, saving to pending swaps\");\r\n            this.pendingSwaps.set(swap.getId(), new WeakRef(swap));\r\n            return Promise.resolve();\r\n        }\r\n        else {\r\n            this.pendingSwaps.delete(swap.getId());\r\n        }\r\n        return this.unifiedStorage.save(swap);\r\n    }\r\n    removeSwapData(swap) {\r\n        this.pendingSwaps.delete(swap.getId());\r\n        if (!swap.isInitiated())\r\n            return Promise.resolve();\r\n        return this.unifiedStorage.remove(swap);\r\n    }\r\n    /**\r\n     * Un-subscribes from event listeners on Solana\r\n     */\r\n    async stop() {\r\n        this.isInitialized = false;\r\n        this.unifiedChainEvents.unregisterListener(this.TYPE);\r\n        this.logger.info(\"stop(): Swap wrapper stopped\");\r\n        if (this.tickInterval != null)\r\n            clearInterval(this.tickInterval);\r\n    }\r\n    /**\r\n     * Returns the smart chain's native token used to pay for fees\r\n     */\r\n    getNativeToken() {\r\n        return this.tokens[this.chain.getNativeCurrencyAddress()];\r\n    }\r\n}\r\nexports.ISwapWrapper = ISwapWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4735, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IEscrowSwap = exports.isIEscrowSwapInit = void 0;\r\nconst ISwap_1 = require(\"../ISwap\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst Tokens_1 = require(\"../../Tokens\");\r\nfunction isIEscrowSwapInit(obj) {\r\n    return typeof obj === 'object' &&\r\n        obj.feeRate != null &&\r\n        (obj.signatureData == null || (typeof (obj.signatureData) === 'object' &&\r\n            typeof (obj.signatureData.prefix) === \"string\" &&\r\n            typeof (obj.signatureData.timeout) === \"string\" &&\r\n            typeof (obj.signatureData.signature) === \"string\")) &&\r\n        (obj.data == null || typeof obj.data === 'object') &&\r\n        (0, ISwap_1.isISwapInit)(obj);\r\n}\r\nexports.isIEscrowSwapInit = isIEscrowSwapInit;\r\nclass IEscrowSwap extends ISwap_1.ISwap {\r\n    constructor(wrapper, swapInitOrObj) {\r\n        super(wrapper, swapInitOrObj);\r\n        if (!isIEscrowSwapInit(swapInitOrObj)) {\r\n            this.data = swapInitOrObj.data != null ? new wrapper.swapDataDeserializer(swapInitOrObj.data) : null;\r\n            this.signatureData = swapInitOrObj.signature == null ? null : {\r\n                prefix: swapInitOrObj.prefix,\r\n                timeout: swapInitOrObj.timeout,\r\n                signature: swapInitOrObj.signature\r\n            };\r\n            this.feeRate = swapInitOrObj.feeRate;\r\n            this.commitTxId = swapInitOrObj.commitTxId;\r\n            this.claimTxId = swapInitOrObj.claimTxId;\r\n            this.refundTxId = swapInitOrObj.refundTxId;\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Identifiers\r\n    /**\r\n     * Returns the identification hash of the swap, usually claim data hash, but can be overriden, e.g. for\r\n     *  lightning swaps the identifier hash is used instead of claim data hash\r\n     */\r\n    getIdentifierHash() {\r\n        const claimHashBuffer = buffer_1.Buffer.from(this.getClaimHash(), \"hex\");\r\n        if (this.randomNonce == null)\r\n            return claimHashBuffer;\r\n        return buffer_1.Buffer.concat([claimHashBuffer, buffer_1.Buffer.from(this.randomNonce, \"hex\")]);\r\n    }\r\n    /**\r\n     * Returns the identification hash of the swap, usually claim data hash, but can be overriden, e.g. for\r\n     *  lightning swaps the identifier hash is used instead of claim data hash\r\n     */\r\n    getIdentifierHashString() {\r\n        const identifierHash = this.getIdentifierHash();\r\n        if (identifierHash == null)\r\n            return null;\r\n        return identifierHash.toString(\"hex\");\r\n    }\r\n    _getEscrowHash() {\r\n        return this.data?.getEscrowHash();\r\n    }\r\n    /**\r\n     * Returns the escrow hash - i.e. hash of the escrow data\r\n     */\r\n    getEscrowHash() {\r\n        return this._getEscrowHash();\r\n    }\r\n    /**\r\n     * Returns the claim data hash - i.e. hash passed to the claim handler\r\n     */\r\n    getClaimHash() {\r\n        return this.data?.getClaimHash();\r\n    }\r\n    getId() {\r\n        return this.getIdentifierHashString();\r\n    }\r\n    //////////////////////////////\r\n    //// Watchdogs\r\n    /**\r\n     * Periodically checks for init signature's expiry\r\n     *\r\n     * @param abortSignal\r\n     * @param interval How often to check (in seconds), default to 5s\r\n     * @protected\r\n     */\r\n    async watchdogWaitTillSignatureExpiry(abortSignal, interval = 5) {\r\n        let expired = false;\r\n        while (!expired) {\r\n            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);\r\n            try {\r\n                expired = await this.wrapper.contract.isInitAuthorizationExpired(this.data, this.signatureData);\r\n            }\r\n            catch (e) {\r\n                this.logger.error(\"watchdogWaitTillSignatureExpiry(): Error when checking signature expiry: \", e);\r\n            }\r\n        }\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n    }\r\n    /**\r\n     * Periodically checks the chain to see whether the swap is committed\r\n     *\r\n     * @param abortSignal\r\n     * @param interval How often to check (in seconds), default to 5s\r\n     * @protected\r\n     */\r\n    async watchdogWaitTillCommited(abortSignal, interval = 5) {\r\n        let status = { type: base_1.SwapCommitStateType.NOT_COMMITED };\r\n        while (status?.type === base_1.SwapCommitStateType.NOT_COMMITED) {\r\n            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);\r\n            try {\r\n                status = await this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data);\r\n                if (status?.type === base_1.SwapCommitStateType.NOT_COMMITED &&\r\n                    await this.wrapper.contract.isInitAuthorizationExpired(this.data, this.signatureData))\r\n                    return false;\r\n            }\r\n            catch (e) {\r\n                this.logger.error(\"watchdogWaitTillCommited(): Error when fetching commit status or signature expiry: \", e);\r\n            }\r\n        }\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        return true;\r\n    }\r\n    /**\r\n     * Periodically checks the chain to see whether the swap was finished (claimed or refunded)\r\n     *\r\n     * @param abortSignal\r\n     * @param interval How often to check (in seconds), default to 5s\r\n     * @protected\r\n     */\r\n    async watchdogWaitTillResult(abortSignal, interval = 5) {\r\n        let status = { type: base_1.SwapCommitStateType.COMMITED };\r\n        while (status?.type === base_1.SwapCommitStateType.COMMITED || status?.type === base_1.SwapCommitStateType.REFUNDABLE) {\r\n            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);\r\n            try {\r\n                status = await this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data);\r\n            }\r\n            catch (e) {\r\n                this.logger.error(\"watchdogWaitTillResult(): Error when fetching commit status: \", e);\r\n            }\r\n        }\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        return status;\r\n    }\r\n    //////////////////////////////\r\n    //// Quote verification\r\n    /**\r\n     * Checks if the swap's quote is expired for good (i.e. the swap strictly cannot be committed on-chain anymore)\r\n     */\r\n    async verifyQuoteDefinitelyExpired() {\r\n        return (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.isInitAuthorizationExpired(this.data, this.signatureData));\r\n    }\r\n    /**\r\n     * Checks if the swap's quote is still valid\r\n     */\r\n    async verifyQuoteValid() {\r\n        try {\r\n            await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.isValidInitAuthorization(this._getInitiator(), this.data, this.signatureData, this.feeRate), null, base_1.SignatureVerificationError);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            if (e instanceof base_1.SignatureVerificationError) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    /**\r\n     * Get the estimated smart chain fee of the commit transaction\r\n     */\r\n    getCommitFee() {\r\n        return this.wrapper.contract.getCommitFee(this.data, this.feeRate);\r\n    }\r\n    /**\r\n     * Returns the transaction fee paid on the smart chain\r\n     */\r\n    async getSmartChainNetworkFee() {\r\n        const swapContract = this.wrapper.contract;\r\n        return (0, Tokens_1.toTokenAmount)(await (swapContract.getRawCommitFee != null ?\r\n            swapContract.getRawCommitFee(this.data, this.feeRate) :\r\n            swapContract.getCommitFee(this.data, this.feeRate)), this.wrapper.getNativeToken(), this.wrapper.prices);\r\n    }\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            data: this.data != null ? this.data.serialize() : null,\r\n            prefix: this.signatureData?.prefix,\r\n            timeout: this.signatureData?.timeout,\r\n            signature: this.signatureData?.signature,\r\n            feeRate: this.feeRate == null ? null : this.feeRate.toString(),\r\n            commitTxId: this.commitTxId,\r\n            claimTxId: this.claimTxId,\r\n            refundTxId: this.refundTxId\r\n        };\r\n    }\r\n    ;\r\n}\r\nexports.IEscrowSwap = IEscrowSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4921, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FeeType = void 0;\r\nvar FeeType;\r\n(function (FeeType) {\r\n    FeeType[FeeType[\"SWAP\"] = 0] = \"SWAP\";\r\n    FeeType[FeeType[\"NETWORK_OUTPUT\"] = 1] = \"NETWORK_OUTPUT\";\r\n})(FeeType = exports.FeeType || (exports.FeeType = {}));\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,OAAO,GAAG,KAAK;AACvB,IAAI;AACJ,CAAC,SAAU,OAAO;IACd,OAAO,CAAC,OAAO,CAAC,OAAO,GAAG,EAAE,GAAG;IAC/B,OAAO,CAAC,OAAO,CAAC,iBAAiB,GAAG,EAAE,GAAG;AAC7C,CAAC,EAAE,UAAU,QAAQ,OAAO,IAAI,CAAC,QAAQ,OAAO,GAAG,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4934, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ToBTCSwapState = exports.IToBTCSwap = exports.isIToBTCSwapInit = void 0;\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst IntermediaryAPI_1 = require(\"../../../intermediaries/IntermediaryAPI\");\r\nconst IntermediaryError_1 = require(\"../../../errors/IntermediaryError\");\r\nconst Utils_1 = require(\"../../../utils/Utils\");\r\nconst Tokens_1 = require(\"../../../Tokens\");\r\nconst IEscrowSwap_1 = require(\"../IEscrowSwap\");\r\nconst Fee_1 = require(\"../../fee/Fee\");\r\nconst ISwap_1 = require(\"../../ISwap\");\r\nfunction isIToBTCSwapInit(obj) {\r\n    return typeof (obj.networkFee) === \"bigint\" &&\r\n        (obj.networkFeeBtc == null || typeof (obj.networkFeeBtc) === \"bigint\") &&\r\n        (0, IEscrowSwap_1.isIEscrowSwapInit)(obj);\r\n}\r\nexports.isIToBTCSwapInit = isIToBTCSwapInit;\r\nclass IToBTCSwap extends IEscrowSwap_1.IEscrowSwap {\r\n    constructor(wrapper, initOrObject) {\r\n        super(wrapper, initOrObject);\r\n        if (isIToBTCSwapInit(initOrObject)) {\r\n            this.state = ToBTCSwapState.CREATED;\r\n        }\r\n        else {\r\n            this.networkFee = initOrObject.networkFee == null ? null : BigInt(initOrObject.networkFee);\r\n            this.networkFeeBtc = initOrObject.networkFeeBtc == null ? null : BigInt(initOrObject.networkFeeBtc);\r\n        }\r\n    }\r\n    upgradeVersion() {\r\n        if (this.version == null) {\r\n            switch (this.state) {\r\n                case -2:\r\n                    this.state = ToBTCSwapState.REFUNDED;\r\n                    break;\r\n                case -1:\r\n                    this.state = ToBTCSwapState.QUOTE_EXPIRED;\r\n                    break;\r\n                case 0:\r\n                    this.state = ToBTCSwapState.CREATED;\r\n                    break;\r\n                case 1:\r\n                    this.state = ToBTCSwapState.COMMITED;\r\n                    break;\r\n                case 2:\r\n                    this.state = ToBTCSwapState.CLAIMED;\r\n                    break;\r\n                case 3:\r\n                    this.state = ToBTCSwapState.REFUNDABLE;\r\n                    break;\r\n            }\r\n            this.version = 1;\r\n        }\r\n    }\r\n    /**\r\n     * In case swapFee in BTC is not supplied it recalculates it based on swap price\r\n     * @protected\r\n     */\r\n    tryRecomputeSwapPrice() {\r\n        if (this.swapFeeBtc == null) {\r\n            this.swapFeeBtc = this.swapFee * this.getOutput().rawAmount / this.getInputWithoutFee().rawAmount;\r\n        }\r\n        if (this.networkFeeBtc == null) {\r\n            this.networkFeeBtc = this.networkFee * this.getOutput().rawAmount / this.getInputWithoutFee().rawAmount;\r\n        }\r\n        super.tryRecomputeSwapPrice();\r\n    }\r\n    /**\r\n     * Returns the payment hash identifier to be sent to the LP for getStatus and getRefund\r\n     * @protected\r\n     */\r\n    getLpIdentifier() {\r\n        return this.getClaimHash();\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    getInputTxId() {\r\n        return this.commitTxId;\r\n    }\r\n    requiresAction() {\r\n        return this.isRefundable();\r\n    }\r\n    /**\r\n     * Returns whether the swap is finished and in its terminal state (this can mean successful, refunded or failed)\r\n     */\r\n    isFinished() {\r\n        return this.state === ToBTCSwapState.CLAIMED || this.state === ToBTCSwapState.REFUNDED || this.state === ToBTCSwapState.QUOTE_EXPIRED;\r\n    }\r\n    isRefundable() {\r\n        return this.state === ToBTCSwapState.REFUNDABLE;\r\n    }\r\n    isQuoteExpired() {\r\n        return this.state === ToBTCSwapState.QUOTE_EXPIRED;\r\n    }\r\n    isQuoteSoftExpired() {\r\n        return this.state === ToBTCSwapState.QUOTE_EXPIRED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED;\r\n    }\r\n    isSuccessful() {\r\n        return this.state === ToBTCSwapState.CLAIMED;\r\n    }\r\n    isFailed() {\r\n        return this.state === ToBTCSwapState.REFUNDED;\r\n    }\r\n    _getInitiator() {\r\n        return this.data.getOfferer();\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getSwapFee() {\r\n        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;\r\n        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getOutput().rawAmount;\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, this.outputToken, this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),\r\n            composition: {\r\n                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, this.outputToken, this.wrapper.prices),\r\n                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Returns network fee for the swap, the fee is represented in source currency & destination currency, but is\r\n     *  paid only once\r\n     */\r\n    getNetworkFee() {\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.networkFee, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.networkFeeBtc, this.outputToken, this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(this.networkFeeBtc, abortSignal, preFetchedUsdPrice)\r\n        };\r\n    }\r\n    getFee() {\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFee + this.networkFee, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc + this.networkFeeBtc, this.outputToken, this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc + this.networkFeeBtc, abortSignal, preFetchedUsdPrice)\r\n        };\r\n    }\r\n    getFeeBreakdown() {\r\n        return [\r\n            {\r\n                type: Fee_1.FeeType.SWAP,\r\n                fee: this.getSwapFee()\r\n            },\r\n            {\r\n                type: Fee_1.FeeType.NETWORK_OUTPUT,\r\n                fee: this.getNetworkFee()\r\n            }\r\n        ];\r\n    }\r\n    getInput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.data.getAmount(), this.wrapper.tokens[this.data.getToken()], this.wrapper.prices);\r\n    }\r\n    getInputWithoutFee() {\r\n        return (0, Tokens_1.toTokenAmount)(this.data.getAmount() - (this.swapFee + this.networkFee), this.wrapper.tokens[this.data.getToken()], this.wrapper.prices);\r\n    }\r\n    /**\r\n     * Checks if the intiator/sender has enough balance to go through with the swap\r\n     */\r\n    async hasEnoughBalance() {\r\n        const [balance, commitFee] = await Promise.all([\r\n            this.wrapper.contract.getBalance(this._getInitiator(), this.data.getToken(), false),\r\n            this.data.getToken() === this.wrapper.chain.getNativeCurrencyAddress() ? this.getCommitFee() : Promise.resolve(null)\r\n        ]);\r\n        let required = this.data.getAmount();\r\n        if (commitFee != null)\r\n            required = required + commitFee;\r\n        return {\r\n            enoughBalance: balance >= required,\r\n            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),\r\n            required: (0, Tokens_1.toTokenAmount)(required, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices)\r\n        };\r\n    }\r\n    /**\r\n     * Check if the initiator/sender has enough balance to cover the transaction fee for processing the swap\r\n     */\r\n    async hasEnoughForTxFees() {\r\n        const [balance, commitFee] = await Promise.all([\r\n            this.wrapper.contract.getBalance(this._getInitiator(), this.wrapper.chain.getNativeCurrencyAddress(), false),\r\n            this.getCommitFee()\r\n        ]);\r\n        return {\r\n            enoughBalance: balance >= commitFee,\r\n            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.getNativeToken(), this.wrapper.prices),\r\n            required: (0, Tokens_1.toTokenAmount)(commitFee, this.wrapper.getNativeToken(), this.wrapper.prices)\r\n        };\r\n    }\r\n    //////////////////////////////\r\n    //// Commit\r\n    /**\r\n     * Returns transactions for committing the swap on-chain, initiating the swap\r\n     *\r\n     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet\r\n     *  (this is handled on swap creation, if you commit right after quoting, you can use skipChecks=true)\r\n     *\r\n     * @throws {Error} When in invalid state (not PR_CREATED)\r\n     */\r\n    async txsCommit(skipChecks) {\r\n        if (this.state !== ToBTCSwapState.CREATED)\r\n            throw new Error(\"Must be in CREATED state!\");\r\n        if (!this.initiated) {\r\n            this.initiated = true;\r\n            await this._saveAndEmit();\r\n        }\r\n        return await this.wrapper.contract.txsInit(this._getInitiator(), this.data, this.signatureData, skipChecks, this.feeRate).catch(e => Promise.reject(e instanceof base_1.SignatureVerificationError ? new Error(\"Request timed out\") : e));\r\n    }\r\n    /**\r\n     * Commits the swap on-chain, initiating the swap\r\n     *\r\n     * @param signer Signer to sign the transactions with, must be the same as used in the initialization\r\n     * @param abortSignal Abort signal\r\n     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet\r\n     *  (this is handled on swap creation, if you commit right after quoting, you can skipChecks)`\r\n     * @throws {Error} If invalid signer is provided that doesn't match the swap data\r\n     */\r\n    async commit(signer, abortSignal, skipChecks) {\r\n        this.checkSigner(signer);\r\n        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommit(skipChecks), true, abortSignal);\r\n        this.commitTxId = result[result.length - 1];\r\n        if (this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === ToBTCSwapState.QUOTE_EXPIRED) {\r\n            await this._saveAndEmit(ToBTCSwapState.COMMITED);\r\n        }\r\n        return this.commitTxId;\r\n    }\r\n    /**\r\n     * Waits till a swap is committed, should be called after sending the commit transactions manually\r\n     *\r\n     * @param abortSignal   AbortSignal\r\n     * @throws {Error} If swap is not in the correct state (must be CREATED)\r\n     */\r\n    async waitTillCommited(abortSignal) {\r\n        if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.CLAIMED)\r\n            return Promise.resolve();\r\n        if (this.state !== ToBTCSwapState.CREATED && this.state !== ToBTCSwapState.QUOTE_SOFT_EXPIRED)\r\n            throw new Error(\"Invalid state (not CREATED)\");\r\n        const abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const result = await Promise.race([\r\n            this.watchdogWaitTillCommited(abortController.signal),\r\n            this.waitTillState(ToBTCSwapState.COMMITED, \"gte\", abortController.signal).then(() => 0)\r\n        ]);\r\n        abortController.abort();\r\n        if (result === 0)\r\n            this.logger.debug(\"waitTillCommited(): Resolved from state change\");\r\n        if (result === true)\r\n            this.logger.debug(\"waitTillCommited(): Resolved from watchdog - commited\");\r\n        if (result === false) {\r\n            this.logger.debug(\"waitTillCommited(): Resolved from watchdog - signature expiry\");\r\n            if (this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === ToBTCSwapState.CREATED) {\r\n                await this._saveAndEmit(ToBTCSwapState.QUOTE_EXPIRED);\r\n                throw new Error(\"Quote expired while waiting for transaction confirmation!\");\r\n            }\r\n            return;\r\n        }\r\n        if (this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_EXPIRED) {\r\n            await this._saveAndEmit(ToBTCSwapState.COMMITED);\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Payment\r\n    async waitTillIntermediarySwapProcessed(abortSignal, checkIntervalSeconds = 5) {\r\n        let resp = { code: IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING, msg: \"\" };\r\n        while (!abortSignal.aborted && (resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING || resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.NOT_FOUND)) {\r\n            resp = await IntermediaryAPI_1.IntermediaryAPI.getRefundAuthorization(this.url, this.getLpIdentifier(), this.data.getSequence());\r\n            if (resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.PAID) {\r\n                const validResponse = await this._setPaymentResult(resp.data, true);\r\n                if (validResponse) {\r\n                    if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.REFUNDABLE) {\r\n                        await this._saveAndEmit(ToBTCSwapState.SOFT_CLAIMED);\r\n                    }\r\n                }\r\n                else {\r\n                    resp = { code: IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING, msg: \"\" };\r\n                }\r\n            }\r\n            if (resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING ||\r\n                resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.NOT_FOUND)\r\n                await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);\r\n        }\r\n        return resp;\r\n    }\r\n    /**\r\n     * Checks whether the swap was already processed by the LP and is either successful (requires proof which is\r\n     *  either a HTLC pre-image for LN swaps or valid txId for on-chain swap) or failed and we can cooperatively\r\n     *  refund.\r\n     *\r\n     * @param save whether to save the data\r\n     * @returns true if swap is processed, false if the swap is still ongoing\r\n     * @private\r\n     */\r\n    async checkIntermediarySwapProcessed(save = true) {\r\n        if (this.state === ToBTCSwapState.CREATED || this.state == ToBTCSwapState.QUOTE_EXPIRED)\r\n            return false;\r\n        if (this.isFinished() || this.isRefundable())\r\n            return true;\r\n        //Check if that maybe already concluded according to the LP\r\n        const resp = await IntermediaryAPI_1.IntermediaryAPI.getRefundAuthorization(this.url, this.getLpIdentifier(), this.data.getSequence());\r\n        switch (resp.code) {\r\n            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.PAID:\r\n                const processed = await this._setPaymentResult(resp.data, true);\r\n                if (processed) {\r\n                    this.state = ToBTCSwapState.SOFT_CLAIMED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                }\r\n                return processed;\r\n            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.REFUND_DATA:\r\n                await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.isValidRefundAuthorization(this.data, resp.data), null, base_1.SignatureVerificationError);\r\n                this.state = ToBTCSwapState.REFUNDABLE;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    /**\r\n     * A blocking promise resolving when swap was concluded by the intermediary,\r\n     *  rejecting in case of failure\r\n     *\r\n     * @param abortSignal           Abort signal\r\n     * @param checkIntervalSeconds  How often to poll the intermediary for answer\r\n     *\r\n     * @returns {Promise<boolean>}  Was the payment successful? If not we can refund.\r\n     * @throws {IntermediaryError} If a swap is determined expired by the intermediary, but it is actually still valid\r\n     * @throws {SignatureVerificationError} If the swap should be cooperatively refundable but the intermediary returned\r\n     *  invalid refund signature\r\n     * @throws {Error} When swap expires or if the swap has invalid state (must be COMMITED)\r\n     */\r\n    async waitForPayment(abortSignal, checkIntervalSeconds) {\r\n        if (this.state === ToBTCSwapState.CLAIMED)\r\n            return Promise.resolve(true);\r\n        if (this.state !== ToBTCSwapState.COMMITED && this.state !== ToBTCSwapState.SOFT_CLAIMED)\r\n            throw new Error(\"Invalid state (not COMMITED)\");\r\n        const abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const result = await Promise.race([\r\n            this.waitTillState(ToBTCSwapState.CLAIMED, \"gte\", abortController.signal),\r\n            this.waitTillIntermediarySwapProcessed(abortController.signal, checkIntervalSeconds)\r\n        ]);\r\n        abortController.abort();\r\n        if (typeof result !== \"object\") {\r\n            if (this.state === ToBTCSwapState.REFUNDABLE)\r\n                throw new Error(\"Swap expired\");\r\n            this.logger.debug(\"waitTillRefunded(): Resolved from state change\");\r\n            return true;\r\n        }\r\n        this.logger.debug(\"waitTillRefunded(): Resolved from intermediary response\");\r\n        switch (result.code) {\r\n            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.PAID:\r\n                return true;\r\n            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.REFUND_DATA:\r\n                await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.isValidRefundAuthorization(this.data, result.data), null, base_1.SignatureVerificationError, abortSignal);\r\n                await this._saveAndEmit(ToBTCSwapState.REFUNDABLE);\r\n                return false;\r\n            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.EXPIRED:\r\n                if (await this.wrapper.contract.isExpired(this._getInitiator(), this.data))\r\n                    throw new Error(\"Swap expired\");\r\n                throw new IntermediaryError_1.IntermediaryError(\"Swap expired\");\r\n            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.NOT_FOUND:\r\n                if (this.state === ToBTCSwapState.CLAIMED)\r\n                    return true;\r\n                throw new Error(\"Intermediary swap not found\");\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Refund\r\n    /**\r\n     * Get the estimated smart chain transaction fee of the refund transaction\r\n     */\r\n    getRefundFee() {\r\n        return this.wrapper.contract.getRefundFee(this.data);\r\n    }\r\n    /**\r\n     * Returns transactions for refunding the swap if the swap is in refundable state, you can check so with isRefundable()\r\n     *\r\n     * @throws {IntermediaryError} If intermediary returns invalid response in case cooperative refund should be used\r\n     * @throws {SignatureVerificationError} If intermediary returned invalid cooperative refund signature\r\n     * @throws {Error} When state is not refundable\r\n     */\r\n    async txsRefund(signer) {\r\n        if (!this.isRefundable())\r\n            throw new Error(\"Must be in REFUNDABLE state or expired!\");\r\n        signer ??= this._getInitiator();\r\n        if (await this.wrapper.contract.isExpired(this._getInitiator(), this.data)) {\r\n            return await this.wrapper.contract.txsRefund(signer, this.data, true, true);\r\n        }\r\n        else {\r\n            const res = await IntermediaryAPI_1.IntermediaryAPI.getRefundAuthorization(this.url, this.getLpIdentifier(), this.data.getSequence());\r\n            if (res.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.REFUND_DATA) {\r\n                return await this.wrapper.contract.txsRefundWithAuthorization(signer, this.data, res.data, true, true);\r\n            }\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid intermediary cooperative message returned\");\r\n        }\r\n    }\r\n    /**\r\n     * Refunds the swap if the swap is in refundable state, you can check so with isRefundable()\r\n     *\r\n     * @param signer Signer to sign the transactions with, must be the same as used in the initialization\r\n     * @param abortSignal               Abort signal\r\n     * @throws {Error} If invalid signer is provided that doesn't match the swap data\r\n     */\r\n    async refund(signer, abortSignal) {\r\n        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsRefund(signer.getAddress()), true, abortSignal);\r\n        this.refundTxId = result[0];\r\n        if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.REFUNDABLE || this.state === ToBTCSwapState.SOFT_CLAIMED) {\r\n            await this._saveAndEmit(ToBTCSwapState.REFUNDED);\r\n        }\r\n        return result[0];\r\n    }\r\n    /**\r\n     * Waits till a swap is refunded, should be called after sending the refund transactions manually\r\n     *\r\n     * @param abortSignal   AbortSignal\r\n     * @throws {Error} When swap is not in a valid state (must be COMMITED)\r\n     * @throws {Error} If we tried to refund but claimer was able to claim first\r\n     */\r\n    async waitTillRefunded(abortSignal) {\r\n        if (this.state === ToBTCSwapState.REFUNDED)\r\n            return Promise.resolve();\r\n        if (this.state !== ToBTCSwapState.COMMITED && this.state !== ToBTCSwapState.SOFT_CLAIMED)\r\n            throw new Error(\"Invalid state (not COMMITED)\");\r\n        const abortController = new AbortController();\r\n        if (abortSignal != null)\r\n            abortSignal.addEventListener(\"abort\", () => abortController.abort(abortSignal.reason));\r\n        const res = await Promise.race([\r\n            this.watchdogWaitTillResult(abortController.signal),\r\n            this.waitTillState(ToBTCSwapState.REFUNDED, \"eq\", abortController.signal).then(() => 0),\r\n            this.waitTillState(ToBTCSwapState.CLAIMED, \"eq\", abortController.signal).then(() => 1),\r\n        ]);\r\n        abortController.abort();\r\n        if (res === 0) {\r\n            this.logger.debug(\"waitTillRefunded(): Resolved from state change (REFUNDED)\");\r\n            return;\r\n        }\r\n        if (res === 1) {\r\n            this.logger.debug(\"waitTillRefunded(): Resolved from state change (CLAIMED)\");\r\n            throw new Error(\"Tried to refund swap, but claimer claimed it in the meantime!\");\r\n        }\r\n        this.logger.debug(\"waitTillRefunded(): Resolved from watchdog\");\r\n        if (res?.type === base_1.SwapCommitStateType.PAID) {\r\n            if (this.claimTxId == null)\r\n                this.claimTxId = await res.getClaimTxId();\r\n            await this._saveAndEmit(ToBTCSwapState.CLAIMED);\r\n            throw new Error(\"Tried to refund swap, but claimer claimed it in the meantime!\");\r\n        }\r\n        if (res?.type === base_1.SwapCommitStateType.NOT_COMMITED) {\r\n            if (this.refundTxId == null && res.getRefundTxId != null)\r\n                this.refundTxId = await res.getRefundTxId();\r\n            await this._saveAndEmit(ToBTCSwapState.REFUNDED);\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        const obj = super.serialize();\r\n        return {\r\n            ...obj,\r\n            networkFee: this.networkFee == null ? null : this.networkFee.toString(10),\r\n            networkFeeBtc: this.networkFeeBtc == null ? null : this.networkFeeBtc.toString(10)\r\n        };\r\n    }\r\n    //////////////////////////////\r\n    //// Swap ticks & sync\r\n    /**\r\n     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain\r\n     *  data\r\n     *\r\n     * @private\r\n     */\r\n    async syncStateFromChain() {\r\n        if (this.state === ToBTCSwapState.CREATED ||\r\n            this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED ||\r\n            this.state === ToBTCSwapState.COMMITED ||\r\n            this.state === ToBTCSwapState.SOFT_CLAIMED ||\r\n            this.state === ToBTCSwapState.REFUNDABLE) {\r\n            let quoteExpired = false;\r\n            if ((this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED)) {\r\n                //Check if quote is still valid\r\n                quoteExpired = await this.verifyQuoteDefinitelyExpired();\r\n            }\r\n            const res = await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));\r\n            switch (res?.type) {\r\n                case base_1.SwapCommitStateType.PAID:\r\n                    if (this.claimTxId == null)\r\n                        this.claimTxId = await res.getClaimTxId();\r\n                    this.state = ToBTCSwapState.CLAIMED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.REFUNDABLE:\r\n                    this.state = ToBTCSwapState.REFUNDABLE;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.EXPIRED:\r\n                    if (this.refundTxId == null && res.getRefundTxId)\r\n                        this.refundTxId = await res.getRefundTxId();\r\n                    this.state = ToBTCSwapState.QUOTE_EXPIRED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.NOT_COMMITED:\r\n                    if (this.refundTxId == null && res.getRefundTxId)\r\n                        this.refundTxId = await res.getRefundTxId();\r\n                    if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.REFUNDABLE) {\r\n                        this.state = ToBTCSwapState.REFUNDED;\r\n                        return true;\r\n                    }\r\n                    break;\r\n                case base_1.SwapCommitStateType.COMMITED:\r\n                    if (this.state !== ToBTCSwapState.COMMITED && this.state !== ToBTCSwapState.REFUNDABLE) {\r\n                        this.state = ToBTCSwapState.COMMITED;\r\n                        return true;\r\n                    }\r\n                    break;\r\n            }\r\n            if ((this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED)) {\r\n                if (quoteExpired) {\r\n                    this.state = ToBTCSwapState.QUOTE_EXPIRED;\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async _sync(save) {\r\n        let changed = await this.syncStateFromChain();\r\n        if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.SOFT_CLAIMED) {\r\n            //Check if that maybe already concluded\r\n            if (await this.checkIntermediarySwapProcessed(false))\r\n                changed = true;\r\n        }\r\n        if (save && changed)\r\n            await this._saveAndEmit();\r\n        return changed;\r\n    }\r\n    async _tick(save) {\r\n        switch (this.state) {\r\n            case ToBTCSwapState.CREATED:\r\n                if (this.expiry < Date.now()) {\r\n                    this.state = ToBTCSwapState.QUOTE_SOFT_EXPIRED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                break;\r\n            case ToBTCSwapState.COMMITED:\r\n            case ToBTCSwapState.SOFT_CLAIMED:\r\n                const expired = await this.wrapper.contract.isExpired(this._getInitiator(), this.data);\r\n                if (expired) {\r\n                    this.state = ToBTCSwapState.REFUNDABLE;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nexports.IToBTCSwap = IToBTCSwap;\r\nvar ToBTCSwapState;\r\n(function (ToBTCSwapState) {\r\n    ToBTCSwapState[ToBTCSwapState[\"REFUNDED\"] = -3] = \"REFUNDED\";\r\n    ToBTCSwapState[ToBTCSwapState[\"QUOTE_EXPIRED\"] = -2] = \"QUOTE_EXPIRED\";\r\n    ToBTCSwapState[ToBTCSwapState[\"QUOTE_SOFT_EXPIRED\"] = -1] = \"QUOTE_SOFT_EXPIRED\";\r\n    ToBTCSwapState[ToBTCSwapState[\"CREATED\"] = 0] = \"CREATED\";\r\n    ToBTCSwapState[ToBTCSwapState[\"COMMITED\"] = 1] = \"COMMITED\";\r\n    ToBTCSwapState[ToBTCSwapState[\"SOFT_CLAIMED\"] = 2] = \"SOFT_CLAIMED\";\r\n    ToBTCSwapState[ToBTCSwapState[\"CLAIMED\"] = 3] = \"CLAIMED\";\r\n    ToBTCSwapState[ToBTCSwapState[\"REFUNDABLE\"] = 4] = \"REFUNDABLE\";\r\n})(ToBTCSwapState = exports.ToBTCSwapState || (exports.ToBTCSwapState = {}));\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5456, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/utils/LNURL.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LNURL = exports.MAIL_REGEX = exports.BASE64_REGEX = exports.isLNURLPaySuccessAction = exports.isLNURLPayResult = exports.isLNURLWithdrawParams = exports.isLNURLPayParams = exports.isLNURLError = exports.isLNURLWithdraw = exports.isLNURLPay = void 0;\r\nconst RequestError_1 = require(\"../errors/RequestError\");\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst UserError_1 = require(\"../errors/UserError\");\r\nconst Utils_1 = require(\"./Utils\");\r\nconst base_1 = require(\"@scure/base\");\r\nconst aes_1 = require(\"@noble/ciphers/aes\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst sha2_1 = require(\"@noble/hashes/sha2\");\r\nfunction isLNURLPay(value) {\r\n    return (typeof value === \"object\" &&\r\n        value != null &&\r\n        value.type === \"pay\" &&\r\n        typeof (value.min) === \"bigint\" &&\r\n        typeof (value.max) === \"bigint\" &&\r\n        typeof value.commentMaxLength === \"number\" &&\r\n        typeof value.shortDescription === \"string\" &&\r\n        (value.longDescription === undefined || typeof value.longDescription === \"string\") &&\r\n        (value.icon === undefined || typeof value.icon === \"string\") &&\r\n        isLNURLPayParams(value.params));\r\n}\r\nexports.isLNURLPay = isLNURLPay;\r\nfunction isLNURLWithdraw(value) {\r\n    return (typeof value === \"object\" &&\r\n        value != null &&\r\n        value.type === \"withdraw\" &&\r\n        typeof (value.min) === \"bigint\" &&\r\n        typeof (value.max) === \"bigint\" &&\r\n        isLNURLWithdrawParams(value.params));\r\n}\r\nexports.isLNURLWithdraw = isLNURLWithdraw;\r\nfunction isLNURLError(obj) {\r\n    return obj.status === \"ERROR\" &&\r\n        (obj.reason == null || typeof obj.reason === \"string\");\r\n}\r\nexports.isLNURLError = isLNURLError;\r\nfunction isLNURLPayParams(obj) {\r\n    return obj.tag === \"payRequest\";\r\n}\r\nexports.isLNURLPayParams = isLNURLPayParams;\r\nfunction isLNURLWithdrawParams(obj) {\r\n    return obj.tag === \"withdrawRequest\";\r\n}\r\nexports.isLNURLWithdrawParams = isLNURLWithdrawParams;\r\nfunction isLNURLPayResult(obj, domain) {\r\n    return typeof obj.pr === \"string\" &&\r\n        (obj.routes == null || Array.isArray(obj.routes)) &&\r\n        (obj.disposable === null || obj.disposable === undefined || typeof obj.disposable === \"boolean\") &&\r\n        (obj.successAction == null || isLNURLPaySuccessAction(obj.successAction, domain));\r\n}\r\nexports.isLNURLPayResult = isLNURLPayResult;\r\nfunction isLNURLPaySuccessAction(obj, domain) {\r\n    if (obj == null || typeof obj !== 'object' || typeof obj.tag !== 'string')\r\n        return false;\r\n    switch (obj.tag) {\r\n        case \"message\":\r\n            return obj.message != null && obj.message.length <= 144;\r\n        case \"url\":\r\n            return obj.description != null && obj.description.length <= 144 &&\r\n                obj.url != null &&\r\n                (domain == null || new URL(obj.url).hostname === domain);\r\n        case \"aes\":\r\n            return obj.description != null && obj.description.length <= 144 &&\r\n                obj.ciphertext != null && obj.ciphertext.length <= 4096 && exports.BASE64_REGEX.test(obj.ciphertext) &&\r\n                obj.iv != null && obj.iv.length <= 24 && exports.BASE64_REGEX.test(obj.iv);\r\n        default:\r\n            //Unsupported action\r\n            return false;\r\n    }\r\n}\r\nexports.isLNURLPaySuccessAction = isLNURLPaySuccessAction;\r\nexports.BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\r\nexports.MAIL_REGEX = /(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[A-z0-9](?:[A-z0-9-]*[A-z0-9])?\\.)+[A-z0-9](?:[A-z0-9-]*[A-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[A-z0-9-]*[A-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])/;\r\nclass LNURL {\r\n    static findBech32LNURL(str) {\r\n        const arr = /,*?((lnurl)([0-9]{1,}[a-z0-9]+){1})/.exec(str.toLowerCase());\r\n        if (arr == null)\r\n            return null;\r\n        return arr[1];\r\n    }\r\n    static isBech32LNURL(str) {\r\n        return this.findBech32LNURL(str) != null;\r\n    }\r\n    /**\r\n     * Checks whether a provided string is bare (non bech32 encoded) lnurl\r\n     * @param str\r\n     * @private\r\n     */\r\n    static isBareLNURL(str) {\r\n        try {\r\n            return str.startsWith(\"lnurlw://\") || str.startsWith(\"lnurlp://\");\r\n        }\r\n        catch (e) { }\r\n        return false;\r\n    }\r\n    /**\r\n     * Checks if the provided string is a lightning network address (e.g. satoshi@nakamoto.com)\r\n     * @param str\r\n     * @private\r\n     */\r\n    static isLightningAddress(str) {\r\n        return exports.MAIL_REGEX.test(str);\r\n    }\r\n    /**\r\n     * Checks whether a given string is a LNURL or lightning address\r\n     * @param str\r\n     */\r\n    static isLNURL(str) {\r\n        return LNURL.isBech32LNURL(str) || LNURL.isLightningAddress(str) || LNURL.isBareLNURL(str);\r\n    }\r\n    /**\r\n     * Extracts the URL that needs to be request from LNURL or lightning address\r\n     * @param str\r\n     * @private\r\n     * @returns An URL to send the request to, or null if it cannot be parsed\r\n     */\r\n    static extractCallUrl(str) {\r\n        if (exports.MAIL_REGEX.test(str)) {\r\n            //lightning e-mail like address\r\n            const arr = str.split(\"@\");\r\n            const username = arr[0];\r\n            const domain = arr[1];\r\n            let scheme = \"https\";\r\n            if (domain.endsWith(\".onion\")) {\r\n                scheme = \"http\";\r\n            }\r\n            return scheme + \"://\" + domain + \"/.well-known/lnurlp/\" + username;\r\n        }\r\n        else if (LNURL.isBareLNURL(str)) {\r\n            //non-bech32m encoded lnurl\r\n            const data = str.substring(\"lnurlw://\".length);\r\n            const httpUrl = new URL(\"http://\" + data);\r\n            let scheme = \"https\";\r\n            if (httpUrl.hostname.endsWith(\".onion\")) {\r\n                scheme = \"http\";\r\n            }\r\n            return scheme + \"://\" + data;\r\n        }\r\n        else {\r\n            const lnurl = LNURL.findBech32LNURL(str);\r\n            if (lnurl != null) {\r\n                let { prefix: hrp, words: dataPart } = base_1.bech32.decode(lnurl, 2000);\r\n                let requestByteArray = base_1.bech32.fromWords(dataPart);\r\n                return buffer_1.Buffer.from(requestByteArray).toString();\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Sends a request to obtain data about a specific LNURL or lightning address\r\n     *\r\n     * @param str A lnurl or lightning address\r\n     * @param shouldRetry Whether we should retry in case of network failure\r\n     * @param timeout Request timeout in milliseconds\r\n     * @param abortSignal\r\n     */\r\n    static async getLNURL(str, shouldRetry = true, timeout, abortSignal) {\r\n        if (shouldRetry == null)\r\n            shouldRetry = true;\r\n        const url = LNURL.extractCallUrl(str);\r\n        if (url != null) {\r\n            const sendRequest = () => (0, Utils_1.httpGet)(url, timeout, abortSignal, true);\r\n            let response = shouldRetry ?\r\n                await (0, Utils_1.tryWithRetries)(sendRequest, null, RequestError_1.RequestError, abortSignal) :\r\n                await sendRequest();\r\n            if (isLNURLError(response))\r\n                return null;\r\n            if (response.tag === \"payRequest\")\r\n                try {\r\n                    response.decodedMetadata = JSON.parse(response.metadata);\r\n                }\r\n                catch (err) {\r\n                    response.decodedMetadata = [];\r\n                }\r\n            if (!isLNURLPayParams(response) && !isLNURLWithdrawParams(response))\r\n                return null;\r\n            return {\r\n                ...response,\r\n                url: str\r\n            };\r\n        }\r\n    }\r\n    /**\r\n     * Sends a request to obtain data about a specific LNURL or lightning address\r\n     *\r\n     * @param str A lnurl or lightning address\r\n     * @param shouldRetry Whether we should retry in case of network failure\r\n     * @param timeout Request timeout in milliseconds\r\n     * @param abortSignal\r\n     */\r\n    static async getLNURLType(str, shouldRetry, timeout, abortSignal) {\r\n        let res = await LNURL.getLNURL(str, shouldRetry, timeout, abortSignal);\r\n        if (res.tag === \"payRequest\") {\r\n            const payRequest = res;\r\n            let shortDescription;\r\n            let longDescription;\r\n            let icon;\r\n            payRequest.decodedMetadata.forEach(data => {\r\n                switch (data[0]) {\r\n                    case \"text/plain\":\r\n                        shortDescription = data[1];\r\n                        break;\r\n                    case \"text/long-desc\":\r\n                        longDescription = data[1];\r\n                        break;\r\n                    case \"image/png;base64\":\r\n                        icon = \"data:\" + data[0] + \",\" + data[1];\r\n                        break;\r\n                    case \"image/jpeg;base64\":\r\n                        icon = \"data:\" + data[0] + \",\" + data[1];\r\n                        break;\r\n                }\r\n            });\r\n            return {\r\n                type: \"pay\",\r\n                min: BigInt(payRequest.minSendable) / 1000n,\r\n                max: BigInt(payRequest.maxSendable) / 1000n,\r\n                commentMaxLength: payRequest.commentAllowed || 0,\r\n                shortDescription,\r\n                longDescription,\r\n                icon,\r\n                params: payRequest\r\n            };\r\n        }\r\n        if (res.tag === \"withdrawRequest\") {\r\n            const payRequest = res;\r\n            return {\r\n                type: \"withdraw\",\r\n                min: BigInt(payRequest.minWithdrawable) / 1000n,\r\n                max: BigInt(payRequest.maxWithdrawable) / 1000n,\r\n                params: payRequest\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Uses a LNURL-pay request by obtaining a lightning network invoice from it\r\n     *\r\n     * @param payRequest LNURL params as returned from the getLNURL call\r\n     * @param amount Amount of sats (BTC) to pay\r\n     * @param comment Optional comment for the payment request\r\n     * @param timeout Request timeout in milliseconds\r\n     * @param abortSignal\r\n     * @throws {RequestError} If the response is non-200, status: ERROR, or invalid format\r\n     */\r\n    static async useLNURLPay(payRequest, amount, comment, timeout, abortSignal) {\r\n        const params = [\"amount=\" + (amount * 1000n).toString(10)];\r\n        if (comment != null) {\r\n            params.push(\"comment=\" + encodeURIComponent(comment));\r\n        }\r\n        const queryParams = (payRequest.callback.includes(\"?\") ? \"&\" : \"?\") + params.join(\"&\");\r\n        const response = await (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(payRequest.callback + queryParams, timeout, abortSignal, true), null, RequestError_1.RequestError, abortSignal);\r\n        if (isLNURLError(response))\r\n            throw new RequestError_1.RequestError(\"LNURL callback error: \" + response.reason, 200);\r\n        if (!isLNURLPayResult(response))\r\n            throw new RequestError_1.RequestError(\"Invalid LNURL response!\", 200);\r\n        const parsedPR = (0, bolt11_1.decode)(response.pr);\r\n        const descHash = buffer_1.Buffer.from((0, sha2_1.sha256)(payRequest.metadata)).toString(\"hex\");\r\n        if (parsedPR.tagsObject.purpose_commit_hash !== descHash)\r\n            throw new RequestError_1.RequestError(\"Invalid invoice received (description hash)!\", 200);\r\n        const invoiceMSats = BigInt(parsedPR.millisatoshis);\r\n        if (invoiceMSats !== (amount * 1000n))\r\n            throw new RequestError_1.RequestError(\"Invalid invoice received (amount)!\", 200);\r\n        return {\r\n            invoice: response.pr,\r\n            parsedInvoice: parsedPR,\r\n            successAction: response.successAction\r\n        };\r\n    }\r\n    /**\r\n     * Submits the bolt11 lightning invoice to the lnurl withdraw url\r\n     *\r\n     * @param withdrawRequest Withdraw request to use\r\n     * @param withdrawRequest.k1 K1 parameter\r\n     * @param withdrawRequest.callback A URL to call\r\n     * @param lnpr bolt11 lightning network invoice to submit to the withdrawal endpoint\r\n     * @throws {RequestError} If the response is non-200 or status: ERROR\r\n     */\r\n    static async postInvoiceToLNURLWithdraw(withdrawRequest, lnpr) {\r\n        const params = [\r\n            \"pr=\" + lnpr,\r\n            \"k1=\" + withdrawRequest.k1\r\n        ];\r\n        const queryParams = (withdrawRequest.callback.includes(\"?\") ? \"&\" : \"?\") + params.join(\"&\");\r\n        const response = await (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(withdrawRequest.callback + queryParams, null, null, true), null, RequestError_1.RequestError);\r\n        if (isLNURLError(response))\r\n            throw new RequestError_1.RequestError(\"LNURL callback error: \" + response.reason, 200);\r\n    }\r\n    /**\r\n     * Uses a LNURL-withdraw request by submitting a lightning network invoice to it\r\n     *\r\n     * @param withdrawRequest Withdrawal request as returned from getLNURL call\r\n     * @param lnpr bolt11 lightning network invoice to submit to the withdrawal endpoint\r\n     * @throws {UserError} In case the provided bolt11 lightning invoice has an amount that is out of bounds for\r\n     *  the specified LNURL-withdraw request\r\n     */\r\n    static async useLNURLWithdraw(withdrawRequest, lnpr) {\r\n        const min = BigInt(withdrawRequest.minWithdrawable) / 1000n;\r\n        const max = BigInt(withdrawRequest.maxWithdrawable) / 1000n;\r\n        const parsedPR = (0, bolt11_1.decode)(lnpr);\r\n        const amount = (BigInt(parsedPR.millisatoshis) + 999n) / 1000n;\r\n        if (amount < min)\r\n            throw new UserError_1.UserError(\"Invoice amount less than minimum LNURL-withdraw limit\");\r\n        if (amount > max)\r\n            throw new UserError_1.UserError(\"Invoice amount more than maximum LNURL-withdraw limit\");\r\n        return await LNURL.postInvoiceToLNURLWithdraw(withdrawRequest, lnpr);\r\n    }\r\n    static decodeSuccessAction(successAction, secret) {\r\n        if (secret == null)\r\n            return null;\r\n        if (successAction.tag === \"message\") {\r\n            return {\r\n                description: successAction.message\r\n            };\r\n        }\r\n        if (successAction.tag === \"url\") {\r\n            return {\r\n                description: successAction.description,\r\n                url: successAction.url\r\n            };\r\n        }\r\n        if (successAction.tag === \"aes\") {\r\n            const CBC = (0, aes_1.cbc)(buffer_1.Buffer.from(secret, \"hex\"), buffer_1.Buffer.from(successAction.iv, \"hex\"));\r\n            let plaintext = CBC.decrypt(buffer_1.Buffer.from(successAction.ciphertext, \"base64\"));\r\n            // remove padding\r\n            const size = plaintext.length;\r\n            const pad = plaintext[size - 1];\r\n            return {\r\n                description: successAction.description,\r\n                text: buffer_1.Buffer.from(plaintext).toString(\"utf8\", 0, size - pad)\r\n            };\r\n        }\r\n    }\r\n}\r\nexports.LNURL = LNURL;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5750, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ToBTCLNSwap = exports.isToBTCLNSwapInit = void 0;\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst IToBTCSwap_1 = require(\"../IToBTCSwap\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst sha2_1 = require(\"@noble/hashes/sha2\");\r\nconst IntermediaryError_1 = require(\"../../../../errors/IntermediaryError\");\r\nconst LNURL_1 = require(\"../../../../utils/LNURL\");\r\nconst Tokens_1 = require(\"../../../../Tokens\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nfunction isToBTCLNSwapInit(obj) {\r\n    return typeof (obj.confidence) === \"number\" &&\r\n        typeof (obj.pr) === \"string\" &&\r\n        (obj.lnurl == null || typeof (obj.lnurl) === \"string\") &&\r\n        (obj.successAction == null || (0, LNURL_1.isLNURLPaySuccessAction)(obj.successAction)) &&\r\n        (0, IToBTCSwap_1.isIToBTCSwapInit)(obj);\r\n}\r\nexports.isToBTCLNSwapInit = isToBTCLNSwapInit;\r\n//Set of nodes which disallow probing, resulting in 0 confidence reported by the LP\r\nconst SNOWFLAKE_LIST = new Set([\r\n    \"038f8f113c580048d847d6949371726653e02b928196bad310e3eda39ff61723f6\",\r\n    \"03a6ce61fcaacd38d31d4e3ce2d506602818e3856b4b44faff1dde9642ba705976\"\r\n]);\r\nclass ToBTCLNSwap extends IToBTCSwap_1.IToBTCSwap {\r\n    constructor(wrapper, initOrObj) {\r\n        if (isToBTCLNSwapInit(initOrObj))\r\n            initOrObj.url += \"/tobtcln\";\r\n        super(wrapper, initOrObj);\r\n        this.outputToken = Tokens_1.BitcoinTokens.BTCLN;\r\n        this.TYPE = SwapType_1.SwapType.TO_BTCLN;\r\n        if (!isToBTCLNSwapInit(initOrObj)) {\r\n            this.confidence = initOrObj.confidence;\r\n            this.pr = initOrObj.pr;\r\n            this.lnurl = initOrObj.lnurl;\r\n            this.successAction = initOrObj.successAction;\r\n            this.secret = initOrObj.secret;\r\n        }\r\n        this.paymentHash = this.getPaymentHash().toString(\"hex\");\r\n        this.logger = (0, Utils_1.getLogger)(\"ToBTCLN(\" + this.getIdentifierHashString() + \"): \");\r\n        this.tryRecomputeSwapPrice();\r\n    }\r\n    _setPaymentResult(result, check = false) {\r\n        if (result == null)\r\n            return Promise.resolve(false);\r\n        if (result.secret == null)\r\n            throw new IntermediaryError_1.IntermediaryError(\"No payment secret returned!\");\r\n        if (check) {\r\n            const secretBuffer = buffer_1.Buffer.from(result.secret, \"hex\");\r\n            const hash = buffer_1.Buffer.from((0, sha2_1.sha256)(secretBuffer));\r\n            if (!hash.equals(this.getPaymentHash()))\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid payment secret returned\");\r\n        }\r\n        this.secret = result.secret;\r\n        return Promise.resolve(true);\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getOutput() {\r\n        const parsedPR = (0, bolt11_1.decode)(this.pr);\r\n        const amount = (BigInt(parsedPR.millisatoshis) + 999n) / 1000n;\r\n        return (0, Tokens_1.toTokenAmount)(amount, this.outputToken, this.wrapper.prices);\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    getOutputTxId() {\r\n        return this.getLpIdentifier();\r\n    }\r\n    /**\r\n     * Returns the lightning BOLT11 invoice where the BTC will be sent to\r\n     */\r\n    getOutputAddress() {\r\n        return this.lnurl ?? this.pr;\r\n    }\r\n    /**\r\n     * Returns payment secret (pre-image) as a proof of payment\r\n     */\r\n    getSecret() {\r\n        return this.secret;\r\n    }\r\n    /**\r\n     * Returns the confidence of the intermediary that this payment will succeed\r\n     * Value between 0 and 1, where 0 is not likely and 1 is very likely\r\n     */\r\n    getConfidence() {\r\n        return this.confidence;\r\n    }\r\n    /**\r\n     * Checks whether a swap is likely to fail, based on the confidence as reported by the LP\r\n     */\r\n    willLikelyFail() {\r\n        const parsedRequest = (0, bolt11_1.decode)(this.pr);\r\n        if (parsedRequest.tagsObject.routing_info != null) {\r\n            for (let route of parsedRequest.tagsObject.routing_info) {\r\n                if (SNOWFLAKE_LIST.has(route.pubkey)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return this.confidence === 0;\r\n    }\r\n    /**\r\n     * Tries to detect if the target lightning invoice is a non-custodial mobile wallet, care must be taken\r\n     *  for such a wallet to be online when attempting to make a swap\r\n     */\r\n    isPayingToNonCustodialWallet() {\r\n        const parsedRequest = (0, bolt11_1.decode)(this.pr);\r\n        if (parsedRequest.tagsObject.routing_info != null) {\r\n            return parsedRequest.tagsObject.routing_info.length > 0;\r\n        }\r\n        return false;\r\n    }\r\n    getIdentifierHash() {\r\n        const paymentHashBuffer = this.getPaymentHash();\r\n        if (this.randomNonce == null)\r\n            return paymentHashBuffer;\r\n        return buffer_1.Buffer.concat([paymentHashBuffer, buffer_1.Buffer.from(this.randomNonce, \"hex\")]);\r\n    }\r\n    getPaymentHash() {\r\n        if (this.pr == null)\r\n            return null;\r\n        const parsed = (0, bolt11_1.decode)(this.pr);\r\n        return buffer_1.Buffer.from(parsed.tagsObject.payment_hash, \"hex\");\r\n    }\r\n    getLpIdentifier() {\r\n        if (this.pr == null)\r\n            return null;\r\n        const parsed = (0, bolt11_1.decode)(this.pr);\r\n        return parsed.tagsObject.payment_hash;\r\n    }\r\n    //////////////////////////////\r\n    //// LNURL-pay\r\n    /**\r\n     * Is this an LNURL-pay swap?\r\n     */\r\n    isLNURL() {\r\n        return this.lnurl != null;\r\n    }\r\n    /**\r\n     * Gets the used LNURL or null if this is not an LNURL-pay swap\r\n     */\r\n    getLNURL() {\r\n        return this.lnurl;\r\n    }\r\n    /**\r\n     * Checks whether this LNURL payment contains a success message\r\n     */\r\n    hasSuccessAction() {\r\n        return this.successAction != null;\r\n    }\r\n    /**\r\n     * Returns the success action after a successful payment, else null\r\n     */\r\n    getSuccessAction() {\r\n        return LNURL_1.LNURL.decodeSuccessAction(this.successAction, this.secret);\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            paymentHash: this.getPaymentHash().toString(\"hex\"),\r\n            pr: this.pr,\r\n            confidence: this.confidence,\r\n            secret: this.secret,\r\n            lnurl: this.lnurl,\r\n            successAction: this.successAction\r\n        };\r\n    }\r\n}\r\nexports.ToBTCLNSwap = ToBTCLNSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5912, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwapWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IEscrowSwapWrapper = void 0;\r\nconst ISwapWrapper_1 = require(\"../ISwapWrapper\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nclass IEscrowSwapWrapper extends ISwapWrapper_1.ISwapWrapper {\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events) {\r\n        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events);\r\n        this.swapDataDeserializer = swapDataDeserializer;\r\n        this.contract = contract;\r\n    }\r\n    /**\r\n     * Pre-fetches signature verification data from the server's pre-sent promise, doesn't throw, instead returns null\r\n     *\r\n     * @param signDataPrefetch Promise that resolves when we receive \"signDataPrefetch\" from the LP in streaming mode\r\n     * @protected\r\n     * @returns Pre-fetched signature verification data or null if failed\r\n     */\r\n    preFetchSignData(signDataPrefetch) {\r\n        if (this.contract.preFetchForInitSignatureVerification == null)\r\n            return Promise.resolve(null);\r\n        return signDataPrefetch.then(obj => {\r\n            if (obj == null)\r\n                return null;\r\n            return this.contract.preFetchForInitSignatureVerification(obj);\r\n        }).catch(e => {\r\n            this.logger.error(\"preFetchSignData(): Error: \", e);\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies swap initialization signature returned by the intermediary\r\n     *\r\n     * @param initiator A smart chain account initiating the swap\r\n     * @param data Parsed swap data from the intermediary\r\n     * @param signature Response of the intermediary\r\n     * @param feeRatePromise Pre-fetched fee rate promise\r\n     * @param preFetchSignatureVerificationData Pre-fetched signature verification data\r\n     * @param abortSignal\r\n     * @protected\r\n     * @returns Swap initialization signature expiry\r\n     * @throws {SignatureVerificationError} when swap init signature is invalid\r\n     */\r\n    async verifyReturnedSignature(initiator, data, signature, feeRatePromise, preFetchSignatureVerificationData, abortSignal) {\r\n        const [feeRate, preFetchedSignatureData] = await Promise.all([feeRatePromise, preFetchSignatureVerificationData]);\r\n        await (0, Utils_1.tryWithRetries)(() => this.contract.isValidInitAuthorization(initiator, data, signature, feeRate, preFetchedSignatureData), null, base_1.SignatureVerificationError, abortSignal);\r\n        return await (0, Utils_1.tryWithRetries)(() => this.contract.getInitAuthorizationExpiry(data, signature, preFetchedSignatureData), null, base_1.SignatureVerificationError, abortSignal);\r\n    }\r\n    /**\r\n     * Processes a single SC on-chain event\r\n     * @private\r\n     * @param event\r\n     * @param swap\r\n     */\r\n    async processEvent(event, swap) {\r\n        if (swap == null)\r\n            return;\r\n        let swapChanged = false;\r\n        if (event instanceof base_1.InitializeEvent) {\r\n            swapChanged = await this.processEventInitialize(swap, event);\r\n            if (event.meta?.txId != null && swap.commitTxId !== event.meta.txId) {\r\n                swap.commitTxId = event.meta.txId;\r\n                swapChanged ||= true;\r\n            }\r\n        }\r\n        if (event instanceof base_1.ClaimEvent) {\r\n            swapChanged = await this.processEventClaim(swap, event);\r\n            if (event.meta?.txId != null && swap.claimTxId !== event.meta.txId) {\r\n                swap.claimTxId = event.meta.txId;\r\n                swapChanged ||= true;\r\n            }\r\n        }\r\n        if (event instanceof base_1.RefundEvent) {\r\n            swapChanged = await this.processEventRefund(swap, event);\r\n            if (event.meta?.txId != null && swap.refundTxId !== event.meta.txId) {\r\n                swap.refundTxId = event.meta.txId;\r\n                swapChanged ||= true;\r\n            }\r\n        }\r\n        this.logger.info(\"processEvents(): \" + event.constructor.name + \" processed for \" + swap.getId() + \" swap: \", swap);\r\n        if (swapChanged) {\r\n            await swap._saveAndEmit();\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexports.IEscrowSwapWrapper = IEscrowSwapWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6005, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IToBTCWrapper = void 0;\r\nconst IToBTCSwap_1 = require(\"./IToBTCSwap\");\r\nconst Utils_1 = require(\"../../../utils/Utils\");\r\nconst IntermediaryError_1 = require(\"../../../errors/IntermediaryError\");\r\nconst IEscrowSwapWrapper_1 = require(\"../IEscrowSwapWrapper\");\r\nclass IToBTCWrapper extends IEscrowSwapWrapper_1.IEscrowSwapWrapper {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.pendingSwapStates = [\r\n            IToBTCSwap_1.ToBTCSwapState.CREATED,\r\n            IToBTCSwap_1.ToBTCSwapState.QUOTE_SOFT_EXPIRED,\r\n            IToBTCSwap_1.ToBTCSwapState.COMMITED,\r\n            IToBTCSwap_1.ToBTCSwapState.SOFT_CLAIMED,\r\n            IToBTCSwap_1.ToBTCSwapState.REFUNDABLE\r\n        ];\r\n        this.tickSwapState = [IToBTCSwap_1.ToBTCSwapState.CREATED, IToBTCSwap_1.ToBTCSwapState.COMMITED, IToBTCSwap_1.ToBTCSwapState.SOFT_CLAIMED];\r\n        this.refundableSwapStates = [IToBTCSwap_1.ToBTCSwapState.REFUNDABLE];\r\n    }\r\n    /**\r\n     * Pre-fetches intermediary's reputation, doesn't throw, instead aborts via abortController and returns null\r\n     *\r\n     * @param amountData\r\n     * @param lp Intermediary\r\n     * @param abortController\r\n     * @protected\r\n     * @returns Intermediary's reputation or null if failed\r\n     * @throws {IntermediaryError} If the intermediary vault doesn't exist\r\n     */\r\n    preFetchIntermediaryReputation(amountData, lp, abortController) {\r\n        return lp.getReputation(this.chainIdentifier, this.contract, [amountData.token.toString()], abortController.signal).then(res => {\r\n            if (res == null)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid data returned - invalid LP vault\");\r\n            return res;\r\n        }).catch(e => {\r\n            this.logger.warn(\"preFetchIntermediaryReputation(): Error: \", e);\r\n            abortController.abort(e);\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Pre-fetches feeRate for a given swap\r\n     *\r\n     * @param signer Address of the swap initiator\r\n     * @param amountData\r\n     * @param claimHash optional hash of the swap or null\r\n     * @param abortController\r\n     * @protected\r\n     * @returns Fee rate\r\n     */\r\n    preFetchFeeRate(signer, amountData, claimHash, abortController) {\r\n        return (0, Utils_1.tryWithRetries)(() => this.contract.getInitPayInFeeRate(signer, null, amountData.token, claimHash), null, null, abortController.signal).catch(e => {\r\n            this.logger.warn(\"preFetchFeeRate(): Error: \", e);\r\n            abortController.abort(e);\r\n            return null;\r\n        });\r\n    }\r\n    async processEventInitialize(swap, event) {\r\n        if (swap.state === IToBTCSwap_1.ToBTCSwapState.CREATED || swap.state === IToBTCSwap_1.ToBTCSwapState.QUOTE_SOFT_EXPIRED) {\r\n            const swapData = await event.swapData();\r\n            if (swap.data != null && !swap.data.equals(swapData))\r\n                return false;\r\n            if (swap.state === IToBTCSwap_1.ToBTCSwapState.CREATED || swap.state === IToBTCSwap_1.ToBTCSwapState.QUOTE_SOFT_EXPIRED)\r\n                swap.state = IToBTCSwap_1.ToBTCSwapState.COMMITED;\r\n            swap.data = swapData;\r\n            return true;\r\n        }\r\n    }\r\n    processEventClaim(swap, event) {\r\n        if (swap.state !== IToBTCSwap_1.ToBTCSwapState.REFUNDED && swap.state !== IToBTCSwap_1.ToBTCSwapState.CLAIMED) {\r\n            swap.state = IToBTCSwap_1.ToBTCSwapState.CLAIMED;\r\n            swap._setPaymentResult({ secret: event.result, txId: Buffer.from(event.result, \"hex\").reverse().toString(\"hex\") });\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    processEventRefund(swap, event) {\r\n        if (swap.state !== IToBTCSwap_1.ToBTCSwapState.CLAIMED && swap.state !== IToBTCSwap_1.ToBTCSwapState.REFUNDED) {\r\n            swap.state = IToBTCSwap_1.ToBTCSwapState.REFUNDED;\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n}\r\nexports.IToBTCWrapper = IToBTCWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6104, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ToBTCLNWrapper = void 0;\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst ToBTCLNSwap_1 = require(\"./ToBTCLNSwap\");\r\nconst IToBTCWrapper_1 = require(\"../IToBTCWrapper\");\r\nconst UserError_1 = require(\"../../../../errors/UserError\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst IntermediaryError_1 = require(\"../../../../errors/IntermediaryError\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nconst IntermediaryAPI_1 = require(\"../../../../intermediaries/IntermediaryAPI\");\r\nconst RequestError_1 = require(\"../../../../errors/RequestError\");\r\nconst LNURL_1 = require(\"../../../../utils/LNURL\");\r\nconst IToBTCSwap_1 = require(\"../IToBTCSwap\");\r\nclass ToBTCLNWrapper extends IToBTCWrapper_1.IToBTCWrapper {\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events) {\r\n        if (options == null)\r\n            options = {};\r\n        options.paymentTimeoutSeconds ??= 4 * 24 * 60 * 60;\r\n        options.lightningBaseFee ??= 10;\r\n        options.lightningFeePPM ??= 2000;\r\n        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);\r\n        this.TYPE = SwapType_1.SwapType.TO_BTCLN;\r\n        this.swapDeserializer = ToBTCLNSwap_1.ToBTCLNSwap;\r\n    }\r\n    async checkPaymentHashWasPaid(paymentHash) {\r\n        const swaps = await this.unifiedStorage.query([[{ key: \"type\", value: this.TYPE }, { key: \"paymentHash\", value: paymentHash }]], (obj) => new this.swapDeserializer(this, obj));\r\n        for (let value of swaps) {\r\n            if (value.state === IToBTCSwap_1.ToBTCSwapState.CLAIMED || value.state === IToBTCSwap_1.ToBTCSwapState.SOFT_CLAIMED)\r\n                throw new UserError_1.UserError(\"Lightning invoice was already paid!\");\r\n        }\r\n    }\r\n    /**\r\n     * Calculates maximum lightning network routing fee based on amount\r\n     *\r\n     * @param amount BTC amount of the swap in satoshis\r\n     * @param overrideBaseFee Override wrapper's default base fee\r\n     * @param overrideFeePPM Override wrapper's default PPM\r\n     * @private\r\n     * @returns Maximum lightning routing fee in sats\r\n     */\r\n    calculateFeeForAmount(amount, overrideBaseFee, overrideFeePPM) {\r\n        return BigInt(overrideBaseFee ?? this.options.lightningBaseFee)\r\n            + (amount * BigInt(overrideFeePPM ?? this.options.lightningFeePPM) / 1000000n);\r\n    }\r\n    /**\r\n     * Verifies returned LP data\r\n     *\r\n     * @param resp Response as returned by the LP\r\n     * @param parsedPr Parsed bolt11 lightning invoice\r\n     * @param token Smart chain token to be used in the swap\r\n     * @param lp\r\n     * @param options Swap options as passed to the swap create function\r\n     * @param data Parsed swap data returned by the LP\r\n     * @param requiredTotal Required total to be paid on the input (for exactIn swaps)\r\n     * @private\r\n     * @throws {IntermediaryError} In case the response is not valid\r\n     */\r\n    async verifyReturnedData(resp, parsedPr, token, lp, options, data, requiredTotal) {\r\n        if (resp.routingFeeSats > await options.maxFee)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid max fee sats returned\");\r\n        if (requiredTotal != null && resp.total !== requiredTotal)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid data returned - total amount\");\r\n        const claimHash = this.contract.getHashForHtlc(Buffer.from(parsedPr.tagsObject.payment_hash, \"hex\"));\r\n        if (data.getAmount() !== resp.total ||\r\n            !Buffer.from(data.getClaimHash(), \"hex\").equals(claimHash) ||\r\n            data.getExpiry() !== options.expiryTimestamp ||\r\n            data.getType() !== base_1.ChainSwapType.HTLC ||\r\n            !data.isPayIn() ||\r\n            !data.isToken(token) ||\r\n            data.getClaimer() !== lp.getAddress(this.chainIdentifier)) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid data returned\");\r\n        }\r\n    }\r\n    /**\r\n     * Returns the quote/swap from a given intermediary\r\n     *\r\n     * @param signer Smartchain signer initiating the swap\r\n     * @param amountData\r\n     * @param lp Intermediary\r\n     * @param pr bolt11 lightning network invoice\r\n     * @param parsedPr Parsed bolt11 lightning network invoice\r\n     * @param options Options as passed to the swap create function\r\n     * @param preFetches\r\n     * @param abort Abort signal or controller, if AbortController is passed it is used as-is, when AbortSignal is passed\r\n     *  it is extended with extendAbortController and then used\r\n     * @param additionalParams Additional params that should be sent to the LP\r\n     * @private\r\n     */\r\n    async getIntermediaryQuote(signer, amountData, lp, pr, parsedPr, options, preFetches, abort, additionalParams) {\r\n        const abortController = abort instanceof AbortController ? abort : (0, Utils_1.extendAbortController)(abort);\r\n        preFetches.reputationPromise ??= this.preFetchIntermediaryReputation(amountData, lp, abortController);\r\n        try {\r\n            const { signDataPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount) => {\r\n                const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.initToBTCLN(this.chainIdentifier, lp.url, {\r\n                    offerer: signer,\r\n                    pr,\r\n                    maxFee: await options.maxFee,\r\n                    expiryTimestamp: options.expiryTimestamp,\r\n                    token: amountData.token,\r\n                    feeRate: preFetches.feeRatePromise,\r\n                    additionalParams\r\n                }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);\r\n                return {\r\n                    signDataPromise: this.preFetchSignData(signDataPrefetch),\r\n                    resp: await response\r\n                };\r\n            }, null, e => e instanceof RequestError_1.RequestError, abortController.signal);\r\n            const amountOut = (BigInt(parsedPr.millisatoshis) + 999n) / 1000n;\r\n            const totalFee = resp.swapFee + resp.maxFee;\r\n            const data = new this.swapDataDeserializer(resp.data);\r\n            data.setOfferer(signer);\r\n            await this.verifyReturnedData(resp, parsedPr, amountData.token, lp, options, data);\r\n            const [pricingInfo, signatureExpiry, reputation] = await Promise.all([\r\n                this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.TO_BTCLN], true, amountOut, data.getAmount(), amountData.token, { networkFee: resp.maxFee }, preFetches.pricePreFetchPromise, abortController.signal),\r\n                this.verifyReturnedSignature(signer, data, resp, preFetches.feeRatePromise, signDataPromise, abortController.signal),\r\n                preFetches.reputationPromise\r\n            ]);\r\n            abortController.signal.throwIfAborted();\r\n            lp.reputation[amountData.token.toString()] = reputation;\r\n            const quote = new ToBTCLNSwap_1.ToBTCLNSwap(this, {\r\n                pricingInfo,\r\n                url: lp.url,\r\n                expiry: signatureExpiry,\r\n                swapFee: resp.swapFee,\r\n                feeRate: await preFetches.feeRatePromise,\r\n                signatureData: resp,\r\n                data,\r\n                networkFee: resp.maxFee,\r\n                networkFeeBtc: resp.routingFeeSats,\r\n                confidence: resp.confidence,\r\n                pr,\r\n                exactIn: false\r\n            });\r\n            await quote._save();\r\n            return quote;\r\n        }\r\n        catch (e) {\r\n            abortController.abort(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a newly created swap, paying for 'bolt11PayRequest' - a bitcoin LN invoice\r\n     *\r\n     * @param signer                Smartchain signer's address initiating the swap\r\n     * @param bolt11PayRequest      BOLT11 payment request (bitcoin lightning invoice) you wish to pay\r\n     * @param amountData            Amount of token & amount to swap\r\n     * @param lps                   LPs (liquidity providers) to get the quotes from\r\n     * @param options               Quote options\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param abortSignal           Abort signal for aborting the process\r\n     * @param preFetches            Existing pre-fetches for the swap (only used internally for LNURL swaps)\r\n     */\r\n    async create(signer, bolt11PayRequest, amountData, lps, options, additionalParams, abortSignal, preFetches) {\r\n        options ??= {};\r\n        options.expirySeconds ??= this.options.paymentTimeoutSeconds;\r\n        options.expiryTimestamp ??= BigInt(Math.floor(Date.now() / 1000) + options.expirySeconds);\r\n        const parsedPr = (0, bolt11_1.decode)(bolt11PayRequest);\r\n        if (parsedPr.millisatoshis == null)\r\n            throw new UserError_1.UserError(\"Must be an invoice with amount\");\r\n        const amountOut = (BigInt(parsedPr.millisatoshis) + 999n) / 1000n;\r\n        options.maxFee ??= this.calculateFeeForAmount(amountOut, options.maxRoutingBaseFee, options.maxRoutingPPM);\r\n        await this.checkPaymentHashWasPaid(parsedPr.tagsObject.payment_hash);\r\n        const claimHash = this.contract.getHashForHtlc(Buffer.from(parsedPr.tagsObject.payment_hash, \"hex\"));\r\n        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        if (preFetches == null)\r\n            preFetches = {\r\n                pricePreFetchPromise: this.preFetchPrice(amountData, _abortController.signal),\r\n                feeRatePromise: this.preFetchFeeRate(signer, amountData, claimHash.toString(\"hex\"), _abortController)\r\n            };\r\n        return lps.map(lp => {\r\n            return {\r\n                intermediary: lp,\r\n                quote: this.getIntermediaryQuote(signer, amountData, lp, bolt11PayRequest, parsedPr, options, preFetches, _abortController.signal, additionalParams)\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Parses and fetches lnurl pay params from the specified lnurl\r\n     *\r\n     * @param lnurl LNURL to be parsed and fetched\r\n     * @param abortSignal\r\n     * @private\r\n     * @throws {UserError} if the LNURL is invalid or if it's not a LNURL-pay\r\n     */\r\n    async getLNURLPay(lnurl, abortSignal) {\r\n        if (typeof (lnurl) !== \"string\")\r\n            return lnurl;\r\n        const res = await LNURL_1.LNURL.getLNURL(lnurl, true, this.options.getRequestTimeout, abortSignal);\r\n        if (res == null)\r\n            throw new UserError_1.UserError(\"Invalid LNURL\");\r\n        if (res.tag !== \"payRequest\")\r\n            throw new UserError_1.UserError(\"Not a LNURL-pay\");\r\n        return res;\r\n    }\r\n    /**\r\n     * Returns the quote/swap from the given LP\r\n     *\r\n     * @param signer Smartchain signer's address initiating the swap\r\n     * @param amountData\r\n     * @param payRequest Parsed LNURL-pay params\r\n     * @param lp Intermediary\r\n     * @param dummyPr Dummy minimum value bolt11 lightning invoice returned from the LNURL-pay\r\n     * @param options Options as passed to the swap create function\r\n     * @param preFetches\r\n     * @param abortSignal\r\n     * @param additionalParams Additional params to be sent to the intermediary\r\n     * @private\r\n     */\r\n    async getIntermediaryQuoteExactIn(signer, amountData, payRequest, lp, dummyPr, options, preFetches, abortSignal, additionalParams) {\r\n        const abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const reputationPromise = this.preFetchIntermediaryReputation(amountData, lp, abortController);\r\n        try {\r\n            const { signDataPromise, prepareResp } = await (0, Utils_1.tryWithRetries)(async (retryCount) => {\r\n                const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.prepareToBTCLNExactIn(this.chainIdentifier, lp.url, {\r\n                    token: amountData.token,\r\n                    offerer: signer,\r\n                    pr: dummyPr,\r\n                    amount: amountData.amount,\r\n                    maxFee: await options.maxFee,\r\n                    expiryTimestamp: options.expiryTimestamp,\r\n                    additionalParams\r\n                }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);\r\n                return {\r\n                    signDataPromise: this.preFetchSignData(signDataPrefetch),\r\n                    prepareResp: await response\r\n                };\r\n            }, null, e => e instanceof RequestError_1.RequestError, abortController.signal);\r\n            if (prepareResp.amount <= 0n)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid amount returned (zero or negative)\");\r\n            const min = BigInt(payRequest.minSendable) / 1000n;\r\n            const max = BigInt(payRequest.maxSendable) / 1000n;\r\n            if (prepareResp.amount < min)\r\n                throw new UserError_1.UserError(\"Amount less than minimum\");\r\n            if (prepareResp.amount > max)\r\n                throw new UserError_1.UserError(\"Amount more than maximum\");\r\n            const { invoice, parsedInvoice, successAction } = await LNURL_1.LNURL.useLNURLPay(payRequest, prepareResp.amount, options.comment, this.options.getRequestTimeout, abortController.signal);\r\n            const resp = await (0, Utils_1.tryWithRetries)((retryCount) => IntermediaryAPI_1.IntermediaryAPI.initToBTCLNExactIn(lp.url, {\r\n                pr: invoice,\r\n                reqId: prepareResp.reqId,\r\n                feeRate: preFetches.feeRatePromise,\r\n                additionalParams\r\n            }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null), null, RequestError_1.RequestError, abortController.signal);\r\n            const totalFee = resp.swapFee + resp.maxFee;\r\n            const data = new this.swapDataDeserializer(resp.data);\r\n            data.setOfferer(signer);\r\n            await this.verifyReturnedData(resp, parsedInvoice, amountData.token, lp, options, data, amountData.amount);\r\n            const [pricingInfo, signatureExpiry, reputation] = await Promise.all([\r\n                this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.TO_BTCLN], true, prepareResp.amount, data.getAmount(), amountData.token, { networkFee: resp.maxFee }, preFetches.pricePreFetchPromise, abortSignal),\r\n                this.verifyReturnedSignature(signer, data, resp, preFetches.feeRatePromise, signDataPromise, abortController.signal),\r\n                reputationPromise\r\n            ]);\r\n            abortController.signal.throwIfAborted();\r\n            lp.reputation[amountData.token.toString()] = reputation;\r\n            const quote = new ToBTCLNSwap_1.ToBTCLNSwap(this, {\r\n                pricingInfo,\r\n                url: lp.url,\r\n                expiry: signatureExpiry,\r\n                swapFee: resp.swapFee,\r\n                feeRate: await preFetches.feeRatePromise,\r\n                signatureData: resp,\r\n                data,\r\n                networkFee: resp.maxFee,\r\n                networkFeeBtc: resp.routingFeeSats,\r\n                confidence: resp.confidence,\r\n                pr: invoice,\r\n                lnurl: payRequest.url,\r\n                successAction,\r\n                exactIn: true\r\n            });\r\n            await quote._save();\r\n            return quote;\r\n        }\r\n        catch (e) {\r\n            abortController.abort(e);\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a newly created swap, paying for 'lnurl' - a lightning LNURL-pay\r\n     *\r\n     * @param signer                Smartchain signer's address initiating the swap\r\n     * @param lnurl                 LMURL-pay you wish to pay\r\n     * @param amountData            Amount of token & amount to swap\r\n     * @param lps                   LPs (liquidity providers/intermediaries) to get the quotes from\r\n     * @param options               Quote options\r\n     * @param additionalParams      Additional parameters sent to the intermediary when creating the swap\r\n     * @param abortSignal           Abort signal for aborting the process\r\n     */\r\n    async createViaLNURL(signer, lnurl, amountData, lps, options, additionalParams, abortSignal) {\r\n        if (!this.isInitialized)\r\n            throw new Error(\"Not initialized, call init() first!\");\r\n        options ??= {};\r\n        options.expirySeconds ??= this.options.paymentTimeoutSeconds;\r\n        options.expiryTimestamp ??= BigInt(Math.floor(Date.now() / 1000) + options.expirySeconds);\r\n        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const pricePreFetchPromise = this.preFetchPrice(amountData, _abortController.signal);\r\n        const feeRatePromise = this.preFetchFeeRate(signer, amountData, null, _abortController);\r\n        options.maxRoutingPPM ??= BigInt(this.options.lightningFeePPM);\r\n        options.maxRoutingBaseFee ??= BigInt(this.options.lightningBaseFee);\r\n        if (amountData.exactIn) {\r\n            options.maxFee ??= pricePreFetchPromise\r\n                .then(val => this.prices.getFromBtcSwapAmount(this.chainIdentifier, options.maxRoutingBaseFee, amountData.token, abortSignal, val))\r\n                .then(_maxBaseFee => this.calculateFeeForAmount(amountData.amount, _maxBaseFee, options.maxRoutingPPM));\r\n        }\r\n        else {\r\n            options.maxFee = this.calculateFeeForAmount(amountData.amount, options.maxRoutingBaseFee, options.maxRoutingPPM);\r\n        }\r\n        try {\r\n            let payRequest = await this.getLNURLPay(lnurl, _abortController.signal);\r\n            if (options.comment != null &&\r\n                (payRequest.commentAllowed == null || options.comment.length > payRequest.commentAllowed))\r\n                throw new UserError_1.UserError(\"Comment not allowed or too long\");\r\n            if (amountData.exactIn) {\r\n                const { invoice: dummyInvoice } = await LNURL_1.LNURL.useLNURLPay(payRequest, BigInt(payRequest.minSendable) / 1000n, null, this.options.getRequestTimeout, _abortController.signal);\r\n                return lps.map(lp => {\r\n                    return {\r\n                        quote: this.getIntermediaryQuoteExactIn(signer, amountData, payRequest, lp, dummyInvoice, options, {\r\n                            pricePreFetchPromise,\r\n                            feeRatePromise\r\n                        }, _abortController.signal, additionalParams),\r\n                        intermediary: lp\r\n                    };\r\n                });\r\n            }\r\n            else {\r\n                const min = BigInt(payRequest.minSendable) / 1000n;\r\n                const max = BigInt(payRequest.maxSendable) / 1000n;\r\n                if (amountData.amount < min)\r\n                    throw new UserError_1.UserError(\"Amount less than minimum\");\r\n                if (amountData.amount > max)\r\n                    throw new UserError_1.UserError(\"Amount more than maximum\");\r\n                const { invoice, parsedInvoice, successAction } = await LNURL_1.LNURL.useLNURLPay(payRequest, amountData.amount, options.comment, this.options.getRequestTimeout, _abortController.signal);\r\n                return (await this.create(signer, invoice, amountData, lps, options, additionalParams, _abortController.signal, {\r\n                    feeRatePromise,\r\n                    pricePreFetchPromise\r\n                })).map(data => {\r\n                    return {\r\n                        quote: data.quote.then(quote => {\r\n                            quote.lnurl = payRequest.url;\r\n                            quote.successAction = successAction;\r\n                            return quote;\r\n                        }),\r\n                        intermediary: data.intermediary\r\n                    };\r\n                });\r\n            }\r\n        }\r\n        catch (e) {\r\n            _abortController.abort(e);\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.ToBTCLNWrapper = ToBTCLNWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6462, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ToBTCSwap = exports.isToBTCSwapInit = void 0;\r\nconst IToBTCSwap_1 = require(\"../IToBTCSwap\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst IntermediaryError_1 = require(\"../../../../errors/IntermediaryError\");\r\nconst Tokens_1 = require(\"../../../../Tokens\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nfunction isToBTCSwapInit(obj) {\r\n    return typeof (obj.address) === \"string\" &&\r\n        typeof (obj.amount) === \"bigint\" &&\r\n        typeof (obj.confirmationTarget) === \"number\" &&\r\n        typeof (obj.satsPerVByte) === \"number\" &&\r\n        (0, IToBTCSwap_1.isIToBTCSwapInit)(obj);\r\n}\r\nexports.isToBTCSwapInit = isToBTCSwapInit;\r\nclass ToBTCSwap extends IToBTCSwap_1.IToBTCSwap {\r\n    constructor(wrapper, initOrObject) {\r\n        if (isToBTCSwapInit(initOrObject))\r\n            initOrObject.url += \"/tobtc\";\r\n        super(wrapper, initOrObject);\r\n        this.outputToken = Tokens_1.BitcoinTokens.BTC;\r\n        this.TYPE = SwapType_1.SwapType.TO_BTC;\r\n        if (!isToBTCSwapInit(initOrObject)) {\r\n            this.address = initOrObject.address;\r\n            this.amount = BigInt(initOrObject.amount);\r\n            this.confirmationTarget = initOrObject.confirmationTarget;\r\n            this.satsPerVByte = initOrObject.satsPerVByte;\r\n            this.txId = initOrObject.txId;\r\n            this.requiredConfirmations = initOrObject.requiredConfirmations ?? this.data.getConfirmationsHint();\r\n            this.nonce = (initOrObject.nonce == null ? null : BigInt(initOrObject.nonce)) ?? this.data.getNonceHint();\r\n        }\r\n        this.logger = (0, Utils_1.getLogger)(\"ToBTC(\" + this.getIdentifierHashString() + \"): \");\r\n        this.tryRecomputeSwapPrice();\r\n    }\r\n    async _setPaymentResult(result, check = false) {\r\n        if (result == null)\r\n            return false;\r\n        if (result.txId == null)\r\n            throw new IntermediaryError_1.IntermediaryError(\"No btc txId returned!\");\r\n        if (check) {\r\n            const btcTx = await this.wrapper.btcRpc.getTransaction(result.txId);\r\n            if (btcTx == null)\r\n                return false;\r\n            const foundVout = btcTx.outs.find(vout => this.data.getClaimHash() === this.wrapper.contract.getHashForOnchain(buffer_1.Buffer.from(vout.scriptPubKey.hex, \"hex\"), BigInt(vout.value), this.requiredConfirmations, this.nonce).toString(\"hex\"));\r\n            if (foundVout == null)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid btc txId returned\");\r\n        }\r\n        this.txId = result.txId;\r\n        return true;\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getOutput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.amount, this.outputToken, this.wrapper.prices);\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    /**\r\n     * Returns the bitcoin address where the BTC will be sent to\r\n     */\r\n    getOutputAddress() {\r\n        return this.address;\r\n    }\r\n    getOutputTxId() {\r\n        return this.txId;\r\n    }\r\n    /**\r\n     * Returns fee rate of the bitcoin transaction in sats/vB\r\n     */\r\n    getBitcoinFeeRate() {\r\n        return this.satsPerVByte;\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            address: this.address,\r\n            amount: this.amount.toString(10),\r\n            confirmationTarget: this.confirmationTarget,\r\n            satsPerVByte: this.satsPerVByte,\r\n            nonce: this.nonce == null ? null : this.nonce.toString(10),\r\n            requiredConfirmations: this.requiredConfirmations,\r\n            txId: this.txId\r\n        };\r\n    }\r\n}\r\nexports.ToBTCSwap = ToBTCSwap;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,SAAS,GAAG,QAAQ,eAAe,GAAG,KAAK;AACnD,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,gBAAgB,GAAG;IACxB,OAAO,OAAQ,IAAI,OAAO,KAAM,YAC5B,OAAQ,IAAI,MAAM,KAAM,YACxB,OAAQ,IAAI,kBAAkB,KAAM,YACpC,OAAQ,IAAI,YAAY,KAAM,YAC9B,CAAC,GAAG,aAAa,gBAAgB,EAAE;AAC3C;AACA,QAAQ,eAAe,GAAG;AAC1B,MAAM,kBAAkB,aAAa,UAAU;IAmB3C,MAAM,kBAAkB,MAAM,EAAiB;YAAf,QAAA,iEAAQ;QACpC,IAAI,UAAU,MACV,OAAO;QACX,IAAI,OAAO,IAAI,IAAI,MACf,MAAM,IAAI,oBAAoB,iBAAiB,CAAC;QACpD,IAAI,OAAO;YACP,MAAM,QAAQ,MAAM,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,OAAO,IAAI;YAClE,IAAI,SAAS,MACT,OAAO;YACX,MAAM,YAAY,MAAM,IAAI,CAAC,IAAI,CAAC,CAAA,OAAQ,IAAI,CAAC,IAAI,CAAC,YAAY,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,iBAAiB,CAAC,SAAS,MAAM,CAAC,IAAI,CAAC,KAAK,YAAY,CAAC,GAAG,EAAE,QAAQ,OAAO,KAAK,KAAK,GAAG,IAAI,CAAC,qBAAqB,EAAE,IAAI,CAAC,KAAK,EAAE,QAAQ,CAAC;YACxO,IAAI,aAAa,MACb,MAAM,IAAI,oBAAoB,iBAAiB,CAAC;QACxD;QACA,IAAI,CAAC,IAAI,GAAG,OAAO,IAAI;QACvB,OAAO;IACX;IACA,8BAA8B;IAC9B,mBAAmB;IACnB,YAAY;QACR,OAAO,CAAC,GAAG,SAAS,aAAa,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,MAAM;IACzF;IACA,8BAA8B;IAC9B,oBAAoB;IACpB;;KAEC,GACD,mBAAmB;QACf,OAAO,IAAI,CAAC,OAAO;IACvB;IACA,gBAAgB;QACZ,OAAO,IAAI,CAAC,IAAI;IACpB;IACA;;KAEC,GACD,oBAAoB;QAChB,OAAO,IAAI,CAAC,YAAY;IAC5B;IACA,8BAA8B;IAC9B,YAAY;IACZ,YAAY;QACR,OAAO;YACH,GAAG,KAAK,CAAC,WAAW;YACpB,SAAS,IAAI,CAAC,OAAO;YACrB,QAAQ,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC;YAC7B,oBAAoB,IAAI,CAAC,kBAAkB;YAC3C,cAAc,IAAI,CAAC,YAAY;YAC/B,OAAO,IAAI,CAAC,KAAK,IAAI,OAAO,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YACvD,uBAAuB,IAAI,CAAC,qBAAqB;YACjD,MAAM,IAAI,CAAC,IAAI;QACnB;IACJ;IArEA,YAAY,OAAO,EAAE,YAAY,CAAE;QAC/B,IAAI,gBAAgB,eAChB,aAAa,GAAG,IAAI;QACxB,KAAK,CAAC,SAAS;QACf,IAAI,CAAC,WAAW,GAAG,SAAS,aAAa,CAAC,GAAG;QAC7C,IAAI,CAAC,IAAI,GAAG,WAAW,QAAQ,CAAC,MAAM;QACtC,IAAI,CAAC,gBAAgB,eAAe;YAChC,IAAI,CAAC,OAAO,GAAG,aAAa,OAAO;YACnC,IAAI,CAAC,MAAM,GAAG,OAAO,aAAa,MAAM;YACxC,IAAI,CAAC,kBAAkB,GAAG,aAAa,kBAAkB;YACzD,IAAI,CAAC,YAAY,GAAG,aAAa,YAAY;YAC7C,IAAI,CAAC,IAAI,GAAG,aAAa,IAAI;gBACA;YAA7B,IAAI,CAAC,qBAAqB,GAAG,CAAA,sCAAA,aAAa,qBAAqB,cAAlC,iDAAA,sCAAsC,IAAI,CAAC,IAAI,CAAC,oBAAoB;gBACpF;YAAb,IAAI,CAAC,KAAK,GAAG,CAAA,OAAC,aAAa,KAAK,IAAI,OAAO,OAAO,OAAO,aAAa,KAAK,eAA9D,kBAAA,OAAoE,IAAI,CAAC,IAAI,CAAC,YAAY;QAC3G;QACA,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,QAAQ,SAAS,EAAE,WAAW,IAAI,CAAC,uBAAuB,KAAK;QACjF,IAAI,CAAC,qBAAqB;IAC9B;AAqDJ;AACA,QAAQ,SAAS,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6549, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ToBTCWrapper = void 0;\r\nconst ToBTCSwap_1 = require(\"./ToBTCSwap\");\r\nconst IToBTCWrapper_1 = require(\"../IToBTCWrapper\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst UserError_1 = require(\"../../../../errors/UserError\");\r\nconst IntermediaryError_1 = require(\"../../../../errors/IntermediaryError\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nconst IntermediaryAPI_1 = require(\"../../../../intermediaries/IntermediaryAPI\");\r\nconst RequestError_1 = require(\"../../../../errors/RequestError\");\r\nconst utils_1 = require(\"@scure/btc-signer/utils\");\r\nclass ToBTCWrapper extends IToBTCWrapper_1.IToBTCWrapper {\r\n    /**\r\n     * @param chainIdentifier\r\n     * @param unifiedStorage Storage interface for the current environment\r\n     * @param unifiedChainEvents Smart chain on-chain event listener\r\n     * @param chain\r\n     * @param contract Chain specific swap contract\r\n     * @param prices Swap pricing handler\r\n     * @param tokens\r\n     * @param swapDataDeserializer Deserializer for chain specific SwapData\r\n     * @param btcRpc Bitcoin RPC api\r\n     * @param options\r\n     * @param events Instance to use for emitting events\r\n     */\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, btcRpc, options, events) {\r\n        if (options == null)\r\n            options = {};\r\n        options.bitcoinNetwork = options.bitcoinNetwork ?? utils_1.TEST_NETWORK;\r\n        options.safetyFactor = options.safetyFactor || 2;\r\n        options.maxConfirmations = options.maxConfirmations || 6;\r\n        options.bitcoinBlocktime = options.bitcoinBlocktime || (60 * 10);\r\n        options.maxExpectedOnchainSendSafetyFactor = options.maxExpectedOnchainSendSafetyFactor || 4;\r\n        options.maxExpectedOnchainSendGracePeriodBlocks = options.maxExpectedOnchainSendGracePeriodBlocks || 12;\r\n        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);\r\n        this.TYPE = SwapType_1.SwapType.TO_BTC;\r\n        this.swapDeserializer = ToBTCSwap_1.ToBTCSwap;\r\n        this.btcRpc = btcRpc;\r\n    }\r\n    /**\r\n     * Returns randomly generated random escrow nonce to be used for to BTC on-chain swaps\r\n     * @private\r\n     * @returns Escrow nonce\r\n     */\r\n    getRandomNonce() {\r\n        const firstPart = BigInt(Math.floor((Date.now() / 1000)) - 700000000);\r\n        return (firstPart << 24n) | base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(3));\r\n    }\r\n    /**\r\n     * Converts bitcoin address to its corresponding output script\r\n     *\r\n     * @param addr Bitcoin address to get the output script for\r\n     * @private\r\n     * @returns Output script as Buffer\r\n     * @throws {UserError} if invalid address is specified\r\n     */\r\n    btcAddressToOutputScript(addr) {\r\n        try {\r\n            return (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, addr);\r\n        }\r\n        catch (e) {\r\n            throw new UserError_1.UserError(\"Invalid address specified\");\r\n        }\r\n    }\r\n    /**\r\n     * Verifies returned LP data\r\n     *\r\n     * @param resp LP's response\r\n     * @param amountData\r\n     * @param lp\r\n     * @param options Options as passed to the swap create function\r\n     * @param data LP's returned parsed swap data\r\n     * @param hash Payment hash of the swap\r\n     * @private\r\n     * @throws {IntermediaryError} if returned data are not correct\r\n     */\r\n    verifyReturnedData(resp, amountData, lp, options, data, hash) {\r\n        if (resp.totalFee !== (resp.swapFee + resp.networkFee))\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid totalFee returned\");\r\n        if (amountData.exactIn) {\r\n            if (resp.total !== amountData.amount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid total returned\");\r\n        }\r\n        else {\r\n            if (resp.amount !== amountData.amount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid amount returned\");\r\n        }\r\n        const maxAllowedBlockDelta = BigInt(options.confirmations +\r\n            options.confirmationTarget +\r\n            this.options.maxExpectedOnchainSendGracePeriodBlocks);\r\n        const maxAllowedExpiryDelta = maxAllowedBlockDelta\r\n            * BigInt(this.options.maxExpectedOnchainSendSafetyFactor)\r\n            * BigInt(this.options.bitcoinBlocktime);\r\n        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));\r\n        const maxAllowedExpiryTimestamp = currentTimestamp + maxAllowedExpiryDelta;\r\n        if (data.getExpiry() > maxAllowedExpiryTimestamp) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Expiry time returned too high!\");\r\n        }\r\n        if (data.getAmount() !== resp.total ||\r\n            data.getClaimHash() !== hash ||\r\n            data.getType() !== base_1.ChainSwapType.CHAIN_NONCED ||\r\n            !data.isPayIn() ||\r\n            !data.isToken(amountData.token) ||\r\n            data.getClaimer() !== lp.getAddress(this.chainIdentifier)) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid data returned\");\r\n        }\r\n    }\r\n    /**\r\n     * Returns quotes fetched from LPs, paying to an 'address' - a bitcoin address\r\n     *\r\n     * @param signer                Smart-chain signer address initiating the swap\r\n     * @param address               Bitcoin on-chain address you wish to pay to\r\n     * @param amountData            Amount of token & amount to swap\r\n     * @param lps                   LPs (liquidity providers) to get the quotes from\r\n     * @param options               Quote options\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param abortSignal           Abort signal for aborting the process\r\n     */\r\n    create(signer, address, amountData, lps, options, additionalParams, abortSignal) {\r\n        if (!this.isInitialized)\r\n            throw new Error(\"Not initialized, call init() first!\");\r\n        options ??= {};\r\n        options.confirmationTarget ??= 3;\r\n        options.confirmations ??= 2;\r\n        const nonce = this.getRandomNonce();\r\n        const outputScript = this.btcAddressToOutputScript(address);\r\n        const _hash = !amountData.exactIn ?\r\n            this.contract.getHashForOnchain(outputScript, amountData.amount, options.confirmations, nonce).toString(\"hex\") :\r\n            null;\r\n        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const pricePreFetchPromise = this.preFetchPrice(amountData, _abortController.signal);\r\n        const feeRatePromise = this.preFetchFeeRate(signer, amountData, _hash, _abortController);\r\n        return lps.map(lp => {\r\n            return {\r\n                intermediary: lp,\r\n                quote: (async () => {\r\n                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);\r\n                    const reputationPromise = this.preFetchIntermediaryReputation(amountData, lp, abortController);\r\n                    try {\r\n                        const { signDataPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount) => {\r\n                            const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.initToBTC(this.chainIdentifier, lp.url, {\r\n                                btcAddress: address,\r\n                                amount: amountData.amount,\r\n                                confirmationTarget: options.confirmationTarget,\r\n                                confirmations: options.confirmations,\r\n                                nonce: nonce,\r\n                                token: amountData.token,\r\n                                offerer: signer,\r\n                                exactIn: amountData.exactIn,\r\n                                feeRate: feeRatePromise,\r\n                                additionalParams\r\n                            }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);\r\n                            return {\r\n                                signDataPromise: this.preFetchSignData(signDataPrefetch),\r\n                                resp: await response\r\n                            };\r\n                        }, null, RequestError_1.RequestError, abortController.signal);\r\n                        let hash = amountData.exactIn ?\r\n                            this.contract.getHashForOnchain(outputScript, resp.amount, options.confirmations, nonce).toString(\"hex\") :\r\n                            _hash;\r\n                        const data = new this.swapDataDeserializer(resp.data);\r\n                        data.setOfferer(signer);\r\n                        this.verifyReturnedData(resp, amountData, lp, options, data, hash);\r\n                        const [pricingInfo, signatureExpiry, reputation] = await Promise.all([\r\n                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.TO_BTC], true, resp.amount, data.getAmount(), amountData.token, resp, pricePreFetchPromise, abortController.signal),\r\n                            this.verifyReturnedSignature(signer, data, resp, feeRatePromise, signDataPromise, abortController.signal),\r\n                            reputationPromise\r\n                        ]);\r\n                        abortController.signal.throwIfAborted();\r\n                        lp.reputation[amountData.token.toString()] = reputation;\r\n                        const quote = new ToBTCSwap_1.ToBTCSwap(this, {\r\n                            pricingInfo,\r\n                            url: lp.url,\r\n                            expiry: signatureExpiry,\r\n                            swapFee: resp.swapFee,\r\n                            feeRate: await feeRatePromise,\r\n                            signatureData: resp,\r\n                            data,\r\n                            networkFee: resp.networkFee,\r\n                            address,\r\n                            amount: resp.amount,\r\n                            confirmationTarget: options.confirmationTarget,\r\n                            satsPerVByte: Number(resp.satsPervByte),\r\n                            exactIn: amountData.exactIn ?? false,\r\n                            requiredConfirmations: options.confirmations,\r\n                            nonce\r\n                        });\r\n                        await quote._save();\r\n                        return quote;\r\n                    }\r\n                    catch (e) {\r\n                        abortController.abort(e);\r\n                        throw e;\r\n                    }\r\n                })()\r\n            };\r\n        });\r\n    }\r\n}\r\nexports.ToBTCWrapper = ToBTCWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6735, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IFromBTCSwap = void 0;\r\nconst ISwap_1 = require(\"../../ISwap\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst Tokens_1 = require(\"../../../Tokens\");\r\nconst IEscrowSwap_1 = require(\"../IEscrowSwap\");\r\nconst Fee_1 = require(\"../../fee/Fee\");\r\nclass IFromBTCSwap extends IEscrowSwap_1.IEscrowSwap {\r\n    constructor(wrapper, initOrObj) {\r\n        super(wrapper, initOrObj);\r\n    }\r\n    /**\r\n     * In case swapFee in BTC is not supplied it recalculates it based on swap price\r\n     * @protected\r\n     */\r\n    tryRecomputeSwapPrice() {\r\n        if (this.swapFeeBtc == null) {\r\n            this.swapFeeBtc = this.swapFee * this.getInput().rawAmount / this.getOutAmountWithoutFee();\r\n        }\r\n        super.tryRecomputeSwapPrice();\r\n    }\r\n    getSwapData() {\r\n        return this.data;\r\n    }\r\n    _getInitiator() {\r\n        return this.getSwapData().getClaimer();\r\n    }\r\n    getOutputTxId() {\r\n        return this.claimTxId;\r\n    }\r\n    getOutputAddress() {\r\n        return this._getInitiator();\r\n    }\r\n    requiresAction() {\r\n        return this.isClaimable();\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getOutAmountWithoutFee() {\r\n        return this.getSwapData().getAmount() + this.swapFee;\r\n    }\r\n    getSwapFee() {\r\n        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;\r\n        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getInputWithoutFee().rawAmount;\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, this.inputToken, this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.getSwapData().getToken()], this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),\r\n            composition: {\r\n                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, this.inputToken, this.wrapper.prices),\r\n                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)\r\n            }\r\n        };\r\n    }\r\n    getFee() {\r\n        return this.getSwapFee();\r\n    }\r\n    getFeeBreakdown() {\r\n        return [{\r\n                type: Fee_1.FeeType.SWAP,\r\n                fee: this.getSwapFee()\r\n            }];\r\n    }\r\n    getOutput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.getSwapData().getAmount(), this.wrapper.tokens[this.getSwapData().getToken()], this.wrapper.prices);\r\n    }\r\n    getInputWithoutFee() {\r\n        return (0, Tokens_1.toTokenAmount)(this.getInput().rawAmount - this.swapFeeBtc, this.inputToken, this.wrapper.prices);\r\n    }\r\n    getSecurityDeposit() {\r\n        return (0, Tokens_1.toTokenAmount)(this.getSwapData().getSecurityDeposit(), this.wrapper.getNativeToken(), this.wrapper.prices);\r\n    }\r\n    getTotalDeposit() {\r\n        return (0, Tokens_1.toTokenAmount)(this.getSwapData().getTotalDeposit(), this.wrapper.getNativeToken(), this.wrapper.prices);\r\n    }\r\n    async hasEnoughForTxFees() {\r\n        const [balance, commitFee] = await Promise.all([\r\n            this.wrapper.contract.getBalance(this._getInitiator(), this.wrapper.chain.getNativeCurrencyAddress(), false),\r\n            this.getCommitFee()\r\n        ]);\r\n        const totalFee = commitFee + this.getSwapData().getTotalDeposit();\r\n        return {\r\n            enoughBalance: balance >= totalFee,\r\n            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.getNativeToken(), this.wrapper.prices),\r\n            required: (0, Tokens_1.toTokenAmount)(totalFee, this.wrapper.getNativeToken(), this.wrapper.prices)\r\n        };\r\n    }\r\n    //////////////////////////////\r\n    //// Commit\r\n    /**\r\n     * Returns the transactions required for committing the swap on-chain, locking the tokens from the intermediary\r\n     *  in an HTLC or PTLC\r\n     *\r\n     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet\r\n     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)\r\n     * @throws {Error} When in invalid state to commit the swap\r\n     */\r\n    async txsCommit(skipChecks) {\r\n        if (!this.canCommit())\r\n            throw new Error(\"Must be in CREATED state!\");\r\n        if (!this.initiated) {\r\n            this.initiated = true;\r\n            await this._saveAndEmit();\r\n        }\r\n        return await this.wrapper.contract.txsInit(this._getInitiator(), this.data, this.signatureData, skipChecks, this.feeRate).catch(e => Promise.reject(e instanceof base_1.SignatureVerificationError ? new Error(\"Request timed out\") : e));\r\n    }\r\n    //////////////////////////////\r\n    //// Claim\r\n    getClaimFee() {\r\n        return this.wrapper.contract.getClaimFee(this._getInitiator(), this.getSwapData());\r\n    }\r\n}\r\nexports.IFromBTCSwap = IFromBTCSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6853, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FromBTCLNSwap = exports.isFromBTCLNSwapInit = exports.FromBTCLNSwapState = void 0;\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst IFromBTCSwap_1 = require(\"../IFromBTCSwap\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst LNURL_1 = require(\"../../../../utils/LNURL\");\r\nconst UserError_1 = require(\"../../../../errors/UserError\");\r\nconst IntermediaryAPI_1 = require(\"../../../../intermediaries/IntermediaryAPI\");\r\nconst IntermediaryError_1 = require(\"../../../../errors/IntermediaryError\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nconst Tokens_1 = require(\"../../../../Tokens\");\r\nconst IEscrowSwap_1 = require(\"../../IEscrowSwap\");\r\nvar FromBTCLNSwapState;\r\n(function (FromBTCLNSwapState) {\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"FAILED\"] = -4] = \"FAILED\";\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"QUOTE_EXPIRED\"] = -3] = \"QUOTE_EXPIRED\";\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"QUOTE_SOFT_EXPIRED\"] = -2] = \"QUOTE_SOFT_EXPIRED\";\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"EXPIRED\"] = -1] = \"EXPIRED\";\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"PR_CREATED\"] = 0] = \"PR_CREATED\";\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"PR_PAID\"] = 1] = \"PR_PAID\";\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"CLAIM_COMMITED\"] = 2] = \"CLAIM_COMMITED\";\r\n    FromBTCLNSwapState[FromBTCLNSwapState[\"CLAIM_CLAIMED\"] = 3] = \"CLAIM_CLAIMED\";\r\n})(FromBTCLNSwapState = exports.FromBTCLNSwapState || (exports.FromBTCLNSwapState = {}));\r\nfunction isFromBTCLNSwapInit(obj) {\r\n    return typeof obj.pr === \"string\" &&\r\n        typeof obj.secret === \"string\" &&\r\n        (obj.lnurl == null || typeof (obj.lnurl) === \"string\") &&\r\n        (obj.lnurlK1 == null || typeof (obj.lnurlK1) === \"string\") &&\r\n        (obj.lnurlCallback == null || typeof (obj.lnurlCallback) === \"string\") &&\r\n        (0, IEscrowSwap_1.isIEscrowSwapInit)(obj);\r\n}\r\nexports.isFromBTCLNSwapInit = isFromBTCLNSwapInit;\r\nclass FromBTCLNSwap extends IFromBTCSwap_1.IFromBTCSwap {\r\n    getSwapData() {\r\n        return this.data ?? this.initialSwapData;\r\n    }\r\n    constructor(wrapper, initOrObject) {\r\n        if (isFromBTCLNSwapInit(initOrObject))\r\n            initOrObject.url += \"/frombtcln\";\r\n        super(wrapper, initOrObject);\r\n        this.inputToken = Tokens_1.BitcoinTokens.BTCLN;\r\n        this.TYPE = SwapType_1.SwapType.FROM_BTCLN;\r\n        this.lnurlFailSignal = new AbortController();\r\n        this.prPosted = false;\r\n        if (isFromBTCLNSwapInit(initOrObject)) {\r\n            this.state = FromBTCLNSwapState.PR_CREATED;\r\n        }\r\n        else {\r\n            this.pr = initOrObject.pr;\r\n            this.secret = initOrObject.secret;\r\n            this.initialSwapData = initOrObject.initialSwapData == null ? null : base_1.SwapData.deserialize(initOrObject.initialSwapData);\r\n            this.lnurl = initOrObject.lnurl;\r\n            this.lnurlK1 = initOrObject.lnurlK1;\r\n            this.lnurlCallback = initOrObject.lnurlCallback;\r\n            this.prPosted = initOrObject.prPosted;\r\n            if (this.state === FromBTCLNSwapState.PR_CREATED && this.data != null) {\r\n                this.initialSwapData = this.data;\r\n                delete this.data;\r\n            }\r\n        }\r\n        this.tryRecomputeSwapPrice();\r\n        this.logger = (0, Utils_1.getLogger)(\"FromBTCLN(\" + this.getIdentifierHashString() + \"): \");\r\n    }\r\n    upgradeVersion() {\r\n        if (this.version == null) {\r\n            switch (this.state) {\r\n                case -2:\r\n                    this.state = FromBTCLNSwapState.QUOTE_EXPIRED;\r\n                    break;\r\n                case -1:\r\n                    this.state = FromBTCLNSwapState.FAILED;\r\n                    break;\r\n                case 0:\r\n                    this.state = FromBTCLNSwapState.PR_CREATED;\r\n                    break;\r\n                case 1:\r\n                    this.state = FromBTCLNSwapState.PR_PAID;\r\n                    break;\r\n                case 2:\r\n                    this.state = FromBTCLNSwapState.CLAIM_COMMITED;\r\n                    break;\r\n                case 3:\r\n                    this.state = FromBTCLNSwapState.CLAIM_CLAIMED;\r\n                    break;\r\n            }\r\n            this.version = 1;\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    getIdentifierHash() {\r\n        const paymentHashBuffer = this.getPaymentHash();\r\n        if (this.randomNonce == null)\r\n            return paymentHashBuffer;\r\n        return buffer_1.Buffer.concat([paymentHashBuffer, buffer_1.Buffer.from(this.randomNonce, \"hex\")]);\r\n    }\r\n    getPaymentHash() {\r\n        if (this.pr == null)\r\n            return null;\r\n        const decodedPR = (0, bolt11_1.decode)(this.pr);\r\n        return buffer_1.Buffer.from(decodedPR.tagsObject.payment_hash, \"hex\");\r\n    }\r\n    canCommit() {\r\n        return this.state === FromBTCLNSwapState.PR_PAID;\r\n    }\r\n    getInputTxId() {\r\n        return this.getPaymentHash().toString(\"hex\");\r\n    }\r\n    /**\r\n     * Returns the lightning network BOLT11 invoice that needs to be paid as an input to the swap\r\n     */\r\n    getAddress() {\r\n        return this.pr;\r\n    }\r\n    getHyperlink() {\r\n        return \"lightning:\" + this.pr.toUpperCase();\r\n    }\r\n    /**\r\n     * Returns timeout time (in UNIX milliseconds) when the LN invoice will expire\r\n     */\r\n    getTimeoutTime() {\r\n        if (this.pr == null)\r\n            return null;\r\n        const decoded = (0, bolt11_1.decode)(this.pr);\r\n        return (decoded.timeExpireDate * 1000);\r\n    }\r\n    /**\r\n     * Returns timeout time (in UNIX milliseconds) when the swap htlc will expire\r\n     */\r\n    getHtlcTimeoutTime() {\r\n        return Number(this.wrapper.getHtlcTimeout(this.data)) * 1000;\r\n    }\r\n    isFinished() {\r\n        return this.state === FromBTCLNSwapState.CLAIM_CLAIMED || this.state === FromBTCLNSwapState.QUOTE_EXPIRED || this.state === FromBTCLNSwapState.FAILED;\r\n    }\r\n    isClaimable() {\r\n        return this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.CLAIM_COMMITED;\r\n    }\r\n    isSuccessful() {\r\n        return this.state === FromBTCLNSwapState.CLAIM_CLAIMED;\r\n    }\r\n    isFailed() {\r\n        return this.state === FromBTCLNSwapState.FAILED || this.state === FromBTCLNSwapState.EXPIRED;\r\n    }\r\n    isQuoteExpired() {\r\n        return this.state === FromBTCLNSwapState.QUOTE_EXPIRED;\r\n    }\r\n    isQuoteSoftExpired() {\r\n        return this.state === FromBTCLNSwapState.QUOTE_EXPIRED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;\r\n    }\r\n    verifyQuoteValid() {\r\n        if (this.state === FromBTCLNSwapState.PR_CREATED ||\r\n            (this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData == null)) {\r\n            return Promise.resolve(this.getTimeoutTime() > Date.now());\r\n        }\r\n        return super.verifyQuoteValid();\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getInput() {\r\n        const parsed = (0, bolt11_1.decode)(this.pr);\r\n        const amount = (BigInt(parsed.millisatoshis) + 999n) / 1000n;\r\n        return (0, Tokens_1.toTokenAmount)(amount, this.inputToken, this.wrapper.prices);\r\n    }\r\n    async getSmartChainNetworkFee() {\r\n        return (0, Tokens_1.toTokenAmount)(await this.getCommitAndClaimFee(), this.wrapper.getNativeToken(), this.wrapper.prices);\r\n    }\r\n    async hasEnoughForTxFees() {\r\n        const [balance, feeRate] = await Promise.all([\r\n            this.wrapper.contract.getBalance(this._getInitiator(), this.wrapper.chain.getNativeCurrencyAddress(), false),\r\n            this.feeRate != null ? Promise.resolve(this.feeRate) : this.wrapper.contract.getInitFeeRate(this.getSwapData().getOfferer(), this.getSwapData().getClaimer(), this.getSwapData().getToken(), this.getSwapData().getClaimHash())\r\n        ]);\r\n        const commitFee = await this.wrapper.contract.getCommitFee(this.getSwapData(), feeRate);\r\n        const claimFee = await this.wrapper.contract.getClaimFee(this._getInitiator(), this.getSwapData(), feeRate);\r\n        const totalFee = commitFee + claimFee + this.getSwapData().getTotalDeposit();\r\n        return {\r\n            enoughBalance: balance >= totalFee,\r\n            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.getNativeToken(), this.wrapper.prices),\r\n            required: (0, Tokens_1.toTokenAmount)(totalFee, this.wrapper.getNativeToken(), this.wrapper.prices)\r\n        };\r\n    }\r\n    //////////////////////////////\r\n    //// Payment\r\n    /**\r\n     * Checks whether the LP received the LN payment and we can continue by committing & claiming the HTLC on-chain\r\n     *\r\n     * @param save If the new swap state should be saved\r\n     */\r\n    async checkIntermediaryPaymentReceived(save = true) {\r\n        if (this.state === FromBTCLNSwapState.PR_PAID ||\r\n            this.state === FromBTCLNSwapState.CLAIM_COMMITED ||\r\n            this.state === FromBTCLNSwapState.CLAIM_CLAIMED ||\r\n            this.state === FromBTCLNSwapState.FAILED)\r\n            return true;\r\n        if (this.state === FromBTCLNSwapState.QUOTE_EXPIRED || (this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null))\r\n            return false;\r\n        const resp = await IntermediaryAPI_1.IntermediaryAPI.getPaymentAuthorization(this.url, this.getPaymentHash().toString(\"hex\"));\r\n        switch (resp.code) {\r\n            case IntermediaryAPI_1.PaymentAuthorizationResponseCodes.AUTH_DATA:\r\n                const data = new this.wrapper.swapDataDeserializer(resp.data.data);\r\n                try {\r\n                    await this.checkIntermediaryReturnedAuthData(this._getInitiator(), data, resp.data);\r\n                    this.expiry = await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getInitAuthorizationExpiry(data, resp.data));\r\n                    this.state = FromBTCLNSwapState.PR_PAID;\r\n                    delete this.initialSwapData;\r\n                    this.data = data;\r\n                    this.signatureData = {\r\n                        prefix: resp.data.prefix,\r\n                        timeout: resp.data.timeout,\r\n                        signature: resp.data.signature\r\n                    };\r\n                    this.initiated = true;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                catch (e) { }\r\n                return null;\r\n            case IntermediaryAPI_1.PaymentAuthorizationResponseCodes.EXPIRED:\r\n                this.state = FromBTCLNSwapState.QUOTE_EXPIRED;\r\n                this.initiated = true;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return false;\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n    /**\r\n     * Checks the data returned by the intermediary in the payment auth request\r\n     *\r\n     * @param signer Smart chain signer's address initiating the swap\r\n     * @param data Parsed swap data as returned by the intermediary\r\n     * @param signature Signature data as returned by the intermediary\r\n     * @protected\r\n     * @throws {IntermediaryError} If the returned are not valid\r\n     * @throws {SignatureVerificationError} If the returned signature is not valid\r\n     * @throws {Error} If the swap is already committed on-chain\r\n     */\r\n    async checkIntermediaryReturnedAuthData(signer, data, signature) {\r\n        data.setClaimer(signer);\r\n        if (data.getOfferer() !== this.getSwapData().getOfferer())\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid offerer used\");\r\n        if (!data.isToken(this.getSwapData().getToken()))\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid token used\");\r\n        if (data.getSecurityDeposit() > this.getSwapData().getSecurityDeposit())\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid security deposit!\");\r\n        if (data.getAmount() < this.getSwapData().getAmount())\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid amount received!\");\r\n        if (data.getClaimHash() !== this.getSwapData().getClaimHash())\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid payment hash used!\");\r\n        if (!data.isDepositToken(this.getSwapData().getDepositToken()))\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid deposit token used!\");\r\n        await Promise.all([\r\n            (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.isValidInitAuthorization(this._getInitiator(), data, signature, this.feeRate), null, base_1.SignatureVerificationError),\r\n            (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getCommitStatus(data.getClaimer(), data)).then(status => {\r\n                if (status?.type !== base_1.SwapCommitStateType.NOT_COMMITED)\r\n                    throw new Error(\"Swap already committed on-chain!\");\r\n            })\r\n        ]);\r\n    }\r\n    /**\r\n     * Waits till an LN payment is received by the intermediary and client can continue commiting & claiming the HTLC\r\n     *\r\n     * @param abortSignal Abort signal to stop waiting for payment\r\n     * @param checkIntervalSeconds How often to poll the intermediary for answer\r\n     */\r\n    async waitForPayment(abortSignal, checkIntervalSeconds = 5) {\r\n        if (this.state !== FromBTCLNSwapState.PR_CREATED &&\r\n            (this.state !== FromBTCLNSwapState.QUOTE_SOFT_EXPIRED || this.signatureData != null))\r\n            throw new Error(\"Must be in PR_CREATED state!\");\r\n        const abortController = new AbortController();\r\n        if (abortSignal != null)\r\n            abortSignal.addEventListener(\"abort\", () => abortController.abort(abortSignal.reason));\r\n        let save = false;\r\n        if (this.lnurl != null && !this.prPosted) {\r\n            LNURL_1.LNURL.postInvoiceToLNURLWithdraw({ k1: this.lnurlK1, callback: this.lnurlCallback }, this.pr).catch(e => {\r\n                this.lnurlFailSignal.abort(e);\r\n            });\r\n            this.prPosted = true;\r\n            save ||= true;\r\n        }\r\n        if (!this.initiated) {\r\n            this.initiated = true;\r\n            save ||= true;\r\n        }\r\n        if (save)\r\n            await this._saveAndEmit();\r\n        let lnurlFailListener = () => abortController.abort(this.lnurlFailSignal.signal.reason);\r\n        this.lnurlFailSignal.signal.addEventListener(\"abort\", lnurlFailListener);\r\n        this.lnurlFailSignal.signal.throwIfAborted();\r\n        let resp = { code: IntermediaryAPI_1.PaymentAuthorizationResponseCodes.PENDING, msg: \"\" };\r\n        while (!abortController.signal.aborted && resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.PENDING) {\r\n            resp = await IntermediaryAPI_1.IntermediaryAPI.getPaymentAuthorization(this.url, this.getPaymentHash().toString(\"hex\"));\r\n            if (resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.PENDING)\r\n                await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortController.signal);\r\n        }\r\n        this.lnurlFailSignal.signal.removeEventListener(\"abort\", lnurlFailListener);\r\n        abortController.signal.throwIfAborted();\r\n        if (resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.AUTH_DATA) {\r\n            const sigData = resp.data;\r\n            const swapData = new this.wrapper.swapDataDeserializer(resp.data.data);\r\n            await this.checkIntermediaryReturnedAuthData(this._getInitiator(), swapData, sigData);\r\n            this.expiry = await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getInitAuthorizationExpiry(swapData, sigData));\r\n            if (this.state === FromBTCLNSwapState.PR_CREATED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {\r\n                delete this.initialSwapData;\r\n                this.data = swapData;\r\n                this.signatureData = {\r\n                    prefix: sigData.prefix,\r\n                    timeout: sigData.timeout,\r\n                    signature: sigData.signature\r\n                };\r\n                await this._saveAndEmit(FromBTCLNSwapState.PR_PAID);\r\n            }\r\n            return true;\r\n        }\r\n        if (this.state === FromBTCLNSwapState.PR_CREATED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {\r\n            if (resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.EXPIRED) {\r\n                await this._saveAndEmit(FromBTCLNSwapState.QUOTE_EXPIRED);\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Commit\r\n    /**\r\n     * Commits the swap on-chain, locking the tokens from the intermediary in an HTLC\r\n     *\r\n     * @param signer Signer to sign the transactions with, must be the same as used in the initialization\r\n     * @param abortSignal Abort signal to stop waiting for the transaction confirmation and abort\r\n     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet\r\n     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)\r\n     * @throws {Error} If invalid signer is provided that doesn't match the swap data\r\n     */\r\n    async commit(signer, abortSignal, skipChecks) {\r\n        this.checkSigner(signer);\r\n        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommit(skipChecks), true, abortSignal);\r\n        this.commitTxId = result[0];\r\n        if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {\r\n            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_COMMITED);\r\n        }\r\n        return result[0];\r\n    }\r\n    async waitTillCommited(abortSignal) {\r\n        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED || this.state === FromBTCLNSwapState.CLAIM_CLAIMED)\r\n            return Promise.resolve();\r\n        if (this.state !== FromBTCLNSwapState.PR_PAID && (this.state !== FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null))\r\n            throw new Error(\"Invalid state\");\r\n        const abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const result = await Promise.race([\r\n            this.watchdogWaitTillCommited(abortController.signal),\r\n            this.waitTillState(FromBTCLNSwapState.CLAIM_COMMITED, \"gte\", abortController.signal).then(() => 0)\r\n        ]);\r\n        abortController.abort();\r\n        if (result === 0)\r\n            this.logger.debug(\"waitTillCommited(): Resolved from state changed\");\r\n        if (result === true)\r\n            this.logger.debug(\"waitTillCommited(): Resolved from watchdog - commited\");\r\n        if (result === false) {\r\n            this.logger.debug(\"waitTillCommited(): Resolved from watchdog - signature expired\");\r\n            if (this.state === FromBTCLNSwapState.PR_PAID ||\r\n                this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {\r\n                await this._saveAndEmit(FromBTCLNSwapState.QUOTE_EXPIRED);\r\n            }\r\n            return;\r\n        }\r\n        if (this.state === FromBTCLNSwapState.PR_PAID ||\r\n            this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {\r\n            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_COMMITED);\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Claim\r\n    /**\r\n     * Returns transactions required for claiming the HTLC and finishing the swap by revealing the HTLC secret\r\n     *  (hash preimage)\r\n     *\r\n     * @param signer Optional signer address to use for claiming the swap, can also be different from the initializer\r\n     * @throws {Error} If in invalid state (must be CLAIM_COMMITED)\r\n     */\r\n    txsClaim(signer) {\r\n        if (this.state !== FromBTCLNSwapState.CLAIM_COMMITED)\r\n            throw new Error(\"Must be in CLAIM_COMMITED state!\");\r\n        return this.wrapper.contract.txsClaimWithSecret(signer ?? this._getInitiator(), this.data, this.secret, true, true);\r\n    }\r\n    /**\r\n     * Claims and finishes the swap\r\n     *\r\n     * @param signer Signer to sign the transactions with, can also be different to the initializer\r\n     * @param abortSignal Abort signal to stop waiting for transaction confirmation\r\n     */\r\n    async claim(signer, abortSignal) {\r\n        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsClaim(), true, abortSignal);\r\n        this.claimTxId = result[0];\r\n        if (FromBTCLNSwapState.CLAIM_COMMITED || FromBTCLNSwapState.EXPIRED || FromBTCLNSwapState.FAILED) {\r\n            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_CLAIMED);\r\n        }\r\n        return result[0];\r\n    }\r\n    /**\r\n     * Waits till the swap is successfully claimed\r\n     *\r\n     * @param abortSignal AbortSignal\r\n     * @throws {Error} If swap is in invalid state (must be BTC_TX_CONFIRMED)\r\n     * @throws {Error} If the LP refunded sooner than we were able to claim\r\n     */\r\n    async waitTillClaimed(abortSignal) {\r\n        if (this.state === FromBTCLNSwapState.CLAIM_CLAIMED)\r\n            return Promise.resolve();\r\n        if (this.state !== FromBTCLNSwapState.CLAIM_COMMITED)\r\n            throw new Error(\"Invalid state (not CLAIM_COMMITED)\");\r\n        const abortController = new AbortController();\r\n        if (abortSignal != null)\r\n            abortSignal.addEventListener(\"abort\", () => abortController.abort(abortSignal.reason));\r\n        const res = await Promise.race([\r\n            this.watchdogWaitTillResult(abortController.signal),\r\n            this.waitTillState(FromBTCLNSwapState.CLAIM_CLAIMED, \"eq\", abortController.signal).then(() => 0),\r\n            this.waitTillState(FromBTCLNSwapState.EXPIRED, \"eq\", abortController.signal).then(() => 1),\r\n        ]);\r\n        abortController.abort();\r\n        if (res === 0) {\r\n            this.logger.debug(\"waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)\");\r\n            return;\r\n        }\r\n        if (res === 1) {\r\n            this.logger.debug(\"waitTillClaimed(): Resolved from state change (EXPIRED)\");\r\n            throw new Error(\"Swap expired during claiming\");\r\n        }\r\n        this.logger.debug(\"waitTillClaimed(): Resolved from watchdog\");\r\n        if (res?.type === base_1.SwapCommitStateType.PAID) {\r\n            if (this.state !== FromBTCLNSwapState.CLAIM_CLAIMED) {\r\n                this.claimTxId = await res.getClaimTxId();\r\n                await this._saveAndEmit(FromBTCLNSwapState.CLAIM_CLAIMED);\r\n            }\r\n        }\r\n        if (res?.type === base_1.SwapCommitStateType.NOT_COMMITED || res?.type === base_1.SwapCommitStateType.EXPIRED) {\r\n            if (this.state !== FromBTCLNSwapState.CLAIM_CLAIMED &&\r\n                this.state !== FromBTCLNSwapState.FAILED) {\r\n                this.refundTxId = res.getRefundTxId == null ? null : await res.getRefundTxId();\r\n                await this._saveAndEmit(FromBTCLNSwapState.FAILED);\r\n            }\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Commit & claim\r\n    /**\r\n     * Estimated transaction fee for commit & claim txs combined\r\n     */\r\n    async getCommitAndClaimFee() {\r\n        const swapContract = this.wrapper.contract;\r\n        const feeRate = this.feeRate ?? await swapContract.getInitFeeRate(this.getSwapData().getOfferer(), this.getSwapData().getClaimer(), this.getSwapData().getToken(), this.getSwapData().getClaimHash());\r\n        const commitFee = await (swapContract.getRawCommitFee != null ?\r\n            swapContract.getRawCommitFee(this.getSwapData(), feeRate) :\r\n            swapContract.getCommitFee(this.getSwapData(), feeRate));\r\n        const claimFee = await (swapContract.getRawClaimFee != null ?\r\n            swapContract.getRawClaimFee(this._getInitiator(), this.getSwapData(), feeRate) :\r\n            swapContract.getClaimFee(this._getInitiator(), this.getSwapData(), feeRate));\r\n        return commitFee + claimFee;\r\n    }\r\n    canCommitAndClaimInOneShot() {\r\n        return this.wrapper.contract.initAndClaimWithSecret != null;\r\n    }\r\n    /**\r\n     * Returns transactions for both commit & claim operation together, such that they can be signed all at once by\r\n     *  the wallet. CAUTION: transactions must be sent sequentially, such that the claim (2nd) transaction is only\r\n     *  sent after the commit (1st) transaction confirms. Failure to do so can reveal the HTLC pre-image too soon,\r\n     *  opening a possibility for the LP to steal funds.\r\n     *\r\n     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet\r\n     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)\r\n     *\r\n     * @throws {Error} If in invalid state (must be PR_PAID or CLAIM_COMMITED)\r\n     */\r\n    async txsCommitAndClaim(skipChecks) {\r\n        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED)\r\n            return await this.txsClaim();\r\n        if (this.state !== FromBTCLNSwapState.PR_PAID && (this.state !== FromBTCLNSwapState.QUOTE_SOFT_EXPIRED || this.signatureData == null))\r\n            throw new Error(\"Must be in PR_PAID state!\");\r\n        const initTxs = await this.txsCommit(skipChecks);\r\n        const claimTxs = await this.wrapper.contract.txsClaimWithSecret(this._getInitiator(), this.data, this.secret, true, true, null, true);\r\n        return initTxs.concat(claimTxs);\r\n    }\r\n    /**\r\n     * Commits and claims the swap, in a way that the transactions can be signed together by the underlying provider and\r\n     *  then sent sequentially\r\n     *\r\n     * @param signer Signer to sign the transactions with, must be the same as used in the initialization\r\n     * @param abortSignal Abort signal to stop waiting for the transaction confirmation and abort\r\n     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet\r\n     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)\r\n     * @throws {Error} If in invalid state (must be PR_PAID or CLAIM_COMMITED)\r\n     * @throws {Error} If invalid signer is provided that doesn't match the swap data\r\n     */\r\n    async commitAndClaim(signer, abortSignal, skipChecks) {\r\n        if (!this.canCommitAndClaimInOneShot())\r\n            throw new Error(\"Cannot commitAndClaim in single action, please run commit and claim separately!\");\r\n        this.checkSigner(signer);\r\n        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED)\r\n            return [null, await this.claim(signer)];\r\n        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommitAndClaim(skipChecks), true, abortSignal);\r\n        this.commitTxId = result[0] || this.commitTxId;\r\n        this.claimTxId = result[result.length - 1] || this.claimTxId;\r\n        if (this.state !== FromBTCLNSwapState.CLAIM_CLAIMED) {\r\n            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_CLAIMED);\r\n        }\r\n        return result;\r\n    }\r\n    //////////////////////////////\r\n    //// LNURL\r\n    /**\r\n     * Is this an LNURL-withdraw swap?\r\n     */\r\n    isLNURL() {\r\n        return this.lnurl != null;\r\n    }\r\n    /**\r\n     * Gets the used LNURL or null if this is not an LNURL-withdraw swap\r\n     */\r\n    getLNURL() {\r\n        return this.lnurl;\r\n    }\r\n    /**\r\n     * Pay the generated lightning network invoice with LNURL-withdraw\r\n     */\r\n    async settleWithLNURLWithdraw(lnurl) {\r\n        if (this.lnurl != null)\r\n            throw new Error(\"Cannot settle LNURL-withdraw swap with different LNURL\");\r\n        let lnurlParams;\r\n        if (typeof (lnurl) === \"string\") {\r\n            const parsedLNURL = await LNURL_1.LNURL.getLNURL(lnurl);\r\n            if (parsedLNURL == null || parsedLNURL.tag !== \"withdrawRequest\")\r\n                throw new UserError_1.UserError(\"Invalid LNURL-withdraw to settle the swap\");\r\n            lnurlParams = parsedLNURL;\r\n        }\r\n        else {\r\n            lnurlParams = lnurl.params;\r\n        }\r\n        LNURL_1.LNURL.useLNURLWithdraw(lnurlParams, this.pr).catch(e => this.lnurlFailSignal.abort(e));\r\n        this.lnurl = lnurlParams.url;\r\n        this.lnurlCallback = lnurlParams.callback;\r\n        this.lnurlK1 = lnurlParams.k1;\r\n        this.prPosted = true;\r\n        await this._saveAndEmit();\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            pr: this.pr,\r\n            secret: this.secret,\r\n            lnurl: this.lnurl,\r\n            lnurlK1: this.lnurlK1,\r\n            lnurlCallback: this.lnurlCallback,\r\n            prPosted: this.prPosted,\r\n            initialSwapData: this.initialSwapData == null ? null : this.initialSwapData.serialize()\r\n        };\r\n    }\r\n    //////////////////////////////\r\n    //// Swap ticks & sync\r\n    /**\r\n     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain\r\n     *  data\r\n     *\r\n     * @private\r\n     */\r\n    async syncStateFromChain() {\r\n        //Check for expiry before the getCommitStatus to prevent race conditions\r\n        let quoteExpired = false;\r\n        if (this.state === FromBTCLNSwapState.PR_PAID || (this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null)) {\r\n            quoteExpired = await this.verifyQuoteDefinitelyExpired();\r\n        }\r\n        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED || this.state === FromBTCLNSwapState.EXPIRED) {\r\n            //Check if it's already successfully paid\r\n            const commitStatus = await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));\r\n            if (commitStatus?.type === base_1.SwapCommitStateType.PAID) {\r\n                if (this.claimTxId == null)\r\n                    this.claimTxId = await commitStatus.getClaimTxId();\r\n                this.state = FromBTCLNSwapState.CLAIM_CLAIMED;\r\n                return true;\r\n            }\r\n            if (commitStatus?.type === base_1.SwapCommitStateType.NOT_COMMITED || commitStatus?.type === base_1.SwapCommitStateType.EXPIRED) {\r\n                if (this.refundTxId == null && commitStatus.getRefundTxId)\r\n                    this.refundTxId = await commitStatus.getRefundTxId();\r\n                this.state = FromBTCLNSwapState.FAILED;\r\n                return true;\r\n            }\r\n        }\r\n        if (this.state === FromBTCLNSwapState.PR_PAID || (this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null)) {\r\n            //Check if it's already committed\r\n            const status = await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));\r\n            switch (status?.type) {\r\n                case base_1.SwapCommitStateType.COMMITED:\r\n                    this.state = FromBTCLNSwapState.CLAIM_COMMITED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.EXPIRED:\r\n                    if (this.refundTxId == null && status.getRefundTxId)\r\n                        this.refundTxId = await status.getRefundTxId();\r\n                    this.state = FromBTCLNSwapState.QUOTE_EXPIRED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.PAID:\r\n                    if (this.claimTxId == null)\r\n                        this.claimTxId = await status.getClaimTxId();\r\n                    this.state = FromBTCLNSwapState.CLAIM_CLAIMED;\r\n                    return true;\r\n            }\r\n        }\r\n        //Set the state on expiry here\r\n        if (this.state === FromBTCLNSwapState.PR_PAID || (this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null)) {\r\n            if (quoteExpired) {\r\n                this.state = FromBTCLNSwapState.QUOTE_EXPIRED;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    async _sync(save) {\r\n        let changed = false;\r\n        if (this.state === FromBTCLNSwapState.PR_CREATED || (this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData == null)) {\r\n            if (this.getTimeoutTime() < Date.now()) {\r\n                this.state = FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;\r\n                changed ||= true;\r\n            }\r\n            const result = await this.checkIntermediaryPaymentReceived(false);\r\n            if (result !== null)\r\n                changed ||= true;\r\n        }\r\n        if (await this.syncStateFromChain())\r\n            changed = true;\r\n        if (save && changed)\r\n            await this._saveAndEmit();\r\n        return changed;\r\n    }\r\n    async _tick(save) {\r\n        switch (this.state) {\r\n            case FromBTCLNSwapState.PR_CREATED:\r\n                if (this.getTimeoutTime() < Date.now()) {\r\n                    this.state = FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                break;\r\n            case FromBTCLNSwapState.PR_PAID:\r\n                if (this.expiry < Date.now()) {\r\n                    this.state = FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                break;\r\n            case FromBTCLNSwapState.CLAIM_COMMITED:\r\n                const expired = await this.wrapper.contract.isExpired(this._getInitiator(), this.data);\r\n                if (expired) {\r\n                    this.state = FromBTCLNSwapState.EXPIRED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports.FromBTCLNSwap = FromBTCLNSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7460, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IFromBTCWrapper = void 0;\r\nconst IntermediaryError_1 = require(\"../../../errors/IntermediaryError\");\r\nconst Utils_1 = require(\"../../../utils/Utils\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst IEscrowSwapWrapper_1 = require(\"../IEscrowSwapWrapper\");\r\nclass IFromBTCWrapper extends IEscrowSwapWrapper_1.IEscrowSwapWrapper {\r\n    /**\r\n     * Returns a random sequence to be used for swaps\r\n     *\r\n     * @protected\r\n     * @returns Random 64-bit sequence number\r\n     */\r\n    getRandomSequence() {\r\n        return base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(8));\r\n    }\r\n    /**\r\n     * Pre-fetches feeRate for a given swap\r\n     *\r\n     * @param signer Address initiating the swap\r\n     * @param amountData\r\n     * @param claimHash optional claim hash of the swap or null\r\n     * @param abortController\r\n     * @protected\r\n     * @returns Fee rate\r\n     */\r\n    preFetchFeeRate(signer, amountData, claimHash, abortController) {\r\n        return (0, Utils_1.tryWithRetries)(() => this.contract.getInitFeeRate(null, signer, amountData.token, claimHash), null, null, abortController.signal).catch(e => {\r\n            this.logger.warn(\"preFetchFeeRate(): Error: \", e);\r\n            abortController.abort(e);\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Pre-fetches intermediary's available SC on-chain liquidity\r\n     * @param amountData\r\n     * @param lp Intermediary\r\n     * @param abortController\r\n     * @protected\r\n     * @returns Intermediary's liquidity balance\r\n     */\r\n    preFetchIntermediaryLiquidity(amountData, lp, abortController) {\r\n        return lp.getLiquidity(this.chainIdentifier, this.contract, amountData.token.toString(), abortController.signal).catch(e => {\r\n            this.logger.warn(\"preFetchIntermediaryLiquidity(): Error: \", e);\r\n            abortController.abort(e);\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies whether the intermediary has enough available liquidity such that we can initiate the swap\r\n     *\r\n     * @param amount Swap amount that we should receive\r\n     * @param liquidityPromise pre-fetched liquidity promise as obtained from preFetchIntermediaryLiquidity()\r\n     * @protected\r\n     * @throws {IntermediaryError} if intermediary's liquidity is lower than what's required for the swap\r\n     */\r\n    async verifyIntermediaryLiquidity(amount, liquidityPromise) {\r\n        const liquidity = await liquidityPromise;\r\n        if (liquidity < amount)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Intermediary doesn't have enough liquidity\");\r\n    }\r\n}\r\nexports.IFromBTCWrapper = IFromBTCWrapper;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,eAAe,GAAG,KAAK;AAC/B,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,wBAAwB,qBAAqB,kBAAkB;IACjE;;;;;KAKC,GACD,oBAAoB;QAChB,OAAO,OAAO,iBAAiB,CAAC,UAAU,CAAC,CAAC,GAAG,QAAQ,WAAW,EAAE;IACxE;IACA;;;;;;;;;KASC,GACD,gBAAgB,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,eAAe,EAAE;QAC5D,OAAO,CAAC,GAAG,QAAQ,cAAc,EAAE,IAAM,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,MAAM,QAAQ,WAAW,KAAK,EAAE,YAAY,MAAM,MAAM,gBAAgB,MAAM,EAAE,KAAK,CAAC,CAAA;YACxJ,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,8BAA8B;YAC/C,gBAAgB,KAAK,CAAC;YACtB,OAAO;QACX;IACJ;IACA;;;;;;;KAOC,GACD,8BAA8B,UAAU,EAAE,EAAE,EAAE,eAAe,EAAE;QAC3D,OAAO,GAAG,YAAY,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,QAAQ,EAAE,WAAW,KAAK,CAAC,QAAQ,IAAI,gBAAgB,MAAM,EAAE,KAAK,CAAC,CAAA;YACnH,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,4CAA4C;YAC7D,gBAAgB,KAAK,CAAC;YACtB,OAAO;QACX;IACJ;IACA;;;;;;;KAOC,GACD,MAAM,4BAA4B,MAAM,EAAE,gBAAgB,EAAE;QACxD,MAAM,YAAY,MAAM;QACxB,IAAI,YAAY,QACZ,MAAM,IAAI,oBAAoB,iBAAiB,CAAC;IACxD;AACJ;AACA,QAAQ,eAAe,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7524, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FromBTCLNWrapper = void 0;\r\nconst FromBTCLNSwap_1 = require(\"./FromBTCLNSwap\");\r\nconst IFromBTCWrapper_1 = require(\"../IFromBTCWrapper\");\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst UserError_1 = require(\"../../../../errors/UserError\");\r\nconst sha2_1 = require(\"@noble/hashes/sha2\");\r\nconst IntermediaryError_1 = require(\"../../../../errors/IntermediaryError\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nconst IntermediaryAPI_1 = require(\"../../../../intermediaries/IntermediaryAPI\");\r\nconst RequestError_1 = require(\"../../../../errors/RequestError\");\r\nconst LNURL_1 = require(\"../../../../utils/LNURL\");\r\nclass FromBTCLNWrapper extends IFromBTCWrapper_1.IFromBTCWrapper {\r\n    /**\r\n     * @param chainIdentifier\r\n     * @param unifiedStorage Storage interface for the current environment\r\n     * @param unifiedChainEvents On-chain event listener\r\n     * @param chain\r\n     * @param contract Underlying contract handling the swaps\r\n     * @param prices Swap pricing handler\r\n     * @param tokens\r\n     * @param swapDataDeserializer Deserializer for SwapData\r\n     * @param lnApi\r\n     * @param options\r\n     * @param events Instance to use for emitting events\r\n     */\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, lnApi, options, events) {\r\n        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);\r\n        this.TYPE = SwapType_1.SwapType.FROM_BTCLN;\r\n        this.swapDeserializer = FromBTCLNSwap_1.FromBTCLNSwap;\r\n        this.pendingSwapStates = [\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.PR_CREATED,\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED,\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.PR_PAID,\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_COMMITED,\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.EXPIRED\r\n        ];\r\n        this.tickSwapState = [\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.PR_CREATED,\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.PR_PAID,\r\n            FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_COMMITED\r\n        ];\r\n        this.lnApi = lnApi;\r\n    }\r\n    processEventInitialize(swap, event) {\r\n        if (swap.state === FromBTCLNSwap_1.FromBTCLNSwapState.PR_PAID || swap.state === FromBTCLNSwap_1.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {\r\n            swap.state = FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_COMMITED;\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    processEventClaim(swap, event) {\r\n        if (swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.FAILED && swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_CLAIMED) {\r\n            swap.state = FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_CLAIMED;\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    processEventRefund(swap, event) {\r\n        if (swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_CLAIMED && swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.FAILED) {\r\n            swap.state = FromBTCLNSwap_1.FromBTCLNSwapState.FAILED;\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    /**\r\n     * Returns the swap expiry, leaving enough time for the user to claim the HTLC\r\n     *\r\n     * @param data Parsed swap data\r\n     */\r\n    getHtlcTimeout(data) {\r\n        return data.getExpiry() - 600n;\r\n    }\r\n    /**\r\n     * Generates a new 32-byte secret to be used as pre-image for lightning network invoice & HTLC swap\\\r\n     *\r\n     * @private\r\n     * @returns Hash pre-image & payment hash\r\n     */\r\n    getSecretAndHash() {\r\n        const secret = (0, Utils_1.randomBytes)(32);\r\n        const paymentHash = buffer_1.Buffer.from((0, sha2_1.sha256)(secret));\r\n        return { secret, paymentHash };\r\n    }\r\n    /**\r\n     * Pre-fetches intermediary's LN node capacity, doesn't throw, instead returns null\r\n     *\r\n     * @param pubkeyPromise Promise that resolves when we receive \"lnPublicKey\" param from the intermediary thorugh\r\n     *  streaming\r\n     * @private\r\n     * @returns LN Node liquidity\r\n     */\r\n    preFetchLnCapacity(pubkeyPromise) {\r\n        return pubkeyPromise.then(pubkey => {\r\n            if (pubkey == null)\r\n                return null;\r\n            return this.lnApi.getLNNodeLiquidity(pubkey);\r\n        }).catch(e => {\r\n            this.logger.warn(\"preFetchLnCapacity(): Error: \", e);\r\n            return null;\r\n        });\r\n    }\r\n    /**\r\n     * Verifies response returned from intermediary\r\n     *\r\n     * @param resp Response as returned by the intermediary\r\n     * @param amountData\r\n     * @param lp Intermediary\r\n     * @param options Options as passed to the swap creation function\r\n     * @param decodedPr Decoded bolt11 lightning network invoice\r\n     * @param amountIn Amount in sats that will be paid for the swap\r\n     * @private\r\n     * @throws {IntermediaryError} in case the response is invalid\r\n     */\r\n    verifyReturnedData(resp, amountData, lp, options, decodedPr, amountIn) {\r\n        if (lp.getAddress(this.chainIdentifier) !== resp.intermediaryKey)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid intermediary address/pubkey\");\r\n        if (options.descriptionHash != null && decodedPr.tagsObject.purpose_commit_hash !== options.descriptionHash.toString(\"hex\"))\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid pr returned - description hash\");\r\n        if (!amountData.exactIn) {\r\n            if (resp.total != amountData.amount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid amount returned\");\r\n        }\r\n        else {\r\n            if (amountIn !== amountData.amount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid payment request returned, amount mismatch\");\r\n        }\r\n    }\r\n    /**\r\n     * Verifies whether the intermediary's lightning node has enough inbound capacity to receive the LN payment\r\n     *\r\n     * @param lp Intermediary\r\n     * @param decodedPr Decoded bolt11 lightning network invoice\r\n     * @param amountIn Amount to be paid for the swap in sats\r\n     * @param lnCapacityPrefetchPromise Pre-fetch for LN node capacity, preFetchLnCapacity()\r\n     * @param abortSignal\r\n     * @private\r\n     * @throws {IntermediaryError} if the lightning network node doesn't have enough inbound liquidity\r\n     * @throws {Error} if the lightning network node's inbound liquidity might be enough, but the swap would\r\n     *  deplete more than half of the liquidity\r\n     */\r\n    async verifyLnNodeCapacity(lp, decodedPr, amountIn, lnCapacityPrefetchPromise, abortSignal) {\r\n        let result = lnCapacityPrefetchPromise == null ? null : await lnCapacityPrefetchPromise;\r\n        if (result == null)\r\n            result = await this.lnApi.getLNNodeLiquidity(decodedPr.payeeNodeKey);\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        if (result === null)\r\n            throw new IntermediaryError_1.IntermediaryError(\"LP's lightning node not found in the lightning network graph!\");\r\n        lp.lnData = result;\r\n        if (decodedPr.payeeNodeKey !== result.publicKey)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid pr returned - payee pubkey\");\r\n        if (result.capacity < amountIn)\r\n            throw new IntermediaryError_1.IntermediaryError(\"LP's lightning node doesn't have enough inbound capacity for the swap!\");\r\n        if ((result.capacity / 2n) < amountIn)\r\n            throw new Error(\"LP's lightning node probably doesn't have enough inbound capacity for the swap!\");\r\n    }\r\n    /**\r\n     * Returns a newly created swap, receiving 'amount' on lightning network\r\n     *\r\n     * @param signer                Smart chain signer's address intiating the swap\r\n     * @param amountData            Amount of token & amount to swap\r\n     * @param lps                   LPs (liquidity providers) to get the quotes from\r\n     * @param options               Quote options\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param abortSignal           Abort signal for aborting the process\r\n     * @param preFetches\r\n     */\r\n    create(signer, amountData, lps, options, additionalParams, abortSignal, preFetches) {\r\n        if (options == null)\r\n            options = {};\r\n        options.unsafeSkipLnNodeCheck ??= this.options.unsafeSkipLnNodeCheck;\r\n        if (preFetches == null)\r\n            preFetches = {};\r\n        if (options.descriptionHash != null && options.descriptionHash.length !== 32)\r\n            throw new UserError_1.UserError(\"Invalid description hash length\");\r\n        const { secret, paymentHash } = this.getSecretAndHash();\r\n        const claimHash = this.contract.getHashForHtlc(paymentHash);\r\n        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        preFetches.pricePrefetchPromise ??= this.preFetchPrice(amountData, _abortController.signal);\r\n        const nativeTokenAddress = this.chain.getNativeCurrencyAddress();\r\n        preFetches.feeRatePromise ??= this.preFetchFeeRate(signer, amountData, claimHash.toString(\"hex\"), _abortController);\r\n        return lps.map(lp => {\r\n            return {\r\n                intermediary: lp,\r\n                quote: (async () => {\r\n                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);\r\n                    const liquidityPromise = this.preFetchIntermediaryLiquidity(amountData, lp, abortController);\r\n                    const { lnCapacityPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount) => {\r\n                        const { lnPublicKey, response } = IntermediaryAPI_1.IntermediaryAPI.initFromBTCLN(this.chainIdentifier, lp.url, nativeTokenAddress, {\r\n                            paymentHash,\r\n                            amount: amountData.amount,\r\n                            claimer: signer,\r\n                            token: amountData.token.toString(),\r\n                            descriptionHash: options.descriptionHash,\r\n                            exactOut: !amountData.exactIn,\r\n                            feeRate: preFetches.feeRatePromise,\r\n                            additionalParams\r\n                        }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);\r\n                        return {\r\n                            lnCapacityPromise: options.unsafeSkipLnNodeCheck ? null : this.preFetchLnCapacity(lnPublicKey),\r\n                            resp: await response\r\n                        };\r\n                    }, null, RequestError_1.RequestError, abortController.signal);\r\n                    const decodedPr = (0, bolt11_1.decode)(resp.pr);\r\n                    const amountIn = (BigInt(decodedPr.millisatoshis) + 999n) / 1000n;\r\n                    try {\r\n                        this.verifyReturnedData(resp, amountData, lp, options, decodedPr, amountIn);\r\n                        const [pricingInfo] = await Promise.all([\r\n                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.FROM_BTCLN], false, amountIn, resp.total, amountData.token, {}, preFetches.pricePrefetchPromise, abortController.signal),\r\n                            this.verifyIntermediaryLiquidity(resp.total, liquidityPromise),\r\n                            options.unsafeSkipLnNodeCheck ? Promise.resolve() : this.verifyLnNodeCapacity(lp, decodedPr, amountIn, lnCapacityPromise, abortController.signal)\r\n                        ]);\r\n                        const quote = new FromBTCLNSwap_1.FromBTCLNSwap(this, {\r\n                            pricingInfo,\r\n                            url: lp.url,\r\n                            expiry: decodedPr.timeExpireDate * 1000,\r\n                            swapFee: resp.swapFee,\r\n                            feeRate: await preFetches.feeRatePromise,\r\n                            initialSwapData: await this.contract.createSwapData(base_1.ChainSwapType.HTLC, lp.getAddress(this.chainIdentifier), signer, amountData.token, resp.total, claimHash.toString(\"hex\"), this.getRandomSequence(), BigInt(Math.floor(Date.now() / 1000)), false, true, resp.securityDeposit, 0n, nativeTokenAddress),\r\n                            pr: resp.pr,\r\n                            secret: secret.toString(\"hex\"),\r\n                            exactIn: amountData.exactIn ?? true\r\n                        });\r\n                        await quote._save();\r\n                        return quote;\r\n                    }\r\n                    catch (e) {\r\n                        abortController.abort(e);\r\n                        throw e;\r\n                    }\r\n                })()\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Parses and fetches lnurl withdraw params from the specified lnurl\r\n     *\r\n     * @param lnurl LNURL to be parsed and fetched\r\n     * @param abortSignal\r\n     * @private\r\n     * @throws {UserError} if the LNURL is invalid or if it's not a LNURL-withdraw\r\n     */\r\n    async getLNURLWithdraw(lnurl, abortSignal) {\r\n        if (typeof (lnurl) !== \"string\")\r\n            return lnurl;\r\n        const res = await LNURL_1.LNURL.getLNURL(lnurl, true, this.options.getRequestTimeout, abortSignal);\r\n        if (res == null)\r\n            throw new UserError_1.UserError(\"Invalid LNURL\");\r\n        if (res.tag !== \"withdrawRequest\")\r\n            throw new UserError_1.UserError(\"Not a LNURL-withdrawal\");\r\n        return res;\r\n    }\r\n    /**\r\n     * Returns a newly created swap, receiving 'amount' from the lnurl-withdraw\r\n     *\r\n     * @param signer                Smart chains signer's address intiating the swap\r\n     * @param lnurl                 LNURL-withdraw to withdraw funds from\r\n     * @param amountData            Amount of token & amount to swap\r\n     * @param lps                   LPs (liquidity providers) to get the quotes from\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param abortSignal           Abort signal for aborting the process\r\n     */\r\n    async createViaLNURL(signer, lnurl, amountData, lps, additionalParams, abortSignal) {\r\n        if (!this.isInitialized)\r\n            throw new Error(\"Not initialized, call init() first!\");\r\n        const abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const preFetches = {\r\n            pricePrefetchPromise: this.preFetchPrice(amountData, abortController.signal),\r\n            feeRatePromise: this.preFetchFeeRate(signer, amountData, null, abortController)\r\n        };\r\n        try {\r\n            const exactOutAmountPromise = !amountData.exactIn ? preFetches.pricePrefetchPromise.then(price => this.prices.getToBtcSwapAmount(this.chainIdentifier, amountData.amount, amountData.token, abortController.signal, price)).catch(e => {\r\n                abortController.abort(e);\r\n                return null;\r\n            }) : null;\r\n            const withdrawRequest = await this.getLNURLWithdraw(lnurl, abortController.signal);\r\n            const min = BigInt(withdrawRequest.minWithdrawable) / 1000n;\r\n            const max = BigInt(withdrawRequest.maxWithdrawable) / 1000n;\r\n            if (amountData.exactIn) {\r\n                if (amountData.amount < min)\r\n                    throw new UserError_1.UserError(\"Amount less than LNURL-withdraw minimum\");\r\n                if (amountData.amount > max)\r\n                    throw new UserError_1.UserError(\"Amount more than LNURL-withdraw maximum\");\r\n            }\r\n            else {\r\n                const amount = await exactOutAmountPromise;\r\n                abortController.signal.throwIfAborted();\r\n                if ((amount * 95n / 100n) < min)\r\n                    throw new UserError_1.UserError(\"Amount less than LNURL-withdraw minimum\");\r\n                if ((amount * 105n / 100n) > max)\r\n                    throw new UserError_1.UserError(\"Amount more than LNURL-withdraw maximum\");\r\n            }\r\n            return this.create(signer, amountData, lps, null, additionalParams, abortSignal, preFetches).map(data => {\r\n                return {\r\n                    quote: data.quote.then(quote => {\r\n                        quote.lnurl = withdrawRequest.url;\r\n                        quote.lnurlK1 = withdrawRequest.k1;\r\n                        quote.lnurlCallback = withdrawRequest.callback;\r\n                        const amountIn = quote.getInput().rawAmount;\r\n                        if (amountIn < min)\r\n                            throw new UserError_1.UserError(\"Amount less than LNURL-withdraw minimum\");\r\n                        if (amountIn > max)\r\n                            throw new UserError_1.UserError(\"Amount more than LNURL-withdraw maximum\");\r\n                        return quote;\r\n                    }),\r\n                    intermediary: data.intermediary\r\n                };\r\n            });\r\n        }\r\n        catch (e) {\r\n            abortController.abort(e);\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nexports.FromBTCLNWrapper = FromBTCLNWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7821, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FromBTCSwap = exports.isFromBTCSwapInit = exports.FromBTCSwapState = void 0;\r\nconst IFromBTCSwap_1 = require(\"../IFromBTCSwap\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst Tokens_1 = require(\"../../../../Tokens\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nconst IEscrowSwap_1 = require(\"../../IEscrowSwap\");\r\nconst IBitcoinWallet_1 = require(\"../../../../btc/wallet/IBitcoinWallet\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst SingleAddressBitcoinWallet_1 = require(\"../../../../btc/wallet/SingleAddressBitcoinWallet\");\r\nvar FromBTCSwapState;\r\n(function (FromBTCSwapState) {\r\n    FromBTCSwapState[FromBTCSwapState[\"FAILED\"] = -4] = \"FAILED\";\r\n    FromBTCSwapState[FromBTCSwapState[\"EXPIRED\"] = -3] = \"EXPIRED\";\r\n    FromBTCSwapState[FromBTCSwapState[\"QUOTE_EXPIRED\"] = -2] = \"QUOTE_EXPIRED\";\r\n    FromBTCSwapState[FromBTCSwapState[\"QUOTE_SOFT_EXPIRED\"] = -1] = \"QUOTE_SOFT_EXPIRED\";\r\n    FromBTCSwapState[FromBTCSwapState[\"PR_CREATED\"] = 0] = \"PR_CREATED\";\r\n    FromBTCSwapState[FromBTCSwapState[\"CLAIM_COMMITED\"] = 1] = \"CLAIM_COMMITED\";\r\n    FromBTCSwapState[FromBTCSwapState[\"BTC_TX_CONFIRMED\"] = 2] = \"BTC_TX_CONFIRMED\";\r\n    FromBTCSwapState[FromBTCSwapState[\"CLAIM_CLAIMED\"] = 3] = \"CLAIM_CLAIMED\";\r\n})(FromBTCSwapState = exports.FromBTCSwapState || (exports.FromBTCSwapState = {}));\r\nfunction isFromBTCSwapInit(obj) {\r\n    return typeof (obj.address) === \"string\" &&\r\n        typeof (obj.amount) === \"bigint\" &&\r\n        (0, IEscrowSwap_1.isIEscrowSwapInit)(obj);\r\n}\r\nexports.isFromBTCSwapInit = isFromBTCSwapInit;\r\nclass FromBTCSwap extends IFromBTCSwap_1.IFromBTCSwap {\r\n    constructor(wrapper, initOrObject) {\r\n        if (isFromBTCSwapInit(initOrObject))\r\n            initOrObject.url += \"/frombtc\";\r\n        super(wrapper, initOrObject);\r\n        this.inputToken = Tokens_1.BitcoinTokens.BTC;\r\n        this.TYPE = SwapType_1.SwapType.FROM_BTC;\r\n        if (isFromBTCSwapInit(initOrObject)) {\r\n            this.state = FromBTCSwapState.PR_CREATED;\r\n        }\r\n        else {\r\n            this.address = initOrObject.address;\r\n            this.amount = BigInt(initOrObject.amount);\r\n            this.txId = initOrObject.txId;\r\n            this.vout = initOrObject.vout;\r\n            this.requiredConfirmations = initOrObject.requiredConfirmations ?? this.data.getConfirmationsHint();\r\n        }\r\n        this.tryRecomputeSwapPrice();\r\n        this.logger = (0, Utils_1.getLogger)(\"FromBTC(\" + this.getIdentifierHashString() + \"): \");\r\n    }\r\n    upgradeVersion() {\r\n        if (this.version == null) {\r\n            switch (this.state) {\r\n                case -2:\r\n                    this.state = FromBTCSwapState.FAILED;\r\n                    break;\r\n                case -1:\r\n                    this.state = FromBTCSwapState.QUOTE_EXPIRED;\r\n                    break;\r\n                case 0:\r\n                    this.state = FromBTCSwapState.PR_CREATED;\r\n                    break;\r\n                case 1:\r\n                    this.state = FromBTCSwapState.CLAIM_COMMITED;\r\n                    break;\r\n                case 2:\r\n                    this.state = FromBTCSwapState.BTC_TX_CONFIRMED;\r\n                    break;\r\n                case 3:\r\n                    this.state = FromBTCSwapState.CLAIM_CLAIMED;\r\n                    break;\r\n            }\r\n            this.version = 1;\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    /**\r\n     * Returns bitcoin address where the on-chain BTC should be sent to\r\n     */\r\n    getAddress() {\r\n        if (this.state === FromBTCSwapState.PR_CREATED)\r\n            return null;\r\n        return this.address;\r\n    }\r\n    getHyperlink() {\r\n        if (this.state === FromBTCSwapState.PR_CREATED)\r\n            return null;\r\n        return \"bitcoin:\" + this.address + \"?amount=\" + encodeURIComponent((Number(this.amount) / 100000000).toString(10));\r\n    }\r\n    getInputTxId() {\r\n        return this.txId;\r\n    }\r\n    /**\r\n     * Returns timeout time (in UNIX milliseconds) when the on-chain address will expire and no funds should be sent\r\n     *  to that address anymore\r\n     */\r\n    getTimeoutTime() {\r\n        return Number(this.wrapper.getOnchainSendTimeout(this.data, this.requiredConfirmations)) * 1000;\r\n    }\r\n    requiresAction() {\r\n        return this.isClaimable() || (this.state === FromBTCSwapState.CLAIM_COMMITED && this.getTimeoutTime() > Date.now());\r\n    }\r\n    isFinished() {\r\n        return this.state === FromBTCSwapState.CLAIM_CLAIMED || this.state === FromBTCSwapState.QUOTE_EXPIRED || this.state === FromBTCSwapState.FAILED;\r\n    }\r\n    isClaimable() {\r\n        return this.state === FromBTCSwapState.BTC_TX_CONFIRMED;\r\n    }\r\n    isSuccessful() {\r\n        return this.state === FromBTCSwapState.CLAIM_CLAIMED;\r\n    }\r\n    isFailed() {\r\n        return this.state === FromBTCSwapState.FAILED || (this.state === FromBTCSwapState.EXPIRED && this.txId != null);\r\n    }\r\n    isQuoteExpired() {\r\n        return this.state === FromBTCSwapState.QUOTE_EXPIRED;\r\n    }\r\n    isQuoteSoftExpired() {\r\n        return this.state === FromBTCSwapState.QUOTE_EXPIRED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED;\r\n    }\r\n    canCommit() {\r\n        if (this.state !== FromBTCSwapState.PR_CREATED)\r\n            return false;\r\n        const expiry = this.wrapper.getOnchainSendTimeout(this.data, this.requiredConfirmations);\r\n        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));\r\n        return (expiry - currentTimestamp) >= this.wrapper.options.minSendWindow;\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getInput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.amount, this.inputToken, this.wrapper.prices);\r\n    }\r\n    /**\r\n     * Returns claimer bounty, acting as a reward for watchtowers to claim the swap automatically\r\n     */\r\n    getClaimerBounty() {\r\n        return (0, Tokens_1.toTokenAmount)(this.data.getClaimerBounty(), this.wrapper.tokens[this.data.getDepositToken()], this.wrapper.prices);\r\n    }\r\n    //////////////////////////////\r\n    //// Bitcoin tx\r\n    getRequiredConfirmationsCount() {\r\n        return this.requiredConfirmations;\r\n    }\r\n    /**\r\n     * Checks whether a bitcoin payment was already made, returns the payment or null when no payment has been made.\r\n     */\r\n    async getBitcoinPayment() {\r\n        const result = await this.wrapper.btcRpc.checkAddressTxos(this.address, buffer_1.Buffer.from(this.data.getTxoHashHint(), \"hex\"));\r\n        if (result == null)\r\n            return null;\r\n        return {\r\n            txId: result.tx.txid,\r\n            vout: result.vout,\r\n            confirmations: result.tx.confirmations,\r\n            targetConfirmations: this.requiredConfirmations\r\n        };\r\n    }\r\n    /**\r\n     * Waits till the bitcoin transaction confirms and swap becomes claimable\r\n     *\r\n     * @param abortSignal Abort signal\r\n     * @param checkIntervalSeconds How often to check the bitcoin transaction\r\n     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations\r\n     * @throws {Error} if in invalid state (must be CLAIM_COMMITED)\r\n     */\r\n    async waitForBitcoinTransaction(abortSignal, checkIntervalSeconds, updateCallback) {\r\n        if (this.state !== FromBTCSwapState.CLAIM_COMMITED && this.state !== FromBTCSwapState.EXPIRED)\r\n            throw new Error(\"Must be in COMMITED state!\");\r\n        const result = await this.wrapper.btcRpc.waitForAddressTxo(this.address, buffer_1.Buffer.from(this.data.getTxoHashHint(), \"hex\"), this.requiredConfirmations, (confirmations, txId, vout, txEtaMs) => {\r\n            if (updateCallback != null)\r\n                updateCallback(txId, confirmations, this.requiredConfirmations, txEtaMs);\r\n        }, abortSignal, checkIntervalSeconds);\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        this.txId = result.tx.txid;\r\n        this.vout = result.vout;\r\n        if (this.state !== FromBTCSwapState.CLAIM_CLAIMED &&\r\n            this.state !== FromBTCSwapState.FAILED) {\r\n            this.state = FromBTCSwapState.BTC_TX_CONFIRMED;\r\n        }\r\n        await this._saveAndEmit();\r\n        return result.tx.txid;\r\n    }\r\n    async getFundedPsbt(_bitcoinWallet, feeRate) {\r\n        if (this.state !== FromBTCSwapState.CLAIM_COMMITED)\r\n            throw new Error(\"Swap not committed yet, please initiate the swap first with commit() call!\");\r\n        let bitcoinWallet;\r\n        if ((0, IBitcoinWallet_1.isIBitcoinWallet)(_bitcoinWallet)) {\r\n            bitcoinWallet = _bitcoinWallet;\r\n        }\r\n        else {\r\n            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.wrapper.btcRpc, this.wrapper.options.bitcoinNetwork, _bitcoinWallet);\r\n        }\r\n        //TODO: Maybe re-introduce fee rate check here if passed from the user\r\n        if (feeRate == null) {\r\n            feeRate = await bitcoinWallet.getFeeRate();\r\n        }\r\n        const basePsbt = new btc_signer_1.Transaction({\r\n            allowUnknownOutputs: true,\r\n            allowLegacyWitnessUtxo: true\r\n        });\r\n        basePsbt.addOutput({\r\n            amount: this.amount,\r\n            script: (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address)\r\n        });\r\n        const psbt = await bitcoinWallet.fundPsbt(basePsbt, feeRate);\r\n        //Sign every input\r\n        const signInputs = [];\r\n        for (let i = 0; i < psbt.inputsLength; i++) {\r\n            signInputs.push(i);\r\n        }\r\n        return { psbt, signInputs };\r\n    }\r\n    async submitPsbt(psbt) {\r\n        if (this.state !== FromBTCSwapState.CLAIM_COMMITED)\r\n            throw new Error(\"Swap not committed yet, please initiate the swap first with commit() call!\");\r\n        //Ensure not expired\r\n        if (this.getTimeoutTime() < Date.now()) {\r\n            throw new Error(\"Swap address expired!\");\r\n        }\r\n        const output0 = psbt.getOutput(0);\r\n        if (output0.amount !== this.amount)\r\n            throw new Error(\"PSBT output amount invalid, expected: \" + this.amount + \" got: \" + output0.amount);\r\n        const expectedOutputScript = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address);\r\n        if (!expectedOutputScript.equals(output0.script))\r\n            throw new Error(\"PSBT output script invalid!\");\r\n        if (!psbt.isFinal)\r\n            psbt.finalize();\r\n        return await this.wrapper.btcRpc.sendRawTransaction(buffer_1.Buffer.from(psbt.toBytes(true, true)).toString(\"hex\"));\r\n    }\r\n    async estimateBitcoinFee(wallet, feeRate) {\r\n        const txFee = await wallet.getTransactionFee(this.address, this.amount, feeRate);\r\n        return (0, Tokens_1.toTokenAmount)(txFee == null ? null : BigInt(txFee), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);\r\n    }\r\n    async sendBitcoinTransaction(wallet, feeRate) {\r\n        if (this.state !== FromBTCSwapState.CLAIM_COMMITED)\r\n            throw new Error(\"Swap not committed yet, please initiate the swap first with commit() call!\");\r\n        return await wallet.sendTransaction(this.address, this.amount, feeRate);\r\n    }\r\n    //////////////////////////////\r\n    //// Commit\r\n    /**\r\n     * Commits the swap on-chain, locking the tokens from the intermediary in a PTLC\r\n     *\r\n     * @param signer Signer to sign the transactions with, must be the same as used in the initialization\r\n     * @param abortSignal Abort signal to stop waiting for the transaction confirmation and abort\r\n     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet\r\n     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)\r\n     * @throws {Error} If invalid signer is provided that doesn't match the swap data\r\n     */\r\n    async commit(signer, abortSignal, skipChecks) {\r\n        this.checkSigner(signer);\r\n        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommit(skipChecks), true, abortSignal);\r\n        this.commitTxId = result[0];\r\n        if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {\r\n            await this._saveAndEmit(FromBTCSwapState.CLAIM_COMMITED);\r\n        }\r\n        return result[0];\r\n    }\r\n    async waitTillCommited(abortSignal) {\r\n        if (this.state === FromBTCSwapState.CLAIM_COMMITED || this.state === FromBTCSwapState.CLAIM_CLAIMED)\r\n            return Promise.resolve();\r\n        if (this.state !== FromBTCSwapState.PR_CREATED && this.state !== FromBTCSwapState.QUOTE_SOFT_EXPIRED)\r\n            throw new Error(\"Invalid state\");\r\n        const abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const result = await Promise.race([\r\n            this.watchdogWaitTillCommited(abortController.signal),\r\n            this.waitTillState(FromBTCSwapState.CLAIM_COMMITED, \"gte\", abortController.signal).then(() => 0)\r\n        ]);\r\n        abortController.abort();\r\n        if (result === 0)\r\n            this.logger.debug(\"waitTillCommited(): Resolved from state changed\");\r\n        if (result === true)\r\n            this.logger.debug(\"waitTillCommited(): Resolved from watchdog - commited\");\r\n        if (result === false) {\r\n            this.logger.debug(\"waitTillCommited(): Resolved from watchdog - signature expired\");\r\n            if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {\r\n                await this._saveAndEmit(FromBTCSwapState.QUOTE_EXPIRED);\r\n            }\r\n            return;\r\n        }\r\n        if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {\r\n            await this._saveAndEmit(FromBTCSwapState.CLAIM_COMMITED);\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Claim\r\n    /**\r\n     * Returns transactions required to claim the swap on-chain (and possibly also sync the bitcoin light client)\r\n     *  after a bitcoin transaction was sent and confirmed\r\n     *\r\n     * @throws {Error} If the swap is in invalid state (must be BTC_TX_CONFIRMED)\r\n     */\r\n    async txsClaim(signer) {\r\n        if (this.state !== FromBTCSwapState.BTC_TX_CONFIRMED)\r\n            throw new Error(\"Must be in BTC_TX_CONFIRMED state!\");\r\n        const tx = await this.wrapper.btcRpc.getTransaction(this.txId);\r\n        return await this.wrapper.contract.txsClaimWithTxData(signer ?? this._getInitiator(), this.data, {\r\n            blockhash: tx.blockhash,\r\n            confirmations: tx.confirmations,\r\n            txid: tx.txid,\r\n            hex: tx.hex,\r\n            height: tx.blockheight\r\n        }, this.requiredConfirmations, this.vout, null, this.wrapper.synchronizer, true);\r\n    }\r\n    /**\r\n     * Claims and finishes the swap\r\n     *\r\n     * @param signer Signer to sign the transactions with, can also be different to the initializer\r\n     * @param abortSignal Abort signal to stop waiting for transaction confirmation\r\n     */\r\n    async claim(signer, abortSignal) {\r\n        let txIds;\r\n        try {\r\n            txIds = await this.wrapper.chain.sendAndConfirm(signer, await this.txsClaim(signer), true, abortSignal);\r\n        }\r\n        catch (e) {\r\n            this.logger.info(\"claim(): Failed to claim ourselves, checking swap claim state...\");\r\n            if (this.state === FromBTCSwapState.CLAIM_CLAIMED) {\r\n                this.logger.info(\"claim(): Transaction state is CLAIM_CLAIMED, swap was successfully claimed by the watchtower\");\r\n                return this.claimTxId;\r\n            }\r\n            const status = await this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data);\r\n            if (status?.type === base_1.SwapCommitStateType.PAID) {\r\n                this.logger.info(\"claim(): Transaction commit status is PAID, swap was successfully claimed by the watchtower\");\r\n                if (this.claimTxId == null)\r\n                    this.claimTxId = await status.getClaimTxId();\r\n                await this._saveAndEmit(FromBTCSwapState.CLAIM_CLAIMED);\r\n                return this.claimTxId;\r\n            }\r\n            throw e;\r\n        }\r\n        this.claimTxId = txIds[txIds.length - 1];\r\n        if (this.state === FromBTCSwapState.CLAIM_COMMITED || this.state === FromBTCSwapState.BTC_TX_CONFIRMED ||\r\n            this.state === FromBTCSwapState.EXPIRED || this.state === FromBTCSwapState.FAILED) {\r\n            await this._saveAndEmit(FromBTCSwapState.CLAIM_CLAIMED);\r\n        }\r\n        return txIds[0];\r\n    }\r\n    /**\r\n     * Waits till the swap is successfully claimed\r\n     *\r\n     * @param abortSignal AbortSignal\r\n     * @throws {Error} If swap is in invalid state (must be BTC_TX_CONFIRMED)\r\n     * @throws {Error} If the LP refunded sooner than we were able to claim\r\n     */\r\n    async waitTillClaimed(abortSignal) {\r\n        if (this.state === FromBTCSwapState.CLAIM_CLAIMED)\r\n            return Promise.resolve();\r\n        if (this.state !== FromBTCSwapState.BTC_TX_CONFIRMED)\r\n            throw new Error(\"Invalid state (not BTC_TX_CONFIRMED)\");\r\n        const abortController = new AbortController();\r\n        if (abortSignal != null)\r\n            abortSignal.addEventListener(\"abort\", () => abortController.abort(abortSignal.reason));\r\n        const res = await Promise.race([\r\n            this.watchdogWaitTillResult(abortController.signal),\r\n            this.waitTillState(FromBTCSwapState.CLAIM_CLAIMED, \"eq\", abortController.signal).then(() => 0),\r\n            this.waitTillState(FromBTCSwapState.FAILED, \"eq\", abortController.signal).then(() => 1),\r\n        ]);\r\n        abortController.abort();\r\n        if (res === 0) {\r\n            this.logger.debug(\"waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)\");\r\n            return;\r\n        }\r\n        if (res === 1) {\r\n            this.logger.debug(\"waitTillClaimed(): Resolved from state change (FAILED)\");\r\n            throw new Error(\"Offerer refunded during claiming\");\r\n        }\r\n        this.logger.debug(\"waitTillClaimed(): Resolved from watchdog\");\r\n        if (res?.type === base_1.SwapCommitStateType.PAID) {\r\n            if (this.state !== FromBTCSwapState.CLAIM_CLAIMED) {\r\n                this.claimTxId = await res.getClaimTxId();\r\n                await this._saveAndEmit(FromBTCSwapState.CLAIM_CLAIMED);\r\n            }\r\n        }\r\n        if (res?.type === base_1.SwapCommitStateType.NOT_COMMITED || res?.type === base_1.SwapCommitStateType.EXPIRED) {\r\n            if (this.state !== FromBTCSwapState.CLAIM_CLAIMED &&\r\n                this.state !== FromBTCSwapState.FAILED) {\r\n                this.refundTxId = res.getRefundTxId == null ? null : await res.getRefundTxId();\r\n                await this._saveAndEmit(FromBTCSwapState.FAILED);\r\n            }\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            address: this.address,\r\n            amount: this.amount.toString(10),\r\n            requiredConfirmations: this.requiredConfirmations,\r\n            txId: this.txId,\r\n            vout: this.vout\r\n        };\r\n    }\r\n    //////////////////////////////\r\n    //// Swap ticks & sync\r\n    /**\r\n     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain\r\n     *  data\r\n     *\r\n     * @private\r\n     */\r\n    async syncStateFromChain() {\r\n        if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {\r\n            const quoteExpired = await this.verifyQuoteDefinitelyExpired(); //Make sure we check for expiry here, to prevent race conditions\r\n            const status = await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));\r\n            switch (status?.type) {\r\n                case base_1.SwapCommitStateType.COMMITED:\r\n                    this.state = FromBTCSwapState.CLAIM_COMMITED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.EXPIRED:\r\n                    if (this.refundTxId == null && status.getRefundTxId)\r\n                        this.refundTxId = await status.getRefundTxId();\r\n                    this.state = FromBTCSwapState.QUOTE_EXPIRED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.PAID:\r\n                    if (this.claimTxId == null)\r\n                        this.claimTxId = await status.getClaimTxId();\r\n                    this.state = FromBTCSwapState.CLAIM_CLAIMED;\r\n                    return true;\r\n            }\r\n            if (quoteExpired) {\r\n                this.state = FromBTCSwapState.QUOTE_EXPIRED;\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        if (this.state === FromBTCSwapState.CLAIM_COMMITED || this.state === FromBTCSwapState.BTC_TX_CONFIRMED || this.state === FromBTCSwapState.EXPIRED) {\r\n            const status = await (0, Utils_1.tryWithRetries)(() => this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));\r\n            switch (status?.type) {\r\n                case base_1.SwapCommitStateType.PAID:\r\n                    if (this.claimTxId == null)\r\n                        this.claimTxId = await status.getClaimTxId();\r\n                    this.state = FromBTCSwapState.CLAIM_CLAIMED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.NOT_COMMITED:\r\n                case base_1.SwapCommitStateType.EXPIRED:\r\n                    if (this.refundTxId == null && status.getRefundTxId)\r\n                        this.refundTxId = await status.getRefundTxId();\r\n                    this.state = FromBTCSwapState.FAILED;\r\n                    return true;\r\n                case base_1.SwapCommitStateType.COMMITED:\r\n                    const res = await this.getBitcoinPayment();\r\n                    if (res != null && res.confirmations >= this.requiredConfirmations) {\r\n                        this.txId = res.txId;\r\n                        this.vout = res.vout;\r\n                        this.state = FromBTCSwapState.BTC_TX_CONFIRMED;\r\n                        return true;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    async _sync(save) {\r\n        const changed = await this.syncStateFromChain();\r\n        if (changed && save)\r\n            await this._saveAndEmit();\r\n        return changed;\r\n    }\r\n    async _tick(save) {\r\n        switch (this.state) {\r\n            case FromBTCSwapState.PR_CREATED:\r\n                if (this.expiry < Date.now()) {\r\n                    this.state = FromBTCSwapState.QUOTE_SOFT_EXPIRED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                break;\r\n            case FromBTCSwapState.CLAIM_COMMITED:\r\n                if (this.getTimeoutTime() < Date.now()) {\r\n                    this.state = FromBTCSwapState.EXPIRED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n            case FromBTCSwapState.EXPIRED:\r\n                //Check if bitcoin payment was received every 2 minutes\r\n                if (Math.floor(Date.now() / 1000) % 120 === 0) {\r\n                    try {\r\n                        const res = await this.getBitcoinPayment();\r\n                        if (res != null && res.confirmations >= this.requiredConfirmations) {\r\n                            this.txId = res.txId;\r\n                            this.vout = res.vout;\r\n                            this.state = FromBTCSwapState.BTC_TX_CONFIRMED;\r\n                            if (save)\r\n                                await this._saveAndEmit();\r\n                            return true;\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        this.logger.warn(\"tickSwap(\" + this.getIdentifierHashString() + \"): \", e);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}\r\nexports.FromBTCSwap = FromBTCSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8281, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FromBTCWrapper = void 0;\r\nconst IFromBTCWrapper_1 = require(\"../IFromBTCWrapper\");\r\nconst FromBTCSwap_1 = require(\"./FromBTCSwap\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst IntermediaryError_1 = require(\"../../../../errors/IntermediaryError\");\r\nconst SwapType_1 = require(\"../../../enums/SwapType\");\r\nconst Utils_1 = require(\"../../../../utils/Utils\");\r\nconst IntermediaryAPI_1 = require(\"../../../../intermediaries/IntermediaryAPI\");\r\nconst RequestError_1 = require(\"../../../../errors/RequestError\");\r\nconst utils_1 = require(\"@scure/btc-signer/utils\");\r\nclass FromBTCWrapper extends IFromBTCWrapper_1.IFromBTCWrapper {\r\n    /**\r\n     * @param chainIdentifier\r\n     * @param unifiedStorage Storage interface for the current environment\r\n     * @param unifiedChainEvents On-chain event listener\r\n     * @param chain\r\n     * @param contract Underlying contract handling the swaps\r\n     * @param prices Pricing to use\r\n     * @param tokens\r\n     * @param swapDataDeserializer Deserializer for SwapData\r\n     * @param btcRelay\r\n     * @param synchronizer Btc relay synchronizer\r\n     * @param btcRpc Bitcoin RPC which also supports getting transactions by txoHash\r\n     * @param options\r\n     * @param events Instance to use for emitting events\r\n     */\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, btcRelay, synchronizer, btcRpc, options, events) {\r\n        if (options == null)\r\n            options = {};\r\n        options.bitcoinNetwork = options.bitcoinNetwork ?? utils_1.TEST_NETWORK;\r\n        options.safetyFactor = options.safetyFactor || 2;\r\n        options.blocksTillTxConfirms = options.blocksTillTxConfirms || 12;\r\n        options.maxConfirmations = options.maxConfirmations || 6;\r\n        options.minSendWindow = options.minSendWindow || 30 * 60; //Minimum time window for user to send in the on-chain funds for From BTC swap\r\n        options.bitcoinBlocktime = options.bitcoinBlocktime || 10 * 60;\r\n        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);\r\n        this.TYPE = SwapType_1.SwapType.FROM_BTC;\r\n        this.swapDeserializer = FromBTCSwap_1.FromBTCSwap;\r\n        this.pendingSwapStates = [\r\n            FromBTCSwap_1.FromBTCSwapState.PR_CREATED,\r\n            FromBTCSwap_1.FromBTCSwapState.QUOTE_SOFT_EXPIRED,\r\n            FromBTCSwap_1.FromBTCSwapState.CLAIM_COMMITED,\r\n            FromBTCSwap_1.FromBTCSwapState.BTC_TX_CONFIRMED,\r\n            FromBTCSwap_1.FromBTCSwapState.EXPIRED\r\n        ];\r\n        this.tickSwapState = [FromBTCSwap_1.FromBTCSwapState.PR_CREATED, FromBTCSwap_1.FromBTCSwapState.CLAIM_COMMITED, FromBTCSwap_1.FromBTCSwapState.EXPIRED];\r\n        this.btcRelay = btcRelay;\r\n        this.synchronizer = synchronizer;\r\n        this.btcRpc = btcRpc;\r\n    }\r\n    processEventInitialize(swap, event) {\r\n        if (swap.state === FromBTCSwap_1.FromBTCSwapState.PR_CREATED || swap.state === FromBTCSwap_1.FromBTCSwapState.QUOTE_SOFT_EXPIRED) {\r\n            swap.state = FromBTCSwap_1.FromBTCSwapState.CLAIM_COMMITED;\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    processEventClaim(swap, event) {\r\n        if (swap.state !== FromBTCSwap_1.FromBTCSwapState.FAILED && swap.state !== FromBTCSwap_1.FromBTCSwapState.CLAIM_CLAIMED) {\r\n            swap.state = FromBTCSwap_1.FromBTCSwapState.CLAIM_CLAIMED;\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    processEventRefund(swap, event) {\r\n        if (swap.state !== FromBTCSwap_1.FromBTCSwapState.CLAIM_CLAIMED && swap.state !== FromBTCSwap_1.FromBTCSwapState.FAILED) {\r\n            swap.state = FromBTCSwap_1.FromBTCSwapState.FAILED;\r\n            return Promise.resolve(true);\r\n        }\r\n        return Promise.resolve(false);\r\n    }\r\n    /**\r\n     * Returns the swap expiry, leaving enough time for the user to send a transaction and for it to confirm\r\n     *\r\n     * @param data Parsed swap data\r\n     * @param requiredConfirmations Confirmations required to claim the tx\r\n     */\r\n    getOnchainSendTimeout(data, requiredConfirmations) {\r\n        const tsDelta = (this.options.blocksTillTxConfirms + requiredConfirmations) * this.options.bitcoinBlocktime * this.options.safetyFactor;\r\n        return data.getExpiry() - BigInt(tsDelta);\r\n    }\r\n    /**\r\n     * Pre-fetches claimer (watchtower) bounty data for the swap. Doesn't throw, instead returns null and aborts the\r\n     *  provided abortController\r\n     *\r\n     * @param signer Smartchain signer address initiating the swap\r\n     * @param amountData\r\n     * @param options Options as passed to the swap creation function\r\n     * @param abortController\r\n     * @private\r\n     */\r\n    async preFetchClaimerBounty(signer, amountData, options, abortController) {\r\n        const startTimestamp = BigInt(Math.floor(Date.now() / 1000));\r\n        if (options.unsafeZeroWatchtowerFee) {\r\n            return {\r\n                feePerBlock: 0n,\r\n                safetyFactor: options.blockSafetyFactor,\r\n                startTimestamp: startTimestamp,\r\n                addBlock: 0,\r\n                addFee: 0n\r\n            };\r\n        }\r\n        const dummyAmount = BigInt(Math.floor(Math.random() * 0x1000000));\r\n        const dummySwapData = await this.contract.createSwapData(base_1.ChainSwapType.CHAIN, signer, signer, amountData.token, dummyAmount, this.contract.getHashForOnchain((0, Utils_1.randomBytes)(20), dummyAmount, 3).toString(\"hex\"), this.getRandomSequence(), startTimestamp, false, true, BigInt(Math.floor(Math.random() * 0x10000)), BigInt(Math.floor(Math.random() * 0x10000)));\r\n        try {\r\n            const [feePerBlock, btcRelayData, currentBtcBlock, claimFeeRate] = await Promise.all([\r\n                (0, Utils_1.tryWithRetries)(() => this.btcRelay.getFeePerBlock(), null, null, abortController.signal),\r\n                (0, Utils_1.tryWithRetries)(() => this.btcRelay.getTipData(), null, null, abortController.signal),\r\n                this.btcRpc.getTipHeight(),\r\n                (0, Utils_1.tryWithRetries)(() => this.contract.getClaimFee(signer, dummySwapData), null, null, abortController.signal)\r\n            ]);\r\n            const currentBtcRelayBlock = btcRelayData.blockheight;\r\n            const addBlock = Math.max(currentBtcBlock - currentBtcRelayBlock, 0);\r\n            return {\r\n                feePerBlock: feePerBlock * options.feeSafetyFactor,\r\n                safetyFactor: options.blockSafetyFactor,\r\n                startTimestamp: startTimestamp,\r\n                addBlock,\r\n                addFee: claimFeeRate * options.feeSafetyFactor\r\n            };\r\n        }\r\n        catch (e) {\r\n            abortController.abort(e);\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns calculated claimer bounty calculated from the claimer bounty data as fetched from preFetchClaimerBounty()\r\n     *\r\n     * @param data Parsed swap data returned from the intermediary\r\n     * @param options Options as passed to the swap creation function\r\n     * @param claimerBounty Claimer bounty data as fetched from preFetchClaimerBounty() function\r\n     * @private\r\n     */\r\n    getClaimerBounty(data, options, claimerBounty) {\r\n        const tsDelta = data.getExpiry() - claimerBounty.startTimestamp;\r\n        const blocksDelta = tsDelta / BigInt(this.options.bitcoinBlocktime) * BigInt(options.blockSafetyFactor);\r\n        const totalBlock = blocksDelta + BigInt(claimerBounty.addBlock);\r\n        return claimerBounty.addFee + (totalBlock * claimerBounty.feePerBlock);\r\n    }\r\n    /**\r\n     * Verifies response returned from intermediary\r\n     *\r\n     * @param resp Response as returned by the intermediary\r\n     * @param amountData\r\n     * @param lp Intermediary\r\n     * @param options Options as passed to the swap creation function\r\n     * @param data Parsed swap data returned by the intermediary\r\n     * @param sequence Required swap sequence\r\n     * @param claimerBounty Claimer bount data as returned from the preFetchClaimerBounty() pre-fetch promise\r\n     * @param depositToken\r\n     * @private\r\n     * @throws {IntermediaryError} in case the response is invalid\r\n     */\r\n    verifyReturnedData(resp, amountData, lp, options, data, sequence, claimerBounty, depositToken) {\r\n        if (amountData.exactIn) {\r\n            if (resp.amount !== amountData.amount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid amount returned\");\r\n        }\r\n        else {\r\n            if (resp.total !== amountData.amount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid total returned\");\r\n        }\r\n        const requiredConfirmations = resp.confirmations ?? lp.services[SwapType_1.SwapType.FROM_BTC].data.confirmations;\r\n        if (requiredConfirmations > this.options.maxConfirmations)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Requires too many confirmations\");\r\n        const totalClaimerBounty = this.getClaimerBounty(data, options, claimerBounty);\r\n        if (data.getClaimerBounty() !== totalClaimerBounty ||\r\n            data.getType() != base_1.ChainSwapType.CHAIN ||\r\n            data.getSequence() !== sequence ||\r\n            data.getAmount() !== resp.total ||\r\n            data.isPayIn() ||\r\n            !data.isToken(amountData.token) ||\r\n            data.getOfferer() !== lp.getAddress(this.chainIdentifier) ||\r\n            !data.isDepositToken(depositToken)) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid data returned\");\r\n        }\r\n        //Check that we have enough time to send the TX and for it to confirm\r\n        const expiry = this.getOnchainSendTimeout(data, requiredConfirmations);\r\n        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));\r\n        if ((expiry - currentTimestamp) < BigInt(this.options.minSendWindow)) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Send window too low\");\r\n        }\r\n        const lockingScript = (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, resp.btcAddress);\r\n        const desiredExtraData = this.contract.getExtraData(lockingScript, resp.amount, requiredConfirmations);\r\n        const desiredClaimHash = this.contract.getHashForOnchain(lockingScript, resp.amount, requiredConfirmations);\r\n        if (!desiredClaimHash.equals(buffer_1.Buffer.from(data.getClaimHash(), \"hex\"))) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid claim hash returned!\");\r\n        }\r\n        if (!desiredExtraData.equals(buffer_1.Buffer.from(data.getExtraData(), \"hex\"))) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid extra data returned!\");\r\n        }\r\n    }\r\n    /**\r\n     * Returns a newly created swap, receiving 'amount' on chain\r\n     *\r\n     * @param signer                Smartchain signer's address intiating the swap\r\n     * @param amountData            Amount of token & amount to swap\r\n     * @param lps                   LPs (liquidity providers) to get the quotes from\r\n     * @param options               Quote options\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param abortSignal           Abort signal for aborting the process\r\n     */\r\n    create(signer, amountData, lps, options, additionalParams, abortSignal) {\r\n        options ??= {};\r\n        options.blockSafetyFactor ??= 1;\r\n        options.feeSafetyFactor ??= 2n;\r\n        const sequence = this.getRandomSequence();\r\n        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const pricePrefetchPromise = this.preFetchPrice(amountData, _abortController.signal);\r\n        const claimerBountyPrefetchPromise = this.preFetchClaimerBounty(signer, amountData, options, _abortController);\r\n        const nativeTokenAddress = this.chain.getNativeCurrencyAddress();\r\n        const feeRatePromise = this.preFetchFeeRate(signer, amountData, null, _abortController);\r\n        return lps.map(lp => {\r\n            return {\r\n                intermediary: lp,\r\n                quote: (async () => {\r\n                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);\r\n                    const liquidityPromise = this.preFetchIntermediaryLiquidity(amountData, lp, abortController);\r\n                    try {\r\n                        const { signDataPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount) => {\r\n                            const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.initFromBTC(this.chainIdentifier, lp.url, nativeTokenAddress, {\r\n                                claimer: signer,\r\n                                amount: amountData.amount,\r\n                                token: amountData.token.toString(),\r\n                                exactOut: !amountData.exactIn,\r\n                                sequence,\r\n                                claimerBounty: claimerBountyPrefetchPromise,\r\n                                feeRate: feeRatePromise,\r\n                                additionalParams\r\n                            }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);\r\n                            return {\r\n                                signDataPromise: this.preFetchSignData(signDataPrefetch),\r\n                                resp: await response\r\n                            };\r\n                        }, null, e => e instanceof RequestError_1.RequestError, abortController.signal);\r\n                        const data = new this.swapDataDeserializer(resp.data);\r\n                        data.setClaimer(signer);\r\n                        this.verifyReturnedData(resp, amountData, lp, options, data, sequence, await claimerBountyPrefetchPromise, nativeTokenAddress);\r\n                        const [pricingInfo, signatureExpiry] = await Promise.all([\r\n                            //Get intermediary's liquidity\r\n                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.FROM_BTC], false, resp.amount, resp.total, amountData.token, {}, pricePrefetchPromise, abortController.signal),\r\n                            this.verifyReturnedSignature(signer, data, resp, feeRatePromise, signDataPromise, abortController.signal),\r\n                            this.verifyIntermediaryLiquidity(data.getAmount(), liquidityPromise),\r\n                        ]);\r\n                        const quote = new FromBTCSwap_1.FromBTCSwap(this, {\r\n                            pricingInfo,\r\n                            url: lp.url,\r\n                            expiry: signatureExpiry,\r\n                            swapFee: resp.swapFee,\r\n                            feeRate: await feeRatePromise,\r\n                            signatureData: resp,\r\n                            data,\r\n                            address: resp.btcAddress,\r\n                            amount: resp.amount,\r\n                            exactIn: amountData.exactIn ?? true,\r\n                            requiredConfirmations: resp.confirmations ?? lp.services[SwapType_1.SwapType.FROM_BTC].data.confirmations\r\n                        });\r\n                        await quote._save();\r\n                        return quote;\r\n                    }\r\n                    catch (e) {\r\n                        abortController.abort(e);\r\n                        throw e;\r\n                    }\r\n                })()\r\n            };\r\n        });\r\n    }\r\n}\r\nexports.FromBTCWrapper = FromBTCWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8550, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/intermediaries/TrustedIntermediaryAPI.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TrustedIntermediaryAPI = exports.InvoiceStatusResponseCodes = exports.AddressStatusResponseCodes = void 0;\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst RequestError_1 = require(\"../errors/RequestError\");\r\nconst SchemaVerifier_1 = require(\"../utils/paramcoders/SchemaVerifier\");\r\nvar AddressStatusResponseCodes;\r\n(function (AddressStatusResponseCodes) {\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"EXPIRED\"] = 10001] = \"EXPIRED\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"PAID\"] = 10000] = \"PAID\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"AWAIT_PAYMENT\"] = 10010] = \"AWAIT_PAYMENT\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"AWAIT_CONFIRMATION\"] = 10011] = \"AWAIT_CONFIRMATION\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"PENDING\"] = 10013] = \"PENDING\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"TX_SENT\"] = 10012] = \"TX_SENT\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"REFUNDED\"] = 10014] = \"REFUNDED\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"DOUBLE_SPENT\"] = 10015] = \"DOUBLE_SPENT\";\r\n    AddressStatusResponseCodes[AddressStatusResponseCodes[\"REFUNDABLE\"] = 10016] = \"REFUNDABLE\";\r\n})(AddressStatusResponseCodes = exports.AddressStatusResponseCodes || (exports.AddressStatusResponseCodes = {}));\r\nconst TrustedFromBTCResponseSchema = {\r\n    paymentHash: SchemaVerifier_1.FieldTypeEnum.String,\r\n    sequence: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    btcAddress: SchemaVerifier_1.FieldTypeEnum.String,\r\n    amountSats: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    swapFeeSats: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    total: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    intermediaryKey: SchemaVerifier_1.FieldTypeEnum.String,\r\n    recommendedFee: SchemaVerifier_1.FieldTypeEnum.Number,\r\n    expiresAt: SchemaVerifier_1.FieldTypeEnum.Number\r\n};\r\nvar InvoiceStatusResponseCodes;\r\n(function (InvoiceStatusResponseCodes) {\r\n    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes[\"EXPIRED\"] = 10001] = \"EXPIRED\";\r\n    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes[\"PAID\"] = 10000] = \"PAID\";\r\n    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes[\"AWAIT_PAYMENT\"] = 10010] = \"AWAIT_PAYMENT\";\r\n    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes[\"PENDING\"] = 10011] = \"PENDING\";\r\n    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes[\"TX_SENT\"] = 10012] = \"TX_SENT\";\r\n})(InvoiceStatusResponseCodes = exports.InvoiceStatusResponseCodes || (exports.InvoiceStatusResponseCodes = {}));\r\nconst TrustedFromBTCLNResponseSchema = {\r\n    pr: SchemaVerifier_1.FieldTypeEnum.String,\r\n    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,\r\n    total: SchemaVerifier_1.FieldTypeEnum.BigInt\r\n};\r\nclass TrustedIntermediaryAPI {\r\n    /**\r\n     * Fetches the invoice status from the intermediary node\r\n     *\r\n     * @param url Url of the trusted intermediary\r\n     * @param paymentHash Payment hash of the lightning invoice\r\n     * @param timeout Timeout in milliseconds\r\n     * @param abortSignal\r\n     * @throws {RequestError} if non-200 http response is returned\r\n     */\r\n    static async getInvoiceStatus(url, paymentHash, timeout, abortSignal) {\r\n        return (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(url + \"/getInvoiceStatus?paymentHash=\" + encodeURIComponent(paymentHash), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);\r\n    }\r\n    /**\r\n     * Initiate a trusted swap from BTCLN to SC native currency, retries!\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base url of the trusted swap intermediary\r\n     * @param init Initialization parameters\r\n     * @param timeout Timeout in milliseconds for the request\r\n     * @param abortSignal\r\n     * @throws {RequestError} If the response is non-200\r\n     */\r\n    static async initTrustedFromBTCLN(chainIdentifier, baseUrl, init, timeout, abortSignal) {\r\n        const resp = await (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(baseUrl + \"/lnforgas/createInvoice\" +\r\n            \"?address=\" + encodeURIComponent(init.address) +\r\n            \"&amount=\" + encodeURIComponent(init.amount.toString(10)) +\r\n            \"&chain=\" + encodeURIComponent(chainIdentifier) +\r\n            \"&token=\" + encodeURIComponent(init.token), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);\r\n        if (resp.code !== 10000)\r\n            throw RequestError_1.RequestError.parse(JSON.stringify(resp), 400);\r\n        return (0, SchemaVerifier_1.verifySchema)(resp.data, TrustedFromBTCLNResponseSchema);\r\n    }\r\n    /**\r\n     * Fetches the address status from the intermediary node\r\n     *\r\n     * @param url Url of the trusted intermediary\r\n     * @param paymentHash Payment hash of the swap\r\n     * @param sequence Sequence number of the swap\r\n     * @param timeout Timeout in milliseconds\r\n     * @param abortSignal\r\n     * @throws {RequestError} if non-200 http response is returned\r\n     */\r\n    static async getAddressStatus(url, paymentHash, sequence, timeout, abortSignal) {\r\n        return (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(url + \"/getAddressStatus?paymentHash=\" + encodeURIComponent(paymentHash) + \"&sequence=\" + encodeURIComponent(sequence.toString(10)), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);\r\n    }\r\n    /**\r\n     * Sets the refund address for an on-chain gas swap\r\n     *\r\n     * @param url Url of the trusted intermediary\r\n     * @param paymentHash Payment hash of the swap\r\n     * @param sequence Sequence number of the swap\r\n     * @param refundAddress Refund address to set for the swap\r\n     * @param timeout Timeout in milliseconds\r\n     * @param abortSignal\r\n     * @throws {RequestError} if non-200 http response is returned\r\n     */\r\n    static async setRefundAddress(url, paymentHash, sequence, refundAddress, timeout, abortSignal) {\r\n        return (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(url + \"/setRefundAddress\" +\r\n            \"?paymentHash=\" + encodeURIComponent(paymentHash) +\r\n            \"&sequence=\" + encodeURIComponent(sequence.toString(10)) +\r\n            \"&refundAddress=\" + encodeURIComponent(refundAddress), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);\r\n    }\r\n    /**\r\n     * Initiate a trusted swap from BTC to SC native currency, retries!\r\n     *\r\n     * @param chainIdentifier\r\n     * @param baseUrl Base url of the trusted swap intermediary\r\n     * @param init Initialization parameters\r\n     * @param timeout Timeout in milliseconds for the request\r\n     * @param abortSignal\r\n     * @throws {RequestError} If the response is non-200\r\n     */\r\n    static async initTrustedFromBTC(chainIdentifier, baseUrl, init, timeout, abortSignal) {\r\n        const resp = await (0, Utils_1.tryWithRetries)(() => (0, Utils_1.httpGet)(baseUrl + \"/frombtc_trusted/getAddress?chain=\" + encodeURIComponent(chainIdentifier) +\r\n            \"&address=\" + encodeURIComponent(init.address) +\r\n            \"&amount=\" + encodeURIComponent(init.amount.toString(10)) +\r\n            \"&refundAddress=\" + encodeURIComponent(init.refundAddress) +\r\n            \"&exactIn=true\" +\r\n            \"&token=\" + encodeURIComponent(init.token), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);\r\n        if (resp.code !== 10000)\r\n            throw RequestError_1.RequestError.parse(JSON.stringify(resp), 400);\r\n        return (0, SchemaVerifier_1.verifySchema)(resp.data, TrustedFromBTCResponseSchema);\r\n    }\r\n}\r\nexports.TrustedIntermediaryAPI = TrustedIntermediaryAPI;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8665, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LnForGasSwap = exports.isLnForGasSwapInit = exports.LnForGasSwapState = void 0;\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst SwapType_1 = require(\"../../enums/SwapType\");\r\nconst PaymentAuthError_1 = require(\"../../../errors/PaymentAuthError\");\r\nconst Utils_1 = require(\"../../../utils/Utils\");\r\nconst ISwap_1 = require(\"../../ISwap\");\r\nconst TrustedIntermediaryAPI_1 = require(\"../../../intermediaries/TrustedIntermediaryAPI\");\r\nconst Tokens_1 = require(\"../../../Tokens\");\r\nconst Fee_1 = require(\"../../fee/Fee\");\r\nvar LnForGasSwapState;\r\n(function (LnForGasSwapState) {\r\n    LnForGasSwapState[LnForGasSwapState[\"EXPIRED\"] = -2] = \"EXPIRED\";\r\n    LnForGasSwapState[LnForGasSwapState[\"FAILED\"] = -1] = \"FAILED\";\r\n    LnForGasSwapState[LnForGasSwapState[\"PR_CREATED\"] = 0] = \"PR_CREATED\";\r\n    LnForGasSwapState[LnForGasSwapState[\"PR_PAID\"] = 1] = \"PR_PAID\";\r\n    LnForGasSwapState[LnForGasSwapState[\"FINISHED\"] = 2] = \"FINISHED\";\r\n})(LnForGasSwapState = exports.LnForGasSwapState || (exports.LnForGasSwapState = {}));\r\nfunction isLnForGasSwapInit(obj) {\r\n    return typeof (obj.pr) === \"string\" &&\r\n        typeof (obj.outputAmount) === \"bigint\" &&\r\n        typeof (obj.recipient) === \"string\" &&\r\n        typeof (obj.token) === \"string\" &&\r\n        (0, ISwap_1.isISwapInit)(obj);\r\n}\r\nexports.isLnForGasSwapInit = isLnForGasSwapInit;\r\nclass LnForGasSwap extends ISwap_1.ISwap {\r\n    constructor(wrapper, initOrObj) {\r\n        if (isLnForGasSwapInit(initOrObj))\r\n            initOrObj.url += \"/lnforgas\";\r\n        super(wrapper, initOrObj);\r\n        this.currentVersion = 2;\r\n        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTCLN;\r\n        if (isLnForGasSwapInit(initOrObj)) {\r\n            this.state = LnForGasSwapState.PR_CREATED;\r\n        }\r\n        else {\r\n            this.pr = initOrObj.pr;\r\n            this.outputAmount = initOrObj.outputAmount == null ? null : BigInt(initOrObj.outputAmount);\r\n            this.recipient = initOrObj.recipient;\r\n            this.token = initOrObj.token;\r\n            this.scTxId = initOrObj.scTxId;\r\n        }\r\n        this.tryRecomputeSwapPrice();\r\n        if (this.pr != null) {\r\n            const decoded = (0, bolt11_1.decode)(this.pr);\r\n            this.expiry = decoded.timeExpireDate * 1000;\r\n        }\r\n        this.logger = (0, Utils_1.getLogger)(\"LnForGas(\" + this.getId() + \"): \");\r\n    }\r\n    upgradeVersion() {\r\n        if (this.version == 1) {\r\n            if (this.state === 1)\r\n                this.state = LnForGasSwapState.FINISHED;\r\n            this.version = 2;\r\n        }\r\n        if (this.version == null) {\r\n            //Noop\r\n            this.version = 1;\r\n        }\r\n    }\r\n    /**\r\n     * In case swapFee in BTC is not supplied it recalculates it based on swap price\r\n     * @protected\r\n     */\r\n    tryRecomputeSwapPrice() {\r\n        if (this.swapFeeBtc == null) {\r\n            this.swapFeeBtc = this.swapFee * this.getInput().rawAmount / this.getOutAmountWithoutFee();\r\n        }\r\n        super.tryRecomputeSwapPrice();\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    _getEscrowHash() {\r\n        return this.getId();\r\n    }\r\n    getOutputAddress() {\r\n        return this.recipient;\r\n    }\r\n    getInputTxId() {\r\n        return this.getId();\r\n    }\r\n    getOutputTxId() {\r\n        return this.scTxId;\r\n    }\r\n    getId() {\r\n        if (this.pr == null)\r\n            return null;\r\n        const decodedPR = (0, bolt11_1.decode)(this.pr);\r\n        return decodedPR.tagsObject.payment_hash;\r\n    }\r\n    /**\r\n     * Returns the lightning network BOLT11 invoice that needs to be paid as an input to the swap\r\n     */\r\n    getAddress() {\r\n        return this.pr;\r\n    }\r\n    /**\r\n     * Returns a string that can be displayed as QR code representation of the lightning invoice (with lightning: prefix)\r\n     */\r\n    getHyperlink() {\r\n        return \"lightning:\" + this.pr.toUpperCase();\r\n    }\r\n    requiresAction() {\r\n        return false;\r\n    }\r\n    isFinished() {\r\n        return this.state === LnForGasSwapState.FINISHED || this.state === LnForGasSwapState.FAILED || this.state === LnForGasSwapState.EXPIRED;\r\n    }\r\n    isQuoteExpired() {\r\n        return this.state === LnForGasSwapState.EXPIRED;\r\n    }\r\n    isQuoteSoftExpired() {\r\n        return this.expiry < Date.now();\r\n    }\r\n    isFailed() {\r\n        return this.state === LnForGasSwapState.FAILED;\r\n    }\r\n    isSuccessful() {\r\n        return this.state === LnForGasSwapState.FINISHED;\r\n    }\r\n    verifyQuoteValid() {\r\n        return Promise.resolve(this.expiry > Date.now());\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getOutAmountWithoutFee() {\r\n        return this.outputAmount + this.swapFee;\r\n    }\r\n    getOutput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.outputAmount, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices);\r\n    }\r\n    getInput() {\r\n        const parsed = (0, bolt11_1.decode)(this.pr);\r\n        const amount = (BigInt(parsed.millisatoshis) + 999n) / 1000n;\r\n        return (0, Tokens_1.toTokenAmount)(amount, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices);\r\n    }\r\n    getInputWithoutFee() {\r\n        const parsed = (0, bolt11_1.decode)(this.pr);\r\n        const amount = (BigInt(parsed.millisatoshis) + 999n) / 1000n;\r\n        return (0, Tokens_1.toTokenAmount)(amount - this.swapFeeBtc, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices);\r\n    }\r\n    getSwapFee() {\r\n        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;\r\n        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getInputWithoutFee().rawAmount;\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),\r\n            composition: {\r\n                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices),\r\n                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)\r\n            }\r\n        };\r\n    }\r\n    getFee() {\r\n        return this.getSwapFee();\r\n    }\r\n    getFeeBreakdown() {\r\n        return [{\r\n                type: Fee_1.FeeType.SWAP,\r\n                fee: this.getSwapFee()\r\n            }];\r\n    }\r\n    //////////////////////////////\r\n    //// Payment\r\n    async checkInvoicePaid(save = true) {\r\n        if (this.state === LnForGasSwapState.FAILED || this.state === LnForGasSwapState.EXPIRED)\r\n            return false;\r\n        if (this.state === LnForGasSwapState.FINISHED)\r\n            return true;\r\n        const decodedPR = (0, bolt11_1.decode)(this.pr);\r\n        const paymentHash = decodedPR.tagsObject.payment_hash;\r\n        const response = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.getInvoiceStatus(this.url, paymentHash, this.wrapper.options.getRequestTimeout);\r\n        this.logger.debug(\"checkInvoicePaid(): LP response: \", response);\r\n        switch (response.code) {\r\n            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.PAID:\r\n                this.scTxId = response.data.txId;\r\n                const txStatus = await this.wrapper.chain.getTxIdStatus(this.scTxId);\r\n                if (txStatus === \"success\") {\r\n                    this.state = LnForGasSwapState.FINISHED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                return null;\r\n            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.EXPIRED:\r\n                if (this.state === LnForGasSwapState.PR_CREATED) {\r\n                    this.state = LnForGasSwapState.EXPIRED;\r\n                }\r\n                else {\r\n                    this.state = LnForGasSwapState.FAILED;\r\n                }\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return false;\r\n            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.TX_SENT:\r\n                this.scTxId = response.data.txId;\r\n                if (this.state === LnForGasSwapState.PR_CREATED) {\r\n                    this.state = LnForGasSwapState.PR_PAID;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                }\r\n                return null;\r\n            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.PENDING:\r\n                if (this.state === LnForGasSwapState.PR_CREATED) {\r\n                    this.state = LnForGasSwapState.PR_PAID;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                }\r\n                return null;\r\n            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.AWAIT_PAYMENT:\r\n                return null;\r\n            default:\r\n                this.state = LnForGasSwapState.FAILED;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return false;\r\n        }\r\n    }\r\n    /**\r\n     * A blocking promise resolving when payment was received by the intermediary and client can continue\r\n     * rejecting in case of failure\r\n     *\r\n     * @param abortSignal Abort signal\r\n     * @param checkIntervalSeconds How often to poll the intermediary for answer\r\n     * @throws {PaymentAuthError} If swap expired or failed\r\n     * @throws {Error} When in invalid state (not PR_CREATED)\r\n     */\r\n    async waitForPayment(abortSignal, checkIntervalSeconds = 5) {\r\n        if (this.state !== LnForGasSwapState.PR_CREATED)\r\n            throw new Error(\"Must be in PR_CREATED state!\");\r\n        if (!this.initiated) {\r\n            this.initiated = true;\r\n            await this._saveAndEmit();\r\n        }\r\n        while (!abortSignal.aborted && (this.state === LnForGasSwapState.PR_CREATED || this.state === LnForGasSwapState.PR_PAID)) {\r\n            await this.checkInvoicePaid(true);\r\n            if (this.state === LnForGasSwapState.PR_CREATED || this.state === LnForGasSwapState.PR_PAID)\r\n                await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);\r\n        }\r\n        if (this.isFailed())\r\n            throw new PaymentAuthError_1.PaymentAuthError(\"Swap failed\");\r\n        return !this.isQuoteExpired();\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            pr: this.pr,\r\n            outputAmount: this.outputAmount == null ? null : this.outputAmount.toString(10),\r\n            recipient: this.recipient,\r\n            token: this.token,\r\n            scTxId: this.scTxId\r\n        };\r\n    }\r\n    _getInitiator() {\r\n        return this.recipient;\r\n    }\r\n    //////////////////////////////\r\n    //// Swap ticks & sync\r\n    async _sync(save) {\r\n        if (this.state === LnForGasSwapState.PR_CREATED) {\r\n            //Check if it's maybe already paid\r\n            const res = await this.checkInvoicePaid(false);\r\n            if (res !== null) {\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _tick(save) {\r\n        return Promise.resolve(false);\r\n    }\r\n}\r\nexports.LnForGasSwap = LnForGasSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8930, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LnForGasWrapper = void 0;\r\nconst LnForGasSwap_1 = require(\"./LnForGasSwap\");\r\nconst ISwapWrapper_1 = require(\"../../ISwapWrapper\");\r\nconst TrustedIntermediaryAPI_1 = require(\"../../../intermediaries/TrustedIntermediaryAPI\");\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst IntermediaryError_1 = require(\"../../../errors/IntermediaryError\");\r\nconst SwapType_1 = require(\"../../enums/SwapType\");\r\nclass LnForGasWrapper extends ISwapWrapper_1.ISwapWrapper {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTCLN;\r\n        this.swapDeserializer = LnForGasSwap_1.LnForGasSwap;\r\n        this.pendingSwapStates = [LnForGasSwap_1.LnForGasSwapState.PR_CREATED];\r\n        this.tickSwapState = null;\r\n        this.processEvent = null;\r\n    }\r\n    /**\r\n     * Returns a newly created swap, receiving 'amount' on lightning network\r\n     *\r\n     * @param signer\r\n     * @param amount            Amount you wish to receive in base units (satoshis)\r\n     * @param lpOrUrl           Intermediary/Counterparty swap service Intermediary object or raw url\r\n     */\r\n    async create(signer, amount, lpOrUrl) {\r\n        if (!this.isInitialized)\r\n            throw new Error(\"Not initialized, call init() first!\");\r\n        const lpUrl = typeof (lpOrUrl) === \"string\" ? lpOrUrl : lpOrUrl.url;\r\n        const token = this.chain.getNativeCurrencyAddress();\r\n        const resp = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.initTrustedFromBTCLN(this.chainIdentifier, lpUrl, {\r\n            address: signer,\r\n            amount,\r\n            token\r\n        }, this.options.getRequestTimeout);\r\n        const decodedPr = (0, bolt11_1.decode)(resp.pr);\r\n        const amountIn = (BigInt(decodedPr.millisatoshis) + 999n) / 1000n;\r\n        if (resp.total !== amount)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid total returned\");\r\n        const pricingInfo = await this.verifyReturnedPrice(typeof (lpOrUrl) === \"string\" ?\r\n            { swapFeePPM: 10000, swapBaseFee: 10 } :\r\n            lpOrUrl.services[SwapType_1.SwapType.TRUSTED_FROM_BTCLN], false, amountIn, amount, token, {});\r\n        const quote = new LnForGasSwap_1.LnForGasSwap(this, {\r\n            pr: resp.pr,\r\n            outputAmount: resp.total,\r\n            recipient: signer,\r\n            pricingInfo,\r\n            url: lpUrl,\r\n            expiry: decodedPr.timeExpireDate * 1000,\r\n            swapFee: resp.swapFee,\r\n            token,\r\n            exactIn: false\r\n        });\r\n        await quote._save();\r\n        return quote;\r\n    }\r\n}\r\nexports.LnForGasWrapper = LnForGasWrapper;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,eAAe,GAAG,KAAK;AAC/B,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,wBAAwB,eAAe,YAAY;IASrD;;;;;;KAMC,GACD,MAAM,OAAO,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE;QAClC,IAAI,CAAC,IAAI,CAAC,aAAa,EACnB,MAAM,IAAI,MAAM;QACpB,MAAM,QAAQ,OAAQ,YAAa,WAAW,UAAU,QAAQ,GAAG;QACnE,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,wBAAwB;QACjD,MAAM,OAAO,MAAM,yBAAyB,sBAAsB,CAAC,oBAAoB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO;YACjH,SAAS;YACT;YACA;QACJ,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB;QACjC,MAAM,YAAY,CAAC,GAAG,SAAS,MAAM,EAAE,KAAK,EAAE;QAC9C,MAAM,WAAW,CAAC,OAAO,UAAU,aAAa,IAAI,IAAI,IAAI,KAAK;QACjE,IAAI,KAAK,KAAK,KAAK,QACf,MAAM,IAAI,oBAAoB,iBAAiB,CAAC;QACpD,MAAM,cAAc,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAQ,YAAa,WACpE;YAAE,YAAY;YAAO,aAAa;QAAG,IACrC,QAAQ,QAAQ,CAAC,WAAW,QAAQ,CAAC,kBAAkB,CAAC,EAAE,OAAO,UAAU,QAAQ,OAAO,CAAC;QAC/F,MAAM,QAAQ,IAAI,eAAe,YAAY,CAAC,IAAI,EAAE;YAChD,IAAI,KAAK,EAAE;YACX,cAAc,KAAK,KAAK;YACxB,WAAW;YACX;YACA,KAAK;YACL,QAAQ,UAAU,cAAc,GAAG;YACnC,SAAS,KAAK,OAAO;YACrB;YACA,SAAS;QACb;QACA,MAAM,MAAM,KAAK;QACjB,OAAO;IACX;IA7CA,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,IAAI,GAAG,WAAW,QAAQ,CAAC,kBAAkB;QAClD,IAAI,CAAC,gBAAgB,GAAG,eAAe,YAAY;QACnD,IAAI,CAAC,iBAAiB,GAAG;YAAC,eAAe,iBAAiB,CAAC,UAAU;SAAC;QACtE,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,YAAY,GAAG;IACxB;AAuCJ;AACA,QAAQ,eAAe,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8993, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/swapper/SwapWithSigner.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.wrapSwapWithSigner = void 0;\r\nconst IToBTCSwap_1 = require(\"../escrow_swaps/tobtc/IToBTCSwap\");\r\nconst IFromBTCSwap_1 = require(\"../escrow_swaps/frombtc/IFromBTCSwap\");\r\nconst FromBTCLNSwap_1 = require(\"../escrow_swaps/frombtc/ln/FromBTCLNSwap\");\r\nfunction wrapSwapWithSigner(swap, signer) {\r\n    return new Proxy(swap, {\r\n        get: (target, prop, receiver) => {\r\n            // Override the \"sayGoodbye\" method\r\n            if (prop === \"commit\") {\r\n                if (swap instanceof IToBTCSwap_1.IToBTCSwap || swap instanceof IFromBTCSwap_1.IFromBTCSwap) {\r\n                    return (abortSignal, skipChecks) => swap.commit(signer, abortSignal, skipChecks);\r\n                }\r\n            }\r\n            if (prop === \"refund\") {\r\n                if (swap instanceof IToBTCSwap_1.IToBTCSwap) {\r\n                    return (abortSignal) => swap.refund(signer, abortSignal);\r\n                }\r\n            }\r\n            if (prop === \"claim\") {\r\n                if (swap instanceof IFromBTCSwap_1.IFromBTCSwap) {\r\n                    return (abortSignal) => swap.claim(signer, abortSignal);\r\n                }\r\n            }\r\n            if (prop === \"commitAndClaim\") {\r\n                if (swap instanceof FromBTCLNSwap_1.FromBTCLNSwap) {\r\n                    return (abortSignal, skipChecks) => swap.commitAndClaim(signer, abortSignal, skipChecks);\r\n                }\r\n            }\r\n            // Delegate other properties and methods to the original instance\r\n            return Reflect.get(target, prop, receiver);\r\n        }\r\n    });\r\n}\r\nexports.wrapSwapWithSigner = wrapSwapWithSigner;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,kBAAkB,GAAG,KAAK;AAClC,MAAM;AACN,MAAM;AACN,MAAM;AACN,SAAS,mBAAmB,IAAI,EAAE,MAAM;IACpC,OAAO,IAAI,MAAM,MAAM;QACnB,KAAK,CAAC,QAAQ,MAAM;YAChB,mCAAmC;YACnC,IAAI,SAAS,UAAU;gBACnB,IAAI,gBAAgB,aAAa,UAAU,IAAI,gBAAgB,eAAe,YAAY,EAAE;oBACxF,OAAO,CAAC,aAAa,aAAe,KAAK,MAAM,CAAC,QAAQ,aAAa;gBACzE;YACJ;YACA,IAAI,SAAS,UAAU;gBACnB,IAAI,gBAAgB,aAAa,UAAU,EAAE;oBACzC,OAAO,CAAC,cAAgB,KAAK,MAAM,CAAC,QAAQ;gBAChD;YACJ;YACA,IAAI,SAAS,SAAS;gBAClB,IAAI,gBAAgB,eAAe,YAAY,EAAE;oBAC7C,OAAO,CAAC,cAAgB,KAAK,KAAK,CAAC,QAAQ;gBAC/C;YACJ;YACA,IAAI,SAAS,kBAAkB;gBAC3B,IAAI,gBAAgB,gBAAgB,aAAa,EAAE;oBAC/C,OAAO,CAAC,aAAa,aAAe,KAAK,cAAc,CAAC,QAAQ,aAAa;gBACjF;YACJ;YACA,iEAAiE;YACjE,OAAO,QAAQ,GAAG,CAAC,QAAQ,MAAM;QACrC;IACJ;AACJ;AACA,QAAQ,kBAAkB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9034, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithSigner.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SwapperWithSigner = void 0;\r\nconst SwapWithSigner_1 = require(\"./SwapWithSigner\");\r\nclass SwapperWithSigner {\r\n    get prices() {\r\n        return this.swapper.prices;\r\n    }\r\n    get intermediaryDiscovery() {\r\n        return this.swapper.intermediaryDiscovery;\r\n    }\r\n    get mempoolApi() {\r\n        return this.swapper.mempoolApi;\r\n    }\r\n    get bitcoinRpc() {\r\n        return this.swapper.bitcoinRpc;\r\n    }\r\n    get bitcoinNetwork() {\r\n        return this.swapper.bitcoinNetwork;\r\n    }\r\n    get Utils() {\r\n        return this.swapper.Utils;\r\n    }\r\n    get SwapTypeInfo() {\r\n        return this.swapper.SwapTypeInfo;\r\n    }\r\n    constructor(swapper, signer) {\r\n        this.swapper = swapper;\r\n        this.signer = signer;\r\n    }\r\n    createToBTCSwap(tokenAddress, address, amount, exactIn, additionalParams, options) {\r\n        return this.swapper.createToBTCSwap(this.signer.getAddress(), tokenAddress, address, amount, exactIn, additionalParams, options)\r\n            .then(swap => (0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));\r\n    }\r\n    createToBTCLNSwap(tokenAddress, paymentRequest, additionalParams, options) {\r\n        return this.swapper.createToBTCLNSwap(this.signer.getAddress(), tokenAddress, paymentRequest, additionalParams, options)\r\n            .then(swap => (0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));\r\n    }\r\n    createToBTCLNSwapViaLNURL(tokenAddress, lnurlPay, amount, exactIn, additionalParams, options) {\r\n        return this.swapper.createToBTCLNSwapViaLNURL(this.signer.getAddress(), tokenAddress, lnurlPay, amount, exactIn, additionalParams, options)\r\n            .then(swap => (0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));\r\n    }\r\n    createFromBTCSwap(tokenAddress, amount, exactOut, additionalParams, options) {\r\n        return this.swapper.createFromBTCSwap(this.signer.getAddress(), tokenAddress, amount, exactOut, additionalParams, options)\r\n            .then(swap => (0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));\r\n    }\r\n    createFromBTCLNSwap(tokenAddress, amount, exactOut, additionalParams, options) {\r\n        return this.swapper.createFromBTCLNSwap(this.signer.getAddress(), tokenAddress, amount, exactOut, additionalParams, options)\r\n            .then(swap => (0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));\r\n    }\r\n    createFromBTCLNSwapViaLNURL(tokenAddress, lnurl, amount, exactOut, additionalParams) {\r\n        return this.swapper.createFromBTCLNSwapViaLNURL(this.signer.getAddress(), tokenAddress, lnurl, amount, exactOut, additionalParams)\r\n            .then(swap => (0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));\r\n    }\r\n    createTrustedLNForGasSwap(amount, trustedIntermediaryUrl) {\r\n        return this.swapper.createTrustedLNForGasSwap(this.signer.getAddress(), amount, trustedIntermediaryUrl);\r\n    }\r\n    createTrustedOnchainForGasSwap(amount, refundAddress, trustedIntermediaryUrl) {\r\n        return this.swapper.createTrustedOnchainForGasSwap(this.signer.getAddress(), amount, refundAddress, trustedIntermediaryUrl);\r\n    }\r\n    /**\r\n     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)\r\n     *  or output amount (exactIn=false), NOTE: For regular -> BTC-LN (lightning) swaps the passed amount is ignored and\r\n     *  invoice's pre-set amount is used instead.\r\n     *\r\n     * @param srcToken Source token of the swap, user pays this token\r\n     * @param dstToken Destination token of the swap, user receives this token\r\n     * @param amount Amount of the swap\r\n     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)\r\n     * @param addressLnurlLightningInvoice Bitcoin on-chain address, lightning invoice, LNURL-pay to pay or\r\n     *  LNURL-withdrawal to withdraw money from\r\n     */\r\n    create(srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice) {\r\n        return this.swapper.create(this.signer.getAddress(), srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice)\r\n            .then(swap => (0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));\r\n    }\r\n    /**\r\n     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address\r\n     */\r\n    getAllSwaps() {\r\n        return this.swapper.getAllSwaps(this.signer.getAddress());\r\n    }\r\n    /**\r\n     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address\r\n     */\r\n    getActionableSwaps() {\r\n        return this.swapper.getActionableSwaps(this.signer.getAddress());\r\n    }\r\n    /**\r\n     * Returns swaps that are refundable for the specific chain, optionally also for a specific signer's address\r\n     */\r\n    getRefundableSwaps() {\r\n        return this.swapper.getRefundableSwaps(this.signer.getAddress());\r\n    }\r\n    /**\r\n     * Returns swap with a specific id (identifier) on a specific chain and optionally with a signer\r\n     */\r\n    getSwapById(id) {\r\n        return this.swapper.getSwapById(id, this.signer.getAddress());\r\n    }\r\n    /**\r\n     * Synchronizes swaps from chain, this is usually ran when SDK is initialized, deletes expired quotes\r\n     */\r\n    async _syncSwaps() {\r\n        return this.swapper._syncSwaps(this.signer.getAddress());\r\n    }\r\n    supportsSwapType(swapType) {\r\n        return this.swapper.supportsSwapType(swapType);\r\n    }\r\n    getSwapType(srcToken, dstToken) {\r\n        return this.swapper.getSwapType(srcToken, dstToken);\r\n    }\r\n    /**\r\n     * Returns minimum/maximum limits for inputs and outputs for a swap between given tokens\r\n     *\r\n     * @param srcToken\r\n     * @param dstToken\r\n     */\r\n    getSwapLimits(srcToken, dstToken) {\r\n        return this.swapper.getSwapLimits(srcToken, dstToken);\r\n    }\r\n    /**\r\n     * Returns tokens that you can swap to (if input=true) from a given token,\r\n     *  or tokens that you can swap from (if input=false) to a given token\r\n     */\r\n    getSwapCounterTokens(token, input) {\r\n        return this.swapper.getSwapCounterTokens(token, input);\r\n    }\r\n    ///////////////////////////////////\r\n    /// Deprecated\r\n    /**\r\n     * Returns swap bounds (minimums & maximums) for different swap types & tokens\r\n     * @deprecated Use getSwapLimits() instead!\r\n     */\r\n    getSwapBounds() {\r\n        return this.swapper.getSwapBounds();\r\n    }\r\n    /**\r\n     * Returns maximum possible swap amount\r\n     * @deprecated Use getSwapLimits() instead!\r\n     *\r\n     * @param type      Type of the swap\r\n     * @param token     Token of the swap\r\n     */\r\n    getMaximum(type, token) {\r\n        return this.swapper.getMaximum(type, token);\r\n    }\r\n    /**\r\n     * Returns minimum possible swap amount\r\n     * @deprecated Use getSwapLimits() instead!\r\n     *\r\n     * @param type      Type of swap\r\n     * @param token     Token of the swap\r\n     */\r\n    getMinimum(type, token) {\r\n        return this.swapper.getMinimum(type, token);\r\n    }\r\n}\r\nexports.SwapperWithSigner = SwapperWithSigner;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9180, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithChain.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SwapperWithChain = void 0;\r\nconst SwapType_1 = require(\"../enums/SwapType\");\r\nconst SwapPriceWithChain_1 = require(\"../../prices/SwapPriceWithChain\");\r\nconst Tokens_1 = require(\"../../Tokens\");\r\nconst SwapperWithSigner_1 = require(\"./SwapperWithSigner\");\r\nclass SwapperWithChain {\r\n    get intermediaryDiscovery() {\r\n        return this.swapper.intermediaryDiscovery;\r\n    }\r\n    get mempoolApi() {\r\n        return this.swapper.mempoolApi;\r\n    }\r\n    get bitcoinRpc() {\r\n        return this.swapper.bitcoinRpc;\r\n    }\r\n    get bitcoinNetwork() {\r\n        return this.swapper.bitcoinNetwork;\r\n    }\r\n    get Utils() {\r\n        return this.swapper.Utils;\r\n    }\r\n    get SwapTypeInfo() {\r\n        return this.swapper.SwapTypeInfo;\r\n    }\r\n    constructor(swapper, chainIdentifier) {\r\n        this.swapper = swapper;\r\n        this.chainIdentifier = chainIdentifier;\r\n        this.prices = new SwapPriceWithChain_1.SwapPriceWithChain(swapper.prices, chainIdentifier);\r\n    }\r\n    createToBTCSwap(signer, tokenAddress, address, amount, exactIn, additionalParams, options) {\r\n        return this.swapper.createToBTCSwap(this.chainIdentifier, signer, tokenAddress, address, amount, exactIn, additionalParams, options);\r\n    }\r\n    createToBTCLNSwap(signer, tokenAddress, paymentRequest, additionalParams, options) {\r\n        return this.swapper.createToBTCLNSwap(this.chainIdentifier, signer, tokenAddress, paymentRequest, additionalParams, options);\r\n    }\r\n    createToBTCLNSwapViaLNURL(signer, tokenAddress, lnurlPay, amount, exactIn, additionalParams, options) {\r\n        return this.swapper.createToBTCLNSwapViaLNURL(this.chainIdentifier, signer, tokenAddress, lnurlPay, amount, exactIn, additionalParams, options);\r\n    }\r\n    createFromBTCSwap(signer, tokenAddress, amount, exactOut, additionalParams, options) {\r\n        return this.swapper.createFromBTCSwap(this.chainIdentifier, signer, tokenAddress, amount, exactOut, additionalParams, options);\r\n    }\r\n    createFromBTCLNSwap(signer, tokenAddress, amount, exactOut, additionalParams, options) {\r\n        return this.swapper.createFromBTCLNSwap(this.chainIdentifier, signer, tokenAddress, amount, exactOut, additionalParams, options);\r\n    }\r\n    createFromBTCLNSwapViaLNURL(signer, tokenAddress, lnurl, amount, exactOut, additionalParams) {\r\n        return this.swapper.createFromBTCLNSwapViaLNURL(this.chainIdentifier, signer, tokenAddress, lnurl, amount, exactOut, additionalParams);\r\n    }\r\n    createTrustedLNForGasSwap(signer, amount, trustedIntermediaryUrl) {\r\n        return this.swapper.createTrustedLNForGasSwap(this.chainIdentifier, signer, amount, trustedIntermediaryUrl);\r\n    }\r\n    createTrustedOnchainForGasSwap(signer, amount, refundAddress, trustedIntermediaryUrl) {\r\n        return this.swapper.createTrustedOnchainForGasSwap(this.chainIdentifier, signer, amount, refundAddress, trustedIntermediaryUrl);\r\n    }\r\n    /**\r\n     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)\r\n     *  or output amount (exactIn=false), NOTE: For regular -> BTC-LN (lightning) swaps the passed amount is ignored and\r\n     *  invoice's pre-set amount is used instead.\r\n     * @deprecated Use swap() instead\r\n     *\r\n     * @param signer Smartchain (Solana, Starknet, etc.) address of the user\r\n     * @param srcToken Source token of the swap, user pays this token\r\n     * @param dstToken Destination token of the swap, user receives this token\r\n     * @param amount Amount of the swap\r\n     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)\r\n     * @param addressLnurlLightningInvoice Bitcoin on-chain address, lightning invoice, LNURL-pay to pay or\r\n     *  LNURL-withdrawal to withdraw money from\r\n     */\r\n    create(signer, srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice) {\r\n        return this.swapper.create(signer, srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice);\r\n    }\r\n    /**\r\n     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)\r\n     *  or output amount (exactIn=false), NOTE: For regular SmartChain -> BTC-LN (lightning) swaps the passed amount is ignored and\r\n     *  invoice's pre-set amount is used instead, use LNURL-pay for dynamic amounts\r\n     *\r\n     * @param srcToken Source token of the swap, user pays this token\r\n     * @param dstToken Destination token of the swap, user receives this token\r\n     * @param amount Amount of the swap\r\n     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)\r\n     * @param src Source wallet/lnurl-withdraw of the swap\r\n     * @param dst Destination smart chain address, bitcoin on-chain address, lightning invoice, LNURL-pay\r\n     * @param options Options for the swap\r\n     */\r\n    swap(srcToken, dstToken, amount, exactIn, src, dst, options) {\r\n        return this.swapper.swap(srcToken, dstToken, amount, exactIn, src, dst, options);\r\n    }\r\n    /**\r\n     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address\r\n     */\r\n    getAllSwaps(signer) {\r\n        return this.swapper.getAllSwaps(this.chainIdentifier, signer);\r\n    }\r\n    /**\r\n     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address\r\n     */\r\n    getActionableSwaps(signer) {\r\n        return this.swapper.getActionableSwaps(this.chainIdentifier, signer);\r\n    }\r\n    /**\r\n     * Returns swaps that are refundable for the specific chain, optionally also for a specific signer's address\r\n     */\r\n    getRefundableSwaps(signer) {\r\n        return this.swapper.getRefundableSwaps(this.chainIdentifier, signer);\r\n    }\r\n    /**\r\n     * Returns swap with a specific id (identifier) on a specific chain and optionally with a signer\r\n     */\r\n    getSwapById(id, signer) {\r\n        return this.swapper.getSwapById(id, this.chainIdentifier, signer);\r\n    }\r\n    /**\r\n     * Synchronizes swaps from chain, this is usually ran when SDK is initialized, deletes expired quotes\r\n     */\r\n    async _syncSwaps(signer) {\r\n        return this.swapper._syncSwaps(this.chainIdentifier, signer);\r\n    }\r\n    supportsSwapType(swapType) {\r\n        return this.swapper.supportsSwapType(this.chainIdentifier, swapType);\r\n    }\r\n    getSwapType(srcToken, dstToken) {\r\n        return this.swapper.getSwapType(srcToken, dstToken);\r\n    }\r\n    /**\r\n     * Returns minimum/maximum limits for inputs and outputs for a swap between given tokens\r\n     *\r\n     * @param srcToken\r\n     * @param dstToken\r\n     */\r\n    getSwapLimits(srcToken, dstToken) {\r\n        return this.swapper.getSwapLimits(srcToken, dstToken);\r\n    }\r\n    /**\r\n     * Returns a set of supported tokens by all the intermediaries offering a specific swap service\r\n     *\r\n     * @param _swapType Swap service type to check supported tokens for\r\n     */\r\n    getSupportedTokens(_swapType) {\r\n        const tokens = [];\r\n        this.intermediaryDiscovery.intermediaries.forEach(lp => {\r\n            let swapType = _swapType;\r\n            if (swapType === SwapType_1.SwapType.FROM_BTC && this.supportsSwapType(SwapType_1.SwapType.SPV_VAULT_FROM_BTC))\r\n                swapType = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;\r\n            if (lp.services[swapType] == null)\r\n                return;\r\n            if (lp.services[swapType].chainTokens == null)\r\n                return;\r\n            for (let tokenAddress of lp.services[swapType].chainTokens[this.chainIdentifier]) {\r\n                const token = this.swapper.tokens?.[this.chainIdentifier]?.[tokenAddress];\r\n                if (token != null)\r\n                    tokens.push(token);\r\n            }\r\n        });\r\n        return tokens;\r\n    }\r\n    /**\r\n     * Returns the set of supported tokens by all the intermediaries we know of offering a specific swapType service\r\n     *\r\n     * @param swapType Specific swap type for which to obtain supported tokens\r\n     */\r\n    getSupportedTokenAddresses(swapType) {\r\n        const set = new Set();\r\n        this.intermediaryDiscovery.intermediaries.forEach(lp => {\r\n            if (lp.services[swapType] == null)\r\n                return;\r\n            if (lp.services[swapType].chainTokens == null || lp.services[swapType].chainTokens[this.chainIdentifier] == null)\r\n                return;\r\n            lp.services[swapType].chainTokens[this.chainIdentifier].forEach(token => set.add(token));\r\n        });\r\n        return set;\r\n    }\r\n    /**\r\n     * Returns tokens that you can swap to (if input=true) from a given token,\r\n     *  or tokens that you can swap from (if input=false) to a given token\r\n     */\r\n    getSwapCounterTokens(token, input) {\r\n        if ((0, Tokens_1.isSCToken)(token)) {\r\n            const result = [];\r\n            if (input) {\r\n                //TO_BTC or TO_BTCLN\r\n                if (this.getSupportedTokenAddresses(SwapType_1.SwapType.TO_BTCLN).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTCLN);\r\n                }\r\n                if (this.getSupportedTokenAddresses(SwapType_1.SwapType.TO_BTC).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTC);\r\n                }\r\n            }\r\n            else {\r\n                //FROM_BTC or FROM_BTCLN\r\n                if (this.getSupportedTokenAddresses(SwapType_1.SwapType.FROM_BTCLN).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTCLN);\r\n                }\r\n                const fromOnchainSwapType = this.supportsSwapType(SwapType_1.SwapType.SPV_VAULT_FROM_BTC) ? SwapType_1.SwapType.SPV_VAULT_FROM_BTC : SwapType_1.SwapType.FROM_BTC;\r\n                if (this.getSupportedTokenAddresses(fromOnchainSwapType).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTC);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            if (input) {\r\n                if (token.lightning) {\r\n                    return this.getSupportedTokens(SwapType_1.SwapType.FROM_BTCLN);\r\n                }\r\n                else {\r\n                    return this.getSupportedTokens(SwapType_1.SwapType.FROM_BTC);\r\n                }\r\n            }\r\n            else {\r\n                if (token.lightning) {\r\n                    return this.getSupportedTokens(SwapType_1.SwapType.TO_BTCLN);\r\n                }\r\n                else {\r\n                    return this.getSupportedTokens(SwapType_1.SwapType.TO_BTC);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Creates a child swapper instance with a signer\r\n     *\r\n     * @param signer Signer to use for the new swapper instance\r\n     */\r\n    withChain(signer) {\r\n        return new SwapperWithSigner_1.SwapperWithSigner(this, signer);\r\n    }\r\n    ///////////////////////////////////\r\n    /// Deprecated\r\n    /**\r\n     * Returns swap bounds (minimums & maximums) for different swap types & tokens\r\n     * @deprecated Use getSwapLimits() instead!\r\n     */\r\n    getSwapBounds() {\r\n        return this.swapper.getSwapBounds(this.chainIdentifier);\r\n    }\r\n    /**\r\n     * Returns maximum possible swap amount\r\n     * @deprecated Use getSwapLimits() instead!\r\n     *\r\n     * @param type      Type of the swap\r\n     * @param token     Token of the swap\r\n     */\r\n    getMaximum(type, token) {\r\n        return this.swapper.getMaximum(this.chainIdentifier, type, token);\r\n    }\r\n    /**\r\n     * Returns minimum possible swap amount\r\n     * @deprecated Use getSwapLimits() instead!\r\n     *\r\n     * @param type      Type of swap\r\n     * @param token     Token of the swap\r\n     */\r\n    getMinimum(type, token) {\r\n        return this.swapper.getMinimum(this.chainIdentifier, type, token);\r\n    }\r\n}\r\nexports.SwapperWithChain = SwapperWithChain;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9418, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OnchainForGasSwap = exports.isOnchainForGasSwapInit = exports.OnchainForGasSwapState = void 0;\r\nconst SwapType_1 = require(\"../../enums/SwapType\");\r\nconst PaymentAuthError_1 = require(\"../../../errors/PaymentAuthError\");\r\nconst Utils_1 = require(\"../../../utils/Utils\");\r\nconst ISwap_1 = require(\"../../ISwap\");\r\nconst TrustedIntermediaryAPI_1 = require(\"../../../intermediaries/TrustedIntermediaryAPI\");\r\nconst Tokens_1 = require(\"../../../Tokens\");\r\nconst Fee_1 = require(\"../../fee/Fee\");\r\nconst IBitcoinWallet_1 = require(\"../../../btc/wallet/IBitcoinWallet\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst SingleAddressBitcoinWallet_1 = require(\"../../../btc/wallet/SingleAddressBitcoinWallet\");\r\nconst buffer_1 = require(\"buffer\");\r\nvar OnchainForGasSwapState;\r\n(function (OnchainForGasSwapState) {\r\n    OnchainForGasSwapState[OnchainForGasSwapState[\"EXPIRED\"] = -3] = \"EXPIRED\";\r\n    OnchainForGasSwapState[OnchainForGasSwapState[\"FAILED\"] = -2] = \"FAILED\";\r\n    OnchainForGasSwapState[OnchainForGasSwapState[\"REFUNDED\"] = -1] = \"REFUNDED\";\r\n    OnchainForGasSwapState[OnchainForGasSwapState[\"PR_CREATED\"] = 0] = \"PR_CREATED\";\r\n    OnchainForGasSwapState[OnchainForGasSwapState[\"FINISHED\"] = 1] = \"FINISHED\";\r\n    OnchainForGasSwapState[OnchainForGasSwapState[\"REFUNDABLE\"] = 2] = \"REFUNDABLE\";\r\n})(OnchainForGasSwapState = exports.OnchainForGasSwapState || (exports.OnchainForGasSwapState = {}));\r\nfunction isOnchainForGasSwapInit(obj) {\r\n    return typeof (obj.paymentHash) === \"string\" &&\r\n        typeof (obj.sequence) === \"bigint\" &&\r\n        typeof (obj.address) === \"string\" &&\r\n        typeof (obj.inputAmount) === \"bigint\" &&\r\n        typeof (obj.outputAmount) === \"bigint\" &&\r\n        typeof (obj.recipient) === \"string\" &&\r\n        typeof (obj.token) === \"string\" &&\r\n        (obj.refundAddress == null || typeof (obj.refundAddress) === \"string\") &&\r\n        (0, ISwap_1.isISwapInit)(obj);\r\n}\r\nexports.isOnchainForGasSwapInit = isOnchainForGasSwapInit;\r\nclass OnchainForGasSwap extends ISwap_1.ISwap {\r\n    constructor(wrapper, initOrObj) {\r\n        if (isOnchainForGasSwapInit(initOrObj))\r\n            initOrObj.url += \"/frombtc_trusted\";\r\n        super(wrapper, initOrObj);\r\n        this.getSmartChainNetworkFee = null;\r\n        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTC;\r\n        if (isOnchainForGasSwapInit(initOrObj)) {\r\n            this.state = OnchainForGasSwapState.PR_CREATED;\r\n        }\r\n        else {\r\n            this.paymentHash = initOrObj.paymentHash;\r\n            this.sequence = initOrObj.sequence == null ? null : BigInt(initOrObj.sequence);\r\n            this.address = initOrObj.address;\r\n            this.inputAmount = initOrObj.inputAmount == null ? null : BigInt(initOrObj.inputAmount);\r\n            this.outputAmount = initOrObj.outputAmount == null ? null : BigInt(initOrObj.outputAmount);\r\n            this.recipient = initOrObj.recipient;\r\n            this.token = initOrObj.token;\r\n            this.refundAddress = initOrObj.refundAddress;\r\n            this.scTxId = initOrObj.scTxId;\r\n            this.txId = initOrObj.txId;\r\n            this.refundTxId = initOrObj.refundTxId;\r\n        }\r\n        this.logger = (0, Utils_1.getLogger)(\"OnchainForGas(\" + this.getId() + \"): \");\r\n        this.tryRecomputeSwapPrice();\r\n    }\r\n    upgradeVersion() {\r\n        if (this.version == null) {\r\n            //Noop\r\n            this.version = 1;\r\n        }\r\n    }\r\n    /**\r\n     * In case swapFee in BTC is not supplied it recalculates it based on swap price\r\n     * @protected\r\n     */\r\n    tryRecomputeSwapPrice() {\r\n        if (this.swapFeeBtc == null) {\r\n            this.swapFeeBtc = this.swapFee * this.getInput().rawAmount / this.getOutAmountWithoutFee();\r\n        }\r\n        super.tryRecomputeSwapPrice();\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    _getEscrowHash() {\r\n        return this.paymentHash;\r\n    }\r\n    getOutputAddress() {\r\n        return this.recipient;\r\n    }\r\n    getInputTxId() {\r\n        return this.txId;\r\n    }\r\n    getOutputTxId() {\r\n        return this.scTxId;\r\n    }\r\n    getId() {\r\n        return this.paymentHash;\r\n    }\r\n    getAddress() {\r\n        return this.address;\r\n    }\r\n    getHyperlink() {\r\n        return \"bitcoin:\" + this.address + \"?amount=\" + encodeURIComponent((Number(this.inputAmount) / 100000000).toString(10));\r\n    }\r\n    requiresAction() {\r\n        return this.state === OnchainForGasSwapState.REFUNDABLE;\r\n    }\r\n    isFinished() {\r\n        return this.state === OnchainForGasSwapState.FINISHED || this.state === OnchainForGasSwapState.FAILED || this.state === OnchainForGasSwapState.EXPIRED || this.state === OnchainForGasSwapState.REFUNDED;\r\n    }\r\n    isQuoteExpired() {\r\n        return this.state === OnchainForGasSwapState.EXPIRED;\r\n    }\r\n    isQuoteSoftExpired() {\r\n        return this.expiry < Date.now();\r\n    }\r\n    isFailed() {\r\n        return this.state === OnchainForGasSwapState.FAILED;\r\n    }\r\n    isSuccessful() {\r\n        return this.state === OnchainForGasSwapState.FINISHED;\r\n    }\r\n    verifyQuoteValid() {\r\n        return Promise.resolve(this.expiry > Date.now());\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getOutAmountWithoutFee() {\r\n        return this.outputAmount + this.swapFee;\r\n    }\r\n    getOutput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.outputAmount, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices);\r\n    }\r\n    getInput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.inputAmount, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);\r\n    }\r\n    getInputWithoutFee() {\r\n        return (0, Tokens_1.toTokenAmount)(this.inputAmount - this.swapFeeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);\r\n    }\r\n    getSwapFee() {\r\n        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;\r\n        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getInputWithoutFee().rawAmount;\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),\r\n            composition: {\r\n                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),\r\n                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)\r\n            }\r\n        };\r\n    }\r\n    getFee() {\r\n        return this.getSwapFee();\r\n    }\r\n    getFeeBreakdown() {\r\n        return [{\r\n                type: Fee_1.FeeType.SWAP,\r\n                fee: this.getSwapFee()\r\n            }];\r\n    }\r\n    getRequiredConfirmationsCount() {\r\n        return 1;\r\n    }\r\n    async getFundedPsbt(_bitcoinWallet, feeRate) {\r\n        if (this.state !== OnchainForGasSwapState.PR_CREATED)\r\n            throw new Error(\"Swap already paid for!\");\r\n        let bitcoinWallet;\r\n        if ((0, IBitcoinWallet_1.isIBitcoinWallet)(_bitcoinWallet)) {\r\n            bitcoinWallet = _bitcoinWallet;\r\n        }\r\n        else {\r\n            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.wrapper.btcRpc, this.wrapper.options.bitcoinNetwork, _bitcoinWallet);\r\n        }\r\n        //TODO: Maybe re-introduce fee rate check here if passed from the user\r\n        if (feeRate == null) {\r\n            feeRate = await bitcoinWallet.getFeeRate();\r\n        }\r\n        const basePsbt = new btc_signer_1.Transaction({\r\n            allowUnknownOutputs: true,\r\n            allowLegacyWitnessUtxo: true\r\n        });\r\n        basePsbt.addOutput({\r\n            amount: this.outputAmount,\r\n            script: (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address)\r\n        });\r\n        const psbt = await bitcoinWallet.fundPsbt(basePsbt, feeRate);\r\n        //Sign every input\r\n        const signInputs = [];\r\n        for (let i = 0; i < psbt.inputsLength; i++) {\r\n            signInputs.push(i);\r\n        }\r\n        return { psbt, signInputs };\r\n    }\r\n    async submitPsbt(psbt) {\r\n        if (this.state !== OnchainForGasSwapState.PR_CREATED)\r\n            throw new Error(\"Swap already paid for!\");\r\n        //Ensure not expired\r\n        if (this.expiry < Date.now()) {\r\n            throw new Error(\"Swap expired!\");\r\n        }\r\n        const output0 = psbt.getOutput(0);\r\n        if (output0.amount !== this.outputAmount)\r\n            throw new Error(\"PSBT output amount invalid, expected: \" + this.outputAmount + \" got: \" + output0.amount);\r\n        const expectedOutputScript = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address);\r\n        if (!expectedOutputScript.equals(output0.script))\r\n            throw new Error(\"PSBT output script invalid!\");\r\n        if (!psbt.isFinal)\r\n            psbt.finalize();\r\n        return await this.wrapper.btcRpc.sendRawTransaction(buffer_1.Buffer.from(psbt.toBytes(true, true)).toString(\"hex\"));\r\n    }\r\n    async estimateBitcoinFee(wallet, feeRate) {\r\n        const txFee = await wallet.getTransactionFee(this.address, this.inputAmount, feeRate);\r\n        return (0, Tokens_1.toTokenAmount)(txFee == null ? null : BigInt(txFee), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);\r\n    }\r\n    async sendBitcoinTransaction(wallet, feeRate) {\r\n        if (this.state !== OnchainForGasSwapState.PR_CREATED)\r\n            throw new Error(\"Swap already paid for!\");\r\n        return await wallet.sendTransaction(this.address, this.inputAmount, feeRate);\r\n    }\r\n    //////////////////////////////\r\n    //// Payment\r\n    async checkAddress(save = true) {\r\n        if (this.state === OnchainForGasSwapState.FAILED ||\r\n            this.state === OnchainForGasSwapState.EXPIRED ||\r\n            this.state === OnchainForGasSwapState.REFUNDED)\r\n            return false;\r\n        if (this.state === OnchainForGasSwapState.FINISHED)\r\n            return false;\r\n        const response = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.getAddressStatus(this.url, this.paymentHash, this.sequence, this.wrapper.options.getRequestTimeout);\r\n        switch (response.code) {\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.AWAIT_PAYMENT:\r\n                if (this.txId != null) {\r\n                    this.txId = null;\r\n                    if (save)\r\n                        await this._save();\r\n                    return true;\r\n                }\r\n                return false;\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.AWAIT_CONFIRMATION:\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.PENDING:\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.TX_SENT:\r\n                const inputAmount = BigInt(response.data.adjustedAmount);\r\n                const outputAmount = BigInt(response.data.adjustedTotal);\r\n                const adjustedFee = response.data.adjustedFee == null ? null : BigInt(response.data.adjustedFee);\r\n                const adjustedFeeSats = response.data.adjustedFeeSats == null ? null : BigInt(response.data.adjustedFeeSats);\r\n                const txId = response.data.txId;\r\n                if (this.txId != txId ||\r\n                    this.inputAmount !== inputAmount ||\r\n                    this.outputAmount !== outputAmount) {\r\n                    this.txId = txId;\r\n                    this.inputAmount = inputAmount;\r\n                    this.outputAmount = outputAmount;\r\n                    if (adjustedFee != null)\r\n                        this.swapFee = adjustedFee;\r\n                    if (adjustedFeeSats != null)\r\n                        this.swapFeeBtc = adjustedFeeSats;\r\n                    if (save)\r\n                        await this._save();\r\n                    return true;\r\n                }\r\n                return false;\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.PAID:\r\n                const txStatus = await this.wrapper.chain.getTxIdStatus(response.data.txId);\r\n                if (txStatus === \"success\") {\r\n                    this.state = OnchainForGasSwapState.FINISHED;\r\n                    this.scTxId = response.data.txId;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n                return false;\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.EXPIRED:\r\n                this.state = OnchainForGasSwapState.EXPIRED;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.REFUNDABLE:\r\n                if (this.state === OnchainForGasSwapState.REFUNDABLE)\r\n                    return null;\r\n                this.state = OnchainForGasSwapState.REFUNDABLE;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.REFUNDED:\r\n                this.state = OnchainForGasSwapState.REFUNDED;\r\n                this.refundTxId = response.data.txId;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            default:\r\n                this.state = OnchainForGasSwapState.FAILED;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n        }\r\n    }\r\n    async setRefundAddress(refundAddress) {\r\n        if (this.refundAddress != null) {\r\n            if (this.refundAddress !== refundAddress)\r\n                throw new Error(\"Different refund address already set!\");\r\n            return;\r\n        }\r\n        await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.setRefundAddress(this.url, this.paymentHash, this.sequence, refundAddress, this.wrapper.options.getRequestTimeout);\r\n        this.refundAddress = refundAddress;\r\n    }\r\n    /**\r\n     * A blocking promise resolving when payment was received by the intermediary and client can continue\r\n     * rejecting in case of failure\r\n     *\r\n     * @param abortSignal Abort signal\r\n     * @param checkIntervalSeconds How often to poll the intermediary for answer\r\n     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations\r\n     * @throws {PaymentAuthError} If swap expired or failed\r\n     * @throws {Error} When in invalid state (not PR_CREATED)\r\n     */\r\n    async waitForBitcoinTransaction(abortSignal, checkIntervalSeconds = 5, updateCallback) {\r\n        if (this.state !== OnchainForGasSwapState.PR_CREATED)\r\n            throw new Error(\"Must be in PR_CREATED state!\");\r\n        if (!this.initiated) {\r\n            this.initiated = true;\r\n            await this._saveAndEmit();\r\n        }\r\n        while (!abortSignal.aborted &&\r\n            this.state === OnchainForGasSwapState.PR_CREATED) {\r\n            await this.checkAddress(true);\r\n            if (this.txId != null && updateCallback != null) {\r\n                const res = await this.wrapper.btcRpc.getTransaction(this.txId);\r\n                if (res == null) {\r\n                    updateCallback(null, null, 1, null);\r\n                }\r\n                else if (res.confirmations > 0) {\r\n                    updateCallback(res.txid, res.confirmations, 1, 0);\r\n                }\r\n                else {\r\n                    const delay = await this.wrapper.btcRpc.getConfirmationDelay(res, 1);\r\n                    updateCallback(res.txid, 0, 1, delay);\r\n                }\r\n            }\r\n            if (this.state === OnchainForGasSwapState.PR_CREATED)\r\n                await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);\r\n        }\r\n        if (this.state === OnchainForGasSwapState.REFUNDABLE ||\r\n            this.state === OnchainForGasSwapState.REFUNDED)\r\n            return this.txId;\r\n        if (this.isQuoteExpired())\r\n            throw new PaymentAuthError_1.PaymentAuthError(\"Swap expired\");\r\n        if (this.isFailed())\r\n            throw new PaymentAuthError_1.PaymentAuthError(\"Swap failed\");\r\n        return this.txId;\r\n    }\r\n    async waitTillRefunded(abortSignal, checkIntervalSeconds = 5) {\r\n        if (this.state === OnchainForGasSwapState.REFUNDED)\r\n            return;\r\n        if (this.state !== OnchainForGasSwapState.REFUNDABLE)\r\n            throw new Error(\"Must be in REFUNDABLE state!\");\r\n        while (!abortSignal.aborted &&\r\n            this.state === OnchainForGasSwapState.REFUNDABLE) {\r\n            await this.checkAddress(true);\r\n            if (this.state === OnchainForGasSwapState.REFUNDABLE)\r\n                await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);\r\n        }\r\n        if (this.isQuoteExpired())\r\n            throw new PaymentAuthError_1.PaymentAuthError(\"Swap expired\");\r\n        if (this.isFailed())\r\n            throw new PaymentAuthError_1.PaymentAuthError(\"Swap failed\");\r\n    }\r\n    async requestRefund(refundAddress, abortSignal) {\r\n        if (refundAddress != null)\r\n            await this.setRefundAddress(refundAddress);\r\n        await this.waitTillRefunded(abortSignal);\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            paymentHash: this.paymentHash,\r\n            sequence: this.sequence == null ? null : this.sequence.toString(10),\r\n            address: this.address,\r\n            inputAmount: this.inputAmount == null ? null : this.inputAmount.toString(10),\r\n            outputAmount: this.outputAmount == null ? null : this.outputAmount.toString(10),\r\n            recipient: this.recipient,\r\n            token: this.token,\r\n            refundAddress: this.refundAddress,\r\n            scTxId: this.scTxId,\r\n            txId: this.txId,\r\n            refundTxId: this.refundTxId,\r\n        };\r\n    }\r\n    _getInitiator() {\r\n        return this.recipient;\r\n    }\r\n    //////////////////////////////\r\n    //// Swap ticks & sync\r\n    async _sync(save) {\r\n        if (this.state === OnchainForGasSwapState.PR_CREATED) {\r\n            //Check if it's maybe already paid\r\n            const result = await this.checkAddress(false);\r\n            if (result) {\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _tick(save) {\r\n        return Promise.resolve(false);\r\n    }\r\n}\r\nexports.OnchainForGasSwap = OnchainForGasSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9786, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OnchainForGasWrapper = void 0;\r\nconst ISwapWrapper_1 = require(\"../../ISwapWrapper\");\r\nconst TrustedIntermediaryAPI_1 = require(\"../../../intermediaries/TrustedIntermediaryAPI\");\r\nconst IntermediaryError_1 = require(\"../../../errors/IntermediaryError\");\r\nconst OnchainForGasSwap_1 = require(\"./OnchainForGasSwap\");\r\nconst SwapType_1 = require(\"../../enums/SwapType\");\r\nclass OnchainForGasWrapper extends ISwapWrapper_1.ISwapWrapper {\r\n    /**\r\n     * @param chainIdentifier\r\n     * @param unifiedStorage Storage interface for the current environment\r\n     * @param unifiedChainEvents On-chain event listener\r\n     * @param chain\r\n     * @param prices Pricing to use\r\n     * @param tokens\r\n     * @param btcRpc Bitcoin RPC which also supports getting transactions by txoHash\r\n     * @param options\r\n     * @param events Instance to use for emitting events\r\n     */\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, btcRpc, options, events) {\r\n        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events);\r\n        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTC;\r\n        this.swapDeserializer = OnchainForGasSwap_1.OnchainForGasSwap;\r\n        this.pendingSwapStates = [OnchainForGasSwap_1.OnchainForGasSwapState.PR_CREATED];\r\n        this.tickSwapState = null;\r\n        this.processEvent = null;\r\n        this.btcRpc = btcRpc;\r\n    }\r\n    /**\r\n     * Returns a newly created swap, receiving 'amount' base units of gas token\r\n     *\r\n     * @param signer\r\n     * @param amount            Amount you wish to receive in base units\r\n     * @param lpOrUrl           Intermediary/Counterparty swap service Intermediary object or raw url\r\n     * @param refundAddress     Bitcoin address to receive refund on in case the counterparty cannot execute the swap\r\n     */\r\n    async create(signer, amount, lpOrUrl, refundAddress) {\r\n        if (!this.isInitialized)\r\n            throw new Error(\"Not initialized, call init() first!\");\r\n        const lpUrl = typeof (lpOrUrl) === \"string\" ? lpOrUrl : lpOrUrl.url;\r\n        const token = this.chain.getNativeCurrencyAddress();\r\n        const resp = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.initTrustedFromBTC(this.chainIdentifier, lpUrl, {\r\n            address: signer,\r\n            amount,\r\n            refundAddress,\r\n            token\r\n        }, this.options.getRequestTimeout);\r\n        if (resp.total !== amount)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid total returned\");\r\n        const pricingInfo = await this.verifyReturnedPrice(typeof (lpOrUrl) === \"string\" ?\r\n            { swapFeePPM: 10000, swapBaseFee: 10 } :\r\n            lpOrUrl.services[SwapType_1.SwapType.TRUSTED_FROM_BTC], false, resp.amountSats, amount, this.chain.getNativeCurrencyAddress(), {});\r\n        const quote = new OnchainForGasSwap_1.OnchainForGasSwap(this, {\r\n            paymentHash: resp.paymentHash,\r\n            sequence: resp.sequence,\r\n            address: resp.btcAddress,\r\n            inputAmount: resp.amountSats,\r\n            outputAmount: resp.total,\r\n            recipient: signer,\r\n            refundAddress,\r\n            pricingInfo,\r\n            url: lpUrl,\r\n            expiry: resp.expiresAt,\r\n            swapFee: resp.swapFee,\r\n            swapFeeBtc: resp.swapFeeSats,\r\n            exactIn: false,\r\n            token\r\n        });\r\n        await quote._save();\r\n        return quote;\r\n    }\r\n}\r\nexports.OnchainForGasWrapper = OnchainForGasWrapper;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,oBAAoB,GAAG,KAAK;AACpC,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,6BAA6B,eAAe,YAAY;IAqB1D;;;;;;;KAOC,GACD,MAAM,OAAO,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE;QACjD,IAAI,CAAC,IAAI,CAAC,aAAa,EACnB,MAAM,IAAI,MAAM;QACpB,MAAM,QAAQ,OAAQ,YAAa,WAAW,UAAU,QAAQ,GAAG;QACnE,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,wBAAwB;QACjD,MAAM,OAAO,MAAM,yBAAyB,sBAAsB,CAAC,kBAAkB,CAAC,IAAI,CAAC,eAAe,EAAE,OAAO;YAC/G,SAAS;YACT;YACA;YACA;QACJ,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB;QACjC,IAAI,KAAK,KAAK,KAAK,QACf,MAAM,IAAI,oBAAoB,iBAAiB,CAAC;QACpD,MAAM,cAAc,MAAM,IAAI,CAAC,mBAAmB,CAAC,OAAQ,YAAa,WACpE;YAAE,YAAY;YAAO,aAAa;QAAG,IACrC,QAAQ,QAAQ,CAAC,WAAW,QAAQ,CAAC,gBAAgB,CAAC,EAAE,OAAO,KAAK,UAAU,EAAE,QAAQ,IAAI,CAAC,KAAK,CAAC,wBAAwB,IAAI,CAAC;QACpI,MAAM,QAAQ,IAAI,oBAAoB,iBAAiB,CAAC,IAAI,EAAE;YAC1D,aAAa,KAAK,WAAW;YAC7B,UAAU,KAAK,QAAQ;YACvB,SAAS,KAAK,UAAU;YACxB,aAAa,KAAK,UAAU;YAC5B,cAAc,KAAK,KAAK;YACxB,WAAW;YACX;YACA;YACA,KAAK;YACL,QAAQ,KAAK,SAAS;YACtB,SAAS,KAAK,OAAO;YACrB,YAAY,KAAK,WAAW;YAC5B,SAAS;YACT;QACJ;QACA,MAAM,MAAM,KAAK;QACjB,OAAO;IACX;IA9DA;;;;;;;;;;KAUC,GACD,YAAY,eAAe,EAAE,cAAc,EAAE,kBAAkB,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAAE;QAC7G,KAAK,CAAC,iBAAiB,gBAAgB,oBAAoB,OAAO,QAAQ,QAAQ,SAAS;QAC3F,IAAI,CAAC,IAAI,GAAG,WAAW,QAAQ,CAAC,gBAAgB;QAChD,IAAI,CAAC,gBAAgB,GAAG,oBAAoB,iBAAiB;QAC7D,IAAI,CAAC,iBAAiB,GAAG;YAAC,oBAAoB,sBAAsB,CAAC,UAAU;SAAC;QAChF,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,MAAM,GAAG;IAClB;AA4CJ;AACA,QAAQ,oBAAoB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 9864, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/browser-storage/IndexedDBUnifiedStorage.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.IndexedDBUnifiedStorage = void 0;\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nfunction toCompositeIndex(values) {\r\n    if (values.length === 0)\r\n        return [];\r\n    if (values.length === 1) {\r\n        return values[0];\r\n    }\r\n    else {\r\n        const compositeArray = [];\r\n        const firstValues = values.shift();\r\n        const restValues = toCompositeIndex(values);\r\n        for (let value of firstValues) {\r\n            for (let restValue of restValues) {\r\n                compositeArray.push([value].concat(restValue));\r\n            }\r\n        }\r\n        return compositeArray;\r\n    }\r\n}\r\nfunction matches(conditions, obj) {\r\n    for (let condition of conditions) {\r\n        let value = obj[condition.key];\r\n        if (!condition.values.has(value))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction toSetConditions(input) {\r\n    return input.map(val => {\r\n        return {\r\n            key: val.key,\r\n            values: Array.isArray(val.value) ? new Set(val.value) : new Set([val.value])\r\n        };\r\n    });\r\n}\r\nconst indexes = {\r\n    \"escrowHash\": { key: \"escrowHash\", unique: true },\r\n    \"type\": { key: \"type\", unique: false },\r\n    \"initiator\": { key: \"initiator\", unique: false },\r\n    \"initiator, id\": { key: [\"initiator\", \"id\"], unique: false },\r\n    \"type, state\": { key: [\"type\", \"state\"], unique: false },\r\n    \"type, paymentHash\": { key: [\"type\", \"paymentHash\"], unique: false },\r\n    \"type, initiator, state\": { key: [\"type\", \"initiator\", \"state\"], unique: false }\r\n};\r\nclass IndexedDBUnifiedStorage {\r\n    constructor(storageKey) {\r\n        this.storageKey = storageKey;\r\n        this.logger = (0, Utils_1.getLogger)(\"IndexedDBUnifiedStorage(\" + this.storageKey + \"): \");\r\n    }\r\n    //Reviver also needs to update the swap to the latest version\r\n    async tryMigrateLocalStorage(storageKey, swapType, reviver) {\r\n        const txt = window.localStorage.getItem(storageKey);\r\n        if (txt == null)\r\n            return false;\r\n        let data;\r\n        try {\r\n            data = JSON.parse(txt);\r\n        }\r\n        catch (e) {\r\n            this.logger.warn(\"tryMigrate(\" + storageKey + \"): Tried to migrate the database, but cannot parse old local storage!\");\r\n            return false;\r\n        }\r\n        let swaps = Object.keys(data).map(id => {\r\n            let swapData = data[id];\r\n            swapData.type = swapType;\r\n            return reviver(swapData);\r\n        });\r\n        await this.saveAll(swaps.map(swap => swap.serialize()));\r\n        window.localStorage.removeItem(storageKey);\r\n        this.logger.info(\"tryMigrate(\" + storageKey + \"): Database successfully migrated from localStorage to unifiedIndexedDB!\");\r\n        return true;\r\n    }\r\n    //Reviver also needs to update the swap to the latest version\r\n    async tryMigrateOldIndexedDB(storageKey, swapType, reviver) {\r\n        const databases = await window.indexedDB.databases();\r\n        if (databases.find(val => val.name === storageKey) == null) {\r\n            this.logger.info(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Old database not found!\");\r\n            return false;\r\n        }\r\n        this.logger.debug(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Old database found!\");\r\n        let db;\r\n        try {\r\n            db = await new Promise((resolve, reject) => {\r\n                const request = window.indexedDB.open(storageKey, 1);\r\n                request.onerror = (e) => reject(e);\r\n                request.onsuccess = (e) => resolve(e.target.result);\r\n            });\r\n        }\r\n        catch (e) {\r\n            this.logger.warn(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Error opening old IndexedDB!\", e);\r\n            return false;\r\n        }\r\n        this.logger.debug(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Connection opened!\");\r\n        try {\r\n            const data = await new Promise((resolve, reject) => {\r\n                const tx = db.transaction(\"swaps\", \"readonly\", { durability: \"strict\" });\r\n                const store = tx.objectStore(\"swaps\");\r\n                const req = store.getAll();\r\n                req.onsuccess = (event) => resolve(event.target.result);\r\n                req.onerror = (event) => reject(event);\r\n            });\r\n            this.logger.debug(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Data retrieved!\");\r\n            let swaps = data.map(({ id, data }) => {\r\n                data.type = swapType;\r\n                return reviver(data);\r\n            });\r\n            this.logger.debug(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Data revived!\");\r\n            await this.saveAll(swaps.map(swap => swap.serialize()));\r\n            this.logger.debug(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Data saved!\");\r\n            //Remove the old database\r\n            db.close();\r\n            this.logger.debug(\"tryMigrateOldIndexedDB(\" + storageKey + \"): DB connection closed!\");\r\n            await new Promise((resolve, reject) => {\r\n                const res = window.indexedDB.deleteDatabase(storageKey);\r\n                res.onsuccess = () => resolve();\r\n                res.onerror = (e) => reject(e);\r\n            });\r\n            this.logger.info(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Database successfully migrated from oldIndexedDB to unifiedIndexedDB!\");\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            this.logger.warn(\"tryMigrateOldIndexedDB(\" + storageKey + \"): Tried to migrate the database, but cannot parse oldIndexedDB!\", e);\r\n            return false;\r\n        }\r\n    }\r\n    //NOTE: Reviver also needs to update the swap to the latest version\r\n    async tryMigrate(storageKeys, reviver) {\r\n        let someMigrated = false;\r\n        for (let storageKey of storageKeys) {\r\n            this.logger.info(\"tryMigrate(): Trying to migrate...\", storageKey);\r\n            if (await this.tryMigrateLocalStorage(storageKey[0], storageKey[1], reviver))\r\n                someMigrated = true;\r\n            if (await this.tryMigrateOldIndexedDB(storageKey[0], storageKey[1], reviver))\r\n                someMigrated = true;\r\n        }\r\n        return someMigrated;\r\n    }\r\n    executeTransaction(cbk, readonly) {\r\n        return new Promise((resolve, reject) => {\r\n            const tx = this.db.transaction(\"swaps\", readonly ? \"readonly\" : \"readwrite\", { durability: \"strict\" });\r\n            const req = cbk(tx.objectStore(\"swaps\"));\r\n            req.onsuccess = (event) => resolve(event.target.result);\r\n            req.onerror = (event) => reject(event);\r\n        });\r\n    }\r\n    executeTransactionArr(cbk, readonly) {\r\n        const tx = this.db.transaction(\"swaps\", readonly ? \"readonly\" : \"readwrite\", { durability: \"strict\" });\r\n        const reqs = cbk(tx.objectStore(\"swaps\"));\r\n        return Promise.all(reqs.map(req => new Promise((resolve, reject) => {\r\n            req.onsuccess = (event) => resolve(event.target.result);\r\n            req.onerror = (event) => reject(event);\r\n        })));\r\n    }\r\n    executeTransactionWithCursor(cbk, valueCbk) {\r\n        return new Promise((resolve, reject) => {\r\n            const tx = this.db.transaction(\"swaps\", \"readonly\", { durability: \"strict\" });\r\n            const cursorRequests = cbk(tx.objectStore(\"swaps\"));\r\n            const resultObjects = [];\r\n            for (let cursorRequest of cursorRequests) {\r\n                cursorRequest.onsuccess = (event) => {\r\n                    const cursor = event.target.result;\r\n                    if (cursor != null) {\r\n                        const value = cursor.value;\r\n                        if (valueCbk(value))\r\n                            resultObjects.push(value);\r\n                        cursor.continue();\r\n                    }\r\n                    else {\r\n                        resolve(resultObjects);\r\n                    }\r\n                };\r\n                cursorRequest.onerror = (event) => reject(event);\r\n            }\r\n        });\r\n    }\r\n    async init() {\r\n        if (this.db == null) {\r\n            this.db = await new Promise((resolve, reject) => {\r\n                const request = window.indexedDB.open(this.storageKey, 1);\r\n                request.onupgradeneeded = (event) => {\r\n                    const db = event.target.result;\r\n                    const objectStore = db.createObjectStore(\"swaps\", { keyPath: \"id\" });\r\n                    Object.keys(indexes).forEach(name => {\r\n                        const index = indexes[name];\r\n                        objectStore.createIndex(name, index.key, { unique: index.unique });\r\n                    });\r\n                };\r\n                request.onerror = (e) => reject(e);\r\n                request.onsuccess = (e) => resolve(e.target.result);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Params are specified in the following way:\r\n     *  - [[condition1, condition2]] - returns all rows where condition1 AND condition2 is met\r\n     *  - [[condition1], [condition2]] - returns all rows where condition1 OR condition2 is met\r\n     *  - [[condition1, condition2], [condition3]] - returns all rows where (condition1 AND condition2) OR condition3 is met\r\n     * @param params\r\n     */\r\n    async query(params) {\r\n        if (params.length === 0)\r\n            return await this.querySingle([]);\r\n        const results = await Promise.all(params.map(singleParam => this.querySingle(singleParam)));\r\n        const resultSet = new Set(results.flat()); //Deduplicate\r\n        return Array.from(resultSet);\r\n    }\r\n    async querySingle(params) {\r\n        if (params.length === 0) {\r\n            return await this.executeTransaction((objectStore) => objectStore.getAll(), true);\r\n        }\r\n        const queryKeys = params.map(param => param.key);\r\n        const requiredIndex = queryKeys.join(\", \");\r\n        if (requiredIndex === \"id\") {\r\n            //ID is the index\r\n            const values = Array.isArray(params[0].value) ? params[0].value : [params[0].value];\r\n            const res = await this.executeTransactionArr((objectStore) => {\r\n                return values.map(val => objectStore.getAll(val));\r\n            }, true);\r\n            return res.flat();\r\n        }\r\n        else if (indexes[requiredIndex] != null) {\r\n            //Index exists\r\n            const values = params.map(param => Array.isArray(param.value) ? param.value : [param.value]);\r\n            const compositeIndexQueries = toCompositeIndex(values);\r\n            const resp = await this.executeTransactionArr(objectStore => {\r\n                const index = objectStore.index(requiredIndex);\r\n                return compositeIndexQueries.map(indexQuery => index.getAll(indexQuery));\r\n            }, true);\r\n            return resp.flat();\r\n        }\r\n        else {\r\n            //Need to go over all values\r\n            this.logger.warn(\"query(): Index cannot be used for query, required index: \" + requiredIndex + \" query params: \", params);\r\n            const setConditions = toSetConditions(params);\r\n            return await this.executeTransactionWithCursor(objectStore => [objectStore.openCursor()], (val) => matches(setConditions, val));\r\n        }\r\n    }\r\n    async remove(object) {\r\n        await this.executeTransaction(store => store.delete(object.id), false)\r\n            .catch(() => null);\r\n    }\r\n    async removeAll(arr) {\r\n        if (arr.length === 0)\r\n            return;\r\n        await this.executeTransactionArr(store => arr.map(object => {\r\n            return store.delete(object.id);\r\n        }), false);\r\n    }\r\n    async save(object) {\r\n        await this.executeTransaction(store => store.put(object), false);\r\n    }\r\n    async saveAll(arr) {\r\n        if (arr.length === 0)\r\n            return;\r\n        await this.executeTransactionArr(store => arr.map(object => {\r\n            return store.put(object);\r\n        }), false);\r\n    }\r\n}\r\nexports.IndexedDBUnifiedStorage = IndexedDBUnifiedStorage;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10171, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/storage/UnifiedSwapStorage.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UnifiedSwapStorage = void 0;\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst logger = (0, Utils_1.getLogger)(\"UnifiedSwapStorage: \");\r\nconst indexes = [\r\n    { key: \"id\", type: \"string\", unique: true, nullable: false },\r\n    { key: \"escrowHash\", type: \"string\", unique: true, nullable: true },\r\n    { key: \"type\", type: \"number\", unique: false, nullable: false },\r\n    { key: \"initiator\", type: \"string\", unique: false, nullable: false },\r\n    { key: \"state\", type: \"number\", unique: false, nullable: false },\r\n    { key: \"paymentHash\", type: \"string\", unique: false, nullable: true },\r\n];\r\nconst compositeIndexes = [\r\n    { keys: [\"initiator\", \"id\"], unique: false },\r\n    { keys: [\"type\", \"state\"], unique: false },\r\n    { keys: [\"type\", \"paymentHash\"], unique: false },\r\n    { keys: [\"type\", \"initiator\", \"state\"], unique: false }\r\n];\r\nclass UnifiedSwapStorage {\r\n    constructor(storage, noWeakRefMap) {\r\n        this.weakRefCache = new Map();\r\n        this.storage = storage;\r\n        this.noWeakRefMap = noWeakRefMap;\r\n    }\r\n    init() {\r\n        return this.storage.init(indexes, compositeIndexes);\r\n    }\r\n    /**\r\n     * Params are specified in the following way:\r\n     *  - [[condition1, condition2]] - returns all rows where condition1 AND condition2 is met\r\n     *  - [[condition1], [condition2]] - returns all rows where condition1 OR condition2 is met\r\n     *  - [[condition1, condition2], [condition3]] - returns all rows where (condition1 AND condition2) OR condition3 is met\r\n     * @param params\r\n     * @param reviver\r\n     */\r\n    async query(params, reviver) {\r\n        const rawSwaps = await this.storage.query(params);\r\n        return rawSwaps.map(rawObj => {\r\n            if (!this.noWeakRefMap) {\r\n                const savedRef = this.weakRefCache.get(rawObj.id)?.deref();\r\n                if (savedRef != null)\r\n                    return savedRef;\r\n                logger.debug(\"query(): Reviving new swap instance: \" + rawObj.id);\r\n            }\r\n            const value = reviver(rawObj);\r\n            if (!this.noWeakRefMap)\r\n                this.weakRefCache.set(rawObj.id, new WeakRef(value));\r\n            return value;\r\n        });\r\n    }\r\n    save(value) {\r\n        if (!this.noWeakRefMap)\r\n            this.weakRefCache.set(value.getId(), new WeakRef(value));\r\n        return this.storage.save(value.serialize());\r\n    }\r\n    saveAll(values) {\r\n        if (!this.noWeakRefMap)\r\n            values.forEach(value => this.weakRefCache.set(value.getId(), new WeakRef(value)));\r\n        return this.storage.saveAll(values.map(obj => obj.serialize()));\r\n    }\r\n    remove(value) {\r\n        if (!this.noWeakRefMap)\r\n            this.weakRefCache.delete(value.getId());\r\n        return this.storage.remove(value.serialize());\r\n    }\r\n    removeAll(values) {\r\n        if (!this.noWeakRefMap)\r\n            values.forEach(value => this.weakRefCache.delete(value.getId()));\r\n        return this.storage.removeAll(values.map(obj => obj.serialize()));\r\n    }\r\n}\r\nexports.UnifiedSwapStorage = UnifiedSwapStorage;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10298, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/events/UnifiedSwapEventListener.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.UnifiedSwapEventListener = void 0;\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nfunction chainEventToEscrowHash(event) {\r\n    if (event instanceof base_1.SwapEvent)\r\n        return event.escrowHash;\r\n    if (event instanceof base_1.SpvVaultFrontEvent ||\r\n        event instanceof base_1.SpvVaultClaimEvent ||\r\n        event instanceof base_1.SpvVaultCloseEvent)\r\n        return event.btcTxId;\r\n}\r\nclass UnifiedSwapEventListener {\r\n    constructor(unifiedStorage, events) {\r\n        this.listeners = {};\r\n        this.storage = unifiedStorage;\r\n        this.events = events;\r\n    }\r\n    async processEvents(events) {\r\n        const swapsByEscrowHash = {};\r\n        events.forEach(event => {\r\n            swapsByEscrowHash[chainEventToEscrowHash(event)] = null;\r\n        });\r\n        const swaps = await this.storage.query([\r\n            [{ key: \"escrowHash\", value: Object.keys(swapsByEscrowHash) }]\r\n        ], (val) => {\r\n            const obj = this.listeners[val.type];\r\n            if (obj == null)\r\n                return null;\r\n            return new obj.reviver(val);\r\n        });\r\n        swaps.forEach(swap => swapsByEscrowHash[swap._getEscrowHash()] = swap);\r\n        for (let event of events) {\r\n            const swap = swapsByEscrowHash[chainEventToEscrowHash(event)];\r\n            if (swap == null)\r\n                continue;\r\n            const obj = this.listeners[swap.getType()];\r\n            if (obj == null)\r\n                continue;\r\n            await obj.listener(event, swap);\r\n        }\r\n    }\r\n    async start() {\r\n        if (this.listener != null)\r\n            return;\r\n        await this.storage.init();\r\n        await this.events.init();\r\n        this.events.registerListener(this.listener = async (events) => {\r\n            await this.processEvents(events);\r\n            return true;\r\n        });\r\n    }\r\n    stop() {\r\n        this.events.unregisterListener(this.listener);\r\n        return this.events.stop();\r\n    }\r\n    registerListener(type, listener, reviver) {\r\n        this.listeners[type] = {\r\n            listener,\r\n            reviver\r\n        };\r\n    }\r\n    unregisterListener(type) {\r\n        if (this.listeners[type])\r\n            return false;\r\n        delete this.listeners[type];\r\n        return true;\r\n    }\r\n}\r\nexports.UnifiedSwapEventListener = UnifiedSwapEventListener;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,wBAAwB,GAAG,KAAK;AACxC,MAAM;AACN,SAAS,uBAAuB,KAAK;IACjC,IAAI,iBAAiB,OAAO,SAAS,EACjC,OAAO,MAAM,UAAU;IAC3B,IAAI,iBAAiB,OAAO,kBAAkB,IAC1C,iBAAiB,OAAO,kBAAkB,IAC1C,iBAAiB,OAAO,kBAAkB,EAC1C,OAAO,MAAM,OAAO;AAC5B;AACA,MAAM;IAMF,MAAM,cAAc,MAAM,EAAE;QACxB,MAAM,oBAAoB,CAAC;QAC3B,OAAO,OAAO,CAAC,CAAA;YACX,iBAAiB,CAAC,uBAAuB,OAAO,GAAG;QACvD;QACA,MAAM,QAAQ,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;YACnC;gBAAC;oBAAE,KAAK;oBAAc,OAAO,OAAO,IAAI,CAAC;gBAAmB;aAAE;SACjE,EAAE,CAAC;YACA,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC;YACpC,IAAI,OAAO,MACP,OAAO;YACX,OAAO,IAAI,IAAI,OAAO,CAAC;QAC3B;QACA,MAAM,OAAO,CAAC,CAAA,OAAQ,iBAAiB,CAAC,KAAK,cAAc,GAAG,GAAG;QACjE,KAAK,IAAI,SAAS,OAAQ;YACtB,MAAM,OAAO,iBAAiB,CAAC,uBAAuB,OAAO;YAC7D,IAAI,QAAQ,MACR;YACJ,MAAM,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,OAAO,GAAG;YAC1C,IAAI,OAAO,MACP;YACJ,MAAM,IAAI,QAAQ,CAAC,OAAO;QAC9B;IACJ;IACA,MAAM,QAAQ;QACV,IAAI,IAAI,CAAC,QAAQ,IAAI,MACjB;QACJ,MAAM,IAAI,CAAC,OAAO,CAAC,IAAI;QACvB,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI;QACtB,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,GAAG,OAAO;YAChD,MAAM,IAAI,CAAC,aAAa,CAAC;YACzB,OAAO;QACX;IACJ;IACA,OAAO;QACH,IAAI,CAAC,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ;QAC5C,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI;IAC3B;IACA,iBAAiB,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE;QACtC,IAAI,CAAC,SAAS,CAAC,KAAK,GAAG;YACnB;YACA;QACJ;IACJ;IACA,mBAAmB,IAAI,EAAE;QACrB,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,EACpB,OAAO;QACX,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK;QAC3B,OAAO;IACX;IAtDA,YAAY,cAAc,EAAE,MAAM,CAAE;QAChC,IAAI,CAAC,SAAS,GAAG,CAAC;QAClB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,MAAM,GAAG;IAClB;AAmDJ;AACA,QAAQ,wBAAwB,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 10369, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCSwap.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SpvFromBTCSwap = exports.isSpvFromBTCSwapInit = exports.SpvFromBTCSwapState = void 0;\r\nconst ISwap_1 = require(\"../ISwap\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst SwapType_1 = require(\"../enums/SwapType\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst Tokens_1 = require(\"../../Tokens\");\r\nconst buffer_1 = require(\"buffer\");\r\nconst Fee_1 = require(\"../fee/Fee\");\r\nconst IBitcoinWallet_1 = require(\"../../btc/wallet/IBitcoinWallet\");\r\nconst IntermediaryAPI_1 = require(\"../../intermediaries/IntermediaryAPI\");\r\nconst SingleAddressBitcoinWallet_1 = require(\"../../btc/wallet/SingleAddressBitcoinWallet\");\r\nvar SpvFromBTCSwapState;\r\n(function (SpvFromBTCSwapState) {\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"CLOSED\"] = -5] = \"CLOSED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"FAILED\"] = -4] = \"FAILED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"DECLINED\"] = -3] = \"DECLINED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"QUOTE_EXPIRED\"] = -2] = \"QUOTE_EXPIRED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"QUOTE_SOFT_EXPIRED\"] = -1] = \"QUOTE_SOFT_EXPIRED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"CREATED\"] = 0] = \"CREATED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"SIGNED\"] = 1] = \"SIGNED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"POSTED\"] = 2] = \"POSTED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"BROADCASTED\"] = 3] = \"BROADCASTED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"FRONTED\"] = 4] = \"FRONTED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"BTC_TX_CONFIRMED\"] = 5] = \"BTC_TX_CONFIRMED\";\r\n    SpvFromBTCSwapState[SpvFromBTCSwapState[\"CLAIMED\"] = 6] = \"CLAIMED\"; //Funds claimed\r\n})(SpvFromBTCSwapState = exports.SpvFromBTCSwapState || (exports.SpvFromBTCSwapState = {}));\r\nfunction isSpvFromBTCSwapInit(obj) {\r\n    return typeof obj === \"object\" &&\r\n        typeof (obj.quoteId) === \"string\" &&\r\n        typeof (obj.recipient) === \"string\" &&\r\n        typeof (obj.vaultOwner) === \"string\" &&\r\n        typeof (obj.vaultId) === \"bigint\" &&\r\n        typeof (obj.vaultRequiredConfirmations) === \"number\" &&\r\n        Array.isArray(obj.vaultTokenMultipliers) && obj.vaultTokenMultipliers.reduce((prev, curr) => prev && typeof (curr) === \"bigint\", true) &&\r\n        typeof (obj.vaultBtcAddress) === \"string\" &&\r\n        typeof (obj.vaultUtxo) === \"string\" &&\r\n        typeof (obj.vaultUtxoValue) === \"bigint\" &&\r\n        typeof (obj.btcDestinationAddress) === \"string\" &&\r\n        typeof (obj.btcAmount) === \"bigint\" &&\r\n        typeof (obj.btcAmountSwap) === \"bigint\" &&\r\n        typeof (obj.btcAmountGas) === \"bigint\" &&\r\n        typeof (obj.minimumBtcFeeRate) === \"number\" &&\r\n        typeof (obj.outputTotalSwap) === \"bigint\" &&\r\n        typeof (obj.outputSwapToken) === \"string\" &&\r\n        typeof (obj.outputTotalGas) === \"bigint\" &&\r\n        typeof (obj.outputGasToken) === \"string\" &&\r\n        typeof (obj.gasSwapFeeBtc) === \"bigint\" &&\r\n        typeof (obj.gasSwapFee) === \"bigint\" &&\r\n        typeof (obj.callerFeeShare) === \"bigint\" &&\r\n        typeof (obj.frontingFeeShare) === \"bigint\" &&\r\n        typeof (obj.executionFeeShare) === \"bigint\" &&\r\n        (0, ISwap_1.isISwapInit)(obj);\r\n}\r\nexports.isSpvFromBTCSwapInit = isSpvFromBTCSwapInit;\r\nclass SpvFromBTCSwap extends ISwap_1.ISwap {\r\n    constructor(wrapper, initOrObject) {\r\n        if (isSpvFromBTCSwapInit(initOrObject))\r\n            initOrObject.url += \"/frombtc_spv\";\r\n        super(wrapper, initOrObject);\r\n        this.TYPE = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;\r\n        if (isSpvFromBTCSwapInit(initOrObject)) {\r\n            this.state = SpvFromBTCSwapState.CREATED;\r\n            const vaultAddressType = (0, Utils_1.toCoinselectAddressType)((0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.vaultBtcAddress));\r\n            if (vaultAddressType !== \"p2tr\" && vaultAddressType !== \"p2wpkh\" && vaultAddressType !== \"p2wsh\")\r\n                throw new Error(\"Vault address type must be of witness type: p2tr, p2wpkh, p2wsh\");\r\n        }\r\n        else {\r\n            this.quoteId = initOrObject.quoteId;\r\n            this.recipient = initOrObject.recipient;\r\n            this.vaultOwner = initOrObject.vaultOwner;\r\n            this.vaultId = BigInt(initOrObject.vaultId);\r\n            this.vaultRequiredConfirmations = initOrObject.vaultRequiredConfirmations;\r\n            this.vaultTokenMultipliers = initOrObject.vaultTokenMultipliers.map(val => BigInt(val));\r\n            this.vaultBtcAddress = initOrObject.vaultBtcAddress;\r\n            this.vaultUtxo = initOrObject.vaultUtxo;\r\n            this.vaultUtxoValue = BigInt(initOrObject.vaultUtxoValue);\r\n            this.btcDestinationAddress = initOrObject.btcDestinationAddress;\r\n            this.btcAmount = BigInt(initOrObject.btcAmount);\r\n            this.btcAmountSwap = BigInt(initOrObject.btcAmountSwap);\r\n            this.btcAmountGas = BigInt(initOrObject.btcAmountGas);\r\n            this.minimumBtcFeeRate = initOrObject.minimumBtcFeeRate;\r\n            this.outputTotalSwap = BigInt(initOrObject.outputTotalSwap);\r\n            this.outputSwapToken = initOrObject.outputSwapToken;\r\n            this.outputTotalGas = BigInt(initOrObject.outputTotalGas);\r\n            this.outputGasToken = initOrObject.outputGasToken;\r\n            this.gasSwapFeeBtc = BigInt(initOrObject.gasSwapFeeBtc);\r\n            this.gasSwapFee = BigInt(initOrObject.gasSwapFee);\r\n            this.callerFeeShare = BigInt(initOrObject.callerFeeShare);\r\n            this.frontingFeeShare = BigInt(initOrObject.frontingFeeShare);\r\n            this.executionFeeShare = BigInt(initOrObject.executionFeeShare);\r\n            this.claimTxId = initOrObject.claimTxId;\r\n            this.frontTxId = initOrObject.frontTxId;\r\n            this.data = initOrObject.data == null ? null : new this.wrapper.spvWithdrawalDataDeserializer(initOrObject.data);\r\n        }\r\n        this.tryCalculateSwapFee();\r\n        this.logger = (0, Utils_1.getLogger)(\"SPVFromBTC(\" + this.getId() + \"): \");\r\n    }\r\n    upgradeVersion() { }\r\n    /**\r\n     * In case swapFee in BTC is not supplied it recalculates it based on swap price\r\n     * @protected\r\n     */\r\n    tryCalculateSwapFee() {\r\n        if (this.swapFeeBtc == null) {\r\n            this.swapFeeBtc = this.swapFee * this.btcAmountSwap / this.getOutputWithoutFee().rawAmount;\r\n        }\r\n        if (this.pricingInfo.swapPriceUSatPerToken == null) {\r\n            this.pricingInfo = this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier, this.btcAmountSwap, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, this.getOutputWithoutFee().rawAmount, this.outputSwapToken);\r\n        }\r\n    }\r\n    //////////////////////////////\r\n    //// Pricing\r\n    async refreshPriceData() {\r\n        if (this.pricingInfo == null)\r\n            return null;\r\n        this.pricingInfo = await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier, this.btcAmountSwap, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, this.getOutputWithoutFee().rawAmount, this.outputSwapToken);\r\n    }\r\n    //////////////////////////////\r\n    //// Getters & utils\r\n    _getInitiator() {\r\n        return this.recipient;\r\n    }\r\n    _getEscrowHash() {\r\n        return this.data?.btcTx?.txid;\r\n    }\r\n    getId() {\r\n        return this.quoteId + this.randomNonce;\r\n    }\r\n    getQuoteExpiry() {\r\n        return this.expiry - 20 * 1000;\r\n    }\r\n    verifyQuoteValid() {\r\n        return Promise.resolve(this.expiry > Date.now() && (this.state === SpvFromBTCSwapState.CREATED || this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED));\r\n    }\r\n    getOutputAddress() {\r\n        return this.recipient;\r\n    }\r\n    getOutputTxId() {\r\n        return this.frontTxId ?? this.claimTxId;\r\n    }\r\n    getInputTxId() {\r\n        return this.data?.btcTx?.txid;\r\n    }\r\n    requiresAction() {\r\n        return this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED;\r\n    }\r\n    isFinished() {\r\n        return this.state === SpvFromBTCSwapState.CLAIMED || this.state === SpvFromBTCSwapState.QUOTE_EXPIRED || this.state === SpvFromBTCSwapState.FAILED;\r\n    }\r\n    isClaimable() {\r\n        return this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED;\r\n    }\r\n    isSuccessful() {\r\n        return this.state === SpvFromBTCSwapState.FRONTED || this.state === SpvFromBTCSwapState.CLAIMED;\r\n    }\r\n    isFailed() {\r\n        return this.state === SpvFromBTCSwapState.FAILED || this.state === SpvFromBTCSwapState.DECLINED || this.state === SpvFromBTCSwapState.CLOSED;\r\n    }\r\n    isQuoteExpired() {\r\n        return this.state === SpvFromBTCSwapState.QUOTE_EXPIRED;\r\n    }\r\n    isQuoteSoftExpired() {\r\n        return this.state === SpvFromBTCSwapState.QUOTE_EXPIRED || this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED;\r\n    }\r\n    //////////////////////////////\r\n    //// Amounts & fees\r\n    getInputSwapAmountWithoutFee() {\r\n        return (this.btcAmountSwap - this.swapFeeBtc) * 100000n / (100000n + this.callerFeeShare + this.frontingFeeShare + this.executionFeeShare);\r\n    }\r\n    getInputGasAmountWithoutFee() {\r\n        return (this.btcAmountGas - this.gasSwapFeeBtc) * 100000n / (100000n + this.callerFeeShare + this.frontingFeeShare);\r\n    }\r\n    getInputAmountWithoutFee() {\r\n        return this.getInputSwapAmountWithoutFee() + this.getInputGasAmountWithoutFee();\r\n    }\r\n    getOutputWithoutFee() {\r\n        return (0, Tokens_1.toTokenAmount)((this.outputTotalSwap * (100000n + this.callerFeeShare + this.frontingFeeShare + this.executionFeeShare) / 100000n) + this.swapFee, this.wrapper.tokens[this.outputSwapToken], this.wrapper.prices);\r\n    }\r\n    getSwapFee() {\r\n        const outputToken = this.wrapper.tokens[this.outputSwapToken];\r\n        const gasSwapFeeInOutputToken = this.gasSwapFeeBtc\r\n            * (10n ** BigInt(outputToken.decimals))\r\n            * 1000000n\r\n            / this.pricingInfo.swapPriceUSatPerToken;\r\n        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;\r\n        const swapFeePPM = feeWithoutBaseFee * 1000000n / (this.btcAmount - this.swapFeeBtc - this.gasSwapFeeBtc);\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc + this.gasSwapFeeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee + gasSwapFeeInOutputToken, outputToken, this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc + this.gasSwapFeeBtc, abortSignal, preFetchedUsdPrice),\r\n            composition: {\r\n                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),\r\n                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)\r\n            }\r\n        };\r\n    }\r\n    getWatchtowerFee() {\r\n        const totalFeeShare = this.callerFeeShare + this.frontingFeeShare;\r\n        const outputToken = this.wrapper.tokens[this.outputSwapToken];\r\n        const watchtowerFeeInOutputToken = this.getInputGasAmountWithoutFee() * totalFeeShare\r\n            * (10n ** BigInt(outputToken.decimals))\r\n            * 1000000n\r\n            / this.pricingInfo.swapPriceUSatPerToken\r\n            / 100000n;\r\n        const feeBtc = this.getInputAmountWithoutFee() * (totalFeeShare + this.executionFeeShare) / 100000n;\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(feeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)((this.outputTotalSwap * (totalFeeShare + this.executionFeeShare) / 100000n) + watchtowerFeeInOutputToken, outputToken, this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(feeBtc, abortSignal, preFetchedUsdPrice)\r\n        };\r\n    }\r\n    getFee() {\r\n        const swapFee = this.getSwapFee();\r\n        const watchtowerFee = this.getWatchtowerFee();\r\n        return {\r\n            amountInSrcToken: (0, Tokens_1.toTokenAmount)(swapFee.amountInSrcToken.rawAmount + watchtowerFee.amountInSrcToken.rawAmount, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),\r\n            amountInDstToken: (0, Tokens_1.toTokenAmount)(swapFee.amountInDstToken.rawAmount + watchtowerFee.amountInDstToken.rawAmount, this.wrapper.tokens[this.outputSwapToken], this.wrapper.prices),\r\n            usdValue: (abortSignal, preFetchedUsdPrice) => this.wrapper.prices.getBtcUsdValue(swapFee.amountInSrcToken.rawAmount + watchtowerFee.amountInSrcToken.rawAmount, abortSignal, preFetchedUsdPrice)\r\n        };\r\n    }\r\n    getFeeBreakdown() {\r\n        return [\r\n            {\r\n                type: Fee_1.FeeType.SWAP,\r\n                fee: this.getSwapFee()\r\n            },\r\n            {\r\n                type: Fee_1.FeeType.NETWORK_OUTPUT,\r\n                fee: this.getWatchtowerFee()\r\n            }\r\n        ];\r\n    }\r\n    getOutput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.outputTotalSwap, this.wrapper.tokens[this.outputSwapToken], this.wrapper.prices);\r\n    }\r\n    getGasDropOutput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.outputTotalGas, this.wrapper.tokens[this.outputGasToken], this.wrapper.prices);\r\n    }\r\n    getInputWithoutFee() {\r\n        return (0, Tokens_1.toTokenAmount)(this.getInputAmountWithoutFee(), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);\r\n    }\r\n    getInput() {\r\n        return (0, Tokens_1.toTokenAmount)(this.btcAmount, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);\r\n    }\r\n    //////////////////////////////\r\n    //// Bitcoin tx\r\n    getRequiredConfirmationsCount() {\r\n        return this.vaultRequiredConfirmations;\r\n    }\r\n    async getTransactionDetails() {\r\n        const [txId, voutStr] = this.vaultUtxo.split(\":\");\r\n        const vaultScript = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.vaultBtcAddress);\r\n        const out2script = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.btcDestinationAddress);\r\n        const opReturnData = this.wrapper.contract.toOpReturnData(this.recipient, [\r\n            this.outputTotalSwap / this.vaultTokenMultipliers[0],\r\n            this.outputTotalGas / this.vaultTokenMultipliers[1]\r\n        ]);\r\n        const out1script = buffer_1.Buffer.concat([\r\n            opReturnData.length > 75 ? buffer_1.Buffer.from([0x6a, 0x4c, opReturnData.length]) : buffer_1.Buffer.from([0x6a, opReturnData.length]),\r\n            opReturnData\r\n        ]);\r\n        if (this.callerFeeShare < 0n || this.callerFeeShare > 0xfffffn)\r\n            throw new Error(\"Caller fee out of bounds!\");\r\n        if (this.frontingFeeShare < 0n || this.frontingFeeShare > 0xfffffn)\r\n            throw new Error(\"Fronting fee out of bounds!\");\r\n        if (this.executionFeeShare < 0n || this.executionFeeShare > 0xfffffn)\r\n            throw new Error(\"Execution fee out of bounds!\");\r\n        const nSequence0 = 0x80000000n | (this.callerFeeShare & 0xfffffn) | (this.frontingFeeShare & 1047552n) << 10n;\r\n        const nSequence1 = 0x80000000n | (this.executionFeeShare & 0xfffffn) | (this.frontingFeeShare & 1023n) << 20n;\r\n        return {\r\n            in0txid: txId,\r\n            in0vout: parseInt(voutStr),\r\n            in0sequence: Number(nSequence0),\r\n            vaultAmount: this.vaultUtxoValue,\r\n            vaultScript,\r\n            in1sequence: Number(nSequence1),\r\n            out1script,\r\n            out2amount: this.btcAmount,\r\n            out2script,\r\n            locktime: 500000000 + Math.floor(Math.random() * 1000000000) //Use this as a random salt to make the btc txId unique!\r\n        };\r\n    }\r\n    async getPsbt() {\r\n        const res = await this.getTransactionDetails();\r\n        const psbt = new btc_signer_1.Transaction({\r\n            allowUnknownOutputs: true,\r\n            allowLegacyWitnessUtxo: true,\r\n            lockTime: res.locktime\r\n        });\r\n        psbt.addInput({\r\n            txid: res.in0txid,\r\n            index: res.in0vout,\r\n            witnessUtxo: {\r\n                amount: res.vaultAmount,\r\n                script: res.vaultScript\r\n            },\r\n            sequence: res.in0sequence\r\n        });\r\n        psbt.addOutput({\r\n            amount: res.vaultAmount,\r\n            script: res.vaultScript\r\n        });\r\n        psbt.addOutput({\r\n            amount: 0n,\r\n            script: res.out1script\r\n        });\r\n        psbt.addOutput({\r\n            amount: res.out2amount,\r\n            script: res.out2script\r\n        });\r\n        return {\r\n            psbt,\r\n            in1sequence: res.in1sequence\r\n        };\r\n    }\r\n    async getFundedPsbt(_bitcoinWallet, feeRate) {\r\n        let bitcoinWallet;\r\n        if ((0, IBitcoinWallet_1.isIBitcoinWallet)(_bitcoinWallet)) {\r\n            bitcoinWallet = _bitcoinWallet;\r\n        }\r\n        else {\r\n            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.wrapper.btcRpc, this.wrapper.options.bitcoinNetwork, _bitcoinWallet);\r\n        }\r\n        if (feeRate != null) {\r\n            if (feeRate < this.minimumBtcFeeRate)\r\n                throw new Error(\"Bitcoin tx fee needs to be at least \" + this.minimumBtcFeeRate + \" sats/vB\");\r\n        }\r\n        else {\r\n            feeRate = Math.max(this.minimumBtcFeeRate, await bitcoinWallet.getFeeRate());\r\n        }\r\n        let { psbt, in1sequence } = await this.getPsbt();\r\n        psbt = await bitcoinWallet.fundPsbt(psbt, feeRate);\r\n        psbt.updateInput(1, { sequence: in1sequence });\r\n        //Sign every input except the first one\r\n        const signInputs = [];\r\n        for (let i = 1; i < psbt.inputsLength; i++) {\r\n            signInputs.push(i);\r\n        }\r\n        return { psbt, signInputs };\r\n    }\r\n    async submitPsbt(psbt) {\r\n        //Ensure not expired\r\n        if (this.expiry < Date.now()) {\r\n            throw new Error(\"Quote expired!\");\r\n        }\r\n        //Ensure valid state\r\n        if (this.state !== SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED && this.state !== SpvFromBTCSwapState.CREATED) {\r\n            throw new Error(\"Invalid swap state!\");\r\n        }\r\n        //Ensure all inputs except the 1st are finalized\r\n        for (let i = 1; i < psbt.inputsLength; i++) {\r\n            if ((0, btc_signer_1.getInputType)(psbt.getInput(i)).txType === \"legacy\")\r\n                throw new Error(\"Legacy (non-segwit) inputs are not allowed in the transaction!\");\r\n            psbt.finalizeIdx(i);\r\n        }\r\n        const btcTx = await this.wrapper.btcRpc.parseTransaction(buffer_1.Buffer.from(psbt.toBytes(true)).toString(\"hex\"));\r\n        const data = await this.wrapper.contract.getWithdrawalData(btcTx);\r\n        this.logger.debug(\"submitPsbt(): parsed withdrawal data: \", data);\r\n        //Verify correct withdrawal data\r\n        if (!data.isRecipient(this.recipient) ||\r\n            data.rawAmounts[0] * this.vaultTokenMultipliers[0] !== this.outputTotalSwap ||\r\n            (data.rawAmounts[1] ?? 0n) * this.vaultTokenMultipliers[1] !== this.outputTotalGas ||\r\n            data.callerFeeRate !== this.callerFeeShare ||\r\n            data.frontingFeeRate !== this.frontingFeeShare ||\r\n            data.executionFeeRate !== this.executionFeeShare ||\r\n            data.getSpentVaultUtxo() !== this.vaultUtxo ||\r\n            BigInt(data.getNewVaultBtcAmount()) !== this.vaultUtxoValue ||\r\n            !data.getNewVaultScript().equals((0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.vaultBtcAddress)) ||\r\n            data.getExecutionData() != null) {\r\n            throw new Error(\"Invalid withdrawal tx data submitted!\");\r\n        }\r\n        //Verify correct LP output\r\n        const lpOutput = psbt.getOutput(2);\r\n        if (lpOutput.amount !== this.btcAmount ||\r\n            !(0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.btcDestinationAddress).equals(buffer_1.Buffer.from(lpOutput.script))) {\r\n            throw new Error(\"Invalid LP bitcoin output in transaction!\");\r\n        }\r\n        //Verify vault utxo not spent yet\r\n        if (await this.wrapper.btcRpc.isSpent(this.vaultUtxo)) {\r\n            throw new Error(\"Vault UTXO already spent, please create new swap!\");\r\n        }\r\n        //Verify tx is parsable by the contract\r\n        try {\r\n            await this.wrapper.contract.checkWithdrawalTx(data);\r\n        }\r\n        catch (e) {\r\n            throw new Error(\"Transaction not parsable by the contract: \" + (e.message ?? e.toString()));\r\n        }\r\n        //Ensure still not expired\r\n        if (this.expiry < Date.now()) {\r\n            throw new Error(\"Quote expired!\");\r\n        }\r\n        this.data = data;\r\n        this.initiated = true;\r\n        await this._saveAndEmit(SpvFromBTCSwapState.SIGNED);\r\n        try {\r\n            await IntermediaryAPI_1.IntermediaryAPI.initSpvFromBTC(this.chainIdentifier, this.url, {\r\n                quoteId: this.quoteId,\r\n                psbtHex: buffer_1.Buffer.from(psbt.toPSBT(0)).toString(\"hex\")\r\n            });\r\n            await this._saveAndEmit(SpvFromBTCSwapState.POSTED);\r\n        }\r\n        catch (e) {\r\n            await this._saveAndEmit(SpvFromBTCSwapState.DECLINED);\r\n            throw e;\r\n        }\r\n        return this.data.getTxId();\r\n    }\r\n    async estimateBitcoinFee(wallet, feeRate) {\r\n        const txFee = await wallet.getFundedPsbtFee((await this.getPsbt()).psbt, feeRate);\r\n        return (0, Tokens_1.toTokenAmount)(txFee == null ? null : BigInt(txFee), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);\r\n    }\r\n    async sendBitcoinTransaction(wallet, feeRate) {\r\n        let { psbt, signInputs } = await this.getFundedPsbt(wallet, feeRate);\r\n        psbt = await wallet.signPsbt(psbt, signInputs);\r\n        return await this.submitPsbt(psbt);\r\n    }\r\n    //////////////////////////////\r\n    //// Bitcoin tx listener\r\n    /**\r\n     * Checks whether a bitcoin payment was already made, returns the payment or null when no payment has been made.\r\n     */\r\n    async getBitcoinPayment() {\r\n        if (this.data?.btcTx?.txid == null)\r\n            return null;\r\n        const result = await this.wrapper.btcRpc.getTransaction(this.data?.btcTx?.txid);\r\n        if (result == null)\r\n            return null;\r\n        return {\r\n            txId: result.txid,\r\n            confirmations: result.confirmations,\r\n            targetConfirmations: this.vaultRequiredConfirmations\r\n        };\r\n    }\r\n    /**\r\n     * Waits till the bitcoin transaction confirms and swap becomes claimable\r\n     *\r\n     * @param abortSignal Abort signal\r\n     * @param checkIntervalSeconds How often to check the bitcoin transaction\r\n     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations\r\n     * @throws {Error} if in invalid state (must be CLAIM_COMMITED)\r\n     */\r\n    async waitForBitcoinTransaction(abortSignal, checkIntervalSeconds, updateCallback) {\r\n        if (this.state !== SpvFromBTCSwapState.POSTED &&\r\n            this.state !== SpvFromBTCSwapState.BROADCASTED &&\r\n            !(this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED && this.initiated))\r\n            throw new Error(\"Must be in POSTED or BROADCASTED state!\");\r\n        const result = await this.wrapper.btcRpc.waitForTransaction(this.data.btcTx.txid, this.vaultRequiredConfirmations, (confirmations, txId, txEtaMs) => {\r\n            if (updateCallback != null)\r\n                updateCallback(txId, confirmations, this.vaultRequiredConfirmations, txEtaMs);\r\n            if (txId != null &&\r\n                (this.state === SpvFromBTCSwapState.POSTED || this.state == SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED))\r\n                this._saveAndEmit(SpvFromBTCSwapState.BROADCASTED);\r\n        }, abortSignal, checkIntervalSeconds);\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        if (this.state !== SpvFromBTCSwapState.FRONTED &&\r\n            this.state !== SpvFromBTCSwapState.CLAIMED) {\r\n            await this._saveAndEmit(SpvFromBTCSwapState.BTC_TX_CONFIRMED);\r\n        }\r\n        return result.txid;\r\n    }\r\n    //////////////////////////////\r\n    //// Claim\r\n    /**\r\n     * Returns transactions required to claim the swap on-chain (and possibly also sync the bitcoin light client)\r\n     *  after a bitcoin transaction was sent and confirmed\r\n     *\r\n     * @throws {Error} If the swap is in invalid state (must be BTC_TX_CONFIRMED)\r\n     */\r\n    async txsClaim(signer) {\r\n        if (!this.isClaimable())\r\n            throw new Error(\"Must be in BTC_TX_CONFIRMED state!\");\r\n        const vaultData = await this.wrapper.contract.getVaultData(this.vaultOwner, this.vaultId);\r\n        const txs = [await this.wrapper.btcRpc.getTransaction(this.data.btcTx.txid)];\r\n        //Trace back from current tx to the vaultData-specified UTXO\r\n        const vaultUtxo = vaultData.getUtxo();\r\n        while (txs[0].ins[0].txid + \":\" + txs[0].ins[0].vout !== vaultUtxo) {\r\n            txs.unshift(await this.wrapper.btcRpc.getTransaction(txs[0].ins[0].txid));\r\n        }\r\n        //Parse transactions to withdrawal data\r\n        const withdrawalData = [];\r\n        for (let tx of txs) {\r\n            withdrawalData.push(await this.wrapper.contract.getWithdrawalData(tx));\r\n        }\r\n        return await this.wrapper.contract.txsClaim(signer == null ? this._getInitiator() : signer.getAddress(), vaultData, withdrawalData.map(tx => { return { tx }; }), this.wrapper.synchronizer, true);\r\n    }\r\n    /**\r\n     * Claims and finishes the swap\r\n     *\r\n     * @param signer Signer to sign the transactions with, can also be different to the initializer\r\n     * @param abortSignal Abort signal to stop waiting for transaction confirmation\r\n     */\r\n    async claim(signer, abortSignal) {\r\n        let txIds;\r\n        try {\r\n            txIds = await this.wrapper.chain.sendAndConfirm(signer, await this.txsClaim(signer), true, abortSignal);\r\n        }\r\n        catch (e) {\r\n            this.logger.info(\"claim(): Failed to claim ourselves, checking swap claim state...\");\r\n            if (this.state === SpvFromBTCSwapState.CLAIMED) {\r\n                this.logger.info(\"claim(): Transaction state is CLAIMED, swap was successfully claimed by the watchtower\");\r\n                return this.claimTxId;\r\n            }\r\n            const withdrawalState = await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);\r\n            if (withdrawalState.type === base_1.SpvWithdrawalStateType.CLAIMED) {\r\n                this.logger.info(\"claim(): Transaction status is CLAIMED, swap was successfully claimed by the watchtower\");\r\n                this.claimTxId = withdrawalState.txId;\r\n                await this._saveAndEmit(SpvFromBTCSwapState.CLAIMED);\r\n                return null;\r\n            }\r\n            throw e;\r\n        }\r\n        this.claimTxId = txIds[0];\r\n        if (this.state === SpvFromBTCSwapState.POSTED || this.state === SpvFromBTCSwapState.BROADCASTED ||\r\n            this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED || this.state === SpvFromBTCSwapState.FAILED ||\r\n            this.state === SpvFromBTCSwapState.FRONTED) {\r\n            await this._saveAndEmit(SpvFromBTCSwapState.CLAIMED);\r\n        }\r\n        return txIds[0];\r\n    }\r\n    /**\r\n     * Periodically checks the chain to see whether the swap was finished (claimed or refunded)\r\n     *\r\n     * @param abortSignal\r\n     * @param interval How often to check (in seconds), default to 5s\r\n     * @protected\r\n     */\r\n    async watchdogWaitTillResult(abortSignal, interval = 5) {\r\n        let status = { type: base_1.SpvWithdrawalStateType.NOT_FOUND };\r\n        while (status.type === base_1.SpvWithdrawalStateType.NOT_FOUND) {\r\n            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);\r\n            try {\r\n                status = await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);\r\n            }\r\n            catch (e) {\r\n                this.logger.error(\"watchdogWaitTillResult(): Error when fetching commit status: \", e);\r\n            }\r\n        }\r\n        if (abortSignal != null)\r\n            abortSignal.throwIfAborted();\r\n        return status;\r\n    }\r\n    /**\r\n     * Waits till the swap is successfully executed\r\n     *\r\n     * @param abortSignal AbortSignal\r\n     * @throws {Error} If swap is in invalid state (must be BTC_TX_CONFIRMED)\r\n     * @throws {Error} If the LP refunded sooner than we were able to claim\r\n     */\r\n    async waitTillClaimedOrFronted(abortSignal) {\r\n        if (this.state === SpvFromBTCSwapState.CLAIMED || this.state === SpvFromBTCSwapState.FRONTED)\r\n            return Promise.resolve();\r\n        const abortController = new AbortController();\r\n        if (abortSignal != null)\r\n            abortSignal.addEventListener(\"abort\", () => abortController.abort(abortSignal.reason));\r\n        const res = await Promise.race([\r\n            this.watchdogWaitTillResult(abortController.signal),\r\n            this.waitTillState(SpvFromBTCSwapState.CLAIMED, \"eq\", abortController.signal).then(() => 0),\r\n            this.waitTillState(SpvFromBTCSwapState.FRONTED, \"eq\", abortController.signal).then(() => 1),\r\n            this.waitTillState(SpvFromBTCSwapState.FAILED, \"eq\", abortController.signal).then(() => 2),\r\n        ]);\r\n        abortController.abort();\r\n        if (typeof (res) === \"number\") {\r\n            if (res === 0) {\r\n                this.logger.debug(\"waitTillClaimedOrFronted(): Resolved from state change (CLAIMED)\");\r\n                return;\r\n            }\r\n            if (res === 1) {\r\n                this.logger.debug(\"waitTillClaimedOrFronted(): Resolved from state change (FRONTED)\");\r\n                return;\r\n            }\r\n            if (res === 2) {\r\n                this.logger.debug(\"waitTillClaimedOrFronted(): Resolved from state change (FAILED)\");\r\n                throw new Error(\"Swap failed while waiting for claim or front\");\r\n            }\r\n            return;\r\n        }\r\n        this.logger.debug(\"waitTillClaimedOrFronted(): Resolved from watchdog\");\r\n        if (res.type === base_1.SpvWithdrawalStateType.FRONTED) {\r\n            if (this.state !== SpvFromBTCSwapState.FRONTED ||\r\n                this.state !== SpvFromBTCSwapState.CLAIMED) {\r\n                this.frontTxId = res.txId;\r\n                await this._saveAndEmit(SpvFromBTCSwapState.FRONTED);\r\n            }\r\n        }\r\n        if (res.type === base_1.SpvWithdrawalStateType.CLAIMED) {\r\n            if (this.state !== SpvFromBTCSwapState.CLAIMED) {\r\n                this.claimTxId = res.txId;\r\n                await this._saveAndEmit(SpvFromBTCSwapState.FRONTED);\r\n            }\r\n        }\r\n        if (res.type === base_1.SpvWithdrawalStateType.CLOSED) {\r\n            if (this.state !== SpvFromBTCSwapState.CLOSED)\r\n                await this._saveAndEmit(SpvFromBTCSwapState.CLOSED);\r\n        }\r\n    }\r\n    /**\r\n     * Waits till the bitcoin transaction confirms and swap is claimed\r\n     *\r\n     * @param abortSignal Abort signal\r\n     * @param checkIntervalSeconds How often to check the bitcoin transaction\r\n     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations\r\n     * @throws {Error} if in invalid state (must be CLAIM_COMMITED)\r\n     */\r\n    async waitTillExecuted(abortSignal, checkIntervalSeconds, updateCallback) {\r\n        await this.waitForBitcoinTransaction(abortSignal, checkIntervalSeconds, updateCallback);\r\n        await this.waitTillClaimedOrFronted(abortSignal);\r\n    }\r\n    //////////////////////////////\r\n    //// Storage\r\n    serialize() {\r\n        return {\r\n            ...super.serialize(),\r\n            quoteId: this.quoteId,\r\n            recipient: this.recipient,\r\n            vaultOwner: this.vaultOwner,\r\n            vaultId: this.vaultId.toString(10),\r\n            vaultRequiredConfirmations: this.vaultRequiredConfirmations,\r\n            vaultTokenMultipliers: this.vaultTokenMultipliers.map(val => val.toString(10)),\r\n            vaultBtcAddress: this.vaultBtcAddress,\r\n            vaultUtxo: this.vaultUtxo,\r\n            vaultUtxoValue: this.vaultUtxoValue.toString(10),\r\n            btcDestinationAddress: this.btcDestinationAddress,\r\n            btcAmount: this.btcAmount.toString(10),\r\n            btcAmountSwap: this.btcAmountSwap.toString(10),\r\n            btcAmountGas: this.btcAmountGas.toString(10),\r\n            minimumBtcFeeRate: this.minimumBtcFeeRate,\r\n            outputTotalSwap: this.outputTotalSwap.toString(10),\r\n            outputSwapToken: this.outputSwapToken,\r\n            outputTotalGas: this.outputTotalGas.toString(10),\r\n            outputGasToken: this.outputGasToken,\r\n            gasSwapFeeBtc: this.gasSwapFeeBtc.toString(10),\r\n            gasSwapFee: this.gasSwapFee.toString(10),\r\n            callerFeeShare: this.callerFeeShare.toString(10),\r\n            frontingFeeShare: this.frontingFeeShare.toString(10),\r\n            executionFeeShare: this.executionFeeShare.toString(10),\r\n            claimTxId: this.claimTxId,\r\n            frontTxId: this.frontTxId,\r\n            data: this.data?.serialize()\r\n        };\r\n    }\r\n    //////////////////////////////\r\n    //// Swap ticks & sync\r\n    async syncStateFromBitcoin(save) {\r\n        if (this.data?.btcTx == null)\r\n            return false;\r\n        //Check if bitcoin payment was confirmed\r\n        const res = await this.getBitcoinPayment();\r\n        if (res == null) {\r\n            //Check inputs double-spent\r\n            for (let input of this.data.btcTx.ins) {\r\n                if (await this.wrapper.btcRpc.isSpent(input.txid + \":\" + input.vout, true)) {\r\n                    if (this.state === SpvFromBTCSwapState.SIGNED ||\r\n                        this.state === SpvFromBTCSwapState.POSTED ||\r\n                        this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED ||\r\n                        this.state === SpvFromBTCSwapState.DECLINED) {\r\n                        //One of the inputs was double-spent\r\n                        this.state = SpvFromBTCSwapState.QUOTE_EXPIRED;\r\n                    }\r\n                    else {\r\n                        //One of the inputs was double-spent\r\n                        this.state = SpvFromBTCSwapState.FAILED;\r\n                    }\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (res.confirmations >= this.vaultRequiredConfirmations) {\r\n                if (this.state !== SpvFromBTCSwapState.FRONTED &&\r\n                    this.state !== SpvFromBTCSwapState.CLAIMED) {\r\n                    this.state = SpvFromBTCSwapState.BTC_TX_CONFIRMED;\r\n                    if (save)\r\n                        await this._saveAndEmit();\r\n                    return true;\r\n                }\r\n            }\r\n            else if (this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED ||\r\n                this.state === SpvFromBTCSwapState.POSTED ||\r\n                this.state === SpvFromBTCSwapState.SIGNED ||\r\n                this.state === SpvFromBTCSwapState.DECLINED) {\r\n                this.state = SpvFromBTCSwapState.BROADCASTED;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain\r\n     *  data\r\n     *\r\n     * @private\r\n     */\r\n    async syncStateFromChain() {\r\n        let changed = false;\r\n        if (this.state === SpvFromBTCSwapState.SIGNED ||\r\n            this.state === SpvFromBTCSwapState.POSTED ||\r\n            this.state === SpvFromBTCSwapState.BROADCASTED ||\r\n            this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED ||\r\n            this.state === SpvFromBTCSwapState.DECLINED) {\r\n            //Check BTC transaction\r\n            if (await this.syncStateFromBitcoin(false))\r\n                changed ||= true;\r\n        }\r\n        if (this.state === SpvFromBTCSwapState.BROADCASTED || this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED) {\r\n            const status = await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);\r\n            this.logger.debug(\"syncStateFromChain(): status of \" + this.data.btcTx.txid, status);\r\n            switch (status.type) {\r\n                case base_1.SpvWithdrawalStateType.FRONTED:\r\n                    this.frontTxId = status.txId;\r\n                    this.state = SpvFromBTCSwapState.FRONTED;\r\n                    changed ||= true;\r\n                    break;\r\n                case base_1.SpvWithdrawalStateType.CLAIMED:\r\n                    this.claimTxId = status.txId;\r\n                    this.state = SpvFromBTCSwapState.CLAIMED;\r\n                    changed ||= true;\r\n                    break;\r\n                case base_1.SpvWithdrawalStateType.CLOSED:\r\n                    this.state = SpvFromBTCSwapState.CLOSED;\r\n                    changed ||= true;\r\n                    break;\r\n            }\r\n        }\r\n        if (this.state === SpvFromBTCSwapState.CREATED ||\r\n            this.state === SpvFromBTCSwapState.SIGNED ||\r\n            this.state === SpvFromBTCSwapState.POSTED) {\r\n            if (this.expiry < Date.now()) {\r\n                if (this.state === SpvFromBTCSwapState.CREATED) {\r\n                    this.state = SpvFromBTCSwapState.QUOTE_EXPIRED;\r\n                }\r\n                else {\r\n                    this.state = SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED;\r\n                }\r\n                changed ||= true;\r\n            }\r\n        }\r\n        return changed;\r\n    }\r\n    async _sync(save) {\r\n        const changed = await this.syncStateFromChain();\r\n        if (changed && save)\r\n            await this._saveAndEmit();\r\n        return changed;\r\n    }\r\n    async _tick(save) {\r\n        if (this.state === SpvFromBTCSwapState.CREATED ||\r\n            this.state === SpvFromBTCSwapState.SIGNED) {\r\n            if (this.getQuoteExpiry() < Date.now()) {\r\n                this.state = SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            }\r\n        }\r\n        if (this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED && !this.initiated) {\r\n            if (this.expiry < Date.now()) {\r\n                this.state = SpvFromBTCSwapState.QUOTE_EXPIRED;\r\n                if (save)\r\n                    await this._saveAndEmit();\r\n                return true;\r\n            }\r\n        }\r\n        if (Math.floor(Date.now() / 1000) % 120 === 0) {\r\n            if (this.state === SpvFromBTCSwapState.POSTED ||\r\n                this.state === SpvFromBTCSwapState.BROADCASTED) {\r\n                try {\r\n                    //Check if bitcoin payment was confirmed\r\n                    return await this.syncStateFromBitcoin(save);\r\n                }\r\n                catch (e) {\r\n                    this.logger.error(\"tickSwap(\" + this.getId() + \"): \", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.SpvFromBTCSwap = SpvFromBTCSwap;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11078, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCWrapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SpvFromBTCWrapper = void 0;\r\nconst ISwapWrapper_1 = require(\"../ISwapWrapper\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst SpvFromBTCSwap_1 = require(\"./SpvFromBTCSwap\");\r\nconst utils_1 = require(\"@scure/btc-signer/utils\");\r\nconst SwapType_1 = require(\"../enums/SwapType\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst IntermediaryAPI_1 = require(\"../../intermediaries/IntermediaryAPI\");\r\nconst RequestError_1 = require(\"../../errors/RequestError\");\r\nconst IntermediaryError_1 = require(\"../../errors/IntermediaryError\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nclass SpvFromBTCWrapper extends ISwapWrapper_1.ISwapWrapper {\r\n    /**\r\n     * @param chainIdentifier\r\n     * @param unifiedStorage Storage interface for the current environment\r\n     * @param unifiedChainEvents On-chain event listener\r\n     * @param chain\r\n     * @param contract Underlying contract handling the swaps\r\n     * @param prices Pricing to use\r\n     * @param tokens\r\n     * @param spvWithdrawalDataDeserializer Deserializer for SpvVaultWithdrawalData\r\n     * @param btcRelay\r\n     * @param synchronizer Btc relay synchronizer\r\n     * @param btcRpc Bitcoin RPC which also supports getting transactions by txoHash\r\n     * @param options\r\n     * @param events Instance to use for emitting events\r\n     */\r\n    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, spvWithdrawalDataDeserializer, btcRelay, synchronizer, btcRpc, options, events) {\r\n        if (options == null)\r\n            options = {};\r\n        options.bitcoinNetwork ??= utils_1.TEST_NETWORK;\r\n        options.maxConfirmations ??= 6;\r\n        options.bitcoinBlocktime ??= 10 * 60;\r\n        options.maxTransactionsDelta ??= 3;\r\n        options.maxRawAmountAdjustmentDifferencePPM ??= 100;\r\n        options.maxBtcFeeOffset ??= 5;\r\n        options.maxBtcFeeMultiplier ??= 1.5;\r\n        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events);\r\n        this.TYPE = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;\r\n        this.swapDeserializer = SpvFromBTCSwap_1.SpvFromBTCSwap;\r\n        this.pendingSwapStates = [\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.CREATED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED\r\n        ];\r\n        this.tickSwapState = [\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.CREATED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED,\r\n            SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED\r\n        ];\r\n        this.spvWithdrawalDataDeserializer = spvWithdrawalDataDeserializer;\r\n        this.contract = contract;\r\n        this.btcRelay = btcRelay;\r\n        this.synchronizer = synchronizer;\r\n        this.btcRpc = btcRpc;\r\n    }\r\n    processEventFront(event, swap) {\r\n        if (swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED ||\r\n            swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED ||\r\n            swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED) {\r\n            swap.state = SpvFromBTCSwap_1.SpvFromBTCSwapState.FRONTED;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    processEventClaim(event, swap) {\r\n        if (swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED ||\r\n            swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED ||\r\n            swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED) {\r\n            swap.state = SpvFromBTCSwap_1.SpvFromBTCSwapState.CLAIMED;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    processEventClose(event, swap) {\r\n        if (swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED ||\r\n            swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED ||\r\n            swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED) {\r\n            swap.state = SpvFromBTCSwap_1.SpvFromBTCSwapState.CLOSED;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    async processEvent(event, swap) {\r\n        if (swap == null)\r\n            return;\r\n        let swapChanged = false;\r\n        if (event instanceof base_1.SpvVaultFrontEvent) {\r\n            swapChanged = this.processEventFront(event, swap);\r\n            if (event.meta?.txId != null && swap.frontTxId !== event.meta.txId) {\r\n                swap.frontTxId = event.meta.txId;\r\n                swapChanged ||= true;\r\n            }\r\n        }\r\n        if (event instanceof base_1.SpvVaultClaimEvent) {\r\n            swapChanged = this.processEventClaim(event, swap);\r\n            if (event.meta?.txId != null && swap.claimTxId !== event.meta.txId) {\r\n                swap.claimTxId = event.meta.txId;\r\n                swapChanged ||= true;\r\n            }\r\n        }\r\n        if (event instanceof base_1.SpvVaultCloseEvent) {\r\n            swapChanged = this.processEventClose(event, swap);\r\n        }\r\n        this.logger.info(\"processEvents(): \" + event.constructor.name + \" processed for \" + swap.getId() + \" swap: \", swap);\r\n        if (swapChanged) {\r\n            await swap._saveAndEmit();\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Pre-fetches caller (watchtower) bounty data for the swap. Doesn't throw, instead returns null and aborts the\r\n     *  provided abortController\r\n     *\r\n     * @param signer Smartchain signer address initiating the swap\r\n     * @param amountData\r\n     * @param options Options as passed to the swap creation function\r\n     * @param pricePrefetch\r\n     * @param nativeTokenPricePrefetch\r\n     * @param abortController\r\n     * @private\r\n     */\r\n    async preFetchCallerFeeShare(signer, amountData, options, pricePrefetch, nativeTokenPricePrefetch, abortController) {\r\n        if (options.unsafeZeroWatchtowerFee)\r\n            return 0n;\r\n        if (amountData.amount === 0n)\r\n            return 0n;\r\n        try {\r\n            const [feePerBlock, btcRelayData, currentBtcBlock, claimFeeRate, nativeTokenPrice] = await Promise.all([\r\n                (0, Utils_1.tryWithRetries)(() => this.btcRelay.getFeePerBlock(), null, null, abortController.signal),\r\n                (0, Utils_1.tryWithRetries)(() => this.btcRelay.getTipData(), null, null, abortController.signal),\r\n                this.btcRpc.getTipHeight(),\r\n                (0, Utils_1.tryWithRetries)(() => this.contract.getClaimFee(this.chain.randomAddress(), null, null), null, null, abortController.signal),\r\n                nativeTokenPricePrefetch ?? (amountData.token === this.chain.getNativeCurrencyAddress() ?\r\n                    pricePrefetch :\r\n                    this.prices.preFetchPrice(this.chainIdentifier, this.chain.getNativeCurrencyAddress(), abortController.signal))\r\n            ]);\r\n            const currentBtcRelayBlock = btcRelayData.blockheight;\r\n            const blockDelta = Math.max(currentBtcBlock - currentBtcRelayBlock + this.options.maxConfirmations, 0);\r\n            const totalFeeInNativeToken = ((BigInt(blockDelta) * feePerBlock) +\r\n                (claimFeeRate * BigInt(this.options.maxTransactionsDelta))) * BigInt(Math.floor(options.feeSafetyFactor * 1000000)) / 1000000n;\r\n            let payoutAmount;\r\n            if (amountData.exactIn) {\r\n                //Convert input amount in BTC to\r\n                const amountInNativeToken = await this.prices.getFromBtcSwapAmount(this.chainIdentifier, amountData.amount, this.chain.getNativeCurrencyAddress(), abortController.signal, nativeTokenPrice);\r\n                payoutAmount = amountInNativeToken - totalFeeInNativeToken;\r\n            }\r\n            else {\r\n                if (amountData.token === this.chain.getNativeCurrencyAddress()) {\r\n                    //Both amounts in same currency\r\n                    payoutAmount = amountData.amount;\r\n                }\r\n                else {\r\n                    //Need to convert both to native currency\r\n                    const btcAmount = await this.prices.getToBtcSwapAmount(this.chainIdentifier, amountData.amount, amountData.token, abortController.signal, await pricePrefetch);\r\n                    payoutAmount = await this.prices.getFromBtcSwapAmount(this.chainIdentifier, btcAmount, this.chain.getNativeCurrencyAddress(), abortController.signal, nativeTokenPrice);\r\n                }\r\n            }\r\n            this.logger.debug(\"preFetchCallerFeeShare(): Caller fee in native token: \" + totalFeeInNativeToken.toString(10) + \" total payout in native token: \" + payoutAmount.toString(10));\r\n            const callerFeeShare = ((totalFeeInNativeToken * 100000n) + payoutAmount - 1n) / payoutAmount; //Make sure to round up here\r\n            if (callerFeeShare < 0n)\r\n                return 0n;\r\n            if (callerFeeShare >= 2n ** 20n)\r\n                return 2n ** 20n - 1n;\r\n            return callerFeeShare;\r\n        }\r\n        catch (e) {\r\n            abortController.abort(e);\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Verifies response returned from intermediary\r\n     *\r\n     * @param resp Response as returned by the intermediary\r\n     * @param amountData\r\n     * @param lp Intermediary\r\n     * @param options Options as passed to the swap creation function\r\n     * @param callerFeeShare\r\n     * @param bitcoinFeeRatePromise Maximum accepted fee rate from the LPs\r\n     * @private\r\n     * @throws {IntermediaryError} in case the response is invalid\r\n     */\r\n    async verifyReturnedData(resp, amountData, lp, options, callerFeeShare, bitcoinFeeRatePromise) {\r\n        if (resp.btcFeeRate > await bitcoinFeeRatePromise)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Bitcoin fee rate returned too high!\");\r\n        //Vault related\r\n        let vaultScript;\r\n        let vaultAddressType;\r\n        let btcAddressScript;\r\n        //Ensure valid btc addresses returned\r\n        try {\r\n            vaultScript = (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, resp.vaultBtcAddress);\r\n            vaultAddressType = (0, Utils_1.toCoinselectAddressType)(vaultScript);\r\n            btcAddressScript = (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, resp.btcAddress);\r\n        }\r\n        catch (e) {\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid btc address data returned!\");\r\n        }\r\n        const decodedUtxo = resp.btcUtxo.split(\":\");\r\n        if (resp.address !== lp.getAddress(this.chainIdentifier) || //Ensure the LP is indeed the vault owner\r\n            resp.vaultId < 0n || //Ensure vaultId is not negative\r\n            vaultScript == null || //Make sure vault script is parsable and of known type\r\n            btcAddressScript == null || //Make sure btc address script is parsable and of known type\r\n            vaultAddressType === \"p2pkh\" || vaultAddressType === \"p2sh-p2wpkh\" || //Constrain the vault script type to witness types\r\n            decodedUtxo.length !== 2 || decodedUtxo[0].length !== 64 || isNaN(parseInt(decodedUtxo[1])) || //Check valid UTXO\r\n            resp.btcFeeRate < 1 || resp.btcFeeRate > 10000 //Sanity check on the returned BTC fee rate\r\n        )\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid vault data returned!\");\r\n        //Amounts sanity\r\n        if (resp.btcAmountSwap + resp.btcAmountGas !== resp.btcAmount)\r\n            throw new Error(\"Btc amount mismatch\");\r\n        if (resp.swapFeeBtc + resp.gasSwapFeeBtc !== resp.totalFeeBtc)\r\n            throw new Error(\"Btc fee mismatch\");\r\n        //TODO: For now ensure fees are at 0\r\n        if (resp.callerFeeShare !== callerFeeShare ||\r\n            resp.frontingFeeShare !== 0n ||\r\n            resp.executionFeeShare !== 0n)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid caller/fronting/execution fee returned\");\r\n        //Check expiry\r\n        if (resp.expiry < Math.floor(Date.now() / 1000))\r\n            throw new IntermediaryError_1.IntermediaryError(\"Quote already expired\");\r\n        //Fetch vault data\r\n        let vault;\r\n        try {\r\n            vault = await this.contract.getVaultData(resp.address, resp.vaultId);\r\n        }\r\n        catch (e) {\r\n            this.logger.error(\"Error getting spv vault (owner: \" + resp.address + \" vaultId: \" + resp.vaultId.toString(10) + \"): \", e);\r\n            throw new IntermediaryError_1.IntermediaryError(\"Spv swap vault not found!\");\r\n        }\r\n        //Make sure vault is opened\r\n        if (!vault.isOpened())\r\n            throw new IntermediaryError_1.IntermediaryError(\"Returned spv swap vault is not opened!\");\r\n        //Make sure the vault doesn't require insane amount of confirmations\r\n        if (vault.getConfirmations() > this.options.maxConfirmations)\r\n            throw new IntermediaryError_1.IntermediaryError(\"SPV swap vault needs too many confirmations: \" + vault.getConfirmations());\r\n        const tokenData = vault.getTokenData();\r\n        //Amounts - make sure the amounts match\r\n        if (amountData.exactIn) {\r\n            if (resp.btcAmount !== amountData.amount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid amount returned\");\r\n        }\r\n        else {\r\n            //Check the difference between amount adjusted due to scaling to raw amount\r\n            const adjustedAmount = amountData.amount / tokenData[0].multiplier * tokenData[0].multiplier;\r\n            const adjustmentPPM = (amountData.amount - adjustedAmount) * 1000000n / amountData.amount;\r\n            if (adjustmentPPM > this.options.maxRawAmountAdjustmentDifferencePPM)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid amount0 multiplier used, rawAmount diff too high\");\r\n            if (resp.total !== adjustedAmount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid total returned\");\r\n        }\r\n        if (options.gasAmount == null || options.gasAmount === 0n) {\r\n            if (resp.totalGas !== 0n)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid gas total returned\");\r\n        }\r\n        else {\r\n            //Check the difference between amount adjusted due to scaling to raw amount\r\n            const adjustedGasAmount = options.gasAmount / tokenData[0].multiplier * tokenData[0].multiplier;\r\n            const adjustmentPPM = (options.gasAmount - adjustedGasAmount) * 1000000n / options.gasAmount;\r\n            if (adjustmentPPM > this.options.maxRawAmountAdjustmentDifferencePPM)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid amount1 multiplier used, rawAmount diff too high\");\r\n            if (resp.totalGas !== adjustedGasAmount)\r\n                throw new IntermediaryError_1.IntermediaryError(\"Invalid gas total returned\");\r\n        }\r\n        //Require the vault UTXO to have at least 1 confirmation\r\n        let utxo = resp.btcUtxo.toLowerCase();\r\n        const [txId, voutStr] = utxo.split(\":\");\r\n        let btcTx = await this.btcRpc.getTransaction(txId);\r\n        if (btcTx.confirmations == null || btcTx.confirmations < 1)\r\n            throw new IntermediaryError_1.IntermediaryError(\"SPV vault UTXO not confirmed\");\r\n        const vout = parseInt(voutStr);\r\n        if (btcTx.outs[vout] == null)\r\n            throw new IntermediaryError_1.IntermediaryError(\"Invalid UTXO, doesn't exist\");\r\n        const vaultUtxoValue = btcTx.outs[vout].value;\r\n        //Require vault UTXO is unspent\r\n        if (await this.btcRpc.isSpent(utxo))\r\n            throw new IntermediaryError_1.IntermediaryError(\"Returned spv vault UTXO is already spent\");\r\n        this.logger.debug(\"verifyReturnedData(): Vault UTXO: \" + vault.getUtxo() + \" current utxo: \" + utxo);\r\n        //Trace returned utxo back to what's saved on-chain\r\n        let pendingWithdrawals = [];\r\n        while (vault.getUtxo() !== utxo) {\r\n            const [txId, voutStr] = utxo.split(\":\");\r\n            //Such that 1st tx isn't fetched twice\r\n            if (btcTx.txid !== txId)\r\n                btcTx = await this.btcRpc.getTransaction(txId);\r\n            const withdrawalData = await this.contract.getWithdrawalData(btcTx);\r\n            pendingWithdrawals.unshift(withdrawalData);\r\n            utxo = pendingWithdrawals[0].getSpentVaultUtxo();\r\n            this.logger.debug(\"verifyReturnedData(): Vault UTXO: \" + vault.getUtxo() + \" current utxo: \" + utxo);\r\n            if (pendingWithdrawals.length >= this.options.maxTransactionsDelta)\r\n                throw new IntermediaryError_1.IntermediaryError(\"BTC <> SC state difference too deep, maximum: \" + this.options.maxTransactionsDelta);\r\n        }\r\n        //Verify that the vault has enough balance after processing all pending withdrawals\r\n        let vaultBalances;\r\n        try {\r\n            vaultBalances = vault.calculateStateAfter(pendingWithdrawals);\r\n        }\r\n        catch (e) {\r\n            this.logger.error(\"Error calculating spv vault balance (owner: \" + resp.address + \" vaultId: \" + resp.vaultId.toString(10) + \"): \", e);\r\n            throw new IntermediaryError_1.IntermediaryError(\"Spv swap vault balance prediction failed!\");\r\n        }\r\n        if (vaultBalances.balances[0].scaledAmount < resp.total)\r\n            throw new IntermediaryError_1.IntermediaryError(\"SPV swap vault, insufficient balance, required: \" + resp.total.toString(10) +\r\n                \" has: \" + vaultBalances.balances[0].scaledAmount.toString(10));\r\n        if (vaultBalances.balances[1].scaledAmount < resp.totalGas)\r\n            throw new IntermediaryError_1.IntermediaryError(\"SPV swap vault, insufficient balance, required: \" + resp.totalGas.toString(10) +\r\n                \" has: \" + vaultBalances.balances[1].scaledAmount.toString(10));\r\n        //Also verify that all the withdrawal txns are valid, this is an extra sanity check\r\n        try {\r\n            for (let withdrawal of pendingWithdrawals) {\r\n                await this.contract.checkWithdrawalTx(withdrawal);\r\n            }\r\n        }\r\n        catch (e) {\r\n            this.logger.error(\"Error calculating spv vault balance (owner: \" + resp.address + \" vaultId: \" + resp.vaultId.toString(10) + \"): \", e);\r\n            throw new IntermediaryError_1.IntermediaryError(\"Spv swap vault balance prediction failed!\");\r\n        }\r\n        return {\r\n            vault,\r\n            vaultUtxoValue\r\n        };\r\n    }\r\n    /**\r\n     * Returns a newly created swap, receiving 'amount' on chain\r\n     *\r\n     * @param signer                Smartchain signer's address intiating the swap\r\n     * @param amountData            Amount of token & amount to swap\r\n     * @param lps                   LPs (liquidity providers) to get the quotes from\r\n     * @param options               Quote options\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param abortSignal           Abort signal for aborting the process\r\n     */\r\n    create(signer, amountData, lps, options, additionalParams, abortSignal) {\r\n        options ??= {};\r\n        options.gasAmount ??= 0n;\r\n        options.feeSafetyFactor ??= 1.25;\r\n        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);\r\n        const pricePrefetchPromise = this.preFetchPrice(amountData, _abortController.signal);\r\n        const nativeTokenAddress = this.chain.getNativeCurrencyAddress();\r\n        const gasTokenPricePrefetchPromise = options.gasAmount === 0n ?\r\n            null :\r\n            this.preFetchPrice({ token: nativeTokenAddress }, _abortController.signal);\r\n        const callerFeePrefetchPromise = this.preFetchCallerFeeShare(signer, amountData, options, pricePrefetchPromise, gasTokenPricePrefetchPromise, _abortController);\r\n        const bitcoinFeeRatePromise = options.maxAllowedNetworkFeeRate != null ?\r\n            Promise.resolve(options.maxAllowedNetworkFeeRate) :\r\n            this.btcRpc.getFeeRate().then(x => this.options.maxBtcFeeOffset + (x * this.options.maxBtcFeeMultiplier)).catch(e => {\r\n                _abortController.abort(e);\r\n                return null;\r\n            });\r\n        return lps.map(lp => {\r\n            return {\r\n                intermediary: lp,\r\n                quote: (async () => {\r\n                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);\r\n                    try {\r\n                        const resp = await (0, Utils_1.tryWithRetries)(async (retryCount) => {\r\n                            return await IntermediaryAPI_1.IntermediaryAPI.prepareSpvFromBTC(this.chainIdentifier, lp.url, {\r\n                                address: signer,\r\n                                amount: amountData.amount,\r\n                                token: amountData.token.toString(),\r\n                                exactOut: !amountData.exactIn,\r\n                                gasToken: nativeTokenAddress,\r\n                                gasAmount: options.gasAmount,\r\n                                callerFeeRate: callerFeePrefetchPromise,\r\n                                frontingFeeRate: 0n,\r\n                                additionalParams\r\n                            }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);\r\n                        }, null, e => e instanceof RequestError_1.RequestError, abortController.signal);\r\n                        this.logger.debug(\"create(\" + lp.url + \"): LP response: \", resp);\r\n                        const callerFeeShare = await callerFeePrefetchPromise;\r\n                        const [pricingInfo, gasPricingInfo, { vault, vaultUtxoValue }] = await Promise.all([\r\n                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.SPV_VAULT_FROM_BTC], false, resp.btcAmountSwap, resp.total * (100000n + callerFeeShare) / 100000n, amountData.token, {}, pricePrefetchPromise, abortController.signal),\r\n                            options.gasAmount === 0n ? Promise.resolve() : this.verifyReturnedPrice({ ...lp.services[SwapType_1.SwapType.SPV_VAULT_FROM_BTC], swapBaseFee: 0 }, //Base fee should be charged only on the amount, not on gas\r\n                            false, resp.btcAmountGas, resp.totalGas * (100000n + callerFeeShare) / 100000n, nativeTokenAddress, {}, gasTokenPricePrefetchPromise, abortController.signal),\r\n                            this.verifyReturnedData(resp, amountData, lp, options, callerFeeShare, bitcoinFeeRatePromise)\r\n                        ]);\r\n                        const swapInit = {\r\n                            pricingInfo,\r\n                            url: lp.url,\r\n                            expiry: resp.expiry * 1000,\r\n                            swapFee: resp.swapFee,\r\n                            swapFeeBtc: resp.swapFeeBtc,\r\n                            exactIn: amountData.exactIn ?? true,\r\n                            quoteId: resp.quoteId,\r\n                            recipient: signer,\r\n                            vaultOwner: resp.address,\r\n                            vaultId: resp.vaultId,\r\n                            vaultRequiredConfirmations: vault.getConfirmations(),\r\n                            vaultTokenMultipliers: vault.getTokenData().map(val => val.multiplier),\r\n                            vaultBtcAddress: resp.vaultBtcAddress,\r\n                            vaultUtxo: resp.btcUtxo,\r\n                            vaultUtxoValue: BigInt(vaultUtxoValue),\r\n                            btcDestinationAddress: resp.btcAddress,\r\n                            btcAmount: resp.btcAmount,\r\n                            btcAmountSwap: resp.btcAmountSwap,\r\n                            btcAmountGas: resp.btcAmountGas,\r\n                            minimumBtcFeeRate: resp.btcFeeRate,\r\n                            outputTotalSwap: resp.total,\r\n                            outputSwapToken: amountData.token,\r\n                            outputTotalGas: resp.totalGas,\r\n                            outputGasToken: nativeTokenAddress,\r\n                            gasSwapFeeBtc: resp.gasSwapFeeBtc,\r\n                            gasSwapFee: resp.gasSwapFee,\r\n                            callerFeeShare: resp.callerFeeShare,\r\n                            frontingFeeShare: resp.frontingFeeShare,\r\n                            executionFeeShare: resp.executionFeeShare\r\n                        };\r\n                        const quote = new SpvFromBTCSwap_1.SpvFromBTCSwap(this, swapInit);\r\n                        await quote._save();\r\n                        return quote;\r\n                    }\r\n                    catch (e) {\r\n                        abortController.abort(e);\r\n                        throw e;\r\n                    }\r\n                })()\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Returns a random dummy PSBT that can be used for fee estimation, the last output (the LP output) is omitted\r\n     *  to allow for coinselection algorithm to determine maximum sendable amount there\r\n     *\r\n     * @param includeGasToken   Whether to return the PSBT also with the gas token amount (increases the vSize by 8)\r\n     */\r\n    getDummySwapPsbt(includeGasToken = false) {\r\n        //Construct dummy swap psbt\r\n        const psbt = new btc_signer_1.Transaction({\r\n            allowUnknownInputs: true,\r\n            allowLegacyWitnessUtxo: true,\r\n            allowUnknownOutputs: true\r\n        });\r\n        const randomVaultOutScript = btc_signer_1.OutScript.encode({ type: \"tr\", pubkey: Buffer.from(\"0101010101010101010101010101010101010101010101010101010101010101\", \"hex\") });\r\n        psbt.addInput({\r\n            txid: (0, Utils_1.randomBytes)(32),\r\n            index: 0,\r\n            witnessUtxo: {\r\n                script: randomVaultOutScript,\r\n                amount: 600n\r\n            }\r\n        });\r\n        psbt.addOutput({\r\n            script: randomVaultOutScript,\r\n            amount: 600n\r\n        });\r\n        const opReturnData = this.contract.toOpReturnData(this.chain.randomAddress(), includeGasToken ? [0xffffffffffffffffn, 0xffffffffffffffffn] : [0xffffffffffffffffn]);\r\n        psbt.addOutput({\r\n            script: Buffer.concat([\r\n                opReturnData.length <= 75 ? Buffer.from([0x6a, opReturnData.length]) : Buffer.from([0x6a, 0x4c, opReturnData.length]),\r\n                opReturnData\r\n            ]),\r\n            amount: 0n\r\n        });\r\n        return psbt;\r\n    }\r\n}\r\nexports.SpvFromBTCWrapper = SpvFromBTCWrapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11526, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/swapper/utils/SwapperUtils.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SwapperUtils = void 0;\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst btc_signer_1 = require(\"@scure/btc-signer\");\r\nconst LNURL_1 = require(\"../../../utils/LNURL\");\r\nconst SwapType_1 = require(\"../../enums/SwapType\");\r\nconst Tokens_1 = require(\"../../../Tokens\");\r\nconst SingleAddressBitcoinWallet_1 = require(\"../../../btc/wallet/SingleAddressBitcoinWallet\");\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst Utils_1 = require(\"../../../utils/Utils\");\r\nclass SwapperUtils {\r\n    constructor(root) {\r\n        this.bitcoinNetwork = root.bitcoinNetwork;\r\n        this.root = root;\r\n    }\r\n    /**\r\n     * Returns true if string is a valid BOLT11 bitcoin lightning invoice\r\n     *\r\n     * @param lnpr\r\n     */\r\n    isLightningInvoice(lnpr) {\r\n        try {\r\n            (0, bolt11_1.decode)(lnpr);\r\n            return true;\r\n        }\r\n        catch (e) { }\r\n        return false;\r\n    }\r\n    /**\r\n     * Returns true if string is a valid bitcoin address\r\n     *\r\n     * @param addr\r\n     */\r\n    isValidBitcoinAddress(addr) {\r\n        try {\r\n            (0, btc_signer_1.Address)(this.bitcoinNetwork).decode(addr);\r\n            return true;\r\n        }\r\n        catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Returns true if string is a valid BOLT11 bitcoin lightning invoice WITH AMOUNT\r\n     *\r\n     * @param lnpr\r\n     */\r\n    isValidLightningInvoice(lnpr) {\r\n        try {\r\n            const parsed = (0, bolt11_1.decode)(lnpr);\r\n            if (parsed.millisatoshis != null)\r\n                return true;\r\n        }\r\n        catch (e) { }\r\n        return false;\r\n    }\r\n    /**\r\n     * Returns true if string is a valid LNURL (no checking on type is performed)\r\n     *\r\n     * @param lnurl\r\n     */\r\n    isValidLNURL(lnurl) {\r\n        return LNURL_1.LNURL.isLNURL(lnurl);\r\n    }\r\n    /**\r\n     * Returns type and data about an LNURL\r\n     *\r\n     * @param lnurl\r\n     * @param shouldRetry\r\n     */\r\n    getLNURLTypeAndData(lnurl, shouldRetry) {\r\n        return LNURL_1.LNURL.getLNURLType(lnurl, shouldRetry);\r\n    }\r\n    /**\r\n     * Returns satoshi value of BOLT11 bitcoin lightning invoice WITH AMOUNT\r\n     *\r\n     * @param lnpr\r\n     */\r\n    getLightningInvoiceValue(lnpr) {\r\n        const parsed = (0, bolt11_1.decode)(lnpr);\r\n        if (parsed.millisatoshis != null)\r\n            return (BigInt(parsed.millisatoshis) + 999n) / 1000n;\r\n        return null;\r\n    }\r\n    parseBitcoinAddress(resultText) {\r\n        let _amount = null;\r\n        if (resultText.includes(\"?\")) {\r\n            const arr = resultText.split(\"?\");\r\n            resultText = arr[0];\r\n            const params = arr[1].split(\"&\");\r\n            for (let param of params) {\r\n                const arr2 = param.split(\"=\");\r\n                const key = arr2[0];\r\n                const value = decodeURIComponent(arr2[1]);\r\n                if (key === \"amount\") {\r\n                    _amount = (0, Tokens_1.fromDecimal)(parseFloat(value).toFixed(8), 8);\r\n                }\r\n            }\r\n        }\r\n        if (this.isValidBitcoinAddress(resultText)) {\r\n            return {\r\n                address: resultText,\r\n                type: \"BITCOIN\",\r\n                swapType: SwapType_1.SwapType.TO_BTC,\r\n                amount: (0, Tokens_1.toTokenAmount)(_amount, Tokens_1.BitcoinTokens.BTC, this.root.prices)\r\n            };\r\n        }\r\n    }\r\n    parseLNURLSync(resultText) {\r\n        if (this.isValidLNURL(resultText)) {\r\n            return {\r\n                address: resultText,\r\n                type: \"LNURL\",\r\n                swapType: null\r\n            };\r\n        }\r\n    }\r\n    async parseLNURL(resultText) {\r\n        if (this.isValidLNURL(resultText)) {\r\n            try {\r\n                const result = await this.getLNURLTypeAndData(resultText);\r\n                if (result == null)\r\n                    throw new Error(\"Invalid LNURL specified!\");\r\n                const response = {\r\n                    address: resultText,\r\n                    type: \"LNURL\",\r\n                    swapType: (0, LNURL_1.isLNURLPay)(result) ? SwapType_1.SwapType.TO_BTCLN : (0, LNURL_1.isLNURLWithdraw)(result) ? SwapType_1.SwapType.FROM_BTCLN : null,\r\n                    lnurl: result\r\n                };\r\n                if (result.min === result.max) {\r\n                    return {\r\n                        ...response,\r\n                        amount: (0, Tokens_1.toTokenAmount)(result.min, Tokens_1.BitcoinTokens.BTCLN, this.root.prices)\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        ...response,\r\n                        min: (0, Tokens_1.toTokenAmount)(result.min, Tokens_1.BitcoinTokens.BTCLN, this.root.prices),\r\n                        max: (0, Tokens_1.toTokenAmount)(result.max, Tokens_1.BitcoinTokens.BTCLN, this.root.prices)\r\n                    };\r\n                }\r\n            }\r\n            catch (e) {\r\n                throw new Error(\"Failed to contact LNURL service, check your internet connection and retry later.\");\r\n            }\r\n        }\r\n    }\r\n    parseLightningInvoice(resultText) {\r\n        if (this.isLightningInvoice(resultText)) {\r\n            if (this.isValidLightningInvoice(resultText)) {\r\n                const amountBN = this.getLightningInvoiceValue(resultText);\r\n                return {\r\n                    address: resultText,\r\n                    type: \"LIGHTNING\",\r\n                    swapType: SwapType_1.SwapType.TO_BTCLN,\r\n                    amount: (0, Tokens_1.toTokenAmount)(amountBN, Tokens_1.BitcoinTokens.BTCLN, this.root.prices)\r\n                };\r\n            }\r\n            else {\r\n                throw new Error(\"Lightning invoice needs to contain an amount!\");\r\n            }\r\n        }\r\n    }\r\n    parseSmartchainAddress(resultText) {\r\n        for (let chainId of this.root.getSmartChains()) {\r\n            if (this.root.chains[chainId].chainInterface.isValidAddress(resultText)) {\r\n                if (this.root.supportsSwapType(chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {\r\n                    return {\r\n                        address: resultText,\r\n                        type: chainId,\r\n                        swapType: SwapType_1.SwapType.SPV_VAULT_FROM_BTC\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        address: resultText,\r\n                        type: chainId,\r\n                        swapType: null\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * General parser for bitcoin addresses, LNURLs, lightning invoices, smart chain addresses, also fetches LNURL data\r\n     *  (hence returns Promise)\r\n     *\r\n     * @param addressString Address to parse\r\n     * @throws {Error} Error in address parsing\r\n     * @returns Address data or null if address doesn't conform to any known format\r\n     */\r\n    async parseAddress(addressString) {\r\n        if (addressString.startsWith(\"bitcoin:\")) {\r\n            const parsedBitcoinAddress = this.parseBitcoinAddress(addressString.substring(8));\r\n            if (parsedBitcoinAddress != null)\r\n                return parsedBitcoinAddress;\r\n            throw new Error(\"Invalid bitcoin address!\");\r\n        }\r\n        const parsedBitcoinAddress = this.parseBitcoinAddress(addressString);\r\n        if (parsedBitcoinAddress != null)\r\n            return parsedBitcoinAddress;\r\n        if (addressString.startsWith(\"lightning:\")) {\r\n            const resultText = addressString.substring(10);\r\n            const resultLnurl = await this.parseLNURL(resultText);\r\n            if (resultLnurl != null)\r\n                return resultLnurl;\r\n            const resultLightningInvoice = this.parseLightningInvoice(resultText);\r\n            if (resultLightningInvoice != null)\r\n                return resultLightningInvoice;\r\n            throw new Error(\"Invalid lightning network invoice or LNURL!\");\r\n        }\r\n        const resultLnurl = await this.parseLNURL(addressString);\r\n        if (resultLnurl != null)\r\n            return resultLnurl;\r\n        const resultLightningInvoice = this.parseLightningInvoice(addressString);\r\n        if (resultLightningInvoice != null)\r\n            return resultLightningInvoice;\r\n        return this.parseSmartchainAddress(addressString);\r\n    }\r\n    /**\r\n     * Synchronous general parser for bitcoin addresses, LNURLs, lightning invoices, smart chain addresses, doesn't fetch\r\n     *  LNURL data, reports swapType: null instead to prevent returning a Promise\r\n     *\r\n     * @param addressString Address to parse\r\n     * @throws {Error} Error in address parsing\r\n     * @returns Address data or null if address doesn't conform to any known format\r\n     */\r\n    parseAddressSync(addressString) {\r\n        if (addressString.startsWith(\"bitcoin:\")) {\r\n            const parsedBitcoinAddress = this.parseBitcoinAddress(addressString.substring(8));\r\n            if (parsedBitcoinAddress != null)\r\n                return parsedBitcoinAddress;\r\n            throw new Error(\"Invalid bitcoin address!\");\r\n        }\r\n        const parsedBitcoinAddress = this.parseBitcoinAddress(addressString);\r\n        if (parsedBitcoinAddress != null)\r\n            return parsedBitcoinAddress;\r\n        if (addressString.startsWith(\"lightning:\")) {\r\n            const resultText = addressString.substring(10);\r\n            const resultLnurl = this.parseLNURLSync(resultText);\r\n            if (resultLnurl != null)\r\n                return resultLnurl;\r\n            const resultLightningInvoice = this.parseLightningInvoice(resultText);\r\n            if (resultLightningInvoice != null)\r\n                return resultLightningInvoice;\r\n            throw new Error(\"Invalid lightning network invoice or LNURL!\");\r\n        }\r\n        const resultLnurl = this.parseLNURLSync(addressString);\r\n        if (resultLnurl != null)\r\n            return resultLnurl;\r\n        const resultLightningInvoice = this.parseLightningInvoice(addressString);\r\n        if (resultLightningInvoice != null)\r\n            return resultLightningInvoice;\r\n        return this.parseSmartchainAddress(addressString);\r\n    }\r\n    /**\r\n     * Returns a random PSBT that can be used for fee estimation, the last output (the LP output) is omitted\r\n     *  to allow for coinselection algorithm to determine maximum sendable amount there\r\n     *\r\n     * @param chainIdentifier\r\n     * @param includeGasToken   Whether to return the PSBT also with the gas token amount (increases the vSize by 8)\r\n     */\r\n    getRandomSpvVaultPsbt(chainIdentifier, includeGasToken) {\r\n        const wrapper = this.root.chains[chainIdentifier].wrappers[SwapType_1.SwapType.SPV_VAULT_FROM_BTC];\r\n        if (wrapper == null)\r\n            throw new Error(\"Chain doesn't support spv vault swaps!\");\r\n        return wrapper.getDummySwapPsbt(includeGasToken);\r\n    }\r\n    /**\r\n     * Returns the spendable balance of a bitcoin wallet\r\n     *\r\n     * @param addressOrWallet\r\n     * @param targetChain\r\n     * @param options Additional options\r\n     */\r\n    async getBitcoinSpendableBalance(addressOrWallet, targetChain, options) {\r\n        if (typeof (addressOrWallet) !== \"string\" && addressOrWallet.getTransactionFee == null)\r\n            throw new Error(\"Wallet must be a string address or IBitcoinWallet\");\r\n        let bitcoinWallet;\r\n        if (typeof (addressOrWallet) === \"string\") {\r\n            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.root.bitcoinRpc, this.bitcoinNetwork, addressOrWallet);\r\n        }\r\n        else {\r\n            bitcoinWallet = addressOrWallet;\r\n        }\r\n        let feeRate = options?.feeRate ?? await bitcoinWallet.getFeeRate();\r\n        if (options?.minFeeRate != null)\r\n            feeRate = Math.max(feeRate, options.minFeeRate);\r\n        let result;\r\n        if (targetChain != null && this.root.supportsSwapType(targetChain, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {\r\n            result = await bitcoinWallet.getSpendableBalance(this.getRandomSpvVaultPsbt(targetChain, options?.gasDrop), feeRate);\r\n        }\r\n        else {\r\n            result = await bitcoinWallet.getSpendableBalance(undefined, feeRate);\r\n        }\r\n        return {\r\n            balance: (0, Tokens_1.toTokenAmount)(result.balance, Tokens_1.BitcoinTokens.BTC, this.root.prices),\r\n            feeRate: result.feeRate\r\n        };\r\n    }\r\n    /**\r\n     * Returns the maximum spendable balance of the wallet, deducting the fee needed to initiate a swap for native balances\r\n     */\r\n    async getSpendableBalance(wallet, token, options) {\r\n        if (typeof (wallet) !== \"string\" && wallet.getAddress == null)\r\n            throw new Error(\"Signer must be a string or smart chain signer\");\r\n        if (this.root.chains[token.chainId] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + token.chainId);\r\n        const { swapContract, chainInterface } = this.root.chains[token.chainId];\r\n        const signer = typeof (wallet) === \"string\" ? wallet : wallet.getAddress();\r\n        let finalBalance;\r\n        if (chainInterface.getNativeCurrencyAddress() !== token.address) {\r\n            finalBalance = await chainInterface.getBalance(signer, token.address);\r\n        }\r\n        else {\r\n            let [balance, commitFee] = await Promise.all([\r\n                chainInterface.getBalance(signer, token.address),\r\n                swapContract.getCommitFee(\r\n                //Use large amount, such that the fee for wrapping more tokens is always included!\r\n                await swapContract.createSwapData(base_1.ChainSwapType.HTLC, signer, null, token.address, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn, swapContract.getHashForHtlc((0, Utils_1.randomBytes)(32)).toString(\"hex\"), base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(8)), BigInt(Math.floor(Date.now() / 1000)), true, false, base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(2)), base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(2))), options?.feeRate)\r\n            ]);\r\n            if (options?.feeMultiplier != null) {\r\n                commitFee = commitFee * (BigInt(Math.floor(options.feeMultiplier * 1000000))) / 1000000n;\r\n            }\r\n            finalBalance = (0, Utils_1.bigIntMax)(balance - commitFee, 0n);\r\n        }\r\n        return (0, Tokens_1.toTokenAmount)(finalBalance, token, this.root.prices);\r\n    }\r\n    /**\r\n     * Returns the address of the native currency of the chain\r\n     */\r\n    getNativeToken(chainIdentifier) {\r\n        if (this.root.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        return this.root.tokens[chainIdentifier][this.root.chains[chainIdentifier].chainInterface.getNativeCurrencyAddress()];\r\n    }\r\n    /**\r\n     * Returns a random signer for a given smart chain\r\n     *\r\n     * @param chainIdentifier\r\n     */\r\n    randomSigner(chainIdentifier) {\r\n        if (this.root.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        return this.root.chains[chainIdentifier].chainInterface.randomSigner();\r\n    }\r\n    /**\r\n     * Returns a random address for a given smart chain\r\n     *\r\n     * @param chainIdentifier\r\n     */\r\n    randomAddress(chainIdentifier) {\r\n        if (this.root.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        return this.root.chains[chainIdentifier].chainInterface.randomAddress();\r\n    }\r\n}\r\nexports.SwapperUtils = SwapperUtils;\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,QAAQ,YAAY,GAAG,KAAK;AAC5B,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;IAKF;;;;KAIC,GACD,mBAAmB,IAAI,EAAE;QACrB,IAAI;YACA,CAAC,GAAG,SAAS,MAAM,EAAE;YACrB,OAAO;QACX,EACA,OAAO,GAAG,CAAE;QACZ,OAAO;IACX;IACA;;;;KAIC,GACD,sBAAsB,IAAI,EAAE;QACxB,IAAI;YACA,CAAC,GAAG,aAAa,OAAO,EAAE,IAAI,CAAC,cAAc,EAAE,MAAM,CAAC;YACtD,OAAO;QACX,EACA,OAAO,GAAG;YACN,OAAO;QACX;IACJ;IACA;;;;KAIC,GACD,wBAAwB,IAAI,EAAE;QAC1B,IAAI;YACA,MAAM,SAAS,CAAC,GAAG,SAAS,MAAM,EAAE;YACpC,IAAI,OAAO,aAAa,IAAI,MACxB,OAAO;QACf,EACA,OAAO,GAAG,CAAE;QACZ,OAAO;IACX;IACA;;;;KAIC,GACD,aAAa,KAAK,EAAE;QAChB,OAAO,QAAQ,KAAK,CAAC,OAAO,CAAC;IACjC;IACA;;;;;KAKC,GACD,oBAAoB,KAAK,EAAE,WAAW,EAAE;QACpC,OAAO,QAAQ,KAAK,CAAC,YAAY,CAAC,OAAO;IAC7C;IACA;;;;KAIC,GACD,yBAAyB,IAAI,EAAE;QAC3B,MAAM,SAAS,CAAC,GAAG,SAAS,MAAM,EAAE;QACpC,IAAI,OAAO,aAAa,IAAI,MACxB,OAAO,CAAC,OAAO,OAAO,aAAa,IAAI,IAAI,IAAI,KAAK;QACxD,OAAO;IACX;IACA,oBAAoB,UAAU,EAAE;QAC5B,IAAI,UAAU;QACd,IAAI,WAAW,QAAQ,CAAC,MAAM;YAC1B,MAAM,MAAM,WAAW,KAAK,CAAC;YAC7B,aAAa,GAAG,CAAC,EAAE;YACnB,MAAM,SAAS,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC;YAC5B,KAAK,IAAI,SAAS,OAAQ;gBACtB,MAAM,OAAO,MAAM,KAAK,CAAC;gBACzB,MAAM,MAAM,IAAI,CAAC,EAAE;gBACnB,MAAM,QAAQ,mBAAmB,IAAI,CAAC,EAAE;gBACxC,IAAI,QAAQ,UAAU;oBAClB,UAAU,CAAC,GAAG,SAAS,WAAW,EAAE,WAAW,OAAO,OAAO,CAAC,IAAI;gBACtE;YACJ;QACJ;QACA,IAAI,IAAI,CAAC,qBAAqB,CAAC,aAAa;YACxC,OAAO;gBACH,SAAS;gBACT,MAAM;gBACN,UAAU,WAAW,QAAQ,CAAC,MAAM;gBACpC,QAAQ,CAAC,GAAG,SAAS,aAAa,EAAE,SAAS,SAAS,aAAa,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;YAC7F;QACJ;IACJ;IACA,eAAe,UAAU,EAAE;QACvB,IAAI,IAAI,CAAC,YAAY,CAAC,aAAa;YAC/B,OAAO;gBACH,SAAS;gBACT,MAAM;gBACN,UAAU;YACd;QACJ;IACJ;IACA,MAAM,WAAW,UAAU,EAAE;QACzB,IAAI,IAAI,CAAC,YAAY,CAAC,aAAa;YAC/B,IAAI;gBACA,MAAM,SAAS,MAAM,IAAI,CAAC,mBAAmB,CAAC;gBAC9C,IAAI,UAAU,MACV,MAAM,IAAI,MAAM;gBACpB,MAAM,WAAW;oBACb,SAAS;oBACT,MAAM;oBACN,UAAU,CAAC,GAAG,QAAQ,UAAU,EAAE,UAAU,WAAW,QAAQ,CAAC,QAAQ,GAAG,CAAC,GAAG,QAAQ,eAAe,EAAE,UAAU,WAAW,QAAQ,CAAC,UAAU,GAAG;oBACnJ,OAAO;gBACX;gBACA,IAAI,OAAO,GAAG,KAAK,OAAO,GAAG,EAAE;oBAC3B,OAAO;wBACH,GAAG,QAAQ;wBACX,QAAQ,CAAC,GAAG,SAAS,aAAa,EAAE,OAAO,GAAG,EAAE,SAAS,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;oBAClG;gBACJ,OACK;oBACD,OAAO;wBACH,GAAG,QAAQ;wBACX,KAAK,CAAC,GAAG,SAAS,aAAa,EAAE,OAAO,GAAG,EAAE,SAAS,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;wBAC3F,KAAK,CAAC,GAAG,SAAS,aAAa,EAAE,OAAO,GAAG,EAAE,SAAS,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;oBAC/F;gBACJ;YACJ,EACA,OAAO,GAAG;gBACN,MAAM,IAAI,MAAM;YACpB;QACJ;IACJ;IACA,sBAAsB,UAAU,EAAE;QAC9B,IAAI,IAAI,CAAC,kBAAkB,CAAC,aAAa;YACrC,IAAI,IAAI,CAAC,uBAAuB,CAAC,aAAa;gBAC1C,MAAM,WAAW,IAAI,CAAC,wBAAwB,CAAC;gBAC/C,OAAO;oBACH,SAAS;oBACT,MAAM;oBACN,UAAU,WAAW,QAAQ,CAAC,QAAQ;oBACtC,QAAQ,CAAC,GAAG,SAAS,aAAa,EAAE,UAAU,SAAS,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;gBAChG;YACJ,OACK;gBACD,MAAM,IAAI,MAAM;YACpB;QACJ;IACJ;IACA,uBAAuB,UAAU,EAAE;QAC/B,KAAK,IAAI,WAAW,IAAI,CAAC,IAAI,CAAC,cAAc,GAAI;YAC5C,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAC,aAAa;gBACrE,IAAI,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,SAAS,WAAW,QAAQ,CAAC,kBAAkB,GAAG;oBAC7E,OAAO;wBACH,SAAS;wBACT,MAAM;wBACN,UAAU,WAAW,QAAQ,CAAC,kBAAkB;oBACpD;gBACJ,OACK;oBACD,OAAO;wBACH,SAAS;wBACT,MAAM;wBACN,UAAU;oBACd;gBACJ;YACJ;QACJ;IACJ;IACA;;;;;;;KAOC,GACD,MAAM,aAAa,aAAa,EAAE;QAC9B,IAAI,cAAc,UAAU,CAAC,aAAa;YACtC,MAAM,uBAAuB,IAAI,CAAC,mBAAmB,CAAC,cAAc,SAAS,CAAC;YAC9E,IAAI,wBAAwB,MACxB,OAAO;YACX,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,uBAAuB,IAAI,CAAC,mBAAmB,CAAC;QACtD,IAAI,wBAAwB,MACxB,OAAO;QACX,IAAI,cAAc,UAAU,CAAC,eAAe;YACxC,MAAM,aAAa,cAAc,SAAS,CAAC;YAC3C,MAAM,cAAc,MAAM,IAAI,CAAC,UAAU,CAAC;YAC1C,IAAI,eAAe,MACf,OAAO;YACX,MAAM,yBAAyB,IAAI,CAAC,qBAAqB,CAAC;YAC1D,IAAI,0BAA0B,MAC1B,OAAO;YACX,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,cAAc,MAAM,IAAI,CAAC,UAAU,CAAC;QAC1C,IAAI,eAAe,MACf,OAAO;QACX,MAAM,yBAAyB,IAAI,CAAC,qBAAqB,CAAC;QAC1D,IAAI,0BAA0B,MAC1B,OAAO;QACX,OAAO,IAAI,CAAC,sBAAsB,CAAC;IACvC;IACA;;;;;;;KAOC,GACD,iBAAiB,aAAa,EAAE;QAC5B,IAAI,cAAc,UAAU,CAAC,aAAa;YACtC,MAAM,uBAAuB,IAAI,CAAC,mBAAmB,CAAC,cAAc,SAAS,CAAC;YAC9E,IAAI,wBAAwB,MACxB,OAAO;YACX,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,uBAAuB,IAAI,CAAC,mBAAmB,CAAC;QACtD,IAAI,wBAAwB,MACxB,OAAO;QACX,IAAI,cAAc,UAAU,CAAC,eAAe;YACxC,MAAM,aAAa,cAAc,SAAS,CAAC;YAC3C,MAAM,cAAc,IAAI,CAAC,cAAc,CAAC;YACxC,IAAI,eAAe,MACf,OAAO;YACX,MAAM,yBAAyB,IAAI,CAAC,qBAAqB,CAAC;YAC1D,IAAI,0BAA0B,MAC1B,OAAO;YACX,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,cAAc,IAAI,CAAC,cAAc,CAAC;QACxC,IAAI,eAAe,MACf,OAAO;QACX,MAAM,yBAAyB,IAAI,CAAC,qBAAqB,CAAC;QAC1D,IAAI,0BAA0B,MAC1B,OAAO;QACX,OAAO,IAAI,CAAC,sBAAsB,CAAC;IACvC;IACA;;;;;;KAMC,GACD,sBAAsB,eAAe,EAAE,eAAe,EAAE;QACpD,MAAM,UAAU,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,CAAC,WAAW,QAAQ,CAAC,kBAAkB,CAAC;QAClG,IAAI,WAAW,MACX,MAAM,IAAI,MAAM;QACpB,OAAO,QAAQ,gBAAgB,CAAC;IACpC;IACA;;;;;;KAMC,GACD,MAAM,2BAA2B,eAAe,EAAE,WAAW,EAAE,OAAO,EAAE;QACpE,IAAI,OAAQ,oBAAqB,YAAY,gBAAgB,iBAAiB,IAAI,MAC9E,MAAM,IAAI,MAAM;QACpB,IAAI;QACJ,IAAI,OAAQ,oBAAqB,UAAU;YACvC,gBAAgB,IAAI,6BAA6B,0BAA0B,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,cAAc,EAAE;QAC3H,OACK;YACD,gBAAgB;QACpB;YACc;QAAd,IAAI,UAAU,CAAA,mBAAA,oBAAA,8BAAA,QAAS,OAAO,cAAhB,8BAAA,mBAAoB,MAAM,cAAc,UAAU;QAChE,IAAI,CAAA,oBAAA,8BAAA,QAAS,UAAU,KAAI,MACvB,UAAU,KAAK,GAAG,CAAC,SAAS,QAAQ,UAAU;QAClD,IAAI;QACJ,IAAI,eAAe,QAAQ,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,aAAa,WAAW,QAAQ,CAAC,kBAAkB,GAAG;YACxG,SAAS,MAAM,cAAc,mBAAmB,CAAC,IAAI,CAAC,qBAAqB,CAAC,aAAa,oBAAA,8BAAA,QAAS,OAAO,GAAG;QAChH,OACK;YACD,SAAS,MAAM,cAAc,mBAAmB,CAAC,WAAW;QAChE;QACA,OAAO;YACH,SAAS,CAAC,GAAG,SAAS,aAAa,EAAE,OAAO,OAAO,EAAE,SAAS,aAAa,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,CAAC,MAAM;YACjG,SAAS,OAAO,OAAO;QAC3B;IACJ;IACA;;KAEC,GACD,MAAM,oBAAoB,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE;QAC9C,IAAI,OAAQ,WAAY,YAAY,OAAO,UAAU,IAAI,MACrD,MAAM,IAAI,MAAM;QACpB,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,OAAO,CAAC,IAAI,MACnC,MAAM,IAAI,MAAM,8CAA8C,MAAM,OAAO;QAC/E,MAAM,EAAE,YAAY,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,OAAO,CAAC;QACxE,MAAM,SAAS,OAAQ,WAAY,WAAW,SAAS,OAAO,UAAU;QACxE,IAAI;QACJ,IAAI,eAAe,wBAAwB,OAAO,MAAM,OAAO,EAAE;YAC7D,eAAe,MAAM,eAAe,UAAU,CAAC,QAAQ,MAAM,OAAO;QACxE,OACK;YACD,IAAI,CAAC,SAAS,UAAU,GAAG,MAAM,QAAQ,GAAG,CAAC;gBACzC,eAAe,UAAU,CAAC,QAAQ,MAAM,OAAO;gBAC/C,aAAa,YAAY,CACzB,kFAAkF;gBAClF,MAAM,aAAa,cAAc,CAAC,OAAO,aAAa,CAAC,IAAI,EAAE,QAAQ,MAAM,MAAM,OAAO,EAAE,mEAAmE,EAAE,aAAa,cAAc,CAAC,CAAC,GAAG,QAAQ,WAAW,EAAE,KAAK,QAAQ,CAAC,QAAQ,OAAO,iBAAiB,CAAC,UAAU,CAAC,CAAC,GAAG,QAAQ,WAAW,EAAE,KAAK,OAAO,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK,QAAQ,MAAM,OAAO,OAAO,iBAAiB,CAAC,UAAU,CAAC,CAAC,GAAG,QAAQ,WAAW,EAAE,KAAK,OAAO,iBAAiB,CAAC,UAAU,CAAC,CAAC,GAAG,QAAQ,WAAW,EAAE,MAAM,oBAAA,8BAAA,QAAS,OAAO;aACxf;YACD,IAAI,CAAA,oBAAA,8BAAA,QAAS,aAAa,KAAI,MAAM;gBAChC,YAAY,YAAa,OAAO,KAAK,KAAK,CAAC,QAAQ,aAAa,GAAG,YAAa,QAAQ;YAC5F;YACA,eAAe,CAAC,GAAG,QAAQ,SAAS,EAAE,UAAU,WAAW,EAAE;QACjE;QACA,OAAO,CAAC,GAAG,SAAS,aAAa,EAAE,cAAc,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM;IAC5E;IACA;;KAEC,GACD,eAAe,eAAe,EAAE;QAC5B,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,IAAI,MACrC,MAAM,IAAI,MAAM,8CAA8C;QAClE,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC,wBAAwB,GAAG;IACzH;IACA;;;;KAIC,GACD,aAAa,eAAe,EAAE;QAC1B,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,IAAI,MACrC,MAAM,IAAI,MAAM,8CAA8C;QAClE,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC,YAAY;IACxE;IACA;;;;KAIC,GACD,cAAc,eAAe,EAAE;QAC3B,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,IAAI,MACrC,MAAM,IAAI,MAAM,8CAA8C;QAClE,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,CAAC,aAAa;IACzE;IAzVA,YAAY,IAAI,CAAE;QACd,IAAI,CAAC,cAAc,GAAG,KAAK,cAAc;QACzC,IAAI,CAAC,IAAI,GAAG;IAChB;AAuVJ;AACA,QAAQ,YAAY,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 11844, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/swaps/swapper/Swapper.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Swapper = void 0;\r\nconst base_1 = require(\"@atomiqlabs/base\");\r\nconst ToBTCLNWrapper_1 = require(\"../escrow_swaps/tobtc/ln/ToBTCLNWrapper\");\r\nconst ToBTCWrapper_1 = require(\"../escrow_swaps/tobtc/onchain/ToBTCWrapper\");\r\nconst FromBTCLNWrapper_1 = require(\"../escrow_swaps/frombtc/ln/FromBTCLNWrapper\");\r\nconst FromBTCWrapper_1 = require(\"../escrow_swaps/frombtc/onchain/FromBTCWrapper\");\r\nconst IntermediaryDiscovery_1 = require(\"../../intermediaries/IntermediaryDiscovery\");\r\nconst bolt11_1 = require(\"@atomiqlabs/bolt11\");\r\nconst IntermediaryError_1 = require(\"../../errors/IntermediaryError\");\r\nconst SwapType_1 = require(\"../enums/SwapType\");\r\nconst MempoolBtcRelaySynchronizer_1 = require(\"../../btc/mempool/synchronizer/MempoolBtcRelaySynchronizer\");\r\nconst LnForGasWrapper_1 = require(\"../trusted/ln/LnForGasWrapper\");\r\nconst events_1 = require(\"events\");\r\nconst LNURL_1 = require(\"../../utils/LNURL\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst RequestError_1 = require(\"../../errors/RequestError\");\r\nconst SwapperWithChain_1 = require(\"./SwapperWithChain\");\r\nconst Tokens_1 = require(\"../../Tokens\");\r\nconst OnchainForGasWrapper_1 = require(\"../trusted/onchain/OnchainForGasWrapper\");\r\nconst utils_1 = require(\"@scure/btc-signer/utils\");\r\nconst IndexedDBUnifiedStorage_1 = require(\"../../browser-storage/IndexedDBUnifiedStorage\");\r\nconst UnifiedSwapStorage_1 = require(\"../../storage/UnifiedSwapStorage\");\r\nconst UnifiedSwapEventListener_1 = require(\"../../events/UnifiedSwapEventListener\");\r\nconst SpvFromBTCWrapper_1 = require(\"../spv_swaps/SpvFromBTCWrapper\");\r\nconst SwapperUtils_1 = require(\"./utils/SwapperUtils\");\r\nclass Swapper extends events_1.EventEmitter {\r\n    constructor(bitcoinRpc, chainsData, pricing, tokens, options) {\r\n        super();\r\n        this.logger = (0, Utils_1.getLogger)(this.constructor.name + \": \");\r\n        this.SwapTypeInfo = {\r\n            [SwapType_1.SwapType.TO_BTC]: {\r\n                requiresInputWallet: true,\r\n                requiresOutputWallet: false,\r\n                supportsGasDrop: false\r\n            },\r\n            [SwapType_1.SwapType.TO_BTCLN]: {\r\n                requiresInputWallet: true,\r\n                requiresOutputWallet: false,\r\n                supportsGasDrop: false\r\n            },\r\n            [SwapType_1.SwapType.FROM_BTC]: {\r\n                requiresInputWallet: false,\r\n                requiresOutputWallet: true,\r\n                supportsGasDrop: false\r\n            },\r\n            [SwapType_1.SwapType.FROM_BTCLN]: {\r\n                requiresInputWallet: false,\r\n                requiresOutputWallet: true,\r\n                supportsGasDrop: false\r\n            },\r\n            [SwapType_1.SwapType.SPV_VAULT_FROM_BTC]: {\r\n                requiresInputWallet: true,\r\n                requiresOutputWallet: false,\r\n                supportsGasDrop: true\r\n            },\r\n            [SwapType_1.SwapType.TRUSTED_FROM_BTC]: {\r\n                requiresInputWallet: false,\r\n                requiresOutputWallet: false,\r\n                supportsGasDrop: false\r\n            },\r\n            [SwapType_1.SwapType.TRUSTED_FROM_BTCLN]: {\r\n                requiresInputWallet: false,\r\n                requiresOutputWallet: false,\r\n                supportsGasDrop: false\r\n            }\r\n        };\r\n        const storagePrefix = options?.storagePrefix ?? \"atomiq-\";\r\n        options.bitcoinNetwork = options.bitcoinNetwork == null ? base_1.BitcoinNetwork.TESTNET : options.bitcoinNetwork;\r\n        options.swapStorage ??= (name) => new IndexedDBUnifiedStorage_1.IndexedDBUnifiedStorage(name);\r\n        this._bitcoinNetwork = options.bitcoinNetwork;\r\n        this.bitcoinNetwork = options.bitcoinNetwork === base_1.BitcoinNetwork.MAINNET ? utils_1.NETWORK :\r\n            (options.bitcoinNetwork === base_1.BitcoinNetwork.TESTNET || options.bitcoinNetwork === base_1.BitcoinNetwork.TESTNET4) ? utils_1.TEST_NETWORK : {\r\n                bech32: 'bcrt',\r\n                pubKeyHash: 111,\r\n                scriptHash: 196,\r\n                wif: 239\r\n            };\r\n        this.Utils = new SwapperUtils_1.SwapperUtils(this);\r\n        this.prices = pricing;\r\n        this.bitcoinRpc = bitcoinRpc;\r\n        this.mempoolApi = bitcoinRpc.api;\r\n        this.options = options;\r\n        this.tokens = {};\r\n        for (let tokenData of tokens) {\r\n            for (let chainId in tokenData.chains) {\r\n                const chainData = tokenData.chains[chainId];\r\n                this.tokens[chainId] ??= {};\r\n                this.tokens[chainId][chainData.address] = {\r\n                    chain: \"SC\",\r\n                    chainId,\r\n                    ticker: tokenData.ticker,\r\n                    name: tokenData.name,\r\n                    decimals: chainData.decimals,\r\n                    displayDecimals: chainData.displayDecimals,\r\n                    address: chainData.address\r\n                };\r\n            }\r\n        }\r\n        this.swapStateListener = (swap) => {\r\n            this.emit(\"swapState\", swap);\r\n        };\r\n        this.chains = (0, Utils_1.objectMap)(chainsData, (chainData, key) => {\r\n            const { swapContract, chainEvents, btcRelay, chainInterface, spvVaultContract, spvVaultWithdrawalDataConstructor } = chainData;\r\n            const synchronizer = new MempoolBtcRelaySynchronizer_1.MempoolBtcRelaySynchronizer(btcRelay, bitcoinRpc);\r\n            const storageHandler = options.swapStorage(storagePrefix + chainData.chainId);\r\n            const unifiedSwapStorage = new UnifiedSwapStorage_1.UnifiedSwapStorage(storageHandler, this.options.noSwapCache);\r\n            const unifiedChainEvents = new UnifiedSwapEventListener_1.UnifiedSwapEventListener(unifiedSwapStorage, chainEvents);\r\n            const wrappers = {};\r\n            wrappers[SwapType_1.SwapType.TO_BTCLN] = new ToBTCLNWrapper_1.ToBTCLNWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, {\r\n                getRequestTimeout: options.getRequestTimeout,\r\n                postRequestTimeout: options.postRequestTimeout,\r\n            });\r\n            wrappers[SwapType_1.SwapType.TO_BTC] = new ToBTCWrapper_1.ToBTCWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, this.bitcoinRpc, {\r\n                getRequestTimeout: options.getRequestTimeout,\r\n                postRequestTimeout: options.postRequestTimeout,\r\n                bitcoinNetwork: this.bitcoinNetwork\r\n            });\r\n            wrappers[SwapType_1.SwapType.FROM_BTCLN] = new FromBTCLNWrapper_1.FromBTCLNWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, bitcoinRpc, {\r\n                getRequestTimeout: options.getRequestTimeout,\r\n                postRequestTimeout: options.postRequestTimeout,\r\n                unsafeSkipLnNodeCheck: this._bitcoinNetwork === base_1.BitcoinNetwork.TESTNET4 || this._bitcoinNetwork === base_1.BitcoinNetwork.REGTEST\r\n            });\r\n            wrappers[SwapType_1.SwapType.FROM_BTC] = new FromBTCWrapper_1.FromBTCWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, btcRelay, synchronizer, this.bitcoinRpc, {\r\n                getRequestTimeout: options.getRequestTimeout,\r\n                postRequestTimeout: options.postRequestTimeout,\r\n                bitcoinNetwork: this.bitcoinNetwork\r\n            });\r\n            wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTCLN] = new LnForGasWrapper_1.LnForGasWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, pricing, tokens, {\r\n                getRequestTimeout: options.getRequestTimeout,\r\n                postRequestTimeout: options.postRequestTimeout\r\n            });\r\n            wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTC] = new OnchainForGasWrapper_1.OnchainForGasWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, pricing, tokens, bitcoinRpc, {\r\n                getRequestTimeout: options.getRequestTimeout,\r\n                postRequestTimeout: options.postRequestTimeout,\r\n                bitcoinNetwork: this.bitcoinNetwork\r\n            });\r\n            if (spvVaultContract != null) {\r\n                wrappers[SwapType_1.SwapType.SPV_VAULT_FROM_BTC] = new SpvFromBTCWrapper_1.SpvFromBTCWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, spvVaultContract, pricing, tokens, spvVaultWithdrawalDataConstructor, btcRelay, synchronizer, bitcoinRpc, {\r\n                    getRequestTimeout: options.getRequestTimeout,\r\n                    postRequestTimeout: options.postRequestTimeout,\r\n                    bitcoinNetwork: this.bitcoinNetwork\r\n                });\r\n            }\r\n            Object.keys(wrappers).forEach(key => wrappers[key].events.on(\"swapState\", this.swapStateListener));\r\n            const reviver = (val) => {\r\n                const wrapper = wrappers[val.type];\r\n                if (wrapper == null)\r\n                    return null;\r\n                return new wrapper.swapDeserializer(wrapper, val);\r\n            };\r\n            return {\r\n                chainEvents,\r\n                spvVaultContract,\r\n                swapContract,\r\n                chainInterface,\r\n                btcRelay,\r\n                synchronizer,\r\n                wrappers,\r\n                unifiedChainEvents,\r\n                unifiedSwapStorage,\r\n                reviver\r\n            };\r\n        });\r\n        const contracts = (0, Utils_1.objectMap)(chainsData, (data) => data.swapContract);\r\n        if (options.intermediaryUrl != null) {\r\n            this.intermediaryDiscovery = new IntermediaryDiscovery_1.IntermediaryDiscovery(contracts, options.registryUrl, Array.isArray(options.intermediaryUrl) ? options.intermediaryUrl : [options.intermediaryUrl], options.getRequestTimeout);\r\n        }\r\n        else {\r\n            this.intermediaryDiscovery = new IntermediaryDiscovery_1.IntermediaryDiscovery(contracts, options.registryUrl, null, options.getRequestTimeout);\r\n        }\r\n        this.intermediaryDiscovery.on(\"removed\", (intermediaries) => {\r\n            this.emit(\"lpsRemoved\", intermediaries);\r\n        });\r\n        this.intermediaryDiscovery.on(\"added\", (intermediaries) => {\r\n            this.emit(\"lpsAdded\", intermediaries);\r\n        });\r\n    }\r\n    /**\r\n     * Initializes the swap storage and loads existing swaps, needs to be called before any other action\r\n     */\r\n    async init() {\r\n        for (let chainIdentifier in this.chains) {\r\n            const { swapContract, unifiedChainEvents, unifiedSwapStorage, wrappers, reviver } = this.chains[chainIdentifier];\r\n            await swapContract.start();\r\n            this.logger.debug(\"init(): Intialized swap contract: \" + chainIdentifier);\r\n            await unifiedSwapStorage.init();\r\n            if (unifiedSwapStorage.storage instanceof IndexedDBUnifiedStorage_1.IndexedDBUnifiedStorage) {\r\n                //Try to migrate the data here\r\n                const storagePrefix = chainIdentifier === \"SOLANA\" ?\r\n                    \"SOLv4-\" + this._bitcoinNetwork + \"-Swaps-\" :\r\n                    \"atomiqsdk-\" + this._bitcoinNetwork + chainIdentifier + \"-Swaps-\";\r\n                await unifiedSwapStorage.storage.tryMigrate([\r\n                    [storagePrefix + \"FromBTC\", SwapType_1.SwapType.FROM_BTC],\r\n                    [storagePrefix + \"FromBTCLN\", SwapType_1.SwapType.FROM_BTCLN],\r\n                    [storagePrefix + \"ToBTC\", SwapType_1.SwapType.TO_BTC],\r\n                    [storagePrefix + \"ToBTCLN\", SwapType_1.SwapType.TO_BTCLN]\r\n                ], (obj) => {\r\n                    const swap = reviver(obj);\r\n                    if (swap.randomNonce == null) {\r\n                        const oldIdentifierHash = swap.getId();\r\n                        swap.randomNonce = (0, Utils_1.randomBytes)(16).toString(\"hex\");\r\n                        const newIdentifierHash = swap.getId();\r\n                        this.logger.info(\"init(): Found older swap version without randomNonce, replacing, old hash: \" + oldIdentifierHash +\r\n                            \" new hash: \" + newIdentifierHash);\r\n                    }\r\n                    return swap;\r\n                });\r\n            }\r\n            if (!this.options.noEvents)\r\n                await unifiedChainEvents.start();\r\n            this.logger.debug(\"init(): Intialized events: \" + chainIdentifier);\r\n            for (let key in wrappers) {\r\n                // this.logger.debug(\"init(): Initializing \"+SwapType[key]+\": \"+chainIdentifier);\r\n                await wrappers[key].init(this.options.noTimers, this.options.dontCheckPastSwaps);\r\n            }\r\n        }\r\n        this.logger.debug(\"init(): Initializing intermediary discovery\");\r\n        if (!this.options.dontFetchLPs)\r\n            await this.intermediaryDiscovery.init();\r\n        if (this.options.defaultTrustedIntermediaryUrl != null) {\r\n            this.defaultTrustedIntermediary = await this.intermediaryDiscovery.getIntermediary(this.options.defaultTrustedIntermediaryUrl);\r\n        }\r\n    }\r\n    /**\r\n     * Stops listening for onchain events and closes this Swapper instance\r\n     */\r\n    async stop() {\r\n        for (let chainIdentifier in this.chains) {\r\n            const { wrappers, unifiedChainEvents } = this.chains[chainIdentifier];\r\n            for (let key in wrappers) {\r\n                wrappers[key].events.removeListener(\"swapState\", this.swapStateListener);\r\n                await wrappers[key].stop();\r\n            }\r\n            await unifiedChainEvents.stop();\r\n        }\r\n    }\r\n    /**\r\n     * Creates swap & handles intermediary, quote selection\r\n     *\r\n     * @param chainIdentifier\r\n     * @param create Callback to create the\r\n     * @param amountData Amount data as passed to the function\r\n     * @param swapType Swap type of the execution\r\n     * @param maxWaitTimeMS Maximum waiting time after the first intermediary returns the quote\r\n     * @private\r\n     * @throws {Error} when no intermediary was found\r\n     * @throws {Error} if the chain with the provided identifier cannot be found\r\n     */\r\n    async createSwap(chainIdentifier, create, amountData, swapType, maxWaitTimeMS = 2000) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        let candidates;\r\n        const inBtc = swapType === SwapType_1.SwapType.TO_BTCLN || swapType === SwapType_1.SwapType.TO_BTC ? !amountData.exactIn : amountData.exactIn;\r\n        if (!inBtc) {\r\n            //Get candidates not based on the amount\r\n            candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token);\r\n        }\r\n        else {\r\n            candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token, amountData.amount);\r\n        }\r\n        let swapLimitsChanged = false;\r\n        if (candidates.length === 0) {\r\n            this.logger.warn(\"createSwap(): No valid intermediary found, reloading intermediary database...\");\r\n            await this.intermediaryDiscovery.reloadIntermediaries();\r\n            swapLimitsChanged = true;\r\n            if (!inBtc) {\r\n                //Get candidates not based on the amount\r\n                candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token);\r\n            }\r\n            else {\r\n                candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token, amountData.amount);\r\n                if (candidates.length === 0) {\r\n                    const min = this.intermediaryDiscovery.getSwapMinimum(chainIdentifier, swapType, amountData.token);\r\n                    const max = this.intermediaryDiscovery.getSwapMaximum(chainIdentifier, swapType, amountData.token);\r\n                    if (min != null && max != null) {\r\n                        if (amountData.amount < BigInt(min))\r\n                            throw new RequestError_1.OutOfBoundsError(\"Amount too low!\", 200, BigInt(min), BigInt(max));\r\n                        if (amountData.amount > BigInt(max))\r\n                            throw new RequestError_1.OutOfBoundsError(\"Amount too high!\", 200, BigInt(min), BigInt(max));\r\n                    }\r\n                }\r\n            }\r\n            if (candidates.length === 0)\r\n                throw new Error(\"No intermediary found!\");\r\n        }\r\n        const abortController = new AbortController();\r\n        this.logger.debug(\"createSwap() Swap candidates: \", candidates.map(lp => lp.url).join());\r\n        const quotePromises = await create(candidates, abortController.signal, this.chains[chainIdentifier]);\r\n        const promiseAll = new Promise((resolve, reject) => {\r\n            let min;\r\n            let max;\r\n            let error;\r\n            let numResolved = 0;\r\n            let quotes = [];\r\n            let timeout;\r\n            quotePromises.forEach(data => {\r\n                data.quote.then(quote => {\r\n                    if (numResolved === 0) {\r\n                        timeout = setTimeout(() => {\r\n                            abortController.abort(new Error(\"Timed out waiting for quote!\"));\r\n                            resolve(quotes);\r\n                        }, maxWaitTimeMS);\r\n                    }\r\n                    numResolved++;\r\n                    quotes.push({\r\n                        quote,\r\n                        intermediary: data.intermediary\r\n                    });\r\n                    if (numResolved === quotePromises.length) {\r\n                        clearTimeout(timeout);\r\n                        resolve(quotes);\r\n                        return;\r\n                    }\r\n                }).catch(e => {\r\n                    numResolved++;\r\n                    if (e instanceof IntermediaryError_1.IntermediaryError) {\r\n                        //Blacklist that node\r\n                        this.intermediaryDiscovery.removeIntermediary(data.intermediary);\r\n                        swapLimitsChanged = true;\r\n                    }\r\n                    else if (e instanceof RequestError_1.OutOfBoundsError) {\r\n                        if (min == null || max == null) {\r\n                            min = e.min;\r\n                            max = e.max;\r\n                        }\r\n                        else {\r\n                            min = (0, Utils_1.bigIntMin)(min, e.min);\r\n                            max = (0, Utils_1.bigIntMax)(max, e.max);\r\n                        }\r\n                        data.intermediary.swapBounds[swapType] ??= {};\r\n                        data.intermediary.swapBounds[swapType][chainIdentifier] ??= {};\r\n                        const tokenBoundsData = (data.intermediary.swapBounds[swapType][chainIdentifier][amountData.token] ??= { input: null, output: null });\r\n                        if (amountData.exactIn) {\r\n                            tokenBoundsData.input = { min: e.min, max: e.max };\r\n                        }\r\n                        else {\r\n                            tokenBoundsData.output = { min: e.min, max: e.max };\r\n                        }\r\n                        swapLimitsChanged = true;\r\n                    }\r\n                    this.logger.warn(\"createSwap(): Intermediary \" + data.intermediary.url + \" error: \", e);\r\n                    error = e;\r\n                    if (numResolved === quotePromises.length) {\r\n                        if (timeout != null)\r\n                            clearTimeout(timeout);\r\n                        if (quotes.length > 0) {\r\n                            resolve(quotes);\r\n                            return;\r\n                        }\r\n                        if (min != null && max != null) {\r\n                            reject(new RequestError_1.OutOfBoundsError(\"Out of bounds\", 400, min, max));\r\n                            return;\r\n                        }\r\n                        reject(error);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        try {\r\n            const quotes = await promiseAll;\r\n            //TODO: Intermediary's reputation is not taken into account!\r\n            quotes.sort((a, b) => {\r\n                if (amountData.exactIn) {\r\n                    //Compare outputs\r\n                    return (0, Utils_1.bigIntCompare)(b.quote.getOutput().rawAmount, a.quote.getOutput().rawAmount);\r\n                }\r\n                else {\r\n                    //Compare inputs\r\n                    return (0, Utils_1.bigIntCompare)(a.quote.getInput().rawAmount, b.quote.getInput().rawAmount);\r\n                }\r\n            });\r\n            this.logger.debug(\"createSwap(): Sorted quotes, best price to worst: \", quotes);\r\n            if (swapLimitsChanged)\r\n                this.emit(\"swapLimitsChanged\");\r\n            const quote = quotes[0].quote;\r\n            if (this.options.saveUninitializedSwaps) {\r\n                quote._setInitiated();\r\n                await quote._save();\r\n            }\r\n            return quote;\r\n        }\r\n        catch (e) {\r\n            if (swapLimitsChanged)\r\n                this.emit(\"swapLimitsChanged\");\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Creates To BTC swap\r\n     *\r\n     * @param chainIdentifier\r\n     * @param signer\r\n     * @param tokenAddress          Token address to pay with\r\n     * @param address               Recipient's bitcoin address\r\n     * @param amount                Amount to send in satoshis (bitcoin's smallest denomination)\r\n     * @param exactIn               Whether to use exact in instead of exact out\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param options\r\n     */\r\n    createToBTCSwap(chainIdentifier, signer, tokenAddress, address, amount, exactIn, additionalParams = this.options.defaultAdditionalParameters, options) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        if (address.startsWith(\"bitcoin:\")) {\r\n            address = address.substring(8).split(\"?\")[0];\r\n        }\r\n        if (!this.Utils.isValidBitcoinAddress(address))\r\n            throw new Error(\"Invalid bitcoin address\");\r\n        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainIdentifier + \" address\");\r\n        options ??= {};\r\n        options.confirmationTarget ??= 3;\r\n        options.confirmations ??= 2;\r\n        const amountData = {\r\n            amount,\r\n            token: tokenAddress,\r\n            exactIn\r\n        };\r\n        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain) => Promise.resolve(chain.wrappers[SwapType_1.SwapType.TO_BTC].create(signer, address, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.TO_BTC);\r\n    }\r\n    /**\r\n     * Creates To BTCLN swap\r\n     *\r\n     * @param chainIdentifier\r\n     * @param signer\r\n     * @param tokenAddress          Token address to pay with\r\n     * @param paymentRequest        BOLT11 lightning network invoice to be paid (needs to have a fixed amount)\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param options\r\n     */\r\n    async createToBTCLNSwap(chainIdentifier, signer, tokenAddress, paymentRequest, additionalParams = this.options.defaultAdditionalParameters, options) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        options ??= {};\r\n        if (paymentRequest.startsWith(\"lightning:\"))\r\n            paymentRequest = paymentRequest.substring(10);\r\n        if (!this.Utils.isValidLightningInvoice(paymentRequest))\r\n            throw new Error(\"Invalid lightning network invoice\");\r\n        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainIdentifier + \" address\");\r\n        const parsedPR = (0, bolt11_1.decode)(paymentRequest);\r\n        const amountData = {\r\n            amount: (BigInt(parsedPR.millisatoshis) + 999n) / 1000n,\r\n            token: tokenAddress,\r\n            exactIn: false\r\n        };\r\n        options.expirySeconds ??= 5 * 24 * 3600;\r\n        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain) => chain.wrappers[SwapType_1.SwapType.TO_BTCLN].create(signer, paymentRequest, amountData, candidates, options, additionalParams, abortSignal), amountData, SwapType_1.SwapType.TO_BTCLN);\r\n    }\r\n    /**\r\n     * Creates To BTCLN swap via LNURL-pay\r\n     *\r\n     * @param chainIdentifier\r\n     * @param signer\r\n     * @param tokenAddress          Token address to pay with\r\n     * @param lnurlPay              LNURL-pay link to use for the payment\r\n     * @param amount                Amount to be paid in sats\r\n     * @param exactIn               Whether to do an exact in swap instead of exact out\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param options\r\n     */\r\n    async createToBTCLNSwapViaLNURL(chainIdentifier, signer, tokenAddress, lnurlPay, amount, exactIn, additionalParams = this.options.defaultAdditionalParameters, options) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        if (typeof (lnurlPay) === \"string\" && !this.Utils.isValidLNURL(lnurlPay))\r\n            throw new Error(\"Invalid LNURL-pay link\");\r\n        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainIdentifier + \" address\");\r\n        options ??= {};\r\n        const amountData = {\r\n            amount,\r\n            token: tokenAddress,\r\n            exactIn\r\n        };\r\n        options.expirySeconds ??= 5 * 24 * 3600;\r\n        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain) => chain.wrappers[SwapType_1.SwapType.TO_BTCLN].createViaLNURL(signer, typeof (lnurlPay) === \"string\" ? (lnurlPay.startsWith(\"lightning:\") ? lnurlPay.substring(10) : lnurlPay) : lnurlPay.params, amountData, candidates, options, additionalParams, abortSignal), amountData, SwapType_1.SwapType.TO_BTCLN);\r\n    }\r\n    /**\r\n     * Creates From BTC swap\r\n     *\r\n     * @param chainIdentifier\r\n     * @param signer\r\n     * @param tokenAddress          Token address to receive\r\n     * @param amount                Amount to receive, in satoshis (bitcoin's smallest denomination)\r\n     * @param exactOut              Whether to use a exact out instead of exact in\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param options\r\n     */\r\n    async createFromBTCSwapNew(chainIdentifier, signer, tokenAddress, amount, exactOut, additionalParams = this.options.defaultAdditionalParameters, options) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainIdentifier + \" address\");\r\n        const amountData = {\r\n            amount,\r\n            token: tokenAddress,\r\n            exactIn: !exactOut\r\n        };\r\n        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain) => Promise.resolve(chain.wrappers[SwapType_1.SwapType.SPV_VAULT_FROM_BTC].create(signer, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.SPV_VAULT_FROM_BTC);\r\n    }\r\n    /**\r\n     * Creates From BTC swap\r\n     *\r\n     * @param chainIdentifier\r\n     * @param signer\r\n     * @param tokenAddress          Token address to receive\r\n     * @param amount                Amount to receive, in satoshis (bitcoin's smallest denomination)\r\n     * @param exactOut              Whether to use a exact out instead of exact in\r\n     * @param additionalParams      Additional parameters sent to the LP when creating the swap\r\n     * @param options\r\n     */\r\n    async createFromBTCSwap(chainIdentifier, signer, tokenAddress, amount, exactOut, additionalParams = this.options.defaultAdditionalParameters, options) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainIdentifier + \" address\");\r\n        const amountData = {\r\n            amount,\r\n            token: tokenAddress,\r\n            exactIn: !exactOut\r\n        };\r\n        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain) => Promise.resolve(chain.wrappers[SwapType_1.SwapType.FROM_BTC].create(signer, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.FROM_BTC);\r\n    }\r\n    /**\r\n     * Creates From BTCLN swap\r\n     *\r\n     * @param chainIdentifier\r\n     * @param signer\r\n     * @param tokenAddress      Token address to receive\r\n     * @param amount            Amount to receive, in satoshis (bitcoin's smallest denomination)\r\n     * @param exactOut          Whether to use exact out instead of exact in\r\n     * @param additionalParams  Additional parameters sent to the LP when creating the swap\r\n     * @param options\r\n     */\r\n    async createFromBTCLNSwap(chainIdentifier, signer, tokenAddress, amount, exactOut, additionalParams = this.options.defaultAdditionalParameters, options) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainIdentifier + \" address\");\r\n        const amountData = {\r\n            amount,\r\n            token: tokenAddress,\r\n            exactIn: !exactOut\r\n        };\r\n        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain) => Promise.resolve(chain.wrappers[SwapType_1.SwapType.FROM_BTCLN].create(signer, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.FROM_BTCLN);\r\n    }\r\n    /**\r\n     * Creates From BTCLN swap, withdrawing from LNURL-withdraw\r\n     *\r\n     * @param chainIdentifier\r\n     * @param signer\r\n     * @param tokenAddress      Token address to receive\r\n     * @param lnurl             LNURL-withdraw to pull the funds from\r\n     * @param amount            Amount to receive, in satoshis (bitcoin's smallest denomination)\r\n     * @param exactOut          Whether to use exact out instead of exact in\r\n     * @param additionalParams  Additional parameters sent to the LP when creating the swap\r\n     */\r\n    async createFromBTCLNSwapViaLNURL(chainIdentifier, signer, tokenAddress, lnurl, amount, exactOut, additionalParams = this.options.defaultAdditionalParameters) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        if (typeof (lnurl) === \"string\" && !this.Utils.isValidLNURL(lnurl))\r\n            throw new Error(\"Invalid LNURL-withdraw link\");\r\n        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainIdentifier + \" address\");\r\n        const amountData = {\r\n            amount,\r\n            token: tokenAddress,\r\n            exactIn: !exactOut\r\n        };\r\n        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain) => chain.wrappers[SwapType_1.SwapType.FROM_BTCLN].createViaLNURL(signer, typeof (lnurl) === \"string\" ? (lnurl.startsWith(\"lightning:\") ? lnurl.substring(10) : lnurl) : lnurl.params, amountData, candidates, additionalParams, abortSignal), amountData, SwapType_1.SwapType.FROM_BTCLN);\r\n    }\r\n    /**\r\n     * Creates trusted LN for Gas swap\r\n     *\r\n     * @param chainId\r\n     * @param signer\r\n     * @param amount                    Amount of native token to receive, in base units\r\n     * @param trustedIntermediaryOrUrl  URL or Intermediary object of the trusted intermediary to use, otherwise uses default\r\n     * @throws {Error}                  If no trusted intermediary specified\r\n     */\r\n    createTrustedLNForGasSwap(chainId, signer, amount, trustedIntermediaryOrUrl) {\r\n        if (this.chains[chainId] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainId);\r\n        if (!this.chains[chainId].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainId + \" address\");\r\n        const useUrl = trustedIntermediaryOrUrl ?? this.defaultTrustedIntermediary ?? this.options.defaultTrustedIntermediaryUrl;\r\n        if (useUrl == null)\r\n            throw new Error(\"No trusted intermediary specified!\");\r\n        return this.chains[chainId].wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTCLN].create(signer, amount, useUrl);\r\n    }\r\n    /**\r\n     * Creates trusted BTC on-chain for Gas swap\r\n     *\r\n     * @param chainId\r\n     * @param signer\r\n     * @param amount                    Amount of native token to receive, in base units\r\n     * @param refundAddress             Bitcoin refund address, in case the swap fails\r\n     * @param trustedIntermediaryOrUrl  URL or Intermediary object of the trusted intermediary to use, otherwise uses default\r\n     * @throws {Error}                  If no trusted intermediary specified\r\n     */\r\n    createTrustedOnchainForGasSwap(chainId, signer, amount, refundAddress, trustedIntermediaryOrUrl) {\r\n        if (this.chains[chainId] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainId);\r\n        if (!this.chains[chainId].chainInterface.isValidAddress(signer))\r\n            throw new Error(\"Invalid \" + chainId + \" address\");\r\n        const useUrl = trustedIntermediaryOrUrl ?? this.defaultTrustedIntermediary ?? this.options.defaultTrustedIntermediaryUrl;\r\n        if (useUrl == null)\r\n            throw new Error(\"No trusted intermediary specified!\");\r\n        return this.chains[chainId].wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTC].create(signer, amount, useUrl, refundAddress);\r\n    }\r\n    /**\r\n     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)\r\n     *  or output amount (exactIn=false), NOTE: For regular -> BTC-LN (lightning) swaps the passed amount is ignored and\r\n     *  invoice's pre-set amount is used instead.\r\n     * @deprecated Use swap() instead\r\n     *\r\n     * @param signer Smartchain (Solana, Starknet, etc.) address of the user\r\n     * @param srcToken Source token of the swap, user pays this token\r\n     * @param dstToken Destination token of the swap, user receives this token\r\n     * @param amount Amount of the swap\r\n     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)\r\n     * @param addressLnurlLightningInvoice Bitcoin on-chain address, lightning invoice, LNURL-pay to pay or\r\n     *  LNURL-withdrawal to withdraw money from\r\n     */\r\n    create(signer, srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice) {\r\n        if (srcToken.chain === \"BTC\") {\r\n            return this.swap(srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice, signer);\r\n        }\r\n        else {\r\n            return this.swap(srcToken, dstToken, amount, exactIn, signer, addressLnurlLightningInvoice);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)\r\n     *  or output amount (exactIn=false), NOTE: For regular SmartChain -> BTC-LN (lightning) swaps the passed amount is ignored and\r\n     *  invoice's pre-set amount is used instead, use LNURL-pay for dynamic amounts\r\n     *\r\n     * @param srcToken Source token of the swap, user pays this token\r\n     * @param dstToken Destination token of the swap, user receives this token\r\n     * @param amount Amount of the swap\r\n     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)\r\n     * @param src Source wallet/lnurl-withdraw of the swap\r\n     * @param dst Destination smart chain address, bitcoin on-chain address, lightning invoice, LNURL-pay\r\n     * @param options Options for the swap\r\n     */\r\n    swap(srcToken, dstToken, amount, exactIn, src, dst, options) {\r\n        if (srcToken.chain === \"BTC\") {\r\n            if (dstToken.chain === \"SC\") {\r\n                if (typeof (dst) !== \"string\")\r\n                    throw new Error(\"Destination for BTC/BTC-LN -> smart chain swaps must be a smart chain address!\");\r\n                if (srcToken.lightning) {\r\n                    //FROM_BTCLN\r\n                    if (src != null) {\r\n                        if (typeof (src) !== \"string\" && !(0, LNURL_1.isLNURLWithdraw)(src))\r\n                            throw new Error(\"LNURL must be a string or LNURLWithdraw object!\");\r\n                        return this.createFromBTCLNSwapViaLNURL(dstToken.chainId, dst, dstToken.address, src, amount, !exactIn);\r\n                    }\r\n                    else {\r\n                        return this.createFromBTCLNSwap(dstToken.chainId, dst, dstToken.address, amount, !exactIn, undefined, options);\r\n                    }\r\n                }\r\n                else {\r\n                    //FROM_BTC\r\n                    if (this.supportsSwapType(dstToken.chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {\r\n                        return this.createFromBTCSwapNew(dstToken.chainId, dst, dstToken.address, amount, !exactIn, undefined, options);\r\n                    }\r\n                    else {\r\n                        return this.createFromBTCSwap(dstToken.chainId, dst, dstToken.address, amount, !exactIn, undefined, options);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (dstToken.chain === \"BTC\") {\r\n                if (typeof (src) !== \"string\")\r\n                    throw new Error(\"Source address for BTC/BTC-LN -> smart chain swaps must be a smart chain address!\");\r\n                if (dstToken.lightning) {\r\n                    //TO_BTCLN\r\n                    if (typeof (dst) !== \"string\" && !(0, LNURL_1.isLNURLPay)(dst))\r\n                        throw new Error(\"Destination LNURL link/lightning invoice must be a string or LNURLPay object!\");\r\n                    if ((0, LNURL_1.isLNURLPay)(dst) || this.Utils.isValidLNURL(dst)) {\r\n                        return this.createToBTCLNSwapViaLNURL(srcToken.chainId, src, srcToken.address, dst, amount, exactIn, undefined, options);\r\n                    }\r\n                    else if (this.Utils.isLightningInvoice(dst)) {\r\n                        if (!this.Utils.isValidLightningInvoice(dst))\r\n                            throw new Error(\"Invalid lightning invoice specified, lightning invoice MUST contain pre-set amount!\");\r\n                        if (exactIn)\r\n                            throw new Error(\"Only exact out swaps are possible with lightning invoices, use LNURL links for exact in lightning swaps!\");\r\n                        return this.createToBTCLNSwap(srcToken.chainId, src, srcToken.address, dst, undefined, options);\r\n                    }\r\n                    else {\r\n                        throw new Error(\"Supplied parameter is not LNURL link nor lightning invoice (bolt11)!\");\r\n                    }\r\n                }\r\n                else {\r\n                    //TO_BTC\r\n                    if (typeof (dst) !== \"string\")\r\n                        throw new Error(\"Destination bitcoin address must be a string!\");\r\n                    return this.createToBTCSwap(srcToken.chainId, src, srcToken.address, dst, amount, exactIn, undefined, options);\r\n                }\r\n            }\r\n        }\r\n        throw new Error(\"Unsupported swap type\");\r\n    }\r\n    async getAllSwaps(chainId, signer) {\r\n        const queryParams = [];\r\n        if (signer != null)\r\n            queryParams.push({ key: \"intiator\", value: signer });\r\n        if (chainId == null) {\r\n            const res = await Promise.all(Object.keys(this.chains).map((chainId) => {\r\n                const { unifiedSwapStorage, reviver } = this.chains[chainId];\r\n                return unifiedSwapStorage.query([queryParams], reviver);\r\n            }));\r\n            return res.flat();\r\n        }\r\n        else {\r\n            const { unifiedSwapStorage, reviver } = this.chains[chainId];\r\n            return await unifiedSwapStorage.query([queryParams], reviver);\r\n        }\r\n    }\r\n    async getActionableSwaps(chainId, signer) {\r\n        if (chainId == null) {\r\n            const res = await Promise.all(Object.keys(this.chains).map((chainId) => {\r\n                const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];\r\n                const queryParams = [];\r\n                for (let key in wrappers) {\r\n                    const wrapper = wrappers[key];\r\n                    const swapTypeQueryParams = [{ key: \"type\", value: wrapper.TYPE }];\r\n                    if (signer != null)\r\n                        swapTypeQueryParams.push({ key: \"intiator\", value: signer });\r\n                    swapTypeQueryParams.push({ key: \"state\", value: wrapper.pendingSwapStates });\r\n                    queryParams.push(swapTypeQueryParams);\r\n                }\r\n                return unifiedSwapStorage.query(queryParams, reviver);\r\n            }));\r\n            return res.flat().filter(swap => swap.requiresAction());\r\n        }\r\n        else {\r\n            const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];\r\n            const queryParams = [];\r\n            for (let key in wrappers) {\r\n                const wrapper = wrappers[key];\r\n                const swapTypeQueryParams = [{ key: \"type\", value: wrapper.TYPE }];\r\n                if (signer != null)\r\n                    swapTypeQueryParams.push({ key: \"intiator\", value: signer });\r\n                swapTypeQueryParams.push({ key: \"state\", value: wrapper.pendingSwapStates });\r\n                queryParams.push(swapTypeQueryParams);\r\n            }\r\n            return (await unifiedSwapStorage.query(queryParams, reviver)).filter(swap => swap.requiresAction());\r\n        }\r\n    }\r\n    async getRefundableSwaps(chainId, signer) {\r\n        if (chainId == null) {\r\n            const res = await Promise.all(Object.keys(this.chains).map((chainId) => {\r\n                const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];\r\n                const queryParams = [];\r\n                for (let wrapper of [wrappers[SwapType_1.SwapType.TO_BTCLN], wrappers[SwapType_1.SwapType.TO_BTC]]) {\r\n                    const swapTypeQueryParams = [{ key: \"type\", value: wrapper.TYPE }];\r\n                    if (signer != null)\r\n                        swapTypeQueryParams.push({ key: \"initiator\", value: signer });\r\n                    swapTypeQueryParams.push({ key: \"state\", value: wrapper.refundableSwapStates });\r\n                    queryParams.push(swapTypeQueryParams);\r\n                }\r\n                return unifiedSwapStorage.query(queryParams, reviver);\r\n            }));\r\n            return res.flat().filter(swap => swap.isRefundable());\r\n        }\r\n        else {\r\n            const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];\r\n            const queryParams = [];\r\n            for (let wrapper of [wrappers[SwapType_1.SwapType.TO_BTCLN], wrappers[SwapType_1.SwapType.TO_BTC]]) {\r\n                const swapTypeQueryParams = [{ key: \"type\", value: wrapper.TYPE }];\r\n                if (signer != null)\r\n                    swapTypeQueryParams.push({ key: \"initiator\", value: signer });\r\n                swapTypeQueryParams.push({ key: \"state\", value: wrapper.refundableSwapStates });\r\n                queryParams.push(swapTypeQueryParams);\r\n            }\r\n            const result = await unifiedSwapStorage.query(queryParams, reviver);\r\n            return result.filter(swap => swap.isRefundable());\r\n        }\r\n    }\r\n    async getSwapById(id, chainId, signer) {\r\n        //Check in pending swaps first\r\n        if (chainId != null) {\r\n            for (let key in this.chains[chainId].wrappers) {\r\n                const wrapper = this.chains[chainId].wrappers[key];\r\n                const result = wrapper.pendingSwaps.get(id)?.deref();\r\n                if (result != null) {\r\n                    if (signer != null) {\r\n                        if (result._getInitiator() === signer)\r\n                            return result;\r\n                    }\r\n                    else {\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let chainId in this.chains) {\r\n                for (let key in this.chains[chainId].wrappers) {\r\n                    const wrapper = this.chains[chainId].wrappers[key];\r\n                    const result = wrapper.pendingSwaps.get(id)?.deref();\r\n                    if (result != null) {\r\n                        if (signer != null) {\r\n                            if (result._getInitiator() === signer)\r\n                                return result;\r\n                        }\r\n                        else {\r\n                            return result;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        const queryParams = [];\r\n        if (signer != null)\r\n            queryParams.push({ key: \"intiator\", value: signer });\r\n        queryParams.push({ key: \"id\", value: id });\r\n        if (chainId == null) {\r\n            const res = await Promise.all(Object.keys(this.chains).map((chainId) => {\r\n                const { unifiedSwapStorage, reviver } = this.chains[chainId];\r\n                return unifiedSwapStorage.query([queryParams], reviver);\r\n            }));\r\n            return res.flat()[0];\r\n        }\r\n        else {\r\n            const { unifiedSwapStorage, reviver } = this.chains[chainId];\r\n            return (await unifiedSwapStorage.query([queryParams], reviver))[0];\r\n        }\r\n    }\r\n    /**\r\n     * Synchronizes swaps from chain, this is usually ran when SDK is initialized, deletes expired quotes\r\n     *\r\n     * @param chainId\r\n     * @param signer\r\n     */\r\n    async _syncSwaps(chainId, signer) {\r\n        if (chainId == null) {\r\n            await Promise.all(Object.keys(this.chains).map(async (chainId) => {\r\n                const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];\r\n                const queryParams = [];\r\n                for (let key in wrappers) {\r\n                    const wrapper = wrappers[key];\r\n                    const swapTypeQueryParams = [{ key: \"type\", value: wrapper.TYPE }];\r\n                    if (signer != null)\r\n                        swapTypeQueryParams.push({ key: \"intiator\", value: signer });\r\n                    swapTypeQueryParams.push({ key: \"state\", value: wrapper.pendingSwapStates });\r\n                    queryParams.push(swapTypeQueryParams);\r\n                }\r\n                this.logger.debug(\"_syncSwaps(): Querying swaps swaps for chain \" + chainId + \"!\");\r\n                const swaps = await unifiedSwapStorage.query(queryParams, reviver);\r\n                this.logger.debug(\"_syncSwaps(): Syncing \" + swaps.length + \" swaps!\");\r\n                const changedSwaps = [];\r\n                const removeSwaps = [];\r\n                for (let swap of swaps) {\r\n                    this.logger.debug(\"_syncSwaps(): Syncing swap: \" + swap.getId());\r\n                    const swapChanged = await swap._sync(false).catch(e => this.logger.warn(\"_syncSwaps(): Error in swap: \" + swap.getId(), e));\r\n                    this.logger.debug(\"_syncSwaps(): Synced swap: \" + swap.getId());\r\n                    if (swap.isQuoteExpired()) {\r\n                        removeSwaps.push(swap);\r\n                    }\r\n                    else {\r\n                        if (swapChanged)\r\n                            changedSwaps.push(swap);\r\n                    }\r\n                }\r\n                this.logger.debug(\"_syncSwaps(): Done syncing \" + swaps.length + \" swaps, saving \" + changedSwaps.length + \" changed swaps, removing \" + removeSwaps.length + \" swaps!\");\r\n                await unifiedSwapStorage.saveAll(changedSwaps);\r\n                await unifiedSwapStorage.removeAll(removeSwaps);\r\n            }));\r\n        }\r\n        else {\r\n            const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];\r\n            const queryParams = [];\r\n            for (let key in wrappers) {\r\n                const wrapper = wrappers[key];\r\n                const swapTypeQueryParams = [{ key: \"type\", value: wrapper.TYPE }];\r\n                if (signer != null)\r\n                    swapTypeQueryParams.push({ key: \"intiator\", value: signer });\r\n                swapTypeQueryParams.push({ key: \"state\", value: wrapper.pendingSwapStates });\r\n                queryParams.push(swapTypeQueryParams);\r\n            }\r\n            this.logger.debug(\"_syncSwaps(): Querying swaps swaps for chain \" + chainId + \"!\");\r\n            const swaps = await unifiedSwapStorage.query(queryParams, reviver);\r\n            this.logger.debug(\"_syncSwaps(): Syncing \" + swaps.length + \" swaps!\");\r\n            const changedSwaps = [];\r\n            const removeSwaps = [];\r\n            for (let swap of swaps) {\r\n                this.logger.debug(\"_syncSwaps(): Syncing swap: \" + swap.getId());\r\n                const swapChanged = await swap._sync(false).catch(e => this.logger.warn(\"_syncSwaps(): Error in swap: \" + swap.getId(), e));\r\n                this.logger.debug(\"_syncSwaps(): Synced swap: \" + swap.getId());\r\n                if (swap.isQuoteExpired()) {\r\n                    removeSwaps.push(swap);\r\n                }\r\n                else {\r\n                    if (swapChanged)\r\n                        changedSwaps.push(swap);\r\n                }\r\n            }\r\n            this.logger.debug(\"_syncSwaps(): Done syncing \" + swaps.length + \" swaps, saving \" + changedSwaps.length + \" changed swaps, removing \" + removeSwaps.length + \" swaps!\");\r\n            await unifiedSwapStorage.saveAll(changedSwaps);\r\n            await unifiedSwapStorage.removeAll(removeSwaps);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a child swapper instance with a given smart chain\r\n     *\r\n     * @param chainIdentifier\r\n     */\r\n    withChain(chainIdentifier) {\r\n        if (this.chains[chainIdentifier] == null)\r\n            throw new Error(\"Invalid chain identifier! Unknown chain: \" + chainIdentifier);\r\n        return new SwapperWithChain_1.SwapperWithChain(this, chainIdentifier);\r\n    }\r\n    /**\r\n     * Returns supported smart chains\r\n     */\r\n    getSmartChains() {\r\n        return Object.keys(this.chains);\r\n    }\r\n    /**\r\n     * Returns whether the SDK supports a given swap type on a given chain based on currently known LPs\r\n     *\r\n     * @param chainId\r\n     * @param swapType\r\n     */\r\n    supportsSwapType(chainId, swapType) {\r\n        return (this.chains[chainId]?.wrappers[swapType] != null);\r\n    }\r\n    getSwapType(srcToken, dstToken) {\r\n        if ((0, Tokens_1.isSCToken)(srcToken)) {\r\n            if (!(0, Tokens_1.isBtcToken)(dstToken))\r\n                throw new Error(\"Swap not supported\");\r\n            if (dstToken.lightning) {\r\n                return SwapType_1.SwapType.TO_BTCLN;\r\n            }\r\n            else {\r\n                return SwapType_1.SwapType.TO_BTC;\r\n            }\r\n        }\r\n        else if ((0, Tokens_1.isBtcToken)(srcToken)) {\r\n            if (!(0, Tokens_1.isSCToken)(dstToken))\r\n                throw new Error(\"Swap not supported\");\r\n            if (srcToken.lightning) {\r\n                return SwapType_1.SwapType.FROM_BTCLN;\r\n            }\r\n            else {\r\n                if (this.supportsSwapType(dstToken.chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {\r\n                    return SwapType_1.SwapType.SPV_VAULT_FROM_BTC;\r\n                }\r\n                else {\r\n                    return SwapType_1.SwapType.FROM_BTC;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns minimum/maximum limits for inputs and outputs for a swap between given tokens\r\n     *\r\n     * @param srcToken\r\n     * @param dstToken\r\n     */\r\n    getSwapLimits(srcToken, dstToken) {\r\n        const swapType = this.getSwapType(srcToken, dstToken);\r\n        const scToken = (0, Tokens_1.isSCToken)(srcToken) ? srcToken : (0, Tokens_1.isSCToken)(dstToken) ? dstToken : null;\r\n        const result = {\r\n            input: { min: null, max: null },\r\n            output: { min: null, max: null }\r\n        };\r\n        for (let lp of this.intermediaryDiscovery.intermediaries) {\r\n            const lpMinMax = lp.getSwapLimits(swapType, scToken.chainId, scToken.address);\r\n            if (lpMinMax == null)\r\n                continue;\r\n            result.input.min = result.input.min == null ? lpMinMax.input.min : (0, Utils_1.bigIntMin)(result.input.min, lpMinMax.input.min);\r\n            result.input.max = result.input.max == null ? lpMinMax.input.max : (0, Utils_1.bigIntMax)(result.input.max, lpMinMax.input.max);\r\n            result.output.min = result.output.min == null ? lpMinMax.output.min : (0, Utils_1.bigIntMin)(result.output.min, lpMinMax.output.min);\r\n            result.output.max = result.output.max == null ? lpMinMax.output.max : (0, Utils_1.bigIntMax)(result.output.max, lpMinMax.output.max);\r\n        }\r\n        return {\r\n            input: {\r\n                min: (0, Tokens_1.toTokenAmount)(result.input.min ?? 1n, srcToken, this.prices),\r\n                max: (0, Tokens_1.toTokenAmount)(result.input.max, srcToken, this.prices),\r\n            },\r\n            output: {\r\n                min: (0, Tokens_1.toTokenAmount)(result.output.min ?? 1n, dstToken, this.prices),\r\n                max: (0, Tokens_1.toTokenAmount)(result.output.max, dstToken, this.prices),\r\n            }\r\n        };\r\n    }\r\n    /**\r\n     * Returns supported tokens for a given direction\r\n     *\r\n     * @param input Whether to return input tokens or output tokens\r\n     */\r\n    getSupportedTokens(input) {\r\n        const tokens = {};\r\n        let lightning = false;\r\n        let btc = false;\r\n        this.intermediaryDiscovery.intermediaries.forEach(lp => {\r\n            for (let swapType of [SwapType_1.SwapType.TO_BTC, SwapType_1.SwapType.TO_BTCLN, SwapType_1.SwapType.FROM_BTC, SwapType_1.SwapType.FROM_BTCLN, SwapType_1.SwapType.SPV_VAULT_FROM_BTC]) {\r\n                if (lp.services[swapType] == null)\r\n                    continue;\r\n                if (lp.services[swapType].chainTokens == null)\r\n                    continue;\r\n                for (let chainId of this.getSmartChains()) {\r\n                    if (this.supportsSwapType(chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC) ? swapType === SwapType_1.SwapType.FROM_BTC : swapType === SwapType_1.SwapType.SPV_VAULT_FROM_BTC)\r\n                        continue;\r\n                    if (lp.services[swapType].chainTokens[chainId] == null)\r\n                        continue;\r\n                    for (let tokenAddress of lp.services[swapType].chainTokens[chainId]) {\r\n                        if (input) {\r\n                            if (swapType === SwapType_1.SwapType.TO_BTC || swapType === SwapType_1.SwapType.TO_BTCLN) {\r\n                                tokens[chainId] ??= new Set();\r\n                                tokens[chainId].add(tokenAddress);\r\n                            }\r\n                            if (swapType === SwapType_1.SwapType.FROM_BTCLN) {\r\n                                lightning = true;\r\n                            }\r\n                            if (swapType === SwapType_1.SwapType.FROM_BTC || swapType === SwapType_1.SwapType.SPV_VAULT_FROM_BTC) {\r\n                                btc = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (swapType === SwapType_1.SwapType.FROM_BTCLN || swapType === SwapType_1.SwapType.FROM_BTC || swapType === SwapType_1.SwapType.SPV_VAULT_FROM_BTC) {\r\n                                tokens[chainId] ??= new Set();\r\n                                tokens[chainId].add(tokenAddress);\r\n                            }\r\n                            if (swapType === SwapType_1.SwapType.TO_BTCLN) {\r\n                                lightning = true;\r\n                            }\r\n                            if (swapType === SwapType_1.SwapType.TO_BTC) {\r\n                                btc = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        const output = [];\r\n        if (lightning)\r\n            output.push(Tokens_1.BitcoinTokens.BTCLN);\r\n        if (btc)\r\n            output.push(Tokens_1.BitcoinTokens.BTC);\r\n        for (let chainId in tokens) {\r\n            tokens[chainId].forEach(tokenAddress => {\r\n                const token = this.tokens?.[chainId]?.[tokenAddress];\r\n                if (token != null)\r\n                    output.push(token);\r\n            });\r\n        }\r\n        return output;\r\n    }\r\n    /**\r\n     * Returns a set of supported tokens by all the intermediaries offering a specific swap service\r\n     *\r\n     * @param _swapType Swap service type to check supported tokens for\r\n     */\r\n    getSupportedTokensForSwapType(_swapType) {\r\n        const tokens = {};\r\n        this.intermediaryDiscovery.intermediaries.forEach(lp => {\r\n            for (let chainId of this.getSmartChains()) {\r\n                let swapType = _swapType;\r\n                if (swapType === SwapType_1.SwapType.FROM_BTC && this.supportsSwapType(chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC))\r\n                    swapType = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;\r\n                if (lp.services[swapType] == null)\r\n                    break;\r\n                if (lp.services[swapType].chainTokens == null)\r\n                    break;\r\n                if (lp.services[swapType].chainTokens[chainId] == null)\r\n                    continue;\r\n                for (let tokenAddress of lp.services[swapType].chainTokens[chainId]) {\r\n                    tokens[chainId] ??= new Set();\r\n                    tokens[chainId].add(tokenAddress);\r\n                }\r\n            }\r\n        });\r\n        const output = [];\r\n        for (let chainId in tokens) {\r\n            tokens[chainId].forEach(tokenAddress => {\r\n                const token = this.tokens?.[chainId]?.[tokenAddress];\r\n                if (token != null)\r\n                    output.push(token);\r\n            });\r\n        }\r\n        return output;\r\n    }\r\n    /**\r\n     * Returns the set of supported token addresses by all the intermediaries we know of offering a specific swapType service\r\n     *\r\n     * @param chainIdentifier\r\n     * @param swapType Specific swap type for which to obtain supported tokens\r\n     */\r\n    getSupportedTokenAddresses(chainIdentifier, swapType) {\r\n        const set = new Set();\r\n        this.intermediaryDiscovery.intermediaries.forEach(lp => {\r\n            if (lp.services[swapType] == null)\r\n                return;\r\n            if (lp.services[swapType].chainTokens == null || lp.services[swapType].chainTokens[chainIdentifier] == null)\r\n                return;\r\n            lp.services[swapType].chainTokens[chainIdentifier].forEach(token => set.add(token));\r\n        });\r\n        return set;\r\n    }\r\n    /**\r\n     * Returns tokens that you can swap to (if input=true) from a given token,\r\n     *  or tokens that you can swap from (if input=false) to a given token\r\n     */\r\n    getSwapCounterTokens(token, input) {\r\n        if ((0, Tokens_1.isSCToken)(token)) {\r\n            const result = [];\r\n            if (input) {\r\n                //TO_BTC or TO_BTCLN\r\n                if (this.getSupportedTokenAddresses(token.chainId, SwapType_1.SwapType.TO_BTCLN).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTCLN);\r\n                }\r\n                if (this.getSupportedTokenAddresses(token.chainId, SwapType_1.SwapType.TO_BTC).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTC);\r\n                }\r\n            }\r\n            else {\r\n                //FROM_BTC or FROM_BTCLN\r\n                if (this.getSupportedTokenAddresses(token.chainId, SwapType_1.SwapType.FROM_BTCLN).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTCLN);\r\n                }\r\n                const fromOnchainSwapType = this.supportsSwapType(token.chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC) ? SwapType_1.SwapType.SPV_VAULT_FROM_BTC : SwapType_1.SwapType.FROM_BTC;\r\n                if (this.getSupportedTokenAddresses(token.chainId, fromOnchainSwapType).has(token.address)) {\r\n                    result.push(Tokens_1.BitcoinTokens.BTC);\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            if (input) {\r\n                if (token.lightning) {\r\n                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.FROM_BTCLN);\r\n                }\r\n                else {\r\n                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.FROM_BTC);\r\n                }\r\n            }\r\n            else {\r\n                if (token.lightning) {\r\n                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.TO_BTCLN);\r\n                }\r\n                else {\r\n                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.TO_BTC);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    getSwapBounds(chainIdentifier) {\r\n        if (this.intermediaryDiscovery != null) {\r\n            if (chainIdentifier == null) {\r\n                return this.intermediaryDiscovery.getMultichainSwapBounds();\r\n            }\r\n            else {\r\n                return this.intermediaryDiscovery.getSwapBounds(chainIdentifier);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Returns maximum possible swap amount\r\n     * @deprecated Use getSwapLimits() instead!\r\n     *\r\n     * @param chainIdentifier\r\n     * @param type      Type of the swap\r\n     * @param token     Token of the swap\r\n     */\r\n    getMaximum(chainIdentifier, type, token) {\r\n        if (this.intermediaryDiscovery != null) {\r\n            const max = this.intermediaryDiscovery.getSwapMaximum(chainIdentifier, type, token);\r\n            if (max != null)\r\n                return BigInt(max);\r\n        }\r\n        return 0n;\r\n    }\r\n    /**\r\n     * Returns minimum possible swap amount\r\n     * @deprecated Use getSwapLimits() instead!\r\n     *\r\n     * @param chainIdentifier\r\n     * @param type      Type of swap\r\n     * @param token     Token of the swap\r\n     */\r\n    getMinimum(chainIdentifier, type, token) {\r\n        if (this.intermediaryDiscovery != null) {\r\n            const min = this.intermediaryDiscovery.getSwapMinimum(chainIdentifier, type, token);\r\n            if (min != null)\r\n                return BigInt(min);\r\n        }\r\n        return 0n;\r\n    }\r\n}\r\nexports.Swapper = Swapper;\r\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13069, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/storage/IUnifiedStorage.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n"],"names":[],"mappings":"AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 13076, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40atomiqlabs/sdk-lib/dist/index.js"],"sourcesContent":["\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./btc/mempool/synchronizer/MempoolBtcRelaySynchronizer\"), exports);\r\n__exportStar(require(\"./btc/mempool/MempoolApi\"), exports);\r\n__exportStar(require(\"./btc/mempool/MempoolBitcoinRpc\"), exports);\r\n__exportStar(require(\"./btc/mempool/MempoolBitcoinBlock\"), exports);\r\n__exportStar(require(\"./btc/BitcoinRpcWithAddressIndex\"), exports);\r\n__exportStar(require(\"./btc/LightningNetworkApi\"), exports);\r\n__exportStar(require(\"./btc/wallet/IBitcoinWallet\"), exports);\r\n__exportStar(require(\"./btc/wallet/BitcoinWallet\"), exports);\r\n__exportStar(require(\"./btc/wallet/SingleAddressBitcoinWallet\"), exports);\r\n__exportStar(require(\"./btc/coinselect2\"), exports);\r\n__exportStar(require(\"./errors/IntermediaryError\"), exports);\r\n__exportStar(require(\"./errors/PaymentAuthError\"), exports);\r\n__exportStar(require(\"./errors/RequestError\"), exports);\r\n__exportStar(require(\"./errors/UserError\"), exports);\r\n__exportStar(require(\"./intermediaries/Intermediary\"), exports);\r\n__exportStar(require(\"./intermediaries/IntermediaryDiscovery\"), exports);\r\n__exportStar(require(\"./prices/abstract/ICachedSwapPrice\"), exports);\r\n__exportStar(require(\"./prices/abstract/IPriceProvider\"), exports);\r\n__exportStar(require(\"./prices/abstract/ISwapPrice\"), exports);\r\n__exportStar(require(\"./prices/providers/abstract/ExchangePriceProvider\"), exports);\r\n__exportStar(require(\"./prices/providers/abstract/HttpPriceProvider\"), exports);\r\n__exportStar(require(\"./prices/providers/BinancePriceProvider\"), exports);\r\n__exportStar(require(\"./prices/providers/CoinGeckoPriceProvider\"), exports);\r\n__exportStar(require(\"./prices/providers/CoinPaprikaPriceProvider\"), exports);\r\n__exportStar(require(\"./prices/providers/OKXPriceProvider\"), exports);\r\n__exportStar(require(\"./prices/providers/CustomPriceProvider\"), exports);\r\n__exportStar(require(\"./prices/RedundantSwapPrice\"), exports);\r\n__exportStar(require(\"./prices/SingleSwapPrice\"), exports);\r\n__exportStar(require(\"./prices/SwapPriceWithChain\"), exports);\r\n__exportStar(require(\"./Tokens\"), exports);\r\n__exportStar(require(\"./swaps/ISwap\"), exports);\r\n__exportStar(require(\"./swaps/IAddressSwap\"), exports);\r\n__exportStar(require(\"./swaps/ISwapWrapper\"), exports);\r\n__exportStar(require(\"./swaps/swapper/Swapper\"), exports);\r\n__exportStar(require(\"./swaps/swapper/SwapperWithChain\"), exports);\r\n__exportStar(require(\"./swaps/swapper/SwapperWithSigner\"), exports);\r\n__exportStar(require(\"./swaps/swapper/utils/SwapperUtils\"), exports);\r\n__exportStar(require(\"./swaps/enums/SwapType\"), exports);\r\n__exportStar(require(\"./swaps/enums/SwapDirection\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/IEscrowSwapWrapper\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/IEscrowSwap\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/tobtc/IToBTCSwap\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/tobtc/IToBTCWrapper\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/tobtc/ln/ToBTCLNSwap\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/tobtc/ln/ToBTCLNWrapper\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/tobtc/onchain/ToBTCSwap\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/tobtc/onchain/ToBTCWrapper\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/frombtc/IFromBTCSwap\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/frombtc/IFromBTCWrapper\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/frombtc/ln/FromBTCLNSwap\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/frombtc/ln/FromBTCLNWrapper\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/frombtc/onchain/FromBTCSwap\"), exports);\r\n__exportStar(require(\"./swaps/escrow_swaps/frombtc/onchain/FromBTCWrapper\"), exports);\r\n__exportStar(require(\"./swaps/trusted/ln/LnForGasSwap\"), exports);\r\n__exportStar(require(\"./swaps/trusted/ln/LnForGasWrapper\"), exports);\r\n__exportStar(require(\"./swaps/trusted/onchain/OnchainForGasSwap\"), exports);\r\n__exportStar(require(\"./swaps/trusted/onchain/OnchainForGasWrapper\"), exports);\r\n__exportStar(require(\"./swaps/spv_swaps/SpvFromBTCSwap\"), exports);\r\n__exportStar(require(\"./swaps/spv_swaps/SpvFromBTCWrapper\"), exports);\r\n__exportStar(require(\"./utils/LNURL\"), exports);\r\n__exportStar(require(\"./storage/IUnifiedStorage\"), exports);\r\n__exportStar(require(\"./browser-storage/IndexedDBUnifiedStorage\"), exports);\r\n__exportStar(require(\"./swaps/fee/Fee\"), exports);\r\n"],"names":[],"mappings":"AACA,IAAI,kBAAkB,4DAAS,yDAAK,eAAe,IAAK,CAAC,OAAO,MAAM,GAAI,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;IAC1F,IAAI,OAAO,WAAW,KAAK;IAC3B,IAAI,OAAO,OAAO,wBAAwB,CAAC,GAAG;IAC9C,IAAI,CAAC,QAAQ,CAAC,SAAS,OAAO,CAAC,EAAE,UAAU,GAAG,KAAK,QAAQ,IAAI,KAAK,YAAY,GAAG;QACjF,OAAO;YAAE,YAAY;YAAM,KAAK;gBAAa,OAAO,CAAC,CAAC,EAAE;YAAE;QAAE;IAC9D;IACA,OAAO,cAAc,CAAC,GAAG,IAAI;AACjC,IAAM,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE;IACtB,IAAI,OAAO,WAAW,KAAK;IAC3B,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,EAAE;AAChB,CAAE;AACF,IAAI,eAAe,4DAAS,yDAAK,YAAY,IAAK,SAAS,CAAC,EAAE,QAAO;IACjE,IAAK,IAAI,KAAK,EAAG,IAAI,MAAM,aAAa,CAAC,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,UAAS,IAAI,gBAAgB,UAAS,GAAG;AAC3H;AACA,OAAO,cAAc,CAAC,SAAS,cAAc;IAAE,OAAO;AAAK;AAC3D,2KAAgF;AAChF,6IAAkD;AAClD,oJAAyD;AACzD,sJAA2D;AAC3D,qJAA0D;AAC1D,8IAAmD;AACnD,gJAAqD;AACrD,+IAAoD;AACpD,4JAAiE;AACjE,4IAA2C;AAC3C,+IAAoD;AACpD,8IAAmD;AACnD,0IAA+C;AAC/C,uIAA4C;AAC5C,kJAAuD;AACvD,2JAAgE;AAChE,uJAA4D;AAC5D,qJAA0D;AAC1D,iJAAsD;AACtD,sKAA2E;AAC3E,kKAAuE;AACvE,4JAAiE;AACjE,8JAAmE;AACnE,gKAAqE;AACrE,wJAA6D;AAC7D,2JAAgE;AAChE,gJAAqD;AACrD,6IAAkD;AAClD,gJAAqD;AACrD,6HAAkC;AAClC,kIAAuC;AACvC,yIAA8C;AAC9C,yIAA8C;AAC9C,4IAAiD;AACjD,qJAA0D;AAC1D,sJAA2D;AAC3D,uJAA4D;AAC5D,2IAAgD;AAChD,gJAAqD;AACrD,4JAAiE;AACjE,qJAA0D;AAC1D,0JAA+D;AAC/D,6JAAkE;AAClE,8JAAmE;AACnE,iKAAsE;AACtE,iKAAsE;AACtE,oKAAyE;AACzE,8JAAmE;AACnE,iKAAsE;AACtE,kKAAuE;AACvE,qKAA0E;AAC1E,qKAA0E;AAC1E,wKAA6E;AAC7E,oJAAyD;AACzD,uJAA4D;AAC5D,8JAAmE;AACnE,iKAAsE;AACtE,qJAA0D;AAC1D,wJAA6D;AAC7D,kIAAuC;AACvC,8IAAmD;AACnD,8JAAmE;AACnE,oIAAyC","ignoreList":[0],"debugId":null}}]
}