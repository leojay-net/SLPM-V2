(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/refund/TimelockRefundHandler.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TimelockRefundHandler = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
class TimelockRefundHandler {
    getCommitment(data) {
        return data;
    }
    getWitness(signer, data) {
        const expiry = TimelockRefundHandler.getExpiry(data);
        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
        if (expiry > currentTimestamp) throw new Error("Not expired yet!");
        return Promise.resolve({
            initialTxns: [],
            witness: []
        });
    }
    getGas() {
        return TimelockRefundHandler.gas;
    }
    static getExpiry(data) {
        return (0, Utils_1.bigNumberishToBuffer)(data.refundData, 32).readBigUInt64BE(24).valueOf();
    }
    constructor(address){
        this.address = address;
    }
}
exports.TimelockRefundHandler = TimelockRefundHandler;
TimelockRefundHandler.gas = {
    l1DataGas: 0,
    l2Gas: 4000000,
    l1Gas: 0
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapData.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSwapData = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const TimelockRefundHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/refund/TimelockRefundHandler.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const FLAG_PAY_OUT = 0x01n;
const FLAG_PAY_IN = 0x02n;
const FLAG_REPUTATION = 0x04n;
class StarknetSwapData extends base_1.SwapData {
    static toFlags(value) {
        const val = (0, Utils_1.toBigInt)(value);
        return {
            sequence: val >> 64n,
            payOut: (val & FLAG_PAY_OUT) === FLAG_PAY_OUT,
            payIn: (val & FLAG_PAY_IN) === FLAG_PAY_IN,
            reputation: (val & FLAG_REPUTATION) === FLAG_REPUTATION
        };
    }
    getFlags() {
        return (this.sequence << 64n) + (this.payOut ? FLAG_PAY_OUT : 0n) + (this.payIn ? FLAG_PAY_IN : 0n) + (this.reputation ? FLAG_REPUTATION : 0n);
    }
    getOfferer() {
        return this.offerer;
    }
    setOfferer(newOfferer) {
        this.offerer = newOfferer;
        this.payIn = true;
    }
    getClaimer() {
        return this.claimer;
    }
    setClaimer(newClaimer) {
        this.claimer = newClaimer;
        this.payIn = false;
        this.payOut = true;
        this.reputation = false;
    }
    serialize() {
        return {
            type: "strk",
            offerer: this.offerer,
            claimer: this.claimer,
            token: this.token,
            refundHandler: this.refundHandler,
            claimHandler: this.claimHandler,
            payOut: this.payOut,
            payIn: this.payIn,
            reputation: this.reputation,
            sequence: this.sequence == null ? null : this.sequence.toString(10),
            claimData: this.claimData,
            refundData: this.refundData,
            amount: this.amount == null ? null : this.amount.toString(10),
            feeToken: this.feeToken,
            securityDeposit: this.securityDeposit == null ? null : this.securityDeposit.toString(10),
            claimerBounty: this.claimerBounty == null ? null : this.claimerBounty.toString(10),
            kind: this.kind,
            extraData: this.extraData
        };
    }
    getAmount() {
        return this.amount;
    }
    getToken() {
        return this.token;
    }
    isToken(token) {
        return this.token.toLowerCase() === token.toLowerCase();
    }
    getType() {
        return this.kind;
    }
    getExpiry() {
        return TimelockRefundHandler_1.TimelockRefundHandler.getExpiry(this);
    }
    isPayIn() {
        return this.payIn;
    }
    isPayOut() {
        return this.payOut;
    }
    getEscrowHash() {
        const amountValue = starknet_1.cairo.uint256("0x" + this.amount.toString(16));
        const securityDepositValue = starknet_1.cairo.uint256("0x" + this.securityDeposit.toString(16));
        const claimerBountyValue = starknet_1.cairo.uint256("0x" + this.claimerBounty.toString(16));
        let escrowHash = starknet_1.hash.computePoseidonHashOnElements([
            this.offerer,
            this.claimer,
            this.token,
            this.refundHandler,
            this.claimHandler,
            this.getFlags(),
            this.claimData,
            this.refundData,
            amountValue.low,
            amountValue.high,
            this.feeToken,
            securityDepositValue.low,
            securityDepositValue.high,
            claimerBountyValue.low,
            claimerBountyValue.high
        ]);
        if (escrowHash.startsWith("0x")) escrowHash = escrowHash.slice(2);
        return escrowHash.padStart(64, "0");
    }
    getClaimHash() {
        let hash = this.claimData;
        if (hash.startsWith("0x")) hash = hash.slice(2);
        return hash.padStart(64, "0");
    }
    getSequence() {
        return this.sequence;
    }
    getConfirmationsHint() {
        if (this.extraData == null) return null;
        if (this.extraData.length != 84) return null;
        return parseInt(this.extraData.slice(80), 16);
    }
    getNonceHint() {
        if (this.extraData == null) return null;
        if (this.extraData.length != 84) return null;
        return BigInt("0x" + this.extraData.slice(64, 80));
    }
    getTxoHashHint() {
        if (this.extraData == null) return null;
        if (this.extraData.length != 84) return null;
        return this.extraData.slice(0, 64);
    }
    getExtraData() {
        return this.extraData;
    }
    setExtraData(extraData) {
        this.extraData = extraData;
    }
    getSecurityDeposit() {
        return this.securityDeposit;
    }
    getClaimerBounty() {
        return this.claimerBounty;
    }
    getTotalDeposit() {
        return this.claimerBounty < this.securityDeposit ? this.securityDeposit : this.claimerBounty;
    }
    getDepositToken() {
        return this.feeToken;
    }
    isDepositToken(token) {
        if (!token.startsWith("0x")) token = "0x" + token;
        return (0, Utils_1.toHex)(this.feeToken) === (0, Utils_1.toHex)(token);
    }
    isClaimer(address) {
        if (!address.startsWith("0x")) address = "0x" + address;
        return (0, Utils_1.toHex)(this.claimer) === (0, Utils_1.toHex)(address);
    }
    isOfferer(address) {
        if (!address.startsWith("0x")) address = "0x" + address;
        return (0, Utils_1.toHex)(this.offerer) === (0, Utils_1.toHex)(address);
    }
    isRefundHandler(address) {
        if (!address.startsWith("0x")) address = "0x" + address;
        return (0, Utils_1.toHex)(this.refundHandler) === (0, Utils_1.toHex)(address);
    }
    isClaimHandler(address) {
        if (!address.startsWith("0x")) address = "0x" + address;
        return (0, Utils_1.toHex)(this.claimHandler) === (0, Utils_1.toHex)(address);
    }
    isClaimData(data) {
        if (!data.startsWith("0x")) data = "0x" + data;
        return (0, Utils_1.toHex)(this.claimData) === (0, Utils_1.toHex)(data);
    }
    equals(other) {
        return other.offerer.toLowerCase() === this.offerer.toLowerCase() && other.claimer.toLowerCase() === this.claimer.toLowerCase() && other.token.toLowerCase() === this.token.toLowerCase() && other.refundHandler.toLowerCase() === this.refundHandler.toLowerCase() && other.claimHandler.toLowerCase() === this.claimHandler.toLowerCase() && other.payIn === this.payIn && other.payOut === this.payOut && other.reputation === this.reputation && this.sequence === other.sequence && other.claimData.toLowerCase() === this.claimData.toLowerCase() && other.refundData.toLowerCase() === this.refundData.toLowerCase() && other.amount === this.amount && other.securityDeposit === this.securityDeposit && other.claimerBounty === this.claimerBounty;
    }
    toEscrowStruct() {
        return {
            offerer: this.offerer,
            claimer: this.claimer,
            token: this.token,
            refund_handler: this.refundHandler,
            claim_handler: this.claimHandler,
            flags: this.getFlags(),
            claim_data: this.claimData,
            refund_data: this.refundData,
            amount: starknet_1.cairo.uint256((0, Utils_1.toBigInt)(this.amount)),
            fee_token: this.feeToken,
            security_deposit: starknet_1.cairo.uint256((0, Utils_1.toBigInt)(this.securityDeposit)),
            claimer_bounty: starknet_1.cairo.uint256((0, Utils_1.toBigInt)(this.claimerBounty)),
            success_action: new starknet_1.CairoOption(starknet_1.CairoOptionVariant.None) //For now enforce no success action
        };
    }
    static fromSerializedFeltArray(span, claimHandlerImpl) {
        const offerer = (0, Utils_1.toHex)(span.shift());
        const claimer = (0, Utils_1.toHex)(span.shift());
        const token = (0, Utils_1.toHex)(span.shift());
        const refundHandler = (0, Utils_1.toHex)(span.shift());
        const claimHandler = (0, Utils_1.toHex)(span.shift());
        const { payOut, payIn, reputation, sequence } = StarknetSwapData.toFlags(span.shift());
        const claimData = (0, Utils_1.toHex)(span.shift());
        const refundData = (0, Utils_1.toHex)(span.shift());
        const amount = (0, Utils_1.toBigInt)({
            low: span.shift(),
            high: span.shift()
        });
        const feeToken = (0, Utils_1.toHex)(span.shift());
        const securityDeposit = (0, Utils_1.toBigInt)({
            low: span.shift(),
            high: span.shift()
        });
        const claimerBounty = (0, Utils_1.toBigInt)({
            low: span.shift(),
            high: span.shift()
        });
        const hasSuccessAction = (0, Utils_1.toBigInt)(span.shift()) === 0n;
        if (hasSuccessAction) {
            const executionHash = (0, Utils_1.toHex)(span.shift());
            const executionExpiry = (0, Utils_1.toBigInt)(span.shift());
            const executionFee = (0, Utils_1.toBigInt)({
                low: span.shift(),
                high: span.shift()
            });
        // throw new Error("Success action not allowed!");
        }
        return new StarknetSwapData(offerer, claimer, token, refundHandler, claimHandler, payOut, payIn, reputation, sequence, claimData, refundData, amount, feeToken, securityDeposit, claimerBounty, claimHandlerImpl.getType(), null);
    }
    constructor(offererOrData, claimer, token, refundHandler, claimHandler, payOut, payIn, reputation, sequence, claimData, refundData, amount, feeToken, securityDeposit, claimerBounty, kind, extraData){
        super();
        if (claimer != null || token != null || refundHandler != null || claimHandler != null || payOut != null || payIn != null || reputation != null || sequence != null || claimData != null || refundData != null || amount != null || feeToken != null || securityDeposit != null || claimerBounty != null) {
            this.offerer = offererOrData;
            this.claimer = claimer;
            this.token = token;
            this.refundHandler = refundHandler;
            this.claimHandler = claimHandler;
            this.payOut = payOut;
            this.payIn = payIn;
            this.reputation = reputation;
            this.sequence = sequence;
            this.claimData = claimData;
            this.refundData = refundData;
            this.amount = amount;
            this.feeToken = feeToken;
            this.securityDeposit = securityDeposit;
            this.claimerBounty = claimerBounty;
            this.kind = kind;
            this.extraData = extraData;
        } else {
            this.offerer = offererOrData.offerer;
            this.claimer = offererOrData.claimer;
            this.token = offererOrData.token;
            this.refundHandler = offererOrData.refundHandler;
            this.claimHandler = offererOrData.claimHandler;
            this.payOut = offererOrData.payOut;
            this.payIn = offererOrData.payIn;
            this.reputation = offererOrData.reputation;
            this.sequence = offererOrData.sequence == null ? null : BigInt(offererOrData.sequence);
            this.claimData = offererOrData.claimData;
            this.refundData = offererOrData.refundData;
            this.amount = offererOrData.amount == null ? null : BigInt(offererOrData.amount);
            this.feeToken = offererOrData.feeToken;
            this.securityDeposit = offererOrData.securityDeposit == null ? null : BigInt(offererOrData.securityDeposit);
            this.claimerBounty = offererOrData.claimerBounty == null ? null : BigInt(offererOrData.claimerBounty);
            this.kind = offererOrData.kind;
            this.extraData = offererOrData.extraData;
        }
    }
}
exports.StarknetSwapData = StarknetSwapData;
base_1.SwapData.deserializers["strk"] = StarknetSwapData;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.findLastIndex = exports.parseInitFunctionCalldata = exports.poseidonHashRange = exports.bufferToByteArray = exports.bufferToBytes31Span = exports.bytes31SpanToBuffer = exports.toBigInt = exports.bigNumberishToBuffer = exports.u32ReverseEndianness = exports.bufferToU32Array = exports.u32ArrayToBuffer = exports.calculateHash = exports.toHex = exports.tryWithRetries = exports.getLogger = exports.onceAsync = exports.timeoutPromise = exports.isUint256 = void 0;
const starknet_types_08_1 = __turbopack_context__.r("[project]/node_modules/@starknet-io/starknet-types-08/dist/cjs/index.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const StarknetSwapData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapData.js [app-client] (ecmascript)");
function isUint256(val) {
    return val.low != null && val.high != null;
}
exports.isUint256 = isUint256;
function timeoutPromise(timeoutMillis, abortSignal) {
    return new Promise((resolve, reject)=>{
        const timeout = setTimeout(resolve, timeoutMillis);
        if (abortSignal != null) abortSignal.addEventListener("abort", ()=>{
            clearTimeout(timeout);
            reject(new Error("Aborted"));
        });
    });
}
exports.timeoutPromise = timeoutPromise;
function onceAsync(executor) {
    let promise;
    return ()=>{
        if (promise == null) {
            promise = executor();
            return promise;
        } else {
            return promise.catch(()=>promise = executor());
        }
    };
}
exports.onceAsync = onceAsync;
function getLogger(prefix) {
    return {
        // @ts-ignore
        debug: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 3 && console.debug(prefix + msg, ...args);
        },
        // @ts-ignore
        info: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 2 && console.info(prefix + msg, ...args);
        },
        // @ts-ignore
        warn: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return (/*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel == null || /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 1) && console.warn(prefix + msg, ...args);
        },
        // @ts-ignore
        error: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return (/*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel == null || /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 0) && console.error(prefix + msg, ...args);
        }
    };
}
exports.getLogger = getLogger;
const logger = getLogger("Utils: ");
async function tryWithRetries(func, retryPolicy, errorAllowed, abortSignal) {
    retryPolicy = retryPolicy || {};
    retryPolicy.maxRetries = retryPolicy.maxRetries || 5;
    retryPolicy.delay = retryPolicy.delay || 500;
    retryPolicy.exponential = retryPolicy.exponential == null ? true : retryPolicy.exponential;
    let err = null;
    for(let i = 0; i < retryPolicy.maxRetries; i++){
        try {
            const resp = await func();
            return resp;
        } catch (e) {
            if (errorAllowed != null && errorAllowed(e)) throw e;
            err = e;
            logger.error("tryWithRetries(): error on try number: " + i, e);
        }
        if (abortSignal != null && abortSignal.aborted) throw new Error("Aborted");
        if (i !== retryPolicy.maxRetries - 1) {
            await timeoutPromise(retryPolicy.exponential ? retryPolicy.delay * Math.pow(2, i) : retryPolicy.delay, abortSignal);
        }
    }
    throw err;
}
exports.tryWithRetries = tryWithRetries;
function toHex(value) {
    let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64;
    if (value == null) return null;
    switch(typeof value){
        case "string":
            if (value.startsWith("0x")) {
                return "0x" + value.slice(2).padStart(length, "0").toLowerCase();
            } else {
                return "0x" + BigInt(value).toString(16).padStart(length, "0");
            }
        case "number":
        case "bigint":
            return "0x" + value.toString(16).padStart(length, "0");
    }
    return "0x" + value.toString("hex").padStart(length, "0");
}
exports.toHex = toHex;
function calculateHash(tx) {
    const commonData = {
        version: tx.details.version,
        maxFee: tx.details.maxFee,
        chainId: tx.details.chainId,
        nonce: tx.details.nonce,
        accountDeploymentData: tx.details.version === "0x3" ? tx.details.accountDeploymentData : null,
        nonceDataAvailabilityMode: tx.details.version === "0x3" ? starknet_types_08_1.EDAMode[tx.details.nonceDataAvailabilityMode] : null,
        feeDataAvailabilityMode: tx.details.version === "0x3" ? starknet_types_08_1.EDAMode[tx.details.feeDataAvailabilityMode] : null,
        resourceBounds: tx.details.version === "0x3" ? tx.details.resourceBounds : null,
        tip: tx.details.version === "0x3" ? tx.details.tip : null,
        paymasterData: tx.details.version === "0x3" ? tx.details.paymasterData : null
    };
    switch(tx.type){
        case "INVOKE":
            const invokeData = starknet_1.CallData.compile(tx.signed.calldata);
            return tx.txId = starknet_1.hash.calculateInvokeTransactionHash({
                senderAddress: tx.details.walletAddress,
                compiledCalldata: invokeData,
                ...commonData
            });
        case "DEPLOY_ACCOUNT":
            const deployAccountData = starknet_1.CallData.compile(tx.signed.constructorCalldata);
            return tx.txId = starknet_1.hash.calculateDeployAccountTransactionHash({
                contractAddress: tx.tx.contractAddress,
                classHash: tx.signed.classHash,
                constructorCalldata: deployAccountData,
                compiledConstructorCalldata: deployAccountData,
                salt: tx.signed.addressSalt,
                ...commonData
            });
        default:
            throw new Error("Unsupported tx type!");
    }
}
exports.calculateHash = calculateHash;
function u32ArrayToBuffer(arr) {
    const buffer = buffer_1.Buffer.alloc(4 * arr.length);
    for(let i = 0; i < arr.length; i++){
        buffer.writeUInt32BE(Number(arr[i]), i * 4);
    }
    return buffer;
}
exports.u32ArrayToBuffer = u32ArrayToBuffer;
function bufferToU32Array(buffer) {
    const result = [];
    for(let i = 0; i < buffer.length; i += 4){
        result.push(buffer.readUInt32BE(i));
    }
    return result;
}
exports.bufferToU32Array = bufferToU32Array;
function u32ReverseEndianness(value) {
    const valueBN = BigInt(value);
    return Number((valueBN & 0xffn) << 24n | (valueBN & 0xff00n) << 8n | valueBN >> 8n & 0xff00n | valueBN >> 24n & 0xffn);
}
exports.u32ReverseEndianness = u32ReverseEndianness;
function bigNumberishToBuffer(value, length) {
    if (isUint256(value)) {
        return buffer_1.Buffer.concat([
            bigNumberishToBuffer(value.high, 16),
            bigNumberishToBuffer(value.low, 16)
        ]);
    }
    if (typeof value === "string") {
        if (value.startsWith("0x")) {
            value = value.slice(2);
        } else {
            value = BigInt(value).toString(16);
        }
    } else {
        value = value.toString(16);
    }
    if (length != null) value = value.padStart(length * 2, "0");
    const buff = buffer_1.Buffer.from(value, "hex");
    if (buff.length > length) return buff.slice(buff.length - length);
    return buff;
}
exports.bigNumberishToBuffer = bigNumberishToBuffer;
function toBigInt(value) {
    if (value == null) return null;
    if (isUint256(value)) {
        return toBigInt(value.high) << 128n | toBigInt(value.low);
    }
    if (typeof value === "string") {
        if (!value.startsWith("0x")) value = "0x" + value;
        return BigInt(value);
    }
    if (typeof value === "bigint") {
        return value;
    }
    return BigInt(value);
}
exports.toBigInt = toBigInt;
function bytes31SpanToBuffer(span, length) {
    const buffers = [];
    const numFullBytes31 = Math.floor(length / 31);
    const additionalBytes = length - numFullBytes31 * 31;
    const requiredSpanLength = numFullBytes31 + (additionalBytes === 0 ? 0 : 1);
    if (span.length < requiredSpanLength) throw new Error("Not enough bytes in the felt array!");
    let i = 0;
    for(; i < numFullBytes31; i++){
        buffers.push(bigNumberishToBuffer(span[i], 31));
    }
    if (additionalBytes !== 0) buffers.push(bigNumberishToBuffer(span[i], additionalBytes));
    return buffer_1.Buffer.concat(buffers);
}
exports.bytes31SpanToBuffer = bytes31SpanToBuffer;
function bufferToBytes31Span(buffer) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : buffer.length;
    const values = [];
    for(let i = startIndex + 31; i < endIndex; i += 31){
        values.push(BigInt("0x" + buffer.slice(i - 31, i).toString("hex")));
    }
    if (endIndex > startIndex + values.length * 31) values.push(BigInt("0x" + buffer.slice(startIndex + values.length * 31, endIndex).toString("hex")));
    return values;
}
exports.bufferToBytes31Span = bufferToBytes31Span;
function bufferToByteArray(buffer) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : buffer.length;
    const values = [];
    for(let i = startIndex + 31; i < endIndex; i += 31){
        values.push(BigInt("0x" + buffer.slice(i - 31, i).toString("hex")));
    }
    let pendingWord = BigInt(0);
    let pendingWordLen = BigInt(endIndex - (startIndex + values.length * 31));
    if (pendingWordLen !== BigInt(0)) {
        pendingWord = BigInt("0x" + buffer.slice(startIndex + values.length * 31, endIndex).toString("hex"));
    }
    return [
        BigInt(values.length),
        ...values,
        pendingWord,
        pendingWordLen
    ];
}
exports.bufferToByteArray = bufferToByteArray;
function poseidonHashRange(buffer) {
    let startIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, endIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : buffer.length;
    return starknet_1.hash.computePoseidonHashOnElements(bufferToBytes31Span(buffer, startIndex, endIndex));
}
exports.poseidonHashRange = poseidonHashRange;
function parseInitFunctionCalldata(calldata, claimHandler) {
    const escrow = StarknetSwapData_1.StarknetSwapData.fromSerializedFeltArray(calldata, claimHandler);
    const signatureLen = Number(toBigInt(calldata.shift()));
    const signature = calldata.splice(0, signatureLen);
    const timeout = toBigInt(calldata.shift());
    const extraDataLen = Number(toBigInt(calldata.shift()));
    const extraData = calldata.splice(0, extraDataLen);
    if (calldata.length !== 0) throw new Error("Calldata not read fully!");
    return {
        escrow,
        signature,
        timeout,
        extraData
    };
}
exports.parseInitFunctionCalldata = parseInitFunctionCalldata;
function findLastIndex(array, callback) {
    for(let i = array.length - 1; i >= 0; i--){
        if (callback(array[i], i)) return i;
    }
    return -1;
}
exports.findLastIndex = findLastIndex;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetModule = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
class StarknetModule {
    constructor(root){
        this.logger = (0, Utils_1.getLogger)(this.constructor.name + ": ");
        this.provider = root.provider;
        this.retryPolicy = root.retryPolicy;
        this.root = root;
    }
}
exports.StarknetModule = StarknetModule;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/ERC20Abi.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ERC20Abi = void 0;
exports.ERC20Abi = [
    {
        "type": "impl",
        "name": "MintableToken",
        "interface_name": "src::mintable_token_interface::IMintableToken"
    },
    {
        "type": "struct",
        "name": "core::integer::u256",
        "members": [
            {
                "name": "low",
                "type": "core::integer::u128"
            },
            {
                "name": "high",
                "type": "core::integer::u128"
            }
        ]
    },
    {
        "type": "interface",
        "name": "src::mintable_token_interface::IMintableToken",
        "items": [
            {
                "type": "function",
                "name": "permissioned_mint",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "permissioned_burn",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "MintableTokenCamelImpl",
        "interface_name": "src::mintable_token_interface::IMintableTokenCamel"
    },
    {
        "type": "interface",
        "name": "src::mintable_token_interface::IMintableTokenCamel",
        "items": [
            {
                "type": "function",
                "name": "permissionedMint",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "permissionedBurn",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "Replaceable",
        "interface_name": "src::replaceability_interface::IReplaceable"
    },
    {
        "type": "struct",
        "name": "core::array::Span::<core::felt252>",
        "members": [
            {
                "name": "snapshot",
                "type": "@core::array::Array::<core::felt252>"
            }
        ]
    },
    {
        "type": "struct",
        "name": "src::replaceability_interface::EICData",
        "members": [
            {
                "name": "eic_hash",
                "type": "core::starknet::class_hash::ClassHash"
            },
            {
                "name": "eic_init_data",
                "type": "core::array::Span::<core::felt252>"
            }
        ]
    },
    {
        "type": "enum",
        "name": "core::option::Option::<src::replaceability_interface::EICData>",
        "variants": [
            {
                "name": "Some",
                "type": "src::replaceability_interface::EICData"
            },
            {
                "name": "None",
                "type": "()"
            }
        ]
    },
    {
        "type": "enum",
        "name": "core::bool",
        "variants": [
            {
                "name": "False",
                "type": "()"
            },
            {
                "name": "True",
                "type": "()"
            }
        ]
    },
    {
        "type": "struct",
        "name": "src::replaceability_interface::ImplementationData",
        "members": [
            {
                "name": "impl_hash",
                "type": "core::starknet::class_hash::ClassHash"
            },
            {
                "name": "eic_data",
                "type": "core::option::Option::<src::replaceability_interface::EICData>"
            },
            {
                "name": "final",
                "type": "core::bool"
            }
        ]
    },
    {
        "type": "interface",
        "name": "src::replaceability_interface::IReplaceable",
        "items": [
            {
                "type": "function",
                "name": "get_upgrade_delay",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::integer::u64"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_impl_activation_time",
                "inputs": [
                    {
                        "name": "implementation_data",
                        "type": "src::replaceability_interface::ImplementationData"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::integer::u64"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "add_new_implementation",
                "inputs": [
                    {
                        "name": "implementation_data",
                        "type": "src::replaceability_interface::ImplementationData"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "remove_implementation",
                "inputs": [
                    {
                        "name": "implementation_data",
                        "type": "src::replaceability_interface::ImplementationData"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "replace_to",
                "inputs": [
                    {
                        "name": "implementation_data",
                        "type": "src::replaceability_interface::ImplementationData"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "AccessControlImplExternal",
        "interface_name": "src::access_control_interface::IAccessControl"
    },
    {
        "type": "interface",
        "name": "src::access_control_interface::IAccessControl",
        "items": [
            {
                "type": "function",
                "name": "has_role",
                "inputs": [
                    {
                        "name": "role",
                        "type": "core::felt252"
                    },
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::bool"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_role_admin",
                "inputs": [
                    {
                        "name": "role",
                        "type": "core::felt252"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::felt252"
                    }
                ],
                "state_mutability": "view"
            }
        ]
    },
    {
        "type": "impl",
        "name": "RolesImpl",
        "interface_name": "src::roles_interface::IMinimalRoles"
    },
    {
        "type": "interface",
        "name": "src::roles_interface::IMinimalRoles",
        "items": [
            {
                "type": "function",
                "name": "is_governance_admin",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::bool"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "is_upgrade_governor",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::bool"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "register_governance_admin",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "remove_governance_admin",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "register_upgrade_governor",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "remove_upgrade_governor",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "renounce",
                "inputs": [
                    {
                        "name": "role",
                        "type": "core::felt252"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "ERC20Impl",
        "interface_name": "openzeppelin::token::erc20::interface::IERC20"
    },
    {
        "type": "interface",
        "name": "openzeppelin::token::erc20::interface::IERC20",
        "items": [
            {
                "type": "function",
                "name": "name",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::felt252"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "symbol",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::felt252"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "decimals",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::integer::u8"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "total_supply",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::integer::u256"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "balance_of",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::integer::u256"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "allowance",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "spender",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::integer::u256"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "transfer",
                "inputs": [
                    {
                        "name": "recipient",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::bool"
                    }
                ],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "transfer_from",
                "inputs": [
                    {
                        "name": "sender",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "recipient",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::bool"
                    }
                ],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "approve",
                "inputs": [
                    {
                        "name": "spender",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::bool"
                    }
                ],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "ERC20CamelOnlyImpl",
        "interface_name": "openzeppelin::token::erc20::interface::IERC20CamelOnly"
    },
    {
        "type": "interface",
        "name": "openzeppelin::token::erc20::interface::IERC20CamelOnly",
        "items": [
            {
                "type": "function",
                "name": "totalSupply",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::integer::u256"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "balanceOf",
                "inputs": [
                    {
                        "name": "account",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::integer::u256"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "transferFrom",
                "inputs": [
                    {
                        "name": "sender",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "recipient",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::bool"
                    }
                ],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "constructor",
        "name": "constructor",
        "inputs": [
            {
                "name": "name",
                "type": "core::felt252"
            },
            {
                "name": "symbol",
                "type": "core::felt252"
            },
            {
                "name": "decimals",
                "type": "core::integer::u8"
            },
            {
                "name": "initial_supply",
                "type": "core::integer::u256"
            },
            {
                "name": "recipient",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "permitted_minter",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "provisional_governance_admin",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "upgrade_delay",
                "type": "core::integer::u64"
            }
        ]
    },
    {
        "type": "function",
        "name": "increase_allowance",
        "inputs": [
            {
                "name": "spender",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "added_value",
                "type": "core::integer::u256"
            }
        ],
        "outputs": [
            {
                "type": "core::bool"
            }
        ],
        "state_mutability": "external"
    },
    {
        "type": "function",
        "name": "decrease_allowance",
        "inputs": [
            {
                "name": "spender",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "subtracted_value",
                "type": "core::integer::u256"
            }
        ],
        "outputs": [
            {
                "type": "core::bool"
            }
        ],
        "state_mutability": "external"
    },
    {
        "type": "function",
        "name": "increaseAllowance",
        "inputs": [
            {
                "name": "spender",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "addedValue",
                "type": "core::integer::u256"
            }
        ],
        "outputs": [
            {
                "type": "core::bool"
            }
        ],
        "state_mutability": "external"
    },
    {
        "type": "function",
        "name": "decreaseAllowance",
        "inputs": [
            {
                "name": "spender",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "subtractedValue",
                "type": "core::integer::u256"
            }
        ],
        "outputs": [
            {
                "type": "core::bool"
            }
        ],
        "state_mutability": "external"
    },
    {
        "type": "event",
        "name": "openzeppelin::token::erc20_v070::erc20::ERC20::Transfer",
        "kind": "struct",
        "members": [
            {
                "name": "from",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "to",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "value",
                "type": "core::integer::u256",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "openzeppelin::token::erc20_v070::erc20::ERC20::Approval",
        "kind": "struct",
        "members": [
            {
                "name": "owner",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "spender",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "value",
                "type": "core::integer::u256",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::replaceability_interface::ImplementationAdded",
        "kind": "struct",
        "members": [
            {
                "name": "implementation_data",
                "type": "src::replaceability_interface::ImplementationData",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::replaceability_interface::ImplementationRemoved",
        "kind": "struct",
        "members": [
            {
                "name": "implementation_data",
                "type": "src::replaceability_interface::ImplementationData",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::replaceability_interface::ImplementationReplaced",
        "kind": "struct",
        "members": [
            {
                "name": "implementation_data",
                "type": "src::replaceability_interface::ImplementationData",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::replaceability_interface::ImplementationFinalized",
        "kind": "struct",
        "members": [
            {
                "name": "impl_hash",
                "type": "core::starknet::class_hash::ClassHash",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::access_control_interface::RoleGranted",
        "kind": "struct",
        "members": [
            {
                "name": "role",
                "type": "core::felt252",
                "kind": "data"
            },
            {
                "name": "account",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "sender",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::access_control_interface::RoleRevoked",
        "kind": "struct",
        "members": [
            {
                "name": "role",
                "type": "core::felt252",
                "kind": "data"
            },
            {
                "name": "account",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "sender",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::access_control_interface::RoleAdminChanged",
        "kind": "struct",
        "members": [
            {
                "name": "role",
                "type": "core::felt252",
                "kind": "data"
            },
            {
                "name": "previous_admin_role",
                "type": "core::felt252",
                "kind": "data"
            },
            {
                "name": "new_admin_role",
                "type": "core::felt252",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::roles_interface::GovernanceAdminAdded",
        "kind": "struct",
        "members": [
            {
                "name": "added_account",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "added_by",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::roles_interface::GovernanceAdminRemoved",
        "kind": "struct",
        "members": [
            {
                "name": "removed_account",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "removed_by",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::roles_interface::UpgradeGovernorAdded",
        "kind": "struct",
        "members": [
            {
                "name": "added_account",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "added_by",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "src::roles_interface::UpgradeGovernorRemoved",
        "kind": "struct",
        "members": [
            {
                "name": "removed_account",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "removed_by",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "openzeppelin::token::erc20_v070::erc20::ERC20::Event",
        "kind": "enum",
        "variants": [
            {
                "name": "Transfer",
                "type": "openzeppelin::token::erc20_v070::erc20::ERC20::Transfer",
                "kind": "nested"
            },
            {
                "name": "Approval",
                "type": "openzeppelin::token::erc20_v070::erc20::ERC20::Approval",
                "kind": "nested"
            },
            {
                "name": "ImplementationAdded",
                "type": "src::replaceability_interface::ImplementationAdded",
                "kind": "nested"
            },
            {
                "name": "ImplementationRemoved",
                "type": "src::replaceability_interface::ImplementationRemoved",
                "kind": "nested"
            },
            {
                "name": "ImplementationReplaced",
                "type": "src::replaceability_interface::ImplementationReplaced",
                "kind": "nested"
            },
            {
                "name": "ImplementationFinalized",
                "type": "src::replaceability_interface::ImplementationFinalized",
                "kind": "nested"
            },
            {
                "name": "RoleGranted",
                "type": "src::access_control_interface::RoleGranted",
                "kind": "nested"
            },
            {
                "name": "RoleRevoked",
                "type": "src::access_control_interface::RoleRevoked",
                "kind": "nested"
            },
            {
                "name": "RoleAdminChanged",
                "type": "src::access_control_interface::RoleAdminChanged",
                "kind": "nested"
            },
            {
                "name": "GovernanceAdminAdded",
                "type": "src::roles_interface::GovernanceAdminAdded",
                "kind": "nested"
            },
            {
                "name": "GovernanceAdminRemoved",
                "type": "src::roles_interface::GovernanceAdminRemoved",
                "kind": "nested"
            },
            {
                "name": "UpgradeGovernorAdded",
                "type": "src::roles_interface::UpgradeGovernorAdded",
                "kind": "nested"
            },
            {
                "name": "UpgradeGovernorRemoved",
                "type": "src::roles_interface::UpgradeGovernorRemoved",
                "kind": "nested"
            }
        ]
    }
];
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetAddresses.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetAddresses = void 0;
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
class StarknetAddresses extends StarknetModule_1.StarknetModule {
    ///////////////////
    //// Address utils
    /**
     * Checks whether an address is a valid starknet address
     *
     * @param value
     */ static isValidAddress(value) {
        if (value.length !== 66) return false;
        try {
            (0, starknet_1.validateAndParseAddress)(value);
            return true;
        } catch (e) {
            return false;
        }
    }
}
exports.StarknetAddresses = StarknetAddresses;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetTokens.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetTokens = void 0;
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
const StarknetAction_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)");
const ERC20Abi_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/ERC20Abi.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetAddresses_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetAddresses.js [app-client] (ecmascript)");
class StarknetTokens extends StarknetModule_1.StarknetModule {
    getContract(address) {
        return new starknet_1.Contract(ERC20Abi_1.ERC20Abi, address, this.root.provider).typedv2(ERC20Abi_1.ERC20Abi);
    }
    /**
     * Action for transferring the erc20 token
     *
     * @param signer
     * @param recipient
     * @param token
     * @param amount
     * @constructor
     * @private
     */ Transfer(signer, recipient, token, amount) {
        const erc20 = this.getContract(token);
        return new StarknetAction_1.StarknetAction(signer, this.root, erc20.populateTransaction.transfer(recipient, amount), StarknetTokens.GasCosts.TRANSFER);
    }
    /**
     * Approves spend of tokens for a specific spender
     *
     * @param signer
     * @param spender
     * @param token
     * @param amount
     * @constructor
     * @private
     */ Approve(signer, spender, token, amount) {
        const erc20 = this.getContract(token);
        return new StarknetAction_1.StarknetAction(signer, this.root, erc20.populateTransaction.approve(spender, amount), StarknetTokens.GasCosts.APPROVE);
    }
    ///////////////////
    //// Tokens
    /**
     * Checks if the provided string is a valid starknet token
     *
     * @param token
     */ isValidToken(token) {
        return StarknetAddresses_1.StarknetAddresses.isValidAddress(token);
    }
    /**
     * Returns the token balance of the address
     *
     * @param address
     * @param token
     */ async getTokenBalance(address, token) {
        const erc20 = this.getContract(token);
        const balance = await erc20.balance_of(address);
        const balanceBN = (0, Utils_1.toBigInt)(balance);
        this.logger.debug("getTokenBalance(): token balance fetched, token: " + token + " address: " + address + " amount: " + balanceBN.toString());
        return balanceBN;
    }
    /**
     * Returns the native currency address, return the default used by the fee module
     */ getNativeCurrencyAddress() {
        return this.root.Fees.getDefaultGasToken();
    }
    ///////////////////
    //// Transfers
    /**
     * Creates transactions for sending the over the tokens
     *
     * @param signer
     * @param token token to send
     * @param amount amount of the token to send
     * @param recipient recipient's address
     * @param feeRate fee rate to use for the transactions
     * @private
     */ async txsTransfer(signer, token, amount, recipient, feeRate) {
        const action = this.Transfer(signer, recipient, token, amount);
        feeRate = feeRate !== null && feeRate !== void 0 ? feeRate : await this.root.Fees.getFeeRate();
        this.logger.debug("txsTransfer(): transfer TX created, recipient: " + recipient.toString() + " token: " + token.toString() + " amount: " + amount.toString(10));
        return [
            await action.tx(feeRate)
        ];
    }
}
exports.StarknetTokens = StarknetTokens;
StarknetTokens.ERC20_ETH = "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7";
StarknetTokens.ERC20_STRK = "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d";
StarknetTokens.GasCosts = {
    TRANSFER: {
        l1DataGas: 400,
        l2Gas: 4000000,
        l1Gas: 0
    },
    APPROVE: {
        l1DataGas: 400,
        l2Gas: 4000000,
        l1Gas: 0
    }
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetFees = exports.starknetGasAdd = exports.starknetGasMul = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetTokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetTokens.js [app-client] (ecmascript)");
const MAX_FEE_AGE = 5000;
function starknetGasMul(gas, scalar) {
    return {
        l1Gas: gas.l1Gas * scalar,
        l2Gas: gas.l2Gas * scalar,
        l1DataGas: gas.l1DataGas * scalar
    };
}
exports.starknetGasMul = starknetGasMul;
function starknetGasAdd(a, b) {
    return {
        l1Gas: a.l1Gas + b.l1Gas,
        l2Gas: a.l2Gas + b.l2Gas,
        l1DataGas: a.l1DataGas + b.l1DataGas
    };
}
exports.starknetGasAdd = starknetGasAdd;
class StarknetFees {
    /**
     * Gets starknet fee rate
     *
     * @private
     * @returns {Promise<StarknetFeeRate>} L1 gas price denominated in Wei
     */ async _getFeeRate() {
        const block = await this.provider.getBlock("latest");
        let l1GasCost = (0, Utils_1.toBigInt)(block.l1_gas_price.price_in_fri) * this.feeMultiplierPPM / 1000000n;
        let l1DataGasCost = (0, Utils_1.toBigInt)(block.l1_data_gas_price.price_in_fri) * this.feeMultiplierPPM / 1000000n;
        let l2GasCost = (0, Utils_1.toBigInt)(block.l2_gas_price.price_in_fri) * this.feeMultiplierPPM / 1000000n;
        this.logger.debug("_getFeeRate(): L1 fee rate: ", [
            l1GasCost.toString(10),
            l1DataGasCost.toString(10),
            l2GasCost.toString(10)
        ]);
        return {
            l1GasCost,
            l2GasCost,
            l1DataGasCost
        };
    }
    /**
     * Gets the gas price with caching, format: <gas price in Wei>;<transaction version: v1/v3>
     *
     * @private
     */ async getFeeRate() {
        if (this.blockFeeCache == null || Date.now() - this.blockFeeCache.timestamp > MAX_FEE_AGE) {
            let obj = {
                timestamp: Date.now(),
                feeRate: null
            };
            obj.feeRate = this._getFeeRate().catch((e)=>{
                if (this.blockFeeCache === obj) this.blockFeeCache = null;
                throw e;
            });
            this.blockFeeCache = obj;
        }
        let { l1GasCost, l2GasCost, l1DataGasCost } = await this.blockFeeCache.feeRate;
        if (l1GasCost > this.maxFeeRate.l1GasCost) l1GasCost = this.maxFeeRate.l1GasCost;
        if (l2GasCost > this.maxFeeRate.l2GasCost) l2GasCost = this.maxFeeRate.l2GasCost;
        if (l1DataGasCost > this.maxFeeRate.l1DataGasCost) l1DataGasCost = this.maxFeeRate.l1DataGasCost;
        const fee = l1GasCost.toString(10) + "," + l2GasCost.toString(10) + "," + l1DataGasCost.toString(10) + ";v3";
        this.logger.debug("getFeeRate(): calculated fee: " + fee);
        return fee;
    }
    getDefaultGasToken() {
        return StarknetTokens_1.StarknetTokens.ERC20_STRK;
    }
    /**
     * Calculates the total gas fee paid for a given gas limit at a given fee rate
     *
     * @param gas
     * @param feeRate
     */ static getGasFee(gas, feeRate) {
        if (feeRate == null) return 0n;
        const arr = feeRate.split(";");
        const [l1GasCostStr, l2GasCostStr, l1DataGasCostStr] = arr[0].split(",");
        return BigInt(gas.l1Gas) * BigInt(l1GasCostStr) + BigInt(gas.l2Gas) * BigInt(l2GasCostStr) + BigInt(gas.l1DataGas) * BigInt(l1DataGasCostStr);
    }
    static getGasToken(feeRate) {
        if (feeRate == null) return null;
        const arr = feeRate.split(";");
        const txVersion = arr[1];
        return txVersion === "v1" ? StarknetTokens_1.StarknetTokens.ERC20_ETH : StarknetTokens_1.StarknetTokens.ERC20_STRK;
    }
    getFeeDetails(gas, feeRate) {
        if (feeRate == null) return null;
        const arr = feeRate.split(";");
        const [l1GasCostStr, l2GasCostStr, l1DataGasCostStr] = arr[0].split(",");
        return {
            version: "0x3",
            resourceBounds: {
                l1_gas: {
                    max_amount: (0, Utils_1.toHex)(gas.l1Gas, 16),
                    max_price_per_unit: (0, Utils_1.toHex)(BigInt(l1GasCostStr), 16)
                },
                l2_gas: {
                    max_amount: (0, Utils_1.toHex)(gas.l2Gas, 16),
                    max_price_per_unit: (0, Utils_1.toHex)(BigInt(l2GasCostStr), 16)
                },
                l1_data_gas: {
                    max_amount: (0, Utils_1.toHex)(gas.l1DataGas, 16),
                    max_price_per_unit: (0, Utils_1.toHex)(BigInt(l1DataGasCostStr), 16)
                }
            },
            tip: "0x0",
            paymasterData: [],
            nonceDataAvailabilityMode: this.nonceDA,
            feeDataAvailabilityMode: this.feeDA
        };
    }
    constructor(provider, maxFeeRate = {
        l1GasCost: 20000000000000000n,
        l2GasCost: 4000000000000000n,
        l1DataGasCost: 10000000000000000n
    }, feeMultiplier = 1.25, da){
        this.logger = (0, Utils_1.getLogger)("StarknetFees: ");
        this.blockFeeCache = null;
        this.provider = provider;
        this.maxFeeRate = maxFeeRate;
        var _da_fee;
        this.feeDA = (_da_fee = da === null || da === void 0 ? void 0 : da.fee) !== null && _da_fee !== void 0 ? _da_fee : "L1";
        var _da_nonce;
        this.nonceDA = (_da_nonce = da === null || da === void 0 ? void 0 : da.nonce) !== null && _da_nonce !== void 0 ? _da_nonce : "L1";
        this.feeMultiplierPPM = BigInt(Math.floor(feeMultiplier * 1000000));
    }
}
exports.StarknetFees = StarknetFees;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetAction = void 0;
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
class StarknetAction {
    estimateFeeRate() {
        return this.root.Fees.getFeeRate();
    }
    addIx(instruction, gasLimit) {
        this.instructions.push(instruction);
        this.gas = (0, StarknetFees_1.starknetGasAdd)(this.gas, gasLimit);
    }
    add(action) {
        return this.addAction(action);
    }
    addAction(action) {
        let index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.instructions.length;
        if (action.mainSigner !== this.mainSigner) throw new Error("Actions need to have the same signer!");
        if (this.gas.l1Gas == null && action.gas.l1Gas != null) this.gas.l1Gas = action.gas.l1Gas;
        if (this.gas.l2Gas == null && action.gas.l2Gas != null) this.gas.l2Gas = action.gas.l2Gas;
        if (this.gas.l1DataGas == null && action.gas.l1DataGas != null) this.gas.l1DataGas = action.gas.l1DataGas;
        if (this.gas.l1Gas != null && action.gas.l1Gas != null) this.gas.l1Gas += action.gas.l1Gas;
        if (this.gas.l2Gas != null && action.gas.l2Gas != null) this.gas.l2Gas += action.gas.l2Gas;
        if (this.gas.l1DataGas != null && action.gas.l1DataGas != null) this.gas.l1DataGas += action.gas.l1DataGas;
        this.instructions.splice(index, 0, ...action.instructions);
        if (this.feeRate == null) this.feeRate = action.feeRate;
        return this;
    }
    async tx(feeRate) {
        if (feeRate == null) feeRate = this.feeRate;
        if (feeRate == null) feeRate = await this.estimateFeeRate();
        return {
            type: "INVOKE",
            tx: this.instructions,
            details: {
                ...this.root.Fees.getFeeDetails(this.gas, feeRate),
                walletAddress: this.mainSigner,
                cairoVersion: "1",
                chainId: this.root.starknetChainId,
                nonce: null,
                accountDeploymentData: [],
                skipValidate: false
            }
        };
    }
    async addToTxs(txs, feeRate) {
        txs.push(await this.tx(feeRate));
    }
    ixsLength() {
        return this.instructions.length;
    }
    constructor(mainSigner, root, instructions = [], gasLimit, feeRate){
        this.mainSigner = mainSigner;
        this.root = root;
        this.instructions = Array.isArray(instructions) ? instructions : [
            instructions
        ];
        var _gasLimit_l1Gas, _gasLimit_l2Gas, _gasLimit_l1DataGas;
        this.gas = {
            l1Gas: (_gasLimit_l1Gas = gasLimit === null || gasLimit === void 0 ? void 0 : gasLimit.l1Gas) !== null && _gasLimit_l1Gas !== void 0 ? _gasLimit_l1Gas : 0,
            l2Gas: (_gasLimit_l2Gas = gasLimit === null || gasLimit === void 0 ? void 0 : gasLimit.l2Gas) !== null && _gasLimit_l2Gas !== void 0 ? _gasLimit_l2Gas : 0,
            l1DataGas: (_gasLimit_l1DataGas = gasLimit === null || gasLimit === void 0 ? void 0 : gasLimit.l1DataGas) !== null && _gasLimit_l1DataGas !== void 0 ? _gasLimit_l1DataGas : 0
        };
        this.feeRate = feeRate;
    }
}
exports.StarknetAction = StarknetAction;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetTransactions.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetTransactions = void 0;
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
class StarknetTransactions extends StarknetModule_1.StarknetModule {
    /**
     * Waits for transaction confirmation using WS subscription and occasional HTTP polling, also re-sends
     *  the transaction at regular interval
     *
     * @param tx starknet transaction to wait for confirmation for & keep re-sending until it confirms
     * @param abortSignal signal to abort waiting for tx confirmation
     * @private
     */ async confirmTransaction(tx, abortSignal) {
        let state = "pending";
        while(state === "pending" || state === "not_found"){
            await (0, Utils_1.timeoutPromise)(3000, abortSignal);
            state = await this._getTxIdStatus(tx.txId);
            if (state === "not_found" && tx.signed != null) await this.sendSignedTransaction(tx).catch((e)=>{
                var _e_baseError;
                if (((_e_baseError = e.baseError) === null || _e_baseError === void 0 ? void 0 : _e_baseError.code) === 59) return; //Transaction already in the mempool
                this.logger.error("confirmTransaction(): Error on transaction re-send: ", e);
            });
        }
        if (state === "rejected") throw new Error("Transaction rejected!");
        const nextAccountNonce = (0, Utils_1.toBigInt)(tx.details.nonce) + 1n;
        const currentNonce = this.latestConfirmedNonces[tx.details.walletAddress];
        if (currentNonce == null || nextAccountNonce > currentNonce) {
            this.latestConfirmedNonces[tx.details.walletAddress] = nextAccountNonce;
        }
        if (state === "reverted") throw new Error("Transaction reverted!");
    }
    /**
     * Prepares starknet transactions, checks if the account is deployed, assigns nonces if needed & calls beforeTxSigned callback
     *
     * @param signer
     * @param txs
     * @private
     */ async prepareTransactions(signer, txs) {
        let nonce = await signer.getNonce();
        const latestConfirmedNonce = this.latestConfirmedNonces[signer.getAddress()];
        if (latestConfirmedNonce != null && latestConfirmedNonce > nonce) {
            this.logger.debug("prepareTransactions(): Using nonce from local cache!");
            nonce = latestConfirmedNonce;
        }
        if (nonce === BigInt(0) && signer.isWalletAccount()) {
            //Just increment the nonce by one and hope the wallet is smart enough to deploy account first
            nonce = BigInt(1);
        }
        const deployPayload = await signer.checkAndGetDeployPayload(nonce);
        if (deployPayload != null) {
            txs.unshift(await this.root.Accounts.getAccountDeployTransaction(deployPayload));
        }
        for(let i = 0; i < txs.length; i++){
            const tx = txs[i];
            if (tx.details.nonce != null) nonce = BigInt(tx.details.nonce); //Take the nonce from last tx
            if (nonce == null) nonce = BigInt(await this.root.provider.getNonceForAddress(signer.getAddress())); //Fetch the nonce
            if (tx.details.nonce == null) tx.details.nonce = nonce;
            this.logger.debug("sendAndConfirm(): transaction prepared (" + (i + 1) + "/" + txs.length + "), nonce: " + tx.details.nonce);
            nonce += BigInt(1);
            if (this.cbkBeforeTxSigned != null) await this.cbkBeforeTxSigned(tx);
        }
    }
    /**
     * Sends out a signed transaction to the RPC
     *
     * @param tx Starknet tx to send
     * @param onBeforePublish a callback called before every transaction is published
     * @param signer
     * @private
     */ async sendSignedTransaction(tx, onBeforePublish, signer) {
        if (onBeforePublish != null) await onBeforePublish(tx.txId, await this.serializeTx(tx));
        this.logger.debug("sendSignedTransaction(): sending transaction: ", tx.txId);
        if (tx.signed == null) {
            let txHash;
            switch(tx.type){
                case "INVOKE":
                    txHash = (await signer.account.execute(tx.tx, tx.details)).transaction_hash;
                    break;
                case "DEPLOY_ACCOUNT":
                    txHash = (await signer.account.deployAccount(tx.tx, tx.details)).transaction_hash;
                    break;
                default:
                    throw new Error("Unsupported tx type!");
            }
            tx.txId = txHash;
            return txHash;
        }
        let txResult;
        switch(tx.type){
            case "INVOKE":
                txResult = await this.provider.channel.invoke(tx.signed, tx.details).then((res)=>res.transaction_hash);
                break;
            case "DEPLOY_ACCOUNT":
                txResult = await this.provider.channel.deployAccount(tx.signed, tx.details).then((res)=>res.transaction_hash);
                break;
            default:
                throw new Error("Unsupported tx type!");
        }
        if (tx.txId !== txResult) this.logger.warn("sendSignedTransaction(): sent tx hash not matching the precomputed hash!");
        this.logger.info("sendSignedTransaction(): tx sent, expected txHash: " + tx.txId + ", txHash: " + txResult);
        return txResult;
    }
    /**
     * Prepares, signs , sends (in parallel or sequentially) & optionally waits for confirmation
     *  of a batch of starknet transactions
     *
     * @param signer
     * @param txs transactions to send
     * @param waitForConfirmation whether to wait for transaction confirmations (this also makes sure the transactions
     *  are re-sent at regular intervals)
     * @param abortSignal abort signal to abort waiting for transaction confirmations
     * @param parallel whether the send all the transaction at once in parallel or sequentially (such that transactions
     *  are executed in order)
     * @param onBeforePublish a callback called before every transaction is published
     */ async sendAndConfirm(signer, txs, waitForConfirmation, abortSignal, parallel, onBeforePublish) {
        await this.prepareTransactions(signer, txs);
        if (!signer.isWalletAccount()) {
            for(let i = 0; i < txs.length; i++){
                const tx = txs[i];
                switch(tx.type){
                    case "INVOKE":
                        tx.signed = await signer.account.buildInvocation(tx.tx, tx.details);
                        (0, Utils_1.calculateHash)(tx);
                        break;
                    case "DEPLOY_ACCOUNT":
                        tx.signed = await signer.account.buildAccountDeployPayload(tx.tx, tx.details);
                        (0, Utils_1.calculateHash)(tx);
                        break;
                    default:
                        throw new Error("Unsupported tx type!");
                }
                this.logger.debug("sendAndConfirm(): transaction signed (" + (i + 1) + "/" + txs.length + "): " + tx.txId);
            }
        }
        this.logger.debug("sendAndConfirm(): sending transactions, count: " + txs.length + " waitForConfirmation: " + waitForConfirmation + " parallel: " + parallel);
        const txIds = [];
        if (parallel) {
            const promises = [];
            for(let i = 0; i < txs.length; i++){
                const signedTx = txs[i];
                const txId = await this.sendSignedTransaction(signedTx, onBeforePublish, signer);
                if (waitForConfirmation) promises.push(this.confirmTransaction(signedTx, abortSignal));
                txIds.push(txId);
                this.logger.debug("sendAndConfirm(): transaction sent (" + (i + 1) + "/" + txs.length + "): " + signedTx.txId);
            }
            if (promises.length > 0) await Promise.all(promises);
        } else {
            for(let i = 0; i < txs.length; i++){
                const signedTx = txs[i];
                const txId = await this.sendSignedTransaction(signedTx, onBeforePublish, signer);
                const confirmPromise = this.confirmTransaction(signedTx, abortSignal);
                this.logger.debug("sendAndConfirm(): transaction sent (" + (i + 1) + "/" + txs.length + "): " + signedTx.txId);
                //Don't await the last promise when !waitForConfirmation
                if (i < txs.length - 1 || waitForConfirmation) await confirmPromise;
                txIds.push(txId);
            }
        }
        this.logger.info("sendAndConfirm(): sent transactions, count: " + txs.length + " waitForConfirmation: " + waitForConfirmation + " parallel: " + parallel);
        return txIds;
    }
    /**
     * Serializes the solana transaction, saves the transaction, signers & last valid blockheight
     *
     * @param tx
     */ serializeTx(tx) {
        return Promise.resolve(JSON.stringify(tx, (key, value)=>{
            if (typeof value === "bigint") return (0, Utils_1.toHex)(value);
            return value;
        }));
    }
    /**
     * Deserializes saved solana transaction, extracting the transaction, signers & last valid blockheight
     *
     * @param txData
     */ deserializeTx(txData) {
        return Promise.resolve(JSON.parse(txData));
    }
    /**
     * Gets the status of the raw starknet transaction
     *
     * @param tx
     */ async getTxStatus(tx) {
        const parsedTx = await this.deserializeTx(tx);
        return await this.getTxIdStatus(parsedTx.txId);
    }
    /**
     * Gets the status of the starknet transaction with a specific txId
     *
     * @param txId
     */ async _getTxIdStatus(txId) {
        const status = await this.provider.getTransactionStatus(txId).catch((e)=>{
            if (e.message != null && e.message.includes("29: Transaction hash not found")) return null;
            throw e;
        });
        if (status == null) return "not_found";
        if (status.finality_status === "RECEIVED") return "pending";
        if (status.finality_status === "REJECTED") return "rejected";
        if (status.execution_status === "SUCCEEDED") {
            return "success";
        }
        return "reverted";
    }
    /**
     * Gets the status of the starknet transaction with a specific txId
     *
     * @param txId
     */ async getTxIdStatus(txId) {
        const status = await this._getTxIdStatus(txId);
        if (status === "rejected") return "reverted";
        return status;
    }
    onBeforeTxSigned(callback) {
        this.cbkBeforeTxSigned = callback;
    }
    offBeforeTxSigned(callback) {
        this.cbkBeforeTxSigned = null;
        return true;
    }
    constructor(){
        super(...arguments);
        this.latestConfirmedNonces = {};
    }
}
exports.StarknetTransactions = StarknetTransactions;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetEvents.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetEvents = void 0;
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
class StarknetEvents extends StarknetModule_1.StarknetModule {
    /**
     * Returns the all the events occuring in a block range as identified by the contract and keys
     *
     * @param contract
     * @param keys
     * @param startBlock
     * @param endBlock
     * @param abortSignal
     */ async getBlockEvents(contract, keys, startBlock) {
        let endBlock = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startBlock, abortSignal = arguments.length > 4 ? arguments[4] : void 0;
        const events = [];
        let result = null;
        while(result == null || (result === null || result === void 0 ? void 0 : result.continuation_token) != null){
            result = await this.root.provider.getEvents({
                address: contract,
                from_block: startBlock == null ? "pending" : {
                    block_number: startBlock
                },
                to_block: endBlock == null ? "pending" : {
                    block_number: endBlock
                },
                keys,
                chunk_size: this.EVENTS_LIMIT,
                continuation_token: result === null || result === void 0 ? void 0 : result.continuation_token
            });
            if (abortSignal != null) abortSignal.throwIfAborted();
            events.push(...result.events);
        }
        return events;
    }
    /**
     * Runs a search backwards in time, processing events from a specific contract and keys
     *
     * @param contract
     * @param keys
     * @param processor called for every batch of returned signatures, should return a value if the correct signature
     *  was found, or null if the search should continue
     * @param abortSignal
     */ async findInEvents(contract, keys, processor, abortSignal) {
        const latestBlockNumber = await this.provider.getBlockNumber();
        for(let blockNumber = latestBlockNumber; blockNumber >= 0; blockNumber -= this.FORWARD_BLOCK_RANGE){
            const eventsResult = await this.getBlockEvents(contract, keys, Math.max(blockNumber - this.FORWARD_BLOCK_RANGE, 0), blockNumber === latestBlockNumber ? null : blockNumber, abortSignal);
            const result = await processor(eventsResult.reverse());
            if (result != null) return result;
        }
        return null;
    }
    /**
     * Runs a search forwards in time, processing events from a specific contract and keys
     *
     * @param contract
     * @param keys
     * @param processor called for every batch of returned signatures, should return a value if the correct signature
     *  was found, or null if the search should continue
     * @param abortSignal
     * @param logFetchLimit
     */ async findInEventsForward(contract, keys, processor, abortSignal, logFetchLimit) {
        if (logFetchLimit == null || logFetchLimit > this.EVENTS_LIMIT) logFetchLimit = this.EVENTS_LIMIT;
        let eventsResult = null;
        while(eventsResult == null || (eventsResult === null || eventsResult === void 0 ? void 0 : eventsResult.continuation_token) != null){
            eventsResult = await this.root.provider.getEvents({
                address: contract,
                to_block: "latest",
                keys,
                chunk_size: logFetchLimit !== null && logFetchLimit !== void 0 ? logFetchLimit : this.EVENTS_LIMIT,
                continuation_token: eventsResult === null || eventsResult === void 0 ? void 0 : eventsResult.continuation_token
            });
            if (abortSignal != null) abortSignal.throwIfAborted();
            const result = await processor(eventsResult.events);
            if (result != null) return result;
        }
        return null;
    }
    constructor(){
        super(...arguments);
        this.EVENTS_LIMIT = 100;
        this.FORWARD_BLOCK_RANGE = 2000;
    }
}
exports.StarknetEvents = StarknetEvents;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetSignatures.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSignatures = void 0;
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
const StarknetDomain = [
    {
        name: 'name',
        type: 'shortstring'
    },
    {
        name: 'version',
        type: 'shortstring'
    },
    {
        name: 'chainId',
        type: 'shortstring'
    },
    {
        name: 'revision',
        type: 'shortstring'
    }
];
const DataHash = [
    {
        name: 'Data hash',
        type: 'u256'
    }
];
class StarknetSignatures extends StarknetModule_1.StarknetModule {
    getTypedMessage(type, typeName, message) {
        return {
            types: {
                StarknetDomain,
                [typeName]: type
            },
            primaryType: typeName,
            domain: this.domain,
            message
        };
    }
    async signTypedMessage(signer, type, typeName, message) {
        const signature = await signer.account.signMessage(this.getTypedMessage(type, typeName, message));
        return JSON.stringify(starknet_1.stark.formatSignature(signature));
    }
    async isValidSignature(signature, address, type, typeName, message) {
        return this.provider.verifyMessageInStarknet(this.getTypedMessage(type, typeName, message), JSON.parse(signature), address);
    }
    ///////////////////
    //// Data signatures
    /**
     * Produces a signature over the sha256 of a specified data Buffer, only works with providers which
     *  expose their private key (i.e. backend based, not browser wallet based)
     *
     * @param signer
     * @param data data to sign
     */ getDataSignature(signer, data) {
        const buff = buffer_1.Buffer.from((0, sha2_1.sha256)(data));
        return this.signTypedMessage(signer, DataHash, 'DataHash', {
            "Data hash": starknet_1.cairo.uint256((0, Utils_1.toHex)(buff))
        });
    }
    /**
     * Checks whether a signature is a valid signature produced by the account over a data message (computes
     *  sha256 hash of the message)
     *
     * @param data signed data
     * @param signature data signature
     * @param address public key of the signer
     */ isValidDataSignature(data, signature, address) {
        const buff = buffer_1.Buffer.from((0, sha2_1.sha256)(data));
        return this.isValidSignature(signature, address, DataHash, 'DataHash', {
            "Data hash": starknet_1.cairo.uint256((0, Utils_1.toHex)(buff))
        });
    }
    constructor(root, domainName = "atomiq.exchange"){
        super(root);
        this.domain = {
            name: domainName,
            version: '1',
            chainId: starknet_1.shortString.decodeShortString(root.starknetChainId),
            revision: '1'
        };
    }
}
exports.StarknetSignatures = StarknetSignatures;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetAccounts.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetAccounts = void 0;
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
class StarknetAccounts extends StarknetModule_1.StarknetModule {
    async getAccountDeployTransaction(deploymentData) {
        const feeDetails = this.root.Fees.getFeeDetails({
            l1DataGas: 500,
            l2Gas: 5000 * 40000,
            l1Gas: 0
        }, await this.root.Fees.getFeeRate());
        const details = {
            ...feeDetails,
            walletAddress: deploymentData.contractAddress,
            cairoVersion: "1",
            chainId: this.root.starknetChainId,
            nonce: 0,
            accountDeploymentData: [],
            skipValidate: false
        };
        return {
            type: "DEPLOY_ACCOUNT",
            tx: deploymentData,
            details
        };
    }
}
exports.StarknetAccounts = StarknetAccounts;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetBlocks.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetBlocks = void 0;
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
class StarknetBlocks extends StarknetModule_1.StarknetModule {
    /**
     * Initiates fetch of a given block & saves it to cache
     *
     * @private
     * @param blockTag
     */ fetchAndSaveBlockTime(blockTag) {
        const blockTagStr = blockTag.toString(10);
        const blockTimePromise = this.provider.getBlockWithTxHashes(blockTag).then((result)=>result.timestamp);
        const timestamp = Date.now();
        this.blockCache[blockTagStr] = {
            blockTime: blockTimePromise,
            timestamp
        };
        blockTimePromise.catch((e)=>{
            if (this.blockCache[blockTagStr] != null && this.blockCache[blockTagStr].blockTime === blockTimePromise) delete this.blockCache[blockTagStr];
            throw e;
        });
        return {
            blockTime: blockTimePromise,
            timestamp
        };
    }
    cleanupBlocks() {
        const currentTime = Date.now();
        //Keys are in order that they were added, so we can stop at the first non-expired block
        for(let key in this.blockCache){
            const block = this.blockCache[key];
            if (currentTime - block.timestamp > this.BLOCK_CACHE_TIME) {
                delete this.blockCache[key];
            } else {
                break;
            }
        }
    }
    ///////////////////
    //// Blocks
    /**
     * Gets the block for a given blocktag, with caching
     *
     * @param blockTag
     */ getBlockTime(blockTag) {
        this.cleanupBlocks();
        let cachedBlockData = this.blockCache[blockTag.toString(10)];
        if (cachedBlockData == null || Date.now() - cachedBlockData.timestamp > this.BLOCK_CACHE_TIME) {
            cachedBlockData = this.fetchAndSaveBlockTime(blockTag);
        }
        return cachedBlockData.blockTime;
    }
    constructor(){
        super(...arguments);
        this.BLOCK_CACHE_TIME = 5 * 1000;
        this.blockCache = {};
    }
}
exports.StarknetBlocks = StarknetBlocks;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/wallet/StarknetSigner.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSigner = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
class StarknetSigner {
    getPublicKey() {
        return this.account.signer.getPubKey();
    }
    getAddress() {
        return (0, Utils_1.toHex)(this.account.address);
    }
    isWalletAccount() {
        return this.account.walletProvider != null;
    }
    //TODO: Introduce proper nonce management!
    async getNonce() {
        try {
            return BigInt(await this.account.getNonceForAddress(this.getAddress(), "pending"));
        } catch (e) {
            if (e.message != null && e.message.includes("20: Contract not found")) {
                return BigInt(0);
            }
            throw e;
        }
    }
    async checkAndGetDeployPayload(nonce) {
        if (this.isDeployed) return null;
        const _account = this.account;
        if (_account.getDeploymentData != null) {
            //Check if deployed
            nonce !== null && nonce !== void 0 ? nonce : nonce = BigInt(await this.getNonce());
            this.isDeployed = nonce != BigInt(0);
            if (!this.isDeployed) {
                return _account.getDeploymentData();
            }
        }
        return null;
    }
    constructor(account){
        this.isDeployed = null;
        this.account = account;
    }
}
exports.StarknetSigner = StarknetSigner;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/wallet/StarknetKeypairWallet.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetKeypairWallet = void 0;
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const OZaccountClassHash = '0x00261c293c8084cd79086214176b33e5911677cec55104fddc8d25b0b736dcad';
//Openzeppelin Account wallet
class StarknetKeypairWallet extends starknet_1.Account {
    getDeploymentData() {
        return {
            classHash: OZaccountClassHash,
            constructorCalldata: starknet_1.CallData.compile({
                publicKey: this.publicKey
            }),
            addressSalt: this.publicKey,
            contractAddress: this.address
        };
    }
    static generateRandomPrivateKey() {
        return "0x" + buffer_1.Buffer.from(starknet_1.ec.starkCurve.utils.randomPrivateKey()).toString("hex");
    }
    constructor(provider, privateKey){
        const publicKey = starknet_1.ec.starkCurve.getStarkKey((0, Utils_1.toHex)(privateKey));
        // Calculate future address of the account
        const OZaccountConstructorCallData = starknet_1.CallData.compile({
            publicKey
        });
        const OZcontractAddress = starknet_1.hash.calculateContractAddressFromHash(publicKey, OZaccountClassHash, OZaccountConstructorCallData, 0);
        super(provider, OZcontractAddress, privateKey, "1");
        this.publicKey = publicKey;
    }
}
exports.StarknetKeypairWallet = StarknetKeypairWallet;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetChainInterface.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetChainInterface = void 0;
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetTransactions_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetTransactions.js [app-client] (ecmascript)");
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
const StarknetAddresses_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetAddresses.js [app-client] (ecmascript)");
const StarknetTokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetTokens.js [app-client] (ecmascript)");
const StarknetEvents_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetEvents.js [app-client] (ecmascript)");
const StarknetSignatures_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetSignatures.js [app-client] (ecmascript)");
const StarknetAccounts_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetAccounts.js [app-client] (ecmascript)");
const StarknetBlocks_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetBlocks.js [app-client] (ecmascript)");
const StarknetSigner_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/wallet/StarknetSigner.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const StarknetKeypairWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/wallet/StarknetKeypairWallet.js [app-client] (ecmascript)");
class StarknetChainInterface {
    async getBalance(signer, tokenAddress) {
        //TODO: For native token we should discount the cost of deploying an account if it is not deployed yet
        return await this.Tokens.getTokenBalance(signer, tokenAddress);
    }
    getNativeCurrencyAddress() {
        return this.Tokens.getNativeCurrencyAddress();
    }
    isValidToken(tokenIdentifier) {
        return this.Tokens.isValidToken(tokenIdentifier);
    }
    isValidAddress(address) {
        return StarknetAddresses_1.StarknetAddresses.isValidAddress(address);
    }
    ///////////////////////////////////
    //// Callbacks & handlers
    offBeforeTxReplace(callback) {
        return true;
    }
    onBeforeTxReplace(callback) {}
    onBeforeTxSigned(callback) {
        this.Transactions.onBeforeTxSigned(callback);
    }
    offBeforeTxSigned(callback) {
        return this.Transactions.offBeforeTxSigned(callback);
    }
    randomAddress() {
        return (0, Utils_1.toHex)(starknet_1.stark.randomAddress());
    }
    randomSigner() {
        const privateKey = "0x" + buffer_1.Buffer.from(starknet_1.ec.starkCurve.utils.randomPrivateKey()).toString("hex");
        const wallet = new StarknetKeypairWallet_1.StarknetKeypairWallet(this.provider, privateKey);
        return new StarknetSigner_1.StarknetSigner(wallet);
    }
    ////////////////////////////////////////////
    //// Transactions
    sendAndConfirm(signer, txs, waitForConfirmation, abortSignal, parallel, onBeforePublish) {
        return this.Transactions.sendAndConfirm(signer, txs, waitForConfirmation, abortSignal, parallel, onBeforePublish);
    }
    serializeTx(tx) {
        return this.Transactions.serializeTx(tx);
    }
    deserializeTx(txData) {
        return this.Transactions.deserializeTx(txData);
    }
    getTxIdStatus(txId) {
        return this.Transactions.getTxIdStatus(txId);
    }
    getTxStatus(tx) {
        return this.Transactions.getTxStatus(tx);
    }
    txsTransfer(signer, token, amount, dstAddress, feeRate) {
        return this.Tokens.txsTransfer(signer, token, amount, dstAddress, feeRate);
    }
    async transfer(signer, token, amount, dstAddress, txOptions) {
        const txs = await this.Tokens.txsTransfer(signer.getAddress(), token, amount, dstAddress, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [txId] = await this.Transactions.sendAndConfirm(signer, txs, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal, false);
        return txId;
    }
    constructor(chainId, provider, retryPolicy, solanaFeeEstimator = new StarknetFees_1.StarknetFees(provider)){
        this.chainId = "STARKNET";
        this.logger = (0, Utils_1.getLogger)("StarknetChainInterface: ");
        this.starknetChainId = chainId;
        this.provider = provider;
        this.retryPolicy = retryPolicy;
        this.Fees = solanaFeeEstimator;
        this.Tokens = new StarknetTokens_1.StarknetTokens(this);
        this.Transactions = new StarknetTransactions_1.StarknetTransactions(this);
        this.Signatures = new StarknetSignatures_1.StarknetSignatures(this);
        this.Events = new StarknetEvents_1.StarknetEvents(this);
        this.Accounts = new StarknetAccounts_1.StarknetAccounts(this);
        this.Blocks = new StarknetBlocks_1.StarknetBlocks(this);
    }
}
exports.StarknetChainInterface = StarknetChainInterface;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/headers/StarknetBtcHeader.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetBtcHeader = void 0;
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
class StarknetBtcHeader {
    getMerkleRoot() {
        return (0, Utils_1.u32ArrayToBuffer)(this.merkle_root);
    }
    getNbits() {
        return (0, Utils_1.u32ReverseEndianness)(this.nbits);
    }
    getNonce() {
        return (0, Utils_1.u32ReverseEndianness)(this.nonce);
    }
    getReversedPrevBlockhash() {
        return (0, Utils_1.u32ArrayToBuffer)(this.previous_blockhash);
    }
    getTimestamp() {
        return (0, Utils_1.u32ReverseEndianness)(this.reversed_timestamp);
    }
    getVersion() {
        return (0, Utils_1.u32ReverseEndianness)(this.reversed_version);
    }
    getHash() {
        if (this.hash != null) return this.hash;
        const buffer = buffer_1.Buffer.alloc(80);
        buffer.writeUInt32BE(this.reversed_version, 0);
        (0, Utils_1.u32ArrayToBuffer)(this.previous_blockhash).copy(buffer, 4);
        (0, Utils_1.u32ArrayToBuffer)(this.merkle_root).copy(buffer, 36);
        buffer.writeUInt32BE(this.reversed_timestamp, 68);
        buffer.writeUInt32BE(this.nbits, 72);
        buffer.writeUInt32BE(this.nonce, 76);
        return buffer_1.Buffer.from((0, sha2_1.sha256)((0, sha2_1.sha256)(buffer)));
    }
    serialize() {
        return [
            this.reversed_version,
            ...this.previous_blockhash,
            ...this.merkle_root,
            this.reversed_timestamp,
            this.nbits,
            this.nonce
        ];
    }
    static fromSerializedFeltArray(span) {
        const reversed_version = (0, Utils_1.toHex)(span.shift());
        const previous_blockhash = span.splice(0, 8).map(Utils_1.toHex);
        const merkle_root = span.splice(0, 8).map(Utils_1.toHex);
        const reversed_timestamp = (0, Utils_1.toHex)(span.shift());
        const nbits = (0, Utils_1.toHex)(span.shift());
        const nonce = (0, Utils_1.toHex)(span.shift());
        return new StarknetBtcHeader({
            reversed_version,
            previous_blockhash,
            merkle_root,
            reversed_timestamp,
            nbits,
            nonce
        });
    }
    constructor(obj){
        this.reversed_version = Number(obj.reversed_version);
        this.previous_blockhash = obj.previous_blockhash.map((val)=>Number(val));
        this.merkle_root = obj.merkle_root.map((val)=>Number(val));
        this.reversed_timestamp = Number(obj.reversed_timestamp);
        this.nbits = Number(obj.nbits);
        this.nonce = Number(obj.nonce);
        this.hash = obj.hash;
    }
}
exports.StarknetBtcHeader = StarknetBtcHeader;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/headers/StarknetBtcStoredHeader.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetBtcStoredHeader = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const StarknetBtcHeader_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/headers/StarknetBtcHeader.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
class StarknetBtcStoredHeader {
    getBlockheight() {
        return this.block_height;
    }
    getChainWork() {
        return (0, Utils_1.bigNumberishToBuffer)(this.chain_work, 32);
    }
    getHeader() {
        return this.blockheader;
    }
    getLastDiffAdjustment() {
        return this.last_diff_adjustment;
    }
    getPrevBlockTimestamps() {
        return this.prev_block_timestamps;
    }
    getBlockHash() {
        return (0, Utils_1.u32ArrayToBuffer)(this.block_hash).reverse();
    }
    /**
     * Computes prevBlockTimestamps for a next block, shifting the old block timestamps to the left & appending
     *  this block's timestamp to the end
     *
     * @private
     */ computeNextBlockTimestamps() {
        const prevBlockTimestamps = [
            ...this.prev_block_timestamps
        ];
        for(let i = 1; i < 10; i++){
            prevBlockTimestamps[i - 1] = prevBlockTimestamps[i];
        }
        prevBlockTimestamps[9] = this.blockheader.getTimestamp();
        return prevBlockTimestamps;
    }
    /**
     * Computes total chain work after a new header with "nbits" is added to the chain
     *
     * @param nbits
     * @private
     */ computeNextChainWork(nbits) {
        const chainWork = [
            ...this.getChainWork()
        ];
        base_1.StatePredictorUtils.addInPlace(chainWork, [
            ...base_1.StatePredictorUtils.getChainwork(nbits)
        ]);
        return buffer_1.Buffer.from(chainWork);
    }
    /**
     * Computes lastDiffAdjustment, this changes only once every DIFF_ADJUSTMENT_PERIOD blocks
     *
     * @param headerTimestamp
     * @private
     */ computeNextLastDiffAdjustment(headerTimestamp) {
        const blockheight = this.block_height + 1;
        let lastDiffAdjustment = this.last_diff_adjustment;
        if (blockheight % base_1.StatePredictorUtils.DIFF_ADJUSTMENT_PERIOD === 0) {
            lastDiffAdjustment = headerTimestamp;
        }
        return lastDiffAdjustment;
    }
    computeNext(header) {
        return new StarknetBtcStoredHeader({
            chain_work: "0x" + this.computeNextChainWork(header.getNbits()).toString("hex"),
            prev_block_timestamps: this.computeNextBlockTimestamps(),
            block_height: this.block_height + 1,
            last_diff_adjustment: this.computeNextLastDiffAdjustment(header.getTimestamp()),
            block_hash: (0, Utils_1.bufferToU32Array)(header.getHash()),
            blockheader: header
        });
    }
    serialize() {
        return [
            ...this.blockheader.serialize(),
            ...this.block_hash,
            this.chain_work.low,
            this.chain_work.high,
            this.block_height,
            this.last_diff_adjustment,
            ...this.prev_block_timestamps
        ];
    }
    static fromSerializedFeltArray(span) {
        const blockheader = StarknetBtcHeader_1.StarknetBtcHeader.fromSerializedFeltArray(span);
        const block_hash = span.splice(0, 8).map(Utils_1.toHex);
        const chain_work = {
            low: span.shift(),
            high: span.shift()
        };
        const block_height = (0, Utils_1.toHex)(span.shift());
        const last_diff_adjustment = (0, Utils_1.toHex)(span.shift());
        const prev_block_timestamps = span.splice(0, 10).map(Utils_1.toHex);
        return new StarknetBtcStoredHeader({
            blockheader,
            block_hash,
            chain_work,
            block_height,
            last_diff_adjustment,
            prev_block_timestamps
        });
    }
    constructor(obj){
        this.blockheader = obj.blockheader instanceof StarknetBtcHeader_1.StarknetBtcHeader ? obj.blockheader : new StarknetBtcHeader_1.StarknetBtcHeader(obj.blockheader);
        this.block_hash = obj.block_hash.map((val)=>Number(val));
        this.chain_work = (0, Utils_1.isUint256)(obj.chain_work) ? obj.chain_work : starknet_1.cairo.uint256(obj.chain_work);
        this.block_height = Number(obj.block_height);
        this.last_diff_adjustment = Number(obj.last_diff_adjustment);
        this.prev_block_timestamps = obj.prev_block_timestamps.map((val)=>Number(val));
    }
}
exports.StarknetBtcStoredHeader = StarknetBtcStoredHeader;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/modules/StarknetContractEvents.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetContractEvents = void 0;
const StarknetEvents_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetEvents.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
class StarknetContractEvents extends StarknetEvents_1.StarknetEvents {
    toStarknetAbiEvents(blockEvents) {
        const abiEvents = starknet_1.events.getAbiEvents(this.abi);
        const abiStructs = starknet_1.CallData.getAbiStruct(this.abi);
        const abiEnums = starknet_1.CallData.getAbiEnum(this.abi);
        const result = starknet_1.events.parseEvents(blockEvents, abiEvents, abiStructs, abiEnums);
        if (result.length !== blockEvents.length) throw new Error("Invalid event detected, please check provided ABI");
        return result.map((value, index)=>{
            const starknetEvent = blockEvents[index];
            const name = Object.keys(value)[0];
            return {
                name: name,
                txHash: starknetEvent.transaction_hash,
                params: value[name],
                blockNumber: starknetEvent.block_number,
                blockHash: starknetEvent.block_hash,
                data: starknetEvent.data,
                keys: starknetEvent.keys
            };
        });
    }
    toFilter(events, keys) {
        const filterArray = [];
        filterArray.push(events.map((name)=>{
            const arr = name.split(":");
            const eventName = arr[arr.length - 1];
            return (0, Utils_1.toHex)(starknet_1.hash.starknetKeccak(eventName));
        }));
        if (keys != null) keys.forEach((key)=>filterArray.push(key == null ? [] : [
                key
            ]));
        return filterArray;
    }
    /**
     * Returns the events occuring in a range of starknet block as identified by the contract and keys,
     *  returns pending events if no startHeight & endHeight is passed
     *
     * @param events
     * @param keys
     * @param startBlockHeight
     * @param endBlockHeight
     */ async getContractBlockEvents(events, keys, startBlockHeight) {
        let endBlockHeight = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startBlockHeight;
        const blockEvents = await super.getBlockEvents(this.contract.contract.address, this.toFilter(events, keys), startBlockHeight, endBlockHeight);
        return this.toStarknetAbiEvents(blockEvents);
    }
    /**
     * Runs a search backwards in time, processing the events for a specific topic public key
     *
     * @param events
     * @param keys
     * @param processor called for every event, should return a value if the correct event was found, or null
     *  if the search should continue
     * @param abortSignal
     */ async findInContractEvents(events, keys, processor, abortSignal) {
        return this.findInEvents(this.contract.contract.address, this.toFilter(events, keys), async (events)=>{
            const parsedEvents = this.toStarknetAbiEvents(events);
            for (let event of parsedEvents){
                const result = await processor(event);
                if (result != null) return result;
            }
        }, abortSignal);
    }
    /**
     * Runs a search forwards in time, processing the events for a specific topic public key
     *
     * @param events
     * @param keys
     * @param processor called for every event, should return a value if the correct event was found, or null
     *  if the search should continue
     * @param abortSignal
     */ async findInContractEventsForward(events, keys, processor, abortSignal) {
        return this.findInEventsForward(this.contract.contract.address, this.toFilter(events, keys), async (events)=>{
            const parsedEvents = this.toStarknetAbiEvents(events);
            for (let event of parsedEvents){
                const result = await processor(event);
                if (result != null) return result;
            }
        }, abortSignal);
    }
    constructor(chainInterface, contract, abi){
        super(chainInterface);
        this.contract = contract;
        this.abi = abi;
    }
}
exports.StarknetContractEvents = StarknetContractEvents;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/StarknetContractBase.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetContractBase = void 0;
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const StarknetContractEvents_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/modules/StarknetContractEvents.js [app-client] (ecmascript)");
/**
 * Base class providing program specific utilities
 */ class StarknetContractBase {
    constructor(chainInterface, contractAddress, contractAbi){
        this.Chain = chainInterface;
        this.contract = new starknet_1.Contract(contractAbi, contractAddress, chainInterface.provider).typedv2(contractAbi);
        this.Events = new StarknetContractEvents_1.StarknetContractEvents(chainInterface, this, contractAbi);
    }
}
exports.StarknetContractBase = StarknetContractBase;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/BtcRelayAbi.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BtcRelayAbi = void 0;
exports.BtcRelayAbi = [
    {
        "type": "impl",
        "name": "BtcRelayImpl",
        "interface_name": "btc_relay::IBtcRelay"
    },
    {
        "type": "struct",
        "name": "btc_relay::structs::blockheader::BlockHeader",
        "members": [
            {
                "name": "reversed_version",
                "type": "core::integer::u32"
            },
            {
                "name": "previous_blockhash",
                "type": "[core::integer::u32; 8]"
            },
            {
                "name": "merkle_root",
                "type": "[core::integer::u32; 8]"
            },
            {
                "name": "reversed_timestamp",
                "type": "core::integer::u32"
            },
            {
                "name": "nbits",
                "type": "core::integer::u32"
            },
            {
                "name": "nonce",
                "type": "core::integer::u32"
            }
        ]
    },
    {
        "type": "struct",
        "name": "core::array::Span::<btc_relay::structs::blockheader::BlockHeader>",
        "members": [
            {
                "name": "snapshot",
                "type": "@core::array::Array::<btc_relay::structs::blockheader::BlockHeader>"
            }
        ]
    },
    {
        "type": "struct",
        "name": "core::integer::u256",
        "members": [
            {
                "name": "low",
                "type": "core::integer::u128"
            },
            {
                "name": "high",
                "type": "core::integer::u128"
            }
        ]
    },
    {
        "type": "struct",
        "name": "btc_relay::structs::stored_blockheader::StoredBlockHeader",
        "members": [
            {
                "name": "blockheader",
                "type": "btc_relay::structs::blockheader::BlockHeader"
            },
            {
                "name": "block_hash",
                "type": "[core::integer::u32; 8]"
            },
            {
                "name": "chain_work",
                "type": "core::integer::u256"
            },
            {
                "name": "block_height",
                "type": "core::integer::u32"
            },
            {
                "name": "last_diff_adjustment",
                "type": "core::integer::u32"
            },
            {
                "name": "prev_block_timestamps",
                "type": "[core::integer::u32; 10]"
            }
        ]
    },
    {
        "type": "interface",
        "name": "btc_relay::IBtcRelay",
        "items": [
            {
                "type": "function",
                "name": "submit_main_blockheaders",
                "inputs": [
                    {
                        "name": "block_headers",
                        "type": "core::array::Span::<btc_relay::structs::blockheader::BlockHeader>"
                    },
                    {
                        "name": "stored_header",
                        "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "submit_short_fork_blockheaders",
                "inputs": [
                    {
                        "name": "block_headers",
                        "type": "core::array::Span::<btc_relay::structs::blockheader::BlockHeader>"
                    },
                    {
                        "name": "stored_header",
                        "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "submit_fork_blockheaders",
                "inputs": [
                    {
                        "name": "fork_id",
                        "type": "core::felt252"
                    },
                    {
                        "name": "block_headers",
                        "type": "core::array::Span::<btc_relay::structs::blockheader::BlockHeader>"
                    },
                    {
                        "name": "stored_header",
                        "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "BtcRelayReadOnlyImpl",
        "interface_name": "btc_relay::IBtcRelayReadOnly"
    },
    {
        "type": "interface",
        "name": "btc_relay::IBtcRelayReadOnly",
        "items": [
            {
                "type": "function",
                "name": "get_chainwork",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::integer::u256"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_blockheight",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::integer::u32"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "verify_blockheader",
                "inputs": [
                    {
                        "name": "stored_header",
                        "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::integer::u32"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_commit_hash",
                "inputs": [
                    {
                        "name": "height",
                        "type": "core::integer::u32"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::felt252"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_tip_commit_hash",
                "inputs": [],
                "outputs": [
                    {
                        "type": "core::felt252"
                    }
                ],
                "state_mutability": "view"
            }
        ]
    },
    {
        "type": "constructor",
        "name": "constructor",
        "inputs": [
            {
                "name": "stored_header",
                "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader"
            }
        ]
    },
    {
        "type": "event",
        "name": "btc_relay::events::StoreHeader",
        "kind": "struct",
        "members": [
            {
                "name": "commit_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "block_hash_poseidon",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "header",
                "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "btc_relay::events::StoreForkHeader",
        "kind": "struct",
        "members": [
            {
                "name": "commit_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "block_hash_poseidon",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "fork_id",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "header",
                "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "btc_relay::events::ChainReorg",
        "kind": "struct",
        "members": [
            {
                "name": "fork_submitter",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "fork_id",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "tip_block_hash_poseidon",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "tip_commit_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "start_height",
                "type": "core::felt252",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "btc_relay::BtcRelay::Event",
        "kind": "enum",
        "variants": [
            {
                "name": "StoreHeader",
                "type": "btc_relay::events::StoreHeader",
                "kind": "nested"
            },
            {
                "name": "StoreForkHeader",
                "type": "btc_relay::events::StoreForkHeader",
                "kind": "nested"
            },
            {
                "name": "ChainReorg",
                "type": "btc_relay::events::ChainReorg",
                "kind": "nested"
            }
        ]
    }
];
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/StarknetBtcRelay.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetBtcRelay = void 0;
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const StarknetBtcHeader_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/headers/StarknetBtcHeader.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetContractBase_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/StarknetContractBase.js [app-client] (ecmascript)");
const StarknetBtcStoredHeader_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/headers/StarknetBtcStoredHeader.js [app-client] (ecmascript)");
const BtcRelayAbi_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/BtcRelayAbi.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
const StarknetAction_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)");
function serializeBlockHeader(e) {
    return new StarknetBtcHeader_1.StarknetBtcHeader({
        reversed_version: (0, Utils_1.u32ReverseEndianness)(e.getVersion()),
        previous_blockhash: (0, Utils_1.bufferToU32Array)(buffer_1.Buffer.from(e.getPrevBlockhash(), "hex").reverse()),
        merkle_root: (0, Utils_1.bufferToU32Array)(buffer_1.Buffer.from(e.getMerkleRoot(), "hex").reverse()),
        reversed_timestamp: (0, Utils_1.u32ReverseEndianness)(e.getTimestamp()),
        nbits: (0, Utils_1.u32ReverseEndianness)(e.getNbits()),
        nonce: (0, Utils_1.u32ReverseEndianness)(e.getNonce()),
        hash: buffer_1.Buffer.from(e.getHash(), "hex").reverse()
    });
}
const GAS_PER_BLOCKHEADER = {
    l1DataGas: 600,
    l2Gas: 24000000,
    l1Gas: 0
};
const GAS_PER_BLOCKHEADER_FORK = {
    l1DataGas: 1000,
    l2Gas: 40000000,
    l1Gas: 0
};
const btcRelayAddreses = {
    [base_1.BitcoinNetwork.TESTNET4]: "0x0099b63f39f0cabb767361de3d8d3e97212351a51540e2687c2571f4da490dbe",
    [base_1.BitcoinNetwork.TESTNET]: "0x068601c79da2231d21e015ccfd59c243861156fa523a12c9f987ec28eb8dbc8c",
    [base_1.BitcoinNetwork.MAINNET]: "0x057b14a4231b82f1e525ff35a722d893ca3dd2bde0baa6cee97937c5be861dbc"
};
function serializeCalldata(headers, storedHeader, span) {
    span.push((0, Utils_1.toHex)(headers.length));
    headers.forEach((header)=>{
        span.push(...header.serialize());
    });
    span.push(...storedHeader.serialize());
    return span;
}
const logger = (0, Utils_1.getLogger)("StarknetBtcRelay: ");
class StarknetBtcRelay extends StarknetContractBase_1.StarknetContractBase {
    SaveMainHeaders(signer, mainHeaders, storedHeader) {
        return new StarknetAction_1.StarknetAction(signer, this.Chain, {
            contractAddress: this.contract.address,
            entrypoint: "submit_main_blockheaders",
            calldata: serializeCalldata(mainHeaders, storedHeader, [])
        }, (0, StarknetFees_1.starknetGasMul)(GAS_PER_BLOCKHEADER, mainHeaders.length));
    }
    SaveShortForkHeaders(signer, forkHeaders, storedHeader) {
        return new StarknetAction_1.StarknetAction(signer, this.Chain, {
            contractAddress: this.contract.address,
            entrypoint: "submit_short_fork_blockheaders",
            calldata: serializeCalldata(forkHeaders, storedHeader, [])
        }, (0, StarknetFees_1.starknetGasMul)(GAS_PER_BLOCKHEADER, forkHeaders.length));
    }
    SaveLongForkHeaders(signer, forkId, forkHeaders, storedHeader) {
        let totalForkHeaders = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 100;
        return new StarknetAction_1.StarknetAction(signer, this.Chain, {
            contractAddress: this.contract.address,
            entrypoint: "submit_fork_blockheaders",
            calldata: serializeCalldata(forkHeaders, storedHeader, [
                (0, Utils_1.toHex)(forkId)
            ])
        }, (0, StarknetFees_1.starknetGasAdd)((0, StarknetFees_1.starknetGasMul)(GAS_PER_BLOCKHEADER, forkHeaders.length), (0, StarknetFees_1.starknetGasMul)(GAS_PER_BLOCKHEADER_FORK, totalForkHeaders)));
    }
    /**
     * Computes subsequent commited headers as they will appear on the blockchain when transactions
     *  are submitted & confirmed
     *
     * @param initialStoredHeader
     * @param syncedHeaders
     * @private
     */ computeCommitedHeaders(initialStoredHeader, syncedHeaders) {
        const computedCommitedHeaders = [
            initialStoredHeader
        ];
        for (let blockHeader of syncedHeaders){
            computedCommitedHeaders.push(computedCommitedHeaders[computedCommitedHeaders.length - 1].computeNext(blockHeader));
        }
        return computedCommitedHeaders;
    }
    /**
     * A common logic for submitting blockheaders in a transaction
     *
     * @param signer
     * @param headers headers to sync to the btc relay
     * @param storedHeader current latest stored block header for a given fork
     * @param tipWork work of the current tip in a given fork
     * @param forkId forkId to submit to, forkId=0 means main chain, forkId=-1 means short fork
     * @param feeRate feeRate for the transaction
     * @private
     */ async _saveHeaders(signer, headers, storedHeader, tipWork, forkId, feeRate) {
        const blockHeaderObj = headers.map(serializeBlockHeader);
        let starknetAction;
        switch(forkId){
            case -1:
                starknetAction = this.SaveShortForkHeaders(signer, blockHeaderObj, storedHeader);
                break;
            case 0:
                starknetAction = this.SaveMainHeaders(signer, blockHeaderObj, storedHeader);
                break;
            default:
                starknetAction = this.SaveLongForkHeaders(signer, forkId, blockHeaderObj, storedHeader);
                break;
        }
        const tx = await starknetAction.tx(feeRate);
        const computedCommitedHeaders = this.computeCommitedHeaders(storedHeader, blockHeaderObj);
        const lastStoredHeader = computedCommitedHeaders[computedCommitedHeaders.length - 1];
        if (forkId !== 0 && base_1.StatePredictorUtils.gtBuffer(lastStoredHeader.getBlockHash(), tipWork)) {
            //Fork's work is higher than main chain's work, this fork will become a main chain
            forkId = 0;
        }
        return {
            forkId: forkId,
            lastStoredHeader,
            tx,
            computedCommitedHeaders
        };
    }
    getBlock(commitHash, blockHash) {
        const keys = [
            commitHash == null ? null : (0, Utils_1.toHex)(commitHash)
        ];
        if (blockHash != null) {
            const starknetBlockHash = starknet_1.hash.computePoseidonHashOnElements((0, Utils_1.bufferToU32Array)(buffer_1.Buffer.from([
                ...blockHash
            ]).reverse()));
            keys.push(starknetBlockHash);
        }
        return this.Events.findInContractEvents([
            "btc_relay::events::StoreHeader",
            "btc_relay::events::StoreForkHeader"
        ], keys, (event)=>{
            return Promise.resolve([
                StarknetBtcStoredHeader_1.StarknetBtcStoredHeader.fromSerializedFeltArray(event.data),
                BigInt(event.params.commit_hash)
            ]);
        });
    }
    async getBlockHeight() {
        return Number(await this.contract.get_blockheight());
    }
    /**
     * Returns data about current main chain tip stored in the btc relay
     */ async getTipData() {
        const commitHash = await this.contract.get_tip_commit_hash();
        if (commitHash == null || BigInt(commitHash) === BigInt(0)) return null;
        const result = await this.getBlock(commitHash);
        if (result == null) return null;
        const [storedBlockHeader] = result;
        return {
            blockheight: storedBlockHeader.getBlockheight(),
            commitHash: (0, Utils_1.bigNumberishToBuffer)(commitHash, 32).toString("hex"),
            blockhash: storedBlockHeader.getBlockHash().toString("hex"),
            chainWork: storedBlockHeader.getChainWork()
        };
    }
    /**
     * Retrieves blockheader with a specific blockhash, returns null if requiredBlockheight is provided and
     *  btc relay contract is not synced up to the desired blockheight
     *
     * @param blockData
     * @param requiredBlockheight
     */ async retrieveLogAndBlockheight(blockData, requiredBlockheight) {
        //TODO: we can fetch the blockheight and events in parallel
        const blockHeight = await this.getBlockHeight();
        if (requiredBlockheight != null && blockHeight < requiredBlockheight) {
            return null;
        }
        const result = await this.getBlock(null, buffer_1.Buffer.from(blockData.blockhash, "hex"));
        if (result == null) return null;
        const [storedBlockHeader, commitHash] = result;
        //Check if block is part of the main chain
        const chainCommitment = await this.contract.get_commit_hash(storedBlockHeader.block_height);
        if (BigInt(chainCommitment) !== BigInt(commitHash)) return null;
        logger.debug("retrieveLogAndBlockheight(): block found," + " commit hash: " + (0, Utils_1.toHex)(commitHash) + " blockhash: " + blockData.blockhash + " current btc relay height: " + blockHeight);
        return {
            header: storedBlockHeader,
            height: blockHeight
        };
    }
    /**
     * Retrieves blockheader data by blockheader's commit hash,
     *
     * @param commitmentHashStr
     * @param blockData
     */ async retrieveLogByCommitHash(commitmentHashStr, blockData) {
        const result = await this.getBlock(commitmentHashStr, buffer_1.Buffer.from(blockData.blockhash, "hex"));
        if (result == null) return null;
        const [storedBlockHeader, commitHash] = result;
        //Check if block is part of the main chain
        const chainCommitment = await this.contract.get_commit_hash(storedBlockHeader.block_height);
        if (BigInt(chainCommitment) !== BigInt(commitHash)) return null;
        logger.debug("retrieveLogByCommitHash(): block found," + " commit hash: " + commitmentHashStr + " blockhash: " + blockData.blockhash + " height: " + storedBlockHeader.block_height);
        return storedBlockHeader;
    }
    /**
     * Retrieves latest known stored blockheader & blockheader from bitcoin RPC that is in the main chain
     */ async retrieveLatestKnownBlockLog() {
        const data = await this.Events.findInContractEvents([
            "btc_relay::events::StoreHeader",
            "btc_relay::events::StoreForkHeader"
        ], null, async (event)=>{
            const storedHeader = StarknetBtcStoredHeader_1.StarknetBtcStoredHeader.fromSerializedFeltArray(event.data);
            const blockHashHex = storedHeader.getBlockHash().toString("hex");
            const commitHash = event.params.commit_hash;
            const [isInBtcMainChain, btcRelayCommitHash] = await Promise.all([
                this.bitcoinRpc.isInMainChain(blockHashHex).catch(()=>false),
                this.contract.get_commit_hash(storedHeader.block_height)
            ]);
            if (!isInBtcMainChain) return null;
            if (BigInt(commitHash) !== BigInt(btcRelayCommitHash)) return null;
            return {
                resultStoredHeader: storedHeader,
                resultBitcoinHeader: await this.bitcoinRpc.getBlockHeader(blockHashHex),
                commitHash: commitHash
            };
        });
        if (data != null) logger.debug("retrieveLatestKnownBlockLog(): block found," + " commit hash: " + (0, Utils_1.toHex)(data.commitHash) + " blockhash: " + data.resultBitcoinHeader.getHash() + " height: " + data.resultStoredHeader.getBlockheight());
        return data;
    }
    /**
     * Saves blockheaders as a bitcoin main chain to the btc relay
     *
     * @param signer
     * @param mainHeaders
     * @param storedHeader
     * @param feeRate
     */ saveMainHeaders(signer, mainHeaders, storedHeader, feeRate) {
        logger.debug("saveMainHeaders(): submitting main blockheaders, count: " + mainHeaders.length);
        return this._saveHeaders(signer, mainHeaders, storedHeader, null, 0, feeRate);
    }
    /**
     * Creates a new long fork and submits the headers to it
     *
     * @param signer
     * @param forkHeaders
     * @param storedHeader
     * @param tipWork
     * @param feeRate
     */ async saveNewForkHeaders(signer, forkHeaders, storedHeader, tipWork, feeRate) {
        let forkId = Math.floor(Math.random() * 0xFFFFFFFFFFFF);
        logger.debug("saveNewForkHeaders(): submitting new fork & blockheaders," + " count: " + forkHeaders.length + " forkId: 0x" + forkId.toString(16));
        return await this._saveHeaders(signer, forkHeaders, storedHeader, tipWork, forkId, feeRate);
    }
    /**
     * Continues submitting blockheaders to a given fork
     *
     * @param signer
     * @param forkHeaders
     * @param storedHeader
     * @param forkId
     * @param tipWork
     * @param feeRate
     */ saveForkHeaders(signer, forkHeaders, storedHeader, forkId, tipWork, feeRate) {
        logger.debug("saveForkHeaders(): submitting blockheaders to existing fork," + " count: " + forkHeaders.length + " forkId: 0x" + forkId.toString(16));
        return this._saveHeaders(signer, forkHeaders, storedHeader, tipWork, forkId, feeRate);
    }
    /**
     * Submits short fork with given blockheaders
     *
     * @param signer
     * @param forkHeaders
     * @param storedHeader
     * @param tipWork
     * @param feeRate
     */ saveShortForkHeaders(signer, forkHeaders, storedHeader, tipWork, feeRate) {
        logger.debug("saveShortForkHeaders(): submitting short fork blockheaders," + " count: " + forkHeaders.length);
        return this._saveHeaders(signer, forkHeaders, storedHeader, tipWork, -1, feeRate);
    }
    /**
     * Estimate required synchronization fee (worst case) to synchronize btc relay to the required blockheight
     *
     * @param requiredBlockheight
     * @param feeRate
     */ async estimateSynchronizeFee(requiredBlockheight, feeRate) {
        const tipData = await this.getTipData();
        const currBlockheight = tipData.blockheight;
        const blockheightDelta = requiredBlockheight - currBlockheight;
        if (blockheightDelta <= 0) return 0n;
        const synchronizationFee = BigInt(blockheightDelta) * await this.getFeePerBlock(feeRate);
        logger.debug("estimateSynchronizeFee(): required blockheight: " + requiredBlockheight + " blockheight delta: " + blockheightDelta + " fee: " + synchronizationFee.toString(10));
        return synchronizationFee;
    }
    /**
     * Returns fee required (in SOL) to synchronize a single block to btc relay
     *
     * @param feeRate
     */ async getFeePerBlock(feeRate) {
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.Chain.Fees.getFeeRate();
        return StarknetFees_1.StarknetFees.getGasFee(GAS_PER_BLOCKHEADER, feeRate);
    }
    /**
     * Gets fee rate required for submitting blockheaders to the main chain
     */ getMainFeeRate(signer) {
        return this.Chain.Fees.getFeeRate();
    }
    /**
     * Gets fee rate required for submitting blockheaders to the specific fork
     */ getForkFeeRate(signer, forkId) {
        return this.Chain.Fees.getFeeRate();
    }
    saveInitialHeader(signer, header, epochStart, pastBlocksTimestamps, feeRate) {
        throw new Error("Not supported, starknet contract is initialized with constructor!");
    }
    /**
     * Gets committed header, identified by blockhash & blockheight, determines required BTC relay blockheight based on
     *  requiredConfirmations
     * If synchronizer is passed & blockhash is not found, it produces transactions to sync up the btc relay to the
     *  current chain tip & adds them to the txs array
     *
     * @param signer
     * @param btcRelay
     * @param btcTxs
     * @param txs solana transaction array, in case we need to synchronize the btc relay ourselves the synchronization
     *  txns are added here
     * @param synchronizer optional synchronizer to use to synchronize the btc relay in case it is not yet synchronized
     *  to the required blockheight
     * @param feeRate Fee rate to use for synchronization transactions
     * @private
     */ static async getCommitedHeadersAndSynchronize(signer, btcRelay, btcTxs, txs, synchronizer, feeRate) {
        const leavesTxs = [];
        const blockheaders = {};
        for (let btcTx of btcTxs){
            const requiredBlockheight = btcTx.blockheight + btcTx.requiredConfirmations - 1;
            const result = await (0, Utils_1.tryWithRetries)(()=>btcRelay.retrieveLogAndBlockheight({
                    blockhash: btcTx.blockhash
                }, requiredBlockheight));
            if (result != null) {
                blockheaders[result.header.getBlockHash().toString("hex")] = result.header;
            } else {
                leavesTxs.push(btcTx);
            }
        }
        if (leavesTxs.length === 0) return blockheaders;
        //Need to synchronize
        if (synchronizer == null) return null;
        //TODO: We don't have to synchronize to tip, only to our required blockheight
        const resp = await synchronizer.syncToLatestTxs(signer.toString(), feeRate);
        logger.debug("getCommitedHeaderAndSynchronize(): BTC Relay not synchronized to required blockheight, " + "synchronizing ourselves in " + resp.txs.length + " txs");
        logger.debug("getCommitedHeaderAndSynchronize(): BTC Relay computed header map: ", resp.computedHeaderMap);
        txs.push(...resp.txs);
        for(let key in resp.computedHeaderMap){
            const header = resp.computedHeaderMap[key];
            blockheaders[header.getBlockHash().toString("hex")] = header;
        }
        //Check that blockhashes of all the rest txs are included
        for (let btcTx of leavesTxs){
            if (blockheaders[btcTx.blockhash] == null) return null;
        }
        //Retrieve computed headers
        return blockheaders;
    }
    constructor(chainInterface, bitcoinRpc, bitcoinNetwork, contractAddress = btcRelayAddreses[bitcoinNetwork]){
        super(chainInterface, contractAddress, BtcRelayAbi_1.BtcRelayAbi);
        this.maxHeadersPerTx = 100;
        this.maxForkHeadersPerTx = 100;
        this.maxShortForkHeadersPerTx = 100;
        this.bitcoinRpc = bitcoinRpc;
    }
}
exports.StarknetBtcRelay = StarknetBtcRelay;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/EscrowManagerAbi.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EscrowManagerAbi = void 0;
exports.EscrowManagerAbi = [
    {
        "type": "impl",
        "name": "EscrowManagerImpl",
        "interface_name": "escrow_manager::IEscrowManager"
    },
    {
        "type": "struct",
        "name": "core::integer::u256",
        "members": [
            {
                "name": "low",
                "type": "core::integer::u128"
            },
            {
                "name": "high",
                "type": "core::integer::u128"
            }
        ]
    },
    {
        "type": "struct",
        "name": "escrow_manager::structs::escrow::EscrowExecution",
        "members": [
            {
                "name": "hash",
                "type": "core::felt252"
            },
            {
                "name": "expiry",
                "type": "core::integer::u64"
            },
            {
                "name": "fee",
                "type": "core::integer::u256"
            }
        ]
    },
    {
        "type": "enum",
        "name": "core::option::Option::<escrow_manager::structs::escrow::EscrowExecution>",
        "variants": [
            {
                "name": "Some",
                "type": "escrow_manager::structs::escrow::EscrowExecution"
            },
            {
                "name": "None",
                "type": "()"
            }
        ]
    },
    {
        "type": "struct",
        "name": "escrow_manager::structs::escrow::EscrowData",
        "members": [
            {
                "name": "offerer",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "claimer",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "token",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "refund_handler",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "claim_handler",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "flags",
                "type": "core::integer::u128"
            },
            {
                "name": "claim_data",
                "type": "core::felt252"
            },
            {
                "name": "refund_data",
                "type": "core::felt252"
            },
            {
                "name": "amount",
                "type": "core::integer::u256"
            },
            {
                "name": "fee_token",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "security_deposit",
                "type": "core::integer::u256"
            },
            {
                "name": "claimer_bounty",
                "type": "core::integer::u256"
            },
            {
                "name": "success_action",
                "type": "core::option::Option::<escrow_manager::structs::escrow::EscrowExecution>"
            }
        ]
    },
    {
        "type": "struct",
        "name": "core::array::Span::<core::felt252>",
        "members": [
            {
                "name": "snapshot",
                "type": "@core::array::Array::<core::felt252>"
            }
        ]
    },
    {
        "type": "interface",
        "name": "escrow_manager::IEscrowManager",
        "items": [
            {
                "type": "function",
                "name": "initialize",
                "inputs": [
                    {
                        "name": "escrow",
                        "type": "escrow_manager::structs::escrow::EscrowData"
                    },
                    {
                        "name": "signature",
                        "type": "core::array::Array::<core::felt252>"
                    },
                    {
                        "name": "timeout",
                        "type": "core::integer::u64"
                    },
                    {
                        "name": "extra_data",
                        "type": "core::array::Span::<core::felt252>"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "claim",
                "inputs": [
                    {
                        "name": "escrow",
                        "type": "escrow_manager::structs::escrow::EscrowData"
                    },
                    {
                        "name": "witness",
                        "type": "core::array::Array::<core::felt252>"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "refund",
                "inputs": [
                    {
                        "name": "escrow",
                        "type": "escrow_manager::structs::escrow::EscrowData"
                    },
                    {
                        "name": "witness",
                        "type": "core::array::Array::<core::felt252>"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "cooperative_refund",
                "inputs": [
                    {
                        "name": "escrow",
                        "type": "escrow_manager::structs::escrow::EscrowData"
                    },
                    {
                        "name": "signature",
                        "type": "core::array::Array::<core::felt252>"
                    },
                    {
                        "name": "timeout",
                        "type": "core::integer::u64"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "LPVaultImpl",
        "interface_name": "escrow_manager::components::lp_vault::ILPVault"
    },
    {
        "type": "struct",
        "name": "core::array::Span::<(core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress)>",
        "members": [
            {
                "name": "snapshot",
                "type": "@core::array::Array::<(core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress)>"
            }
        ]
    },
    {
        "type": "interface",
        "name": "escrow_manager::components::lp_vault::ILPVault",
        "items": [
            {
                "type": "function",
                "name": "deposit",
                "inputs": [
                    {
                        "name": "token",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "withdraw",
                "inputs": [
                    {
                        "name": "token",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "amount",
                        "type": "core::integer::u256"
                    },
                    {
                        "name": "destination",
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "get_balance",
                "inputs": [
                    {
                        "name": "data",
                        "type": "core::array::Span::<(core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress)>"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::array::Array::<core::integer::u256>"
                    }
                ],
                "state_mutability": "view"
            }
        ]
    },
    {
        "type": "impl",
        "name": "ReputationTrackerImpl",
        "interface_name": "escrow_manager::components::reputation::IReputationTracker"
    },
    {
        "type": "struct",
        "name": "core::array::Span::<(core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress)>",
        "members": [
            {
                "name": "snapshot",
                "type": "@core::array::Array::<(core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress)>"
            }
        ]
    },
    {
        "type": "struct",
        "name": "escrow_manager::state::reputation::Reputation",
        "members": [
            {
                "name": "amount",
                "type": "core::integer::u256"
            },
            {
                "name": "count",
                "type": "core::integer::u128"
            }
        ]
    },
    {
        "type": "interface",
        "name": "escrow_manager::components::reputation::IReputationTracker",
        "items": [
            {
                "type": "function",
                "name": "get_reputation",
                "inputs": [
                    {
                        "name": "data",
                        "type": "core::array::Span::<(core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress, core::starknet::contract_address::ContractAddress)>"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::array::Array::<[escrow_manager::state::reputation::Reputation; 3]>"
                    }
                ],
                "state_mutability": "view"
            }
        ]
    },
    {
        "type": "impl",
        "name": "EscrowStorageImpl",
        "interface_name": "escrow_manager::components::escrow_storage::IEscrowStorage"
    },
    {
        "type": "struct",
        "name": "escrow_manager::state::escrow::EscrowState",
        "members": [
            {
                "name": "init_blockheight",
                "type": "core::integer::u64"
            },
            {
                "name": "finish_blockheight",
                "type": "core::integer::u64"
            },
            {
                "name": "state",
                "type": "core::integer::u8"
            }
        ]
    },
    {
        "type": "struct",
        "name": "core::array::Span::<escrow_manager::state::escrow::EscrowState>",
        "members": [
            {
                "name": "snapshot",
                "type": "@core::array::Array::<escrow_manager::state::escrow::EscrowState>"
            }
        ]
    },
    {
        "type": "interface",
        "name": "escrow_manager::components::escrow_storage::IEscrowStorage",
        "items": [
            {
                "type": "function",
                "name": "get_state",
                "inputs": [
                    {
                        "name": "escrow",
                        "type": "escrow_manager::structs::escrow::EscrowData"
                    }
                ],
                "outputs": [
                    {
                        "type": "escrow_manager::state::escrow::EscrowState"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_hash_state",
                "inputs": [
                    {
                        "name": "escrow_hash",
                        "type": "core::felt252"
                    }
                ],
                "outputs": [
                    {
                        "type": "escrow_manager::state::escrow::EscrowState"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_hash_state_multiple",
                "inputs": [
                    {
                        "name": "escrow_hashes",
                        "type": "core::array::Span::<core::felt252>"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::array::Span::<escrow_manager::state::escrow::EscrowState>"
                    }
                ],
                "state_mutability": "view"
            }
        ]
    },
    {
        "type": "event",
        "name": "escrow_manager::components::lp_vault::lp_vault::Event",
        "kind": "enum",
        "variants": []
    },
    {
        "type": "event",
        "name": "escrow_manager::components::reputation::reputation::Event",
        "kind": "enum",
        "variants": []
    },
    {
        "type": "event",
        "name": "escrow_manager::components::escrow_storage::escrow_storage::Event",
        "kind": "enum",
        "variants": []
    },
    {
        "type": "event",
        "name": "escrow_manager::events::Initialize",
        "kind": "struct",
        "members": [
            {
                "name": "offerer",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "claimer",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "claim_data",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "escrow_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "claim_handler",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            },
            {
                "name": "refund_handler",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "escrow_manager::events::Claim",
        "kind": "struct",
        "members": [
            {
                "name": "offerer",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "claimer",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "claim_data",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "escrow_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "witness_result",
                "type": "core::array::Span::<core::felt252>",
                "kind": "data"
            },
            {
                "name": "claim_handler",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "escrow_manager::events::Refund",
        "kind": "struct",
        "members": [
            {
                "name": "offerer",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "claimer",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "claim_data",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "escrow_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "witness_result",
                "type": "core::array::Span::<core::felt252>",
                "kind": "data"
            },
            {
                "name": "refund_handler",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "escrow_manager::EscrowManager::Event",
        "kind": "enum",
        "variants": [
            {
                "name": "LPVaultEvent",
                "type": "escrow_manager::components::lp_vault::lp_vault::Event",
                "kind": "nested"
            },
            {
                "name": "ReputationTrackerEvent",
                "type": "escrow_manager::components::reputation::reputation::Event",
                "kind": "nested"
            },
            {
                "name": "EscrowStorageEvent",
                "type": "escrow_manager::components::escrow_storage::escrow_storage::Event",
                "kind": "nested"
            },
            {
                "name": "Initialize",
                "type": "escrow_manager::events::Initialize",
                "kind": "nested"
            },
            {
                "name": "Claim",
                "type": "escrow_manager::events::Claim",
                "kind": "nested"
            },
            {
                "name": "Refund",
                "type": "escrow_manager::events::Refund",
                "kind": "nested"
            }
        ]
    }
];
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/StarknetContractModule.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetContractModule = void 0;
const StarknetModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)");
class StarknetContractModule extends StarknetModule_1.StarknetModule {
    constructor(chainInterface, contract){
        super(chainInterface);
        this.contract = contract;
    }
}
exports.StarknetContractModule = StarknetContractModule;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapModule.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSwapModule = void 0;
const StarknetContractModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/StarknetContractModule.js [app-client] (ecmascript)");
class StarknetSwapModule extends StarknetContractModule_1.StarknetContractModule {
    constructor(chainInterface, contract){
        super(chainInterface, contract);
        this.swapContract = contract.contract;
    }
}
exports.StarknetSwapModule = StarknetSwapModule;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetLpVault.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetLpVault = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetSwapModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapModule.js [app-client] (ecmascript)");
const StarknetAction_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
class StarknetLpVault extends StarknetSwapModule_1.StarknetSwapModule {
    /**
     * Action for withdrawing funds from the LP vault
     *
     * @param signer
     * @param token
     * @param amount
     * @constructor
     * @private
     */ Withdraw(signer, token, amount) {
        return new StarknetAction_1.StarknetAction(signer, this.root, this.swapContract.populateTransaction.withdraw(token, starknet_1.cairo.uint256(amount), signer), StarknetLpVault.GasCosts.WITHDRAW);
    }
    /**
     * Action for depositing funds to the LP vault
     *
     * @param signer
     * @param token
     * @param amount
     * @constructor
     * @private
     */ Deposit(signer, token, amount) {
        return new StarknetAction_1.StarknetAction(signer, this.root, this.swapContract.populateTransaction.deposit(token, starknet_1.cairo.uint256(amount)), StarknetLpVault.GasCosts.WITHDRAW);
    }
    /**
     * Returns intermediary's reputation & vault balance for a specific token
     *
     * @param address
     * @param token
     */ async getIntermediaryData(address, token) {
        const [balance, reputation] = await Promise.all([
            this.getIntermediaryBalance(address, token),
            this.getIntermediaryReputation(address, token)
        ]);
        return {
            balance,
            reputation
        };
    }
    /**
     * Returns intermediary's reputation for a specific token
     *
     * @param address
     * @param token
     */ async getIntermediaryReputation(address, token) {
        const filter = Object.keys(this.contract.claimHandlersByAddress).map((claimHandler)=>starknet_1.cairo.tuple(address, token, claimHandler));
        const rawReputation = await this.provider.callContract(this.swapContract.populateTransaction.get_reputation(filter));
        const length = (0, Utils_1.toBigInt)(rawReputation.shift());
        if (Number(length) !== filter.length) throw new Error("getIntermediaryReputation(): Invalid response length");
        const result = {};
        Object.keys(this.contract.claimHandlersByAddress).forEach((address)=>{
            const handler = this.contract.claimHandlersByAddress[address];
            result[handler.getType()] = {
                successVolume: (0, Utils_1.toBigInt)({
                    low: rawReputation.shift(),
                    high: rawReputation.shift()
                }),
                successCount: (0, Utils_1.toBigInt)(rawReputation.shift()),
                coopCloseVolume: (0, Utils_1.toBigInt)({
                    low: rawReputation.shift(),
                    high: rawReputation.shift()
                }),
                coopCloseCount: (0, Utils_1.toBigInt)(rawReputation.shift()),
                failVolume: (0, Utils_1.toBigInt)({
                    low: rawReputation.shift(),
                    high: rawReputation.shift()
                }),
                failCount: (0, Utils_1.toBigInt)(rawReputation.shift())
            };
        });
        return result;
    }
    /**
     * Returns the balance of the token an intermediary has in his LP vault
     *
     * @param address
     * @param token
     */ async getIntermediaryBalance(address, token) {
        const balance = (0, Utils_1.toBigInt)((await this.swapContract.get_balance([
            starknet_1.cairo.tuple(address, token)
        ]))[0]);
        this.logger.debug("getIntermediaryBalance(): token LP balance fetched, token: " + token.toString() + " address: " + address + " amount: " + (balance == null ? "null" : balance.toString()));
        return balance;
    }
    /**
     * Creates transactions for withdrawing funds from the LP vault, creates ATA if it doesn't exist and unwraps
     *  WSOL to SOL if required
     *
     * @param signer
     * @param token
     * @param amount
     * @param feeRate
     */ async txsWithdraw(signer, token, amount, feeRate) {
        const action = await this.Withdraw(signer, token, amount);
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        this.logger.debug("txsWithdraw(): withdraw TX created, token: " + token.toString() + " amount: " + amount.toString(10));
        return [
            await action.tx(feeRate)
        ];
    }
    /**
     * Creates transaction for depositing funds into the LP vault, wraps SOL to WSOL if required
     *
     * @param signer
     * @param token
     * @param amount
     * @param feeRate
     */ async txsDeposit(signer, token, amount, feeRate) {
        //Approve first
        const action = await this.root.Tokens.Approve(signer, this.swapContract.address, token, amount);
        action.add(this.Deposit(signer, token, amount));
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        this.logger.debug("txsDeposit(): deposit TX created, token: " + token.toString() + " amount: " + amount.toString(10));
        return [
            await action.tx(feeRate)
        ];
    }
}
exports.StarknetLpVault = StarknetLpVault;
StarknetLpVault.GasCosts = {
    WITHDRAW: {
        l1DataGas: 500,
        l2Gas: 3200000,
        l1Gas: 0
    },
    DEPOSIT: {
        l1: 500,
        l2Gas: 4000000,
        l1Gas: 0
    }
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapInit.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSwapInit = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const StarknetAction_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)");
const StarknetSwapModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapModule.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
const Initialize = [
    {
        name: 'Swap hash',
        type: 'felt'
    },
    {
        name: 'Offerer',
        type: 'ContractAddress'
    },
    {
        name: 'Claimer',
        type: 'ContractAddress'
    },
    {
        name: 'Token amount',
        type: 'TokenAmount'
    },
    {
        name: 'Pay in',
        type: 'bool'
    },
    {
        name: 'Pay out',
        type: 'bool'
    },
    {
        name: 'Tracking reputation',
        type: 'bool'
    },
    {
        name: 'Claim handler',
        type: 'ContractAddress'
    },
    {
        name: 'Claim data',
        type: 'felt'
    },
    {
        name: 'Refund handler',
        type: 'ContractAddress'
    },
    {
        name: 'Refund data',
        type: 'felt'
    },
    {
        name: 'Security deposit',
        type: 'TokenAmount'
    },
    {
        name: 'Claimer bounty',
        type: 'TokenAmount'
    },
    {
        name: 'Claim action hash',
        type: 'felt'
    },
    {
        name: 'Deadline',
        type: 'timestamp'
    }
];
class StarknetSwapInit extends StarknetSwapModule_1.StarknetSwapModule {
    /**
     * bare Init action based on the data passed in swapData
     *
     * @param swapData
     * @param timeout
     * @param signature
     * @private
     */ Init(swapData, timeout, signature) {
        return new StarknetAction_1.StarknetAction(swapData.payIn ? swapData.offerer : swapData.claimer, this.root, this.swapContract.populateTransaction.initialize(swapData.toEscrowStruct(), signature, timeout, swapData.extraData == null || swapData.extraData === "" ? [] : (0, Utils_1.bufferToBytes31Span)(buffer_1.Buffer.from(swapData.extraData, "hex")).map(Utils_1.toHex)), swapData.payIn ? StarknetSwapInit.GasCosts.INIT_PAY_IN : StarknetSwapInit.GasCosts.INIT);
    }
    /**
     * Returns auth prefix to be used with a specific swap, payIn=true & payIn=false use different prefixes (these
     *  actually have no meaning for the smart contract/solana program in the Solana case)
     *
     * @param swapData
     * @private
     */ getAuthPrefix(swapData) {
        return swapData.isPayIn() ? "claim_initialize" : "initialize";
    }
    async preFetchForInitSignatureVerification() {
        return {
            pendingBlockTime: await this.root.Blocks.getBlockTime("pending")
        };
    }
    /**
     * Signs swap initialization authorization, using data from preFetchedBlockData if provided & still valid (subject
     *  to SIGNATURE_PREFETCH_DATA_VALIDITY)
     *
     * @param signer
     * @param swapData
     * @param authorizationTimeout
     * @public
     */ async signSwapInitialization(signer, swapData, authorizationTimeout) {
        const authTimeout = Math.floor(Date.now() / 1000) + authorizationTimeout;
        const signature = await this.root.Signatures.signTypedMessage(signer, Initialize, "Initialize", {
            "Swap hash": "0x" + swapData.getEscrowHash(),
            "Offerer": swapData.offerer,
            "Claimer": swapData.claimer,
            "Token amount": {
                token_address: swapData.token,
                amount: starknet_1.cairo.uint256(swapData.amount)
            },
            "Pay in": swapData.isPayIn(),
            "Pay out": swapData.isPayOut(),
            "Tracking reputation": swapData.reputation,
            "Refund handler": swapData.refundHandler,
            "Claim handler": swapData.claimHandler,
            "Claim data": "0x" + swapData.getClaimHash(),
            "Refund data": swapData.refundData.startsWith("0x") ? swapData.refundData : "0x" + swapData.refundData,
            "Security deposit": {
                token_address: swapData.feeToken,
                amount: starknet_1.cairo.uint256(swapData.securityDeposit)
            },
            "Claimer bounty": {
                token_address: swapData.feeToken,
                amount: starknet_1.cairo.uint256(swapData.claimerBounty)
            },
            "Claim action hash": 0n,
            "Deadline": (0, Utils_1.toHex)(authTimeout)
        });
        return {
            prefix: this.getAuthPrefix(swapData),
            timeout: authTimeout.toString(10),
            signature
        };
    }
    /**
     * Checks whether the provided signature data is valid, using preFetchedData if provided and still valid
     *
     * @param swapData
     * @param timeout
     * @param prefix
     * @param signature
     * @param preFetchData
     * @public
     */ async isSignatureValid(sender, swapData, timeout, prefix, signature, preFetchData) {
        if (!swapData.isOfferer(sender) && !swapData.isClaimer(sender)) throw new base_1.SignatureVerificationError("TX sender not offerer nor claimer");
        const signer = swapData.isOfferer(sender) ? swapData.claimer : swapData.offerer;
        if (!swapData.isPayIn() && await this.contract.isExpired(sender.toString(), swapData)) {
            throw new base_1.SignatureVerificationError("Swap will expire too soon!");
        }
        if (prefix !== this.getAuthPrefix(swapData)) throw new base_1.SignatureVerificationError("Invalid prefix");
        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
        const timeoutBN = BigInt(timeout);
        const isExpired = timeoutBN - currentTimestamp < BigInt(this.contract.authGracePeriod);
        if (isExpired) throw new base_1.SignatureVerificationError("Authorization expired!");
        if (await this.isSignatureExpired(timeout, preFetchData)) throw new base_1.SignatureVerificationError("Authorization expired!");
        const valid = await this.root.Signatures.isValidSignature(signature, signer, Initialize, "Initialize", {
            "Swap hash": "0x" + swapData.getEscrowHash(),
            "Offerer": swapData.offerer,
            "Claimer": swapData.claimer,
            "Token amount": {
                token_address: swapData.token,
                amount: starknet_1.cairo.uint256(swapData.amount)
            },
            "Pay in": swapData.isPayIn(),
            "Pay out": swapData.isPayOut(),
            "Tracking reputation": swapData.reputation,
            "Refund handler": swapData.refundHandler,
            "Claim handler": swapData.claimHandler,
            "Claim data": "0x" + swapData.getClaimHash(),
            "Refund data": swapData.refundData.startsWith("0x") ? swapData.refundData : "0x" + swapData.refundData,
            "Security deposit": {
                token_address: swapData.feeToken,
                amount: starknet_1.cairo.uint256(swapData.securityDeposit)
            },
            "Claimer bounty": {
                token_address: swapData.feeToken,
                amount: starknet_1.cairo.uint256(swapData.claimerBounty)
            },
            "Claim action hash": 0n,
            "Deadline": (0, Utils_1.toHex)(timeoutBN)
        });
        if (!valid) throw new base_1.SignatureVerificationError("Invalid signature!");
        return null;
    }
    /**
     * Gets expiry of the provided signature data, this is a minimum of slot expiry & swap signature expiry
     *
     * @param timeout
     * @public
     */ async getSignatureExpiry(timeout) {
        const now = Date.now();
        const timeoutExpiryTime = (parseInt(timeout) - this.contract.authGracePeriod) * 1000;
        if (timeoutExpiryTime < now) return 0;
        return timeoutExpiryTime;
    }
    /**
     * Checks whether signature is expired for good, compares the timestamp to the current "pending" block timestamp
     *
     * @param timeout
     * @param preFetchData
     * @public
     */ async isSignatureExpired(timeout, preFetchData) {
        if (preFetchData == null || preFetchData.pendingBlockTime == null) {
            preFetchData = await this.preFetchForInitSignatureVerification();
        }
        return preFetchData.pendingBlockTime > parseInt(timeout);
    }
    /**
     * Creates init transaction with a valid signature from an LP
     *
     * @param sender
     * @param swapData swap to initialize
     * @param timeout init signature timeout
     * @param prefix init signature prefix
     * @param signature init signature
     * @param skipChecks whether to skip signature validity checks
     * @param feeRate fee rate to use for the transaction
     */ async txsInit(sender, swapData, timeout, prefix, signature, skipChecks, feeRate) {
        if (!skipChecks) {
            const [_, payStatus] = await Promise.all([
                (0, Utils_1.tryWithRetries)(()=>this.isSignatureValid(sender, swapData, timeout, prefix, signature), this.retryPolicy, (e)=>e instanceof base_1.SignatureVerificationError),
                (0, Utils_1.tryWithRetries)(()=>this.contract.getCommitStatus(sender, swapData), this.retryPolicy)
            ]);
            if (payStatus.type !== base_1.SwapCommitStateType.NOT_COMMITED) throw new base_1.SwapDataVerificationError("Invoice already being paid for or paid");
        }
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        const initAction = this.Init(swapData, BigInt(timeout), JSON.parse(signature));
        if (swapData.payIn && swapData.isOfferer(sender)) initAction.addAction(this.root.Tokens.Approve(sender, this.swapContract.address, swapData.token, swapData.amount), 0); //Add erc20 approve
        if (swapData.getTotalDeposit() !== 0n) initAction.addAction(this.root.Tokens.Approve(sender, this.swapContract.address, swapData.feeToken, swapData.getTotalDeposit()), 0); //Add deposit erc20 approve
        this.logger.debug("txsInitPayIn(): create swap init TX, swap: " + swapData.getClaimHash() + " feerate: " + feeRate);
        return [
            await initAction.tx(feeRate)
        ];
    }
    /**
     * Get the estimated solana fee of the init transaction, this includes the required deposit for creating swap PDA
     *  and also deposit for ATAs
     */ async getInitFee(swapData, feeRate) {
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        return StarknetFees_1.StarknetFees.getGasFee(swapData.payIn ? StarknetSwapInit.GasCosts.INIT_PAY_IN : StarknetSwapInit.GasCosts.INIT, feeRate);
    }
}
exports.StarknetSwapInit = StarknetSwapInit;
StarknetSwapInit.GasCosts = {
    INIT: {
        l1DataGas: 750,
        l2Gas: 8000000,
        l1Gas: 0
    },
    INIT_PAY_IN: {
        l1DataGas: 500,
        l2Gas: 4800000,
        l1Gas: 0
    }
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapRefund.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSwapRefund = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetSwapModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapModule.js [app-client] (ecmascript)");
const StarknetAction_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)");
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
const Refund = [
    {
        name: 'Swap hash',
        type: 'felt'
    },
    {
        name: 'Timeout',
        type: 'timestamp'
    }
];
class StarknetSwapRefund extends StarknetSwapModule_1.StarknetSwapModule {
    /**
     * Action for generic Refund instruction
     *
     * @param signer
     * @param swapData
     * @param witness
     * @param handlerGas
     * @constructor
     * @private
     */ Refund(signer, swapData, witness, handlerGas) {
        return new StarknetAction_1.StarknetAction(signer, this.root, this.swapContract.populateTransaction.refund(swapData.toEscrowStruct(), witness), (0, StarknetFees_1.starknetGasAdd)(swapData.payIn ? StarknetSwapRefund.GasCosts.REFUND_PAY_OUT : StarknetSwapRefund.GasCosts.REFUND, handlerGas));
    }
    /**
     * Action for cooperative refunding with signature
     *
     * @param sender
     * @param swapData
     * @param timeout
     * @param signature
     * @constructor
     * @private
     */ RefundWithSignature(sender, swapData, timeout, signature) {
        return new StarknetAction_1.StarknetAction(sender, this.root, this.swapContract.populateTransaction.cooperative_refund(swapData.toEscrowStruct(), signature, BigInt(timeout)), swapData.payIn ? StarknetSwapRefund.GasCosts.REFUND_PAY_OUT : StarknetSwapRefund.GasCosts.REFUND);
    }
    async signSwapRefund(signer, swapData, authorizationTimeout) {
        const authPrefix = "refund";
        const authTimeout = Math.floor(Date.now() / 1000) + authorizationTimeout;
        const signature = await this.root.Signatures.signTypedMessage(signer, Refund, "Refund", {
            "Swap hash": "0x" + swapData.getEscrowHash(),
            "Timeout": (0, Utils_1.toHex)(authTimeout)
        });
        return {
            prefix: authPrefix,
            timeout: authTimeout.toString(10),
            signature: signature
        };
    }
    async isSignatureValid(swapData, timeout, prefix, signature) {
        if (prefix !== "refund") throw new base_1.SignatureVerificationError("Invalid prefix");
        const expiryTimestamp = BigInt(timeout);
        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
        const isExpired = expiryTimestamp - currentTimestamp < BigInt(this.contract.authGracePeriod);
        if (isExpired) throw new base_1.SignatureVerificationError("Authorization expired!");
        const valid = await this.root.Signatures.isValidSignature(signature, swapData.claimer, Refund, "Refund", {
            "Swap hash": "0x" + swapData.getEscrowHash(),
            "Timeout": (0, Utils_1.toHex)(expiryTimestamp)
        });
        if (!valid) {
            throw new base_1.SignatureVerificationError("Invalid signature!");
        }
        return null;
    }
    /**
     * Creates transactions required for refunding timed out swap
     *
     * @param signer
     * @param swapData swap data to refund
     * @param check whether to check if swap is already expired and refundable
     * @param feeRate fee rate to be used for the transactions
     * @param witnessData
     */ async txsRefund(signer, swapData, check, feeRate, witnessData) {
        const refundHandler = this.contract.refundHandlersByAddress[swapData.refundHandler.toLowerCase()];
        if (refundHandler == null) throw new Error("Invalid refund handler");
        if (check && !await (0, Utils_1.tryWithRetries)(()=>this.contract.isRequestRefundable(swapData.offerer.toString(), swapData), this.retryPolicy)) {
            throw new base_1.SwapDataVerificationError("Not refundable yet!");
        }
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        const { initialTxns, witness } = await refundHandler.getWitness(signer, swapData, witnessData, feeRate);
        const action = this.Refund(signer, swapData, witness, refundHandler.getGas(swapData));
        await action.addToTxs(initialTxns, feeRate);
        this.logger.debug("txsRefund(): creating refund transaction, swap: " + swapData.getClaimHash());
        return initialTxns;
    }
    /**
     * Creates transactions required for refunding the swap with authorization signature, also unwraps WSOL to SOL
     *
     * @param signer
     * @param swapData swap data to refund
     * @param timeout signature timeout
     * @param prefix signature prefix of the counterparty
     * @param signature signature of the counterparty
     * @param check whether to check if swap is committed before attempting refund
     * @param feeRate fee rate to be used for the transactions
     */ async txsRefundWithAuthorization(signer, swapData, timeout, prefix, signature, check, feeRate) {
        if (check && !await (0, Utils_1.tryWithRetries)(()=>this.contract.isCommited(swapData), this.retryPolicy)) {
            throw new base_1.SwapDataVerificationError("Not correctly committed");
        }
        await (0, Utils_1.tryWithRetries)(()=>this.isSignatureValid(swapData, timeout, prefix, signature), this.retryPolicy, (e)=>e instanceof base_1.SignatureVerificationError);
        const action = this.RefundWithSignature(signer, swapData, timeout, JSON.parse(signature));
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        this.logger.debug("txsRefundWithAuthorization(): creating refund transaction, swap: " + swapData.getClaimHash() + " auth expiry: " + timeout + " signature: " + signature);
        return [
            await action.tx(feeRate)
        ];
    }
    /**
     * Get the estimated solana transaction fee of the refund transaction, in the worst case scenario in case where the
     *  ATA needs to be initialized again (i.e. adding the ATA rent exempt lamports to the fee)
     */ async getRefundFee(swapData, feeRate) {
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        return StarknetFees_1.StarknetFees.getGasFee(swapData.payIn ? StarknetSwapRefund.GasCosts.REFUND_PAY_OUT : StarknetSwapRefund.GasCosts.REFUND, feeRate);
    }
}
exports.StarknetSwapRefund = StarknetSwapRefund;
StarknetSwapRefund.GasCosts = {
    REFUND: {
        l1DataGas: 750,
        l2Gas: 4000000,
        l1Gas: 0
    },
    REFUND_PAY_OUT: {
        l1DataGas: 900,
        l2Gas: 6000000,
        l1Gas: 0
    }
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/HashlockClaimHandler.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HashlockClaimHandler = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
class HashlockClaimHandler {
    getCommitment(data) {
        if (data.length !== 32) throw new Error("Invalid swap hash");
        return starknet_1.hash.computePoseidonHashOnElements((0, Utils_1.bufferToU32Array)(data));
    }
    getWitness(signer, data, witnessData) {
        if (!data.isClaimHandler(this.address)) throw new Error("Invalid claim handler");
        if (witnessData.length !== 64) throw new Error("Invalid hash secret: string length");
        const buffer = buffer_1.Buffer.from(witnessData, "hex");
        if (buffer.length !== 32) throw new Error("Invalid hash secret: buff length");
        const witnessSha256 = buffer_1.Buffer.from((0, sha2_1.sha256)(buffer));
        if (!data.isClaimData((0, Utils_1.toHex)(this.getCommitment(witnessSha256)))) throw new Error("Invalid hash secret: poseidon hash doesn't match");
        const witnessArray = (0, Utils_1.bufferToU32Array)(buffer);
        return Promise.resolve({
            initialTxns: [],
            witness: witnessArray
        });
    }
    getGas() {
        return HashlockClaimHandler.gas;
    }
    getType() {
        return HashlockClaimHandler.type;
    }
    parseWitnessResult(result) {
        return (0, Utils_1.u32ArrayToBuffer)(result).toString("hex");
    }
    constructor(address){
        this.address = address;
    }
}
exports.HashlockClaimHandler = HashlockClaimHandler;
HashlockClaimHandler.type = base_1.ChainSwapType.HTLC;
HashlockClaimHandler.gas = {
    l1DataGas: 0,
    l2Gas: 16000000,
    l1Gas: 0
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/IBitcoinClaimHandler.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IBitcoinClaimHandler = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const StarknetBtcRelay_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/StarknetBtcRelay.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("IBitcoinClaimHandler: ");
class IBitcoinClaimHandler {
    serializeCommitment(data) {
        return [
            data.confirmations,
            data.btcRelay.contract.address
        ];
    }
    getCommitment(data) {
        return starknet_1.hash.computePoseidonHashOnElements(this.serializeCommitment(data));
    }
    async _getWitness(signer, swapData, param, commitment, feeRate) {
        let { tx, btcRelay, commitedHeader, synchronizer, requiredConfirmations } = param;
        const serializedData = this.serializeCommitment({
            ...commitment,
            btcRelay,
            confirmations: requiredConfirmations
        });
        const commitmentHash = starknet_1.hash.computePoseidonHashOnElements(serializedData);
        if (!swapData.isClaimData(commitmentHash)) throw new Error("Invalid commit data");
        const merkleProof = await btcRelay.bitcoinRpc.getMerkleProof(tx.txid, tx.blockhash);
        logger.debug("getWitness(): merkle proof computed: ", merkleProof);
        const txs = [];
        if (commitedHeader == null) {
            const headers = await StarknetBtcRelay_1.StarknetBtcRelay.getCommitedHeadersAndSynchronize(signer, btcRelay, [
                {
                    blockheight: tx.height,
                    requiredConfirmations,
                    blockhash: tx.blockhash
                }
            ], txs, synchronizer, feeRate);
            if (headers == null) throw new Error("Cannot fetch committed header!");
            commitedHeader = headers[tx.blockhash];
        }
        serializedData.push(...commitedHeader.serialize());
        serializedData.push(merkleProof.merkle.length, ...merkleProof.merkle.map(Utils_1.bufferToU32Array).flat());
        serializedData.push(merkleProof.pos);
        return {
            initialTxns: txs,
            witness: serializedData
        };
    }
    parseWitnessResult(result) {
        return (0, Utils_1.u32ArrayToBuffer)(result).toString("hex");
    }
    constructor(address){
        this.address = address;
    }
}
exports.IBitcoinClaimHandler = IBitcoinClaimHandler;
IBitcoinClaimHandler.address = "";
IBitcoinClaimHandler.type = base_1.ChainSwapType.CHAIN_TXID;
IBitcoinClaimHandler.gas = {
    l1DataGas: 0,
    l2Gas: 10000 * 40000,
    l1Gas: 0
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinTxIdClaimHandler.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitcoinTxIdClaimHandler = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const IBitcoinClaimHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/IBitcoinClaimHandler.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("BitcoinTxIdClaimHandler: ");
class BitcoinTxIdClaimHandler extends IBitcoinClaimHandler_1.IBitcoinClaimHandler {
    serializeCommitment(data) {
        return [
            ...(0, Utils_1.bufferToU32Array)(buffer_1.Buffer.from(data.txId, "hex").reverse()),
            ...super.serializeCommitment(data)
        ];
    }
    getWitness(signer, swapData, witnessData, feeRate) {
        if (!swapData.isClaimHandler(this.address)) throw new Error("Invalid claim handler");
        return this._getWitness(signer, swapData, witnessData, {
            txId: witnessData.tx.txid
        });
    }
    getGas(data) {
        return BitcoinTxIdClaimHandler.gas;
    }
    getType() {
        return BitcoinTxIdClaimHandler.type;
    }
}
exports.BitcoinTxIdClaimHandler = BitcoinTxIdClaimHandler;
BitcoinTxIdClaimHandler.type = base_1.ChainSwapType.CHAIN_TXID;
BitcoinTxIdClaimHandler.gas = {
    l1DataGas: 0,
    l2Gas: 10000 * 40000,
    l1Gas: 0
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinOutputClaimHandler.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitcoinOutputClaimHandler = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const IBitcoinClaimHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/IBitcoinClaimHandler.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("BitcoinOutputClaimHandler: ");
class BitcoinOutputClaimHandler extends IBitcoinClaimHandler_1.IBitcoinClaimHandler {
    serializeCommitment(data) {
        return [
            starknet_1.hash.computePoseidonHashOnElements([
                (0, Utils_1.toBigInt)(data.amount),
                (0, Utils_1.poseidonHashRange)(data.output)
            ]),
            ...super.serializeCommitment(data)
        ];
    }
    async getWitness(signer, swapData, witnessData, feeRate) {
        if (!swapData.isClaimHandler(this.address)) throw new Error("Invalid claim handler");
        const parsedBtcTx = btc_signer_1.Transaction.fromRaw(buffer_1.Buffer.from(witnessData.tx.hex, "hex"));
        const out = parsedBtcTx.getOutput(witnessData.vout);
        const { initialTxns, witness } = await this._getWitness(signer, swapData, witnessData, {
            output: buffer_1.Buffer.from(out.script),
            amount: out.amount
        });
        witness.push(...(0, Utils_1.bufferToByteArray)(buffer_1.Buffer.from(witnessData.tx.hex, "hex")));
        witness.push(BigInt(witnessData.vout));
        return {
            initialTxns,
            witness
        };
    }
    getGas(data) {
        return BitcoinOutputClaimHandler.gas;
    }
    getType() {
        return BitcoinOutputClaimHandler.type;
    }
}
exports.BitcoinOutputClaimHandler = BitcoinOutputClaimHandler;
BitcoinOutputClaimHandler.type = base_1.ChainSwapType.CHAIN;
BitcoinOutputClaimHandler.gas = {
    l1DataGas: 0,
    l2Gas: 10000 * 40000,
    l1Gas: 0
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinNoncedOutputClaimHandler.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitcoinNoncedOutputClaimHandler = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const IBitcoinClaimHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/IBitcoinClaimHandler.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("BitcoinNoncedOutputClaimHandler: ");
function getTransactionNonce(btcTx) {
    const locktimeSub500M = BigInt(btcTx.lockTime - 500000000);
    if (locktimeSub500M < 0n) throw new Error("Locktime too low!");
    const nSequence = BigInt(btcTx.getInput(0).sequence);
    return locktimeSub500M << 24n | nSequence & 0x00ffffffn;
}
class BitcoinNoncedOutputClaimHandler extends IBitcoinClaimHandler_1.IBitcoinClaimHandler {
    serializeCommitment(data) {
        return [
            starknet_1.hash.computePoseidonHashOnElements([
                (0, Utils_1.toBigInt)(data.nonce),
                (0, Utils_1.toBigInt)(data.amount),
                (0, Utils_1.poseidonHashRange)(data.output)
            ]),
            ...super.serializeCommitment(data)
        ];
    }
    async getWitness(signer, swapData, witnessData, feeRate) {
        if (!swapData.isClaimHandler(this.address)) throw new Error("Invalid claim handler");
        const parsedBtcTx = btc_signer_1.Transaction.fromRaw(buffer_1.Buffer.from(witnessData.tx.hex, "hex"));
        const out = parsedBtcTx.getOutput(witnessData.vout);
        const { initialTxns, witness } = await this._getWitness(signer, swapData, witnessData, {
            output: buffer_1.Buffer.from(out.script),
            amount: out.amount,
            nonce: getTransactionNonce(parsedBtcTx)
        });
        witness.push(...(0, Utils_1.bufferToByteArray)(buffer_1.Buffer.from(witnessData.tx.hex, "hex")));
        witness.push(BigInt(witnessData.vout));
        return {
            initialTxns,
            witness
        };
    }
    getGas(data) {
        return BitcoinNoncedOutputClaimHandler.gas;
    }
    getType() {
        return BitcoinNoncedOutputClaimHandler.type;
    }
}
exports.BitcoinNoncedOutputClaimHandler = BitcoinNoncedOutputClaimHandler;
BitcoinNoncedOutputClaimHandler.type = base_1.ChainSwapType.CHAIN_NONCED;
BitcoinNoncedOutputClaimHandler.gas = {
    l1DataGas: 0,
    l2Gas: 10000 * 40000,
    l1Gas: 0
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/ClaimHandlers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.claimHandlersList = void 0;
const HashlockClaimHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/HashlockClaimHandler.js [app-client] (ecmascript)");
const BitcoinTxIdClaimHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinTxIdClaimHandler.js [app-client] (ecmascript)");
const BitcoinOutputClaimHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinOutputClaimHandler.js [app-client] (ecmascript)");
const BitcoinNoncedOutputClaimHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinNoncedOutputClaimHandler.js [app-client] (ecmascript)");
exports.claimHandlersList = [
    HashlockClaimHandler_1.HashlockClaimHandler,
    BitcoinTxIdClaimHandler_1.BitcoinTxIdClaimHandler,
    BitcoinOutputClaimHandler_1.BitcoinOutputClaimHandler,
    BitcoinNoncedOutputClaimHandler_1.BitcoinNoncedOutputClaimHandler
];
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapClaim.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSwapClaim = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetSwapModule_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapModule.js [app-client] (ecmascript)");
const StarknetAction_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)");
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
class StarknetSwapClaim extends StarknetSwapModule_1.StarknetSwapModule {
    /**
     * Claim action which uses the provided witness for claiming the swap
     *
     * @param signer
     * @param swapData
     * @param witness
     * @param claimHandlerGas
     * @constructor
     * @private
     */ Claim(signer, swapData, witness, claimHandlerGas) {
        return new StarknetAction_1.StarknetAction(signer, this.root, this.swapContract.populateTransaction.claim(swapData.toEscrowStruct(), witness), (0, StarknetFees_1.starknetGasAdd)(swapData.payOut ? StarknetSwapClaim.GasCosts.CLAIM_PAY_OUT : StarknetSwapClaim.GasCosts.CLAIM, claimHandlerGas));
    }
    /**
     * Creates transactions claiming the swap using a secret (for HTLC swaps)
     *
     * @param signer
     * @param swapData swap to claim
     * @param secret hex encoded secret pre-image to the HTLC hash
     * @param checkExpiry whether to check if the swap is already expired (trying to claim an expired swap with a secret
     *  is dangerous because we might end up revealing the secret to the counterparty without being able to claim the swap)
     * @param feeRate fee rate to use for the transaction
     */ async txsClaimWithSecret(signer, swapData, secret, checkExpiry, feeRate) {
        //We need to be sure that this transaction confirms in time, otherwise we reveal the secret to the counterparty
        // and won't claim the funds
        if (checkExpiry && await this.contract.isExpired(swapData.claimer.toString(), swapData)) {
            throw new base_1.SwapDataVerificationError("Not enough time to reliably pay the invoice");
        }
        const claimHandler = this.contract.claimHandlersByAddress[(0, Utils_1.toHex)(swapData.claimHandler)];
        if (claimHandler == null) throw new base_1.SwapDataVerificationError("Unknown claim handler!");
        if (claimHandler.getType() !== base_1.ChainSwapType.HTLC) throw new base_1.SwapDataVerificationError("Invalid claim handler!");
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        const { initialTxns, witness } = await claimHandler.getWitness(signer, swapData, secret, feeRate);
        const action = this.Claim(signer, swapData, witness, claimHandler.getGas(swapData));
        await action.addToTxs(initialTxns, feeRate);
        this.logger.debug("txsClaimWithSecret(): creating claim transaction, swap: " + swapData.getClaimHash() + " witness: ", witness.map(Utils_1.toHex));
        return initialTxns;
    }
    /**
     * Creates transaction claiming the swap using a confirmed transaction data (for BTC on-chain swaps)
     *
     * @param signer
     * @param swapData swap to claim
     * @param tx bitcoin transaction that satisfies the swap condition
     * @param requiredConfirmations
     * @param vout vout of the bitcoin transaction that satisfies the swap condition
     * @param commitedHeader commited header data from btc relay (fetched internally if null)
     * @param synchronizer optional synchronizer to use in case we need to sync up the btc relay ourselves
     * @param feeRate fee rate to be used for the transactions
     */ async txsClaimWithTxData(signer, swapData, tx, requiredConfirmations, vout, commitedHeader, synchronizer, feeRate) {
        const claimHandler = this.contract.claimHandlersByAddress[(0, Utils_1.toHex)(swapData.claimHandler)];
        if (claimHandler == null) throw new base_1.SwapDataVerificationError("Unknown claim handler!");
        if (claimHandler.getType() !== base_1.ChainSwapType.CHAIN_NONCED && claimHandler.getType() !== base_1.ChainSwapType.CHAIN_TXID && claimHandler.getType() !== base_1.ChainSwapType.CHAIN) throw new base_1.SwapDataVerificationError("Invalid claim handler!");
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        const { initialTxns, witness } = await claimHandler.getWitness(signer, swapData, {
            tx,
            vout,
            requiredConfirmations,
            commitedHeader,
            btcRelay: this.contract.btcRelay,
            synchronizer
        }, feeRate);
        const action = this.Claim(signer, swapData, witness, claimHandler.getGas(swapData));
        await action.addToTxs(initialTxns, feeRate);
        return initialTxns;
    }
    /**
     * Get the estimated starknet transaction fee of the claim transaction
     */ async getClaimFee(swapData, feeRate) {
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.root.Fees.getFeeRate();
        let gasRequired = swapData.payOut ? StarknetSwapClaim.GasCosts.CLAIM_PAY_OUT : StarknetSwapClaim.GasCosts.CLAIM;
        const claimHandler = this.contract.claimHandlersByAddress[(0, Utils_1.toHex)(swapData.claimHandler)];
        if (claimHandler != null) gasRequired = (0, StarknetFees_1.starknetGasAdd)(gasRequired, claimHandler.getGas(swapData));
        return StarknetFees_1.StarknetFees.getGasFee(gasRequired, feeRate);
    }
}
exports.StarknetSwapClaim = StarknetSwapClaim;
StarknetSwapClaim.GasCosts = {
    CLAIM: {
        l1DataGas: 750,
        l2Gas: 4000000,
        l1Gas: 0
    },
    CLAIM_PAY_OUT: {
        l1DataGas: 900,
        l2Gas: 6000000,
        l1Gas: 0
    }
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapContract.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSwapContract = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const EscrowManagerAbi_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/EscrowManagerAbi.js [app-client] (ecmascript)");
const StarknetContractBase_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/StarknetContractBase.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const StarknetSwapData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapData.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const TimelockRefundHandler_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/refund/TimelockRefundHandler.js [app-client] (ecmascript)");
const StarknetLpVault_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetLpVault.js [app-client] (ecmascript)");
const StarknetSwapInit_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapInit.js [app-client] (ecmascript)");
const StarknetSwapRefund_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapRefund.js [app-client] (ecmascript)");
const ClaimHandlers_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/ClaimHandlers.js [app-client] (ecmascript)");
const StarknetSwapClaim_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapClaim.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
const ESCROW_STATE_COMMITTED = 1;
const ESCROW_STATE_CLAIMED = 2;
const ESCROW_STATE_REFUNDED = 3;
const swapContractAddreses = {
    [starknet_1.constants.StarknetChainId.SN_SEPOLIA]: "0x017bf50dd28b6d823a231355bb25813d4396c8e19d2df03026038714a22f0413",
    [starknet_1.constants.StarknetChainId.SN_MAIN]: "0x04f278e1f19e495c3b1dd35ef307c4f7510768ed95481958fbae588bd173f79a"
};
const defaultClaimAddresses = {
    [starknet_1.constants.StarknetChainId.SN_SEPOLIA]: {
        [base_1.ChainSwapType.HTLC]: "0x04a57ea54d4637c352aad1bbee046868926a11702216a0aaf7eeec1568be2d7b",
        [base_1.ChainSwapType.CHAIN_TXID]: "0x04c7cde88359e14b6f6f779f8b9d8310cee37e91a6f143f855ae29fab33c396e",
        [base_1.ChainSwapType.CHAIN]: "0x051bef6f5fd12e2832a7d38653bdfc8eb84ba7eb7a4aada5b87ef38a9999cf17",
        [base_1.ChainSwapType.CHAIN_NONCED]: "0x050e50eacd16da414f2c3a7c3570fd5e248974c6fe757d41acbf72d2836fa0a1"
    },
    [starknet_1.constants.StarknetChainId.SN_MAIN]: {
        [base_1.ChainSwapType.HTLC]: "0x07b74b50a883ebee262b6db0e3c0c697670c6f30e3d610e75faf33a89c46aa2a",
        [base_1.ChainSwapType.CHAIN_TXID]: "0x016c2db2b03f39cf4fd7f871035000f66b62307d9983056e33a38315da8a44dc",
        [base_1.ChainSwapType.CHAIN]: "0x02c45a81c4a48d0645a0a199e620061e8a55dcc9c2b5946d050eaeeddba64e9a",
        [base_1.ChainSwapType.CHAIN_NONCED]: "0x0019b5480dd7ed8ded10a09437b0a7a30b8997b4ef139deb24ff8c86f995d84f"
    }
};
const defaultRefundAddresses = {
    [starknet_1.constants.StarknetChainId.SN_SEPOLIA]: {
        timelock: "0x034b8f28b3ca979036cb2849cfa3af7f67207459224b6ca5ce2474aa398ec3e7"
    },
    [starknet_1.constants.StarknetChainId.SN_MAIN]: {
        timelock: "0x06a59659990c2aefbf7239f6d911617b3ae60b79cb3364f3bd242a6ca8f4f4f7"
    }
};
class StarknetSwapContract extends StarknetContractBase_1.StarknetContractBase {
    async start() {}
    ////////////////////////////////////////////
    //// Signatures
    preFetchForInitSignatureVerification() {
        return this.Init.preFetchForInitSignatureVerification();
    }
    getInitSignature(signer, swapData, authorizationTimeout, preFetchedBlockData, feeRate) {
        return this.Init.signSwapInitialization(signer, swapData, authorizationTimeout);
    }
    isValidInitAuthorization(sender, swapData, param, feeRate, preFetchedData) {
        let { timeout, prefix, signature } = param;
        return this.Init.isSignatureValid(sender, swapData, timeout, prefix, signature, preFetchedData);
    }
    getInitAuthorizationExpiry(swapData, param, preFetchedData) {
        let { timeout, prefix, signature } = param;
        return this.Init.getSignatureExpiry(timeout);
    }
    isInitAuthorizationExpired(swapData, param) {
        let { timeout, prefix, signature } = param;
        return this.Init.isSignatureExpired(timeout);
    }
    getRefundSignature(signer, swapData, authorizationTimeout) {
        return this.Refund.signSwapRefund(signer, swapData, authorizationTimeout);
    }
    isValidRefundAuthorization(swapData, param) {
        let { timeout, prefix, signature } = param;
        return this.Refund.isSignatureValid(swapData, timeout, prefix, signature);
    }
    getDataSignature(signer, data) {
        return this.Chain.Signatures.getDataSignature(signer, data);
    }
    isValidDataSignature(data, signature, publicKey) {
        return this.Chain.Signatures.isValidDataSignature(data, signature, publicKey);
    }
    ////////////////////////////////////////////
    //// Swap data utils
    /**
     * Checks whether the claim is claimable by us, that means not expired, we are claimer & the swap is commited
     *
     * @param signer
     * @param data
     */ async isClaimable(signer, data) {
        if (!data.isClaimer(signer)) return false;
        if (await this.isExpired(signer, data)) return false;
        return await this.isCommited(data);
    }
    /**
     * Checks whether a swap is commited, i.e. the swap still exists on-chain and was not claimed nor refunded
     *
     * @param swapData
     */ async isCommited(swapData) {
        const data = await this.contract.get_hash_state("0x" + swapData.getEscrowHash());
        return Number(data.state) === ESCROW_STATE_COMMITTED;
    }
    /**
     * Checks whether the swap is expired, takes into consideration possible on-chain time skew, therefore for claimer
     *  the swap expires a bit sooner than it should've & for the offerer it expires a bit later
     *
     * @param signer
     * @param data
     */ isExpired(signer, data) {
        let currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
        if (data.isClaimer(signer)) currentTimestamp = currentTimestamp + BigInt(this.claimGracePeriod);
        if (data.isOfferer(signer)) currentTimestamp = currentTimestamp - BigInt(this.refundGracePeriod);
        return Promise.resolve(data.getExpiry() < currentTimestamp);
    }
    /**
     * Checks if the swap is refundable by us, checks if we are offerer, if the swap is already expired & if the swap
     *  is still commited
     *
     * @param signer
     * @param data
     */ async isRequestRefundable(signer, data) {
        //Swap can only be refunded by the offerer
        if (!data.isOfferer(signer)) return false;
        if (!await this.isExpired(signer, data)) return false;
        return await this.isCommited(data);
    }
    getHashForTxId(txId, confirmations) {
        return (0, Utils_1.bigNumberishToBuffer)(this.claimHandlersBySwapType[base_1.ChainSwapType.CHAIN_TXID].getCommitment({
            txId,
            confirmations,
            btcRelay: this.btcRelay
        }), 32);
    }
    /**
     * Get the swap payment hash to be used for an on-chain swap, uses poseidon hash of the value
     *
     * @param outputScript output script required to claim the swap
     * @param amount sats sent required to claim the swap
     * @param confirmations
     * @param nonce swap nonce uniquely identifying the transaction to prevent replay attacks
     */ getHashForOnchain(outputScript, amount, confirmations, nonce) {
        let result;
        if (nonce == null || nonce === 0n) {
            result = this.claimHandlersBySwapType[base_1.ChainSwapType.CHAIN].getCommitment({
                output: outputScript,
                amount,
                confirmations,
                btcRelay: this.btcRelay
            });
        } else {
            result = this.claimHandlersBySwapType[base_1.ChainSwapType.CHAIN_NONCED].getCommitment({
                output: outputScript,
                amount,
                nonce,
                confirmations,
                btcRelay: this.btcRelay
            });
        }
        return (0, Utils_1.bigNumberishToBuffer)(result, 32);
    }
    /**
     * Get the swap payment hash to be used for a lightning htlc swap, uses poseidon hash of the sha256 hash of the preimage
     *
     * @param paymentHash payment hash of the HTLC
     */ getHashForHtlc(paymentHash) {
        return (0, Utils_1.bigNumberishToBuffer)(this.claimHandlersBySwapType[base_1.ChainSwapType.HTLC].getCommitment(paymentHash), 32);
    }
    getExtraData(outputScript, amount, confirmations, nonce) {
        if (nonce == null) nonce = 0n;
        const txoHash = buffer_1.Buffer.from((0, sha2_1.sha256)(buffer_1.Buffer.concat([
            base_1.BigIntBufferUtils.toBuffer(amount, "le", 8),
            outputScript
        ])));
        return buffer_1.Buffer.concat([
            txoHash,
            base_1.BigIntBufferUtils.toBuffer(nonce, "be", 8),
            base_1.BigIntBufferUtils.toBuffer(BigInt(confirmations), "be", 2)
        ]);
    }
    ////////////////////////////////////////////
    //// Swap data getters
    /**
     * Gets the status of the specific swap, this also checks if we are offerer/claimer & checks for expiry (to see
     *  if swap is refundable)
     *
     * @param signer
     * @param data
     */ async getCommitStatus(signer, data) {
        const escrowHash = data.getEscrowHash();
        const stateData = await this.contract.get_hash_state("0x" + escrowHash);
        const state = Number(stateData.state);
        const blockHeight = Number(stateData.finish_blockheight);
        switch(state){
            case ESCROW_STATE_COMMITTED:
                if (data.isOfferer(signer) && await this.isExpired(signer, data)) return {
                    type: base_1.SwapCommitStateType.REFUNDABLE
                };
                return {
                    type: base_1.SwapCommitStateType.COMMITED
                };
            case ESCROW_STATE_CLAIMED:
                return {
                    type: base_1.SwapCommitStateType.PAID,
                    getTxBlock: async ()=>{
                        return {
                            blockTime: await this.Chain.Blocks.getBlockTime(blockHeight),
                            blockHeight: blockHeight
                        };
                    },
                    getClaimTxId: async ()=>{
                        const events = await this.Events.getContractBlockEvents([
                            "escrow_manager::events::Claim"
                        ], [
                            null,
                            null,
                            null,
                            "0x" + escrowHash
                        ], blockHeight, blockHeight);
                        return events.length === 0 ? null : events[0].txHash;
                    },
                    getClaimResult: async ()=>{
                        const events = await this.Events.getContractBlockEvents([
                            "escrow_manager::events::Claim"
                        ], [
                            null,
                            null,
                            null,
                            "0x" + escrowHash
                        ], blockHeight, blockHeight);
                        if (events.length === 0) return null;
                        const event = events[0];
                        const claimHandlerHex = (0, Utils_1.toHex)(event.params.claim_handler);
                        const claimHandler = this.claimHandlersByAddress[claimHandlerHex];
                        if (claimHandler == null) {
                            starknet_1.logger.warn("getCommitStatus(): getClaimResult(" + escrowHash + "): Unknown claim handler with claim: " + claimHandlerHex);
                            return null;
                        }
                        const witnessResult = claimHandler.parseWitnessResult(event.params.witness_result);
                        return witnessResult;
                    }
                };
            default:
                return {
                    type: await this.isExpired(signer, data) ? base_1.SwapCommitStateType.EXPIRED : base_1.SwapCommitStateType.NOT_COMMITED,
                    getTxBlock: async ()=>{
                        return {
                            blockTime: await this.Chain.Blocks.getBlockTime(blockHeight),
                            blockHeight: blockHeight
                        };
                    },
                    getClaimTxId: async ()=>{
                        const events = await this.Events.getContractBlockEvents([
                            "escrow_manager::events::Refund"
                        ], [
                            null,
                            null,
                            null,
                            "0x" + escrowHash
                        ], blockHeight, blockHeight);
                        return events.length === 0 ? null : events[0].txHash;
                    }
                };
        }
    }
    /**
     * Returns the data committed for a specific payment hash, or null if no data is currently commited for
     *  the specific swap
     *
     * @param paymentHashHex
     */ async getCommitedData(paymentHashHex) {
        //TODO: Noop
        return null;
    }
    ////////////////////////////////////////////
    //// Swap data initializer
    createSwapData(type, offerer, claimer, token, amount, paymentHash, sequence, expiry, payIn, payOut, securityDeposit, claimerBounty) {
        let depositToken = arguments.length > 12 && arguments[12] !== void 0 ? arguments[12] : this.Chain.Tokens.getNativeCurrencyAddress();
        var _this_claimHandlersBySwapType_type, _this_claimHandlersBySwapType;
        return Promise.resolve(new StarknetSwapData_1.StarknetSwapData(offerer, claimer, token, this.timelockRefundHandler.address, (_this_claimHandlersBySwapType = this.claimHandlersBySwapType) === null || _this_claimHandlersBySwapType === void 0 ? void 0 : (_this_claimHandlersBySwapType_type = _this_claimHandlersBySwapType[type]) === null || _this_claimHandlersBySwapType_type === void 0 ? void 0 : _this_claimHandlersBySwapType_type.address, payOut, payIn, payIn, sequence, "0x" + paymentHash, (0, Utils_1.toHex)(expiry), amount, depositToken, securityDeposit, claimerBounty, type, null));
    }
    ////////////////////////////////////////////
    //// Utils
    async getBalance(signer, tokenAddress, inContract) {
        if (inContract) return await this.getIntermediaryBalance(signer, tokenAddress);
        //TODO: For native token we should discount the cost of deploying an account if it is not deployed yet
        return await this.Chain.getBalance(signer, tokenAddress);
    }
    getIntermediaryData(address, token) {
        return this.LpVault.getIntermediaryData(address, token);
    }
    getIntermediaryReputation(address, token) {
        return this.LpVault.getIntermediaryReputation(address, token);
    }
    getIntermediaryBalance(address, token) {
        return this.LpVault.getIntermediaryBalance(address, token);
    }
    ////////////////////////////////////////////
    //// Transaction initializers
    async txsClaimWithSecret(signer, swapData, secret, checkExpiry, initAta, feeRate, skipAtaCheck) {
        return this.Claim.txsClaimWithSecret(typeof signer === "string" ? signer : signer.getAddress(), swapData, secret, checkExpiry, feeRate);
    }
    async txsClaimWithTxData(signer, swapData, tx, requiredConfirmations, vout, commitedHeader, synchronizer, initAta, feeRate) {
        return this.Claim.txsClaimWithTxData(typeof signer === "string" ? signer : signer.getAddress(), swapData, tx, requiredConfirmations, vout, commitedHeader, synchronizer, feeRate);
    }
    txsRefund(signer, swapData, check, initAta, feeRate) {
        return this.Refund.txsRefund(signer, swapData, check, feeRate);
    }
    txsRefundWithAuthorization(signer, swapData, param, check, initAta, feeRate) {
        let { timeout, prefix, signature } = param;
        return this.Refund.txsRefundWithAuthorization(signer, swapData, timeout, prefix, signature, check, feeRate);
    }
    txsInit(sender, swapData, param, skipChecks, feeRate) {
        let { timeout, prefix, signature } = param;
        return this.Init.txsInit(sender, swapData, timeout, prefix, signature, skipChecks, feeRate);
    }
    txsWithdraw(signer, token, amount, feeRate) {
        return this.LpVault.txsWithdraw(signer, token, amount, feeRate);
    }
    txsDeposit(signer, token, amount, feeRate) {
        return this.LpVault.txsDeposit(signer, token, amount, feeRate);
    }
    ////////////////////////////////////////////
    //// Executors
    async claimWithSecret(signer, swapData, secret, checkExpiry, initAta, txOptions) {
        const result = await this.Claim.txsClaimWithSecret(signer.getAddress(), swapData, secret, checkExpiry, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [signature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return signature;
    }
    async claimWithTxData(signer, swapData, tx, requiredConfirmations, vout, commitedHeader, synchronizer, initAta, txOptions) {
        const txs = await this.Claim.txsClaimWithTxData(signer.getAddress(), swapData, tx, requiredConfirmations, vout, commitedHeader, synchronizer, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        if (txs === null) throw new Error("Btc relay not synchronized to required blockheight!");
        //TODO: This doesn't return proper tx signature
        const [signature] = await this.Chain.sendAndConfirm(signer, txs, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return signature;
    }
    async refund(signer, swapData, check, initAta, txOptions) {
        let result = await this.txsRefund(signer.getAddress(), swapData, check, initAta, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [signature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return signature;
    }
    async refundWithAuthorization(signer, swapData, signature, check, initAta, txOptions) {
        let result = await this.txsRefundWithAuthorization(signer.getAddress(), swapData, signature, check, initAta, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [txSignature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return txSignature;
    }
    async init(signer, swapData, signature, skipChecks, txOptions) {
        if (swapData.isPayIn()) {
            if (!swapData.isOfferer(signer.getAddress())) throw new Error("Invalid signer provided!");
        } else {
            if (!swapData.isClaimer(signer.getAddress())) throw new Error("Invalid signer provided!");
        }
        let result = await this.txsInit(signer.getAddress(), swapData, signature, skipChecks, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [txSignature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return txSignature;
    }
    async withdraw(signer, token, amount, txOptions) {
        const txs = await this.LpVault.txsWithdraw(signer.getAddress(), token, amount, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [txId] = await this.Chain.sendAndConfirm(signer, txs, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal, false);
        return txId;
    }
    async deposit(signer, token, amount, txOptions) {
        const txs = await this.LpVault.txsDeposit(signer.getAddress(), token, amount, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [txId] = await this.Chain.sendAndConfirm(signer, txs, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal, false);
        return txId;
    }
    ////////////////////////////////////////////
    //// Fees
    getInitPayInFeeRate(offerer, claimer, token, paymentHash) {
        return this.Chain.Fees.getFeeRate();
    }
    getInitFeeRate(offerer, claimer, token, paymentHash) {
        return this.Chain.Fees.getFeeRate();
    }
    getRefundFeeRate(swapData) {
        return this.Chain.Fees.getFeeRate();
    }
    getClaimFeeRate(signer, swapData) {
        return this.Chain.Fees.getFeeRate();
    }
    getClaimFee(signer, swapData, feeRate) {
        return this.Claim.getClaimFee(swapData, feeRate);
    }
    /**
     * Get the estimated solana fee of the commit transaction
     */ getCommitFee(swapData, feeRate) {
        return this.Init.getInitFee(swapData, feeRate);
    }
    /**
     * Get the estimated solana transaction fee of the refund transaction
     */ getRefundFee(swapData, feeRate) {
        return this.Refund.getRefundFee(swapData, feeRate);
    }
    constructor(chainInterface, btcRelay, contractAddress = swapContractAddreses[chainInterface.starknetChainId], handlerAddresses){
        super(chainInterface, contractAddress, EscrowManagerAbi_1.EscrowManagerAbi);
        ////////////////////////
        //// Constants
        this.chainId = "STARKNET";
        ////////////////////////
        //// Timeouts
        this.claimWithSecretTimeout = 180;
        this.claimWithTxDataTimeout = 180;
        this.refundTimeout = 180;
        this.claimGracePeriod = 10 * 60;
        this.refundGracePeriod = 10 * 60;
        this.authGracePeriod = 30;
        ////////////////////////
        //// Handlers
        this.claimHandlersByAddress = {};
        this.claimHandlersBySwapType = {};
        this.refundHandlersByAddress = {};
        this.Init = new StarknetSwapInit_1.StarknetSwapInit(chainInterface, this);
        this.Refund = new StarknetSwapRefund_1.StarknetSwapRefund(chainInterface, this);
        this.Claim = new StarknetSwapClaim_1.StarknetSwapClaim(chainInterface, this);
        this.LpVault = new StarknetLpVault_1.StarknetLpVault(chainInterface, this);
        this.btcRelay = btcRelay;
        handlerAddresses !== null && handlerAddresses !== void 0 ? handlerAddresses : handlerAddresses = {};
        var _handlerAddresses_refund;
        (_handlerAddresses_refund = handlerAddresses.refund) !== null && _handlerAddresses_refund !== void 0 ? _handlerAddresses_refund : handlerAddresses.refund = {};
        handlerAddresses.refund = {
            ...defaultRefundAddresses[chainInterface.starknetChainId],
            ...handlerAddresses.refund
        };
        var _handlerAddresses_claim;
        (_handlerAddresses_claim = handlerAddresses.claim) !== null && _handlerAddresses_claim !== void 0 ? _handlerAddresses_claim : handlerAddresses.claim = {};
        handlerAddresses.claim = {
            ...defaultClaimAddresses[chainInterface.starknetChainId],
            ...handlerAddresses.claim
        };
        ClaimHandlers_1.claimHandlersList.forEach((handlerCtor)=>{
            const handler = new handlerCtor(handlerAddresses.claim[handlerCtor.type]);
            this.claimHandlersByAddress[(0, Utils_1.toHex)(handler.address)] = handler;
            this.claimHandlersBySwapType[handlerCtor.type] = handler;
        });
        this.timelockRefundHandler = new TimelockRefundHandler_1.TimelockRefundHandler(handlerAddresses.refund.timelock);
        this.refundHandlersByAddress[this.timelockRefundHandler.address] = this.timelockRefundHandler;
    }
}
exports.StarknetSwapContract = StarknetSwapContract;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/IHandler.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/events/StarknetChainEventsBrowser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetChainEventsBrowser = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
/**
 * Starknet on-chain event handler for front-end systems without access to fs, uses WS or long-polling to subscribe, might lose
 *  out on some events if the network is unreliable, front-end systems should take this into consideration and not
 *  rely purely on events
 */ class StarknetChainEventsBrowser {
    findInitSwapData(call, escrowHash, claimHandler) {
        if (BigInt(call.contract_address) === BigInt(this.starknetSwapContract.contract.address) && BigInt(call.entry_point_selector) === this.initEntryPointSelector) {
            //Found, check correct escrow hash
            const { escrow, extraData } = (0, Utils_1.parseInitFunctionCalldata)(call.calldata, claimHandler);
            if ("0x" + escrow.getEscrowHash() === (0, Utils_1.toHex)(escrowHash)) {
                if (extraData.length !== 0) {
                    escrow.setExtraData((0, Utils_1.bytes31SpanToBuffer)(extraData, 42).toString("hex"));
                }
                return escrow;
            }
        }
        for (let _call of call.calls){
            const found = this.findInitSwapData(_call, escrowHash, claimHandler);
            if (found != null) return found;
        }
        return null;
    }
    /**
     * Returns async getter for fetching on-demand initialize event swap data
     *
     * @param event
     * @param claimHandler
     * @private
     * @returns {() => Promise<StarknetSwapData>} getter to be passed to InitializeEvent constructor
     */ getSwapDataGetter(event, claimHandler) {
        return async ()=>{
            let trace;
            try {
                trace = await this.provider.getTransactionTrace(event.txHash);
            } catch (e) {
                this.logger.warn("getSwapDataGetter(): getter: starknet_traceTransaction not supported by the RPC: ", e);
                const blockTraces = await this.provider.getBlockTransactionsTraces(event.blockHash);
                const foundTrace = blockTraces.find((val)=>(0, Utils_1.toHex)(val.transaction_hash) === (0, Utils_1.toHex)(event.txHash));
                if (foundTrace == null) throw new Error("Cannot find ".concat(event.txHash, " in the block traces, block: ").concat(event.blockHash));
                trace = foundTrace.trace_root;
            }
            if (trace == null) return null;
            if (trace.execute_invocation.revert_reason != null) return null;
            return this.findInitSwapData(trace.execute_invocation, event.params.escrow_hash, claimHandler);
        };
    }
    parseInitializeEvent(event) {
        const escrowHashBuffer = (0, Utils_1.bigNumberishToBuffer)(event.params.escrow_hash, 32);
        const escrowHash = escrowHashBuffer.toString("hex");
        const claimHandlerHex = (0, Utils_1.toHex)(event.params.claim_handler);
        const claimHandler = this.starknetSwapContract.claimHandlersByAddress[claimHandlerHex];
        if (claimHandler == null) {
            this.logger.warn("parseInitializeEvent(" + escrowHash + "): Unknown claim handler with claim: " + claimHandlerHex);
            return null;
        }
        const swapType = claimHandler.getType();
        this.logger.debug("InitializeEvent claimHash: " + (0, Utils_1.toHex)(event.params.claim_data) + " escrowHash: " + escrowHash);
        return new base_1.InitializeEvent(escrowHash, swapType, (0, Utils_1.onceAsync)(this.getSwapDataGetter(event, claimHandler)));
    }
    parseRefundEvent(event) {
        const escrowHashBuffer = (0, Utils_1.bigNumberishToBuffer)(event.params.escrow_hash, 32);
        const escrowHash = escrowHashBuffer.toString("hex");
        this.logger.debug("RefundEvent claimHash: " + (0, Utils_1.toHex)(event.params.claim_data) + " escrowHash: " + escrowHash);
        return new base_1.RefundEvent(escrowHash);
    }
    parseClaimEvent(event) {
        const escrowHashBuffer = (0, Utils_1.bigNumberishToBuffer)(event.params.escrow_hash, 32);
        const escrowHash = escrowHashBuffer.toString("hex");
        const claimHandlerHex = (0, Utils_1.toHex)(event.params.claim_handler);
        const claimHandler = this.starknetSwapContract.claimHandlersByAddress[claimHandlerHex];
        if (claimHandler == null) {
            this.logger.warn("parseClaimEvent(" + escrowHash + "): Unknown claim handler with claim: " + claimHandlerHex);
            return null;
        }
        const witnessResult = claimHandler.parseWitnessResult(event.params.witness_result);
        this.logger.debug("ClaimEvent claimHash: " + (0, Utils_1.toHex)(event.params.claim_data) + " witnessResult: " + witnessResult + " escrowHash: " + escrowHash);
        return new base_1.ClaimEvent(escrowHash, witnessResult);
    }
    parseSpvOpenEvent(event) {
        const owner = (0, Utils_1.toHex)(event.params.owner);
        const vaultId = (0, Utils_1.toBigInt)(event.params.vault_id);
        const btcTxId = (0, Utils_1.bigNumberishToBuffer)(event.params.btc_tx_hash, 32).reverse().toString("hex");
        const vout = Number((0, Utils_1.toBigInt)(event.params.vout));
        this.logger.debug("SpvOpenEvent owner: " + owner + " vaultId: " + vaultId + " utxo: " + btcTxId + ":" + vout);
        return new base_1.SpvVaultOpenEvent(owner, vaultId, btcTxId, vout);
    }
    parseSpvDepositEvent(event) {
        const owner = (0, Utils_1.toHex)(event.params.owner);
        const vaultId = (0, Utils_1.toBigInt)(event.params.vault_id);
        const amounts = [
            (0, Utils_1.toBigInt)(event.params.amounts["0"]),
            (0, Utils_1.toBigInt)(event.params.amounts["1"])
        ];
        const depositCount = Number((0, Utils_1.toBigInt)(event.params.deposit_count));
        this.logger.debug("SpvDepositEvent owner: " + owner + " vaultId: " + vaultId + " depositCount: " + depositCount + " amounts: ", amounts);
        return new base_1.SpvVaultDepositEvent(owner, vaultId, amounts, depositCount);
    }
    parseSpvFrontEvent(event) {
        const owner = (0, Utils_1.toHex)(event.params.owner);
        const vaultId = (0, Utils_1.toBigInt)(event.params.vault_id);
        const btcTxId = (0, Utils_1.bigNumberishToBuffer)(event.params.btc_tx_hash, 32).reverse().toString("hex");
        const recipient = (0, Utils_1.toHex)(event.params.recipient);
        const executionHash = (0, Utils_1.toHex)(event.params.execution_hash);
        const amounts = [
            (0, Utils_1.toBigInt)(event.params.amounts["0"]),
            (0, Utils_1.toBigInt)(event.params.amounts["1"])
        ];
        const frontingAddress = (0, Utils_1.toHex)(event.params.caller);
        this.logger.debug("SpvFrontEvent owner: " + owner + " vaultId: " + vaultId + " btcTxId: " + btcTxId + " recipient: " + recipient + " frontedBy: " + frontingAddress + " amounts: ", amounts);
        return new base_1.SpvVaultFrontEvent(owner, vaultId, btcTxId, recipient, executionHash, amounts, frontingAddress);
    }
    parseSpvClaimEvent(event) {
        const owner = (0, Utils_1.toHex)(event.params.owner);
        const vaultId = (0, Utils_1.toBigInt)(event.params.vault_id);
        const btcTxId = (0, Utils_1.bigNumberishToBuffer)(event.params.btc_tx_hash, 32).reverse().toString("hex");
        const recipient = (0, Utils_1.toHex)(event.params.recipient);
        const executionHash = (0, Utils_1.toHex)(event.params.execution_hash);
        const amounts = [
            (0, Utils_1.toBigInt)(event.params.amounts["0"]),
            (0, Utils_1.toBigInt)(event.params.amounts["1"])
        ];
        const caller = (0, Utils_1.toHex)(event.params.caller);
        const frontingAddress = (0, Utils_1.toHex)(event.params.fronting_address);
        const withdrawCount = Number((0, Utils_1.toBigInt)(event.params.withdraw_count));
        this.logger.debug("SpvClaimEvent owner: " + owner + " vaultId: " + vaultId + " btcTxId: " + btcTxId + " withdrawCount: " + withdrawCount + " recipient: " + recipient + " frontedBy: " + frontingAddress + " claimedBy: " + caller + " amounts: ", amounts);
        return new base_1.SpvVaultClaimEvent(owner, vaultId, btcTxId, recipient, executionHash, amounts, caller, frontingAddress, withdrawCount);
    }
    parseSpvCloseEvent(event) {
        const owner = (0, Utils_1.toHex)(event.params.owner);
        const vaultId = (0, Utils_1.toBigInt)(event.params.vault_id);
        const btcTxId = (0, Utils_1.bigNumberishToBuffer)(event.params.btc_tx_hash, 32).reverse().toString("hex");
        const error = (0, Utils_1.bigNumberishToBuffer)(event.params.error).toString();
        return new base_1.SpvVaultCloseEvent(owner, vaultId, btcTxId, error);
    }
    /**
     * Processes event as received from the chain, parses it & calls event listeners
     *
     * @param events
     * @param currentBlockNumber
     * @param currentBlockTimestamp
     * @param pendingEventTime
     * @protected
     */ async processEvents(events, currentBlockNumber, currentBlockTimestamp, pendingEventTime) {
        const blockTimestampsCache = {};
        const getBlockTimestamp = async (blockNumber)=>{
            if (blockNumber === currentBlockNumber) return currentBlockTimestamp;
            const blockNumberString = blockNumber.toString();
            var _blockTimestampsCache_blockNumberString;
            (_blockTimestampsCache_blockNumberString = blockTimestampsCache[blockNumberString]) !== null && _blockTimestampsCache_blockNumberString !== void 0 ? _blockTimestampsCache_blockNumberString : blockTimestampsCache[blockNumberString] = (await this.provider.getBlockWithTxHashes(blockNumber)).timestamp;
            return blockTimestampsCache[blockNumberString];
        };
        const parsedEvents = [];
        for (let event of events){
            let parsedEvent;
            switch(event.name){
                case "escrow_manager::events::Claim":
                    parsedEvent = this.parseClaimEvent(event);
                    break;
                case "escrow_manager::events::Refund":
                    parsedEvent = this.parseRefundEvent(event);
                    break;
                case "escrow_manager::events::Initialize":
                    parsedEvent = this.parseInitializeEvent(event);
                    break;
                case "spv_swap_vault::events::Opened":
                    parsedEvent = this.parseSpvOpenEvent(event);
                    break;
                case "spv_swap_vault::events::Deposited":
                    parsedEvent = this.parseSpvDepositEvent(event);
                    break;
                case "spv_swap_vault::events::Fronted":
                    parsedEvent = this.parseSpvFrontEvent(event);
                    break;
                case "spv_swap_vault::events::Claimed":
                    parsedEvent = this.parseSpvClaimEvent(event);
                    break;
                case "spv_swap_vault::events::Closed":
                    parsedEvent = this.parseSpvCloseEvent(event);
                    break;
            }
            if (parsedEvent == null) continue;
            const timestamp = event.blockNumber == null ? pendingEventTime : await getBlockTimestamp(event.blockNumber);
            parsedEvent.meta = {
                blockTime: timestamp,
                txId: event.txHash,
                timestamp
            };
            parsedEvents.push(parsedEvent);
        }
        for (let listener of this.listeners){
            await listener(parsedEvents);
        }
    }
    async checkEventsEcrowManager(lastTxHash, lastBlockNumber, currentBlock) {
        const currentBlockNumber = currentBlock.block_number;
        lastBlockNumber !== null && lastBlockNumber !== void 0 ? lastBlockNumber : lastBlockNumber = currentBlockNumber;
        // this.logger.debug("checkEvents(EscrowManager): Requesting logs: "+logStartHeight+"...pending");
        let events = await this.starknetSwapContract.Events.getContractBlockEvents([
            "escrow_manager::events::Initialize",
            "escrow_manager::events::Claim",
            "escrow_manager::events::Refund"
        ], [], lastBlockNumber, null);
        if (lastTxHash != null) {
            const latestProcessedEventIndex = (0, Utils_1.findLastIndex)(events, (val)=>val.txHash === lastTxHash);
            if (latestProcessedEventIndex !== -1) {
                events.splice(0, latestProcessedEventIndex + 1);
            // this.logger.debug("checkEvents(EscrowManager): Splicing processed events, resulting size: "+events.length);
            }
        }
        if (events.length > 0) {
            await this.processEvents(events, currentBlock === null || currentBlock === void 0 ? void 0 : currentBlock.block_number, currentBlock === null || currentBlock === void 0 ? void 0 : currentBlock.timestamp, Math.floor(Date.now() / 1000));
            lastTxHash = events[events.length - 1].txHash;
        }
        return lastTxHash;
    }
    async checkEventsSpvVaults(lastTxHash, lastBlockNumber, currentBlock) {
        const currentBlockNumber = currentBlock.block_number;
        lastBlockNumber !== null && lastBlockNumber !== void 0 ? lastBlockNumber : lastBlockNumber = currentBlockNumber;
        // this.logger.debug("checkEvents(SpvVaults): Requesting logs: "+logStartHeight+"...pending");
        let events = await this.starknetSpvVaultContract.Events.getContractBlockEvents([
            "spv_swap_vault::events::Opened",
            "spv_swap_vault::events::Deposited",
            "spv_swap_vault::events::Closed",
            "spv_swap_vault::events::Fronted",
            "spv_swap_vault::events::Claimed"
        ], [], lastBlockNumber, null);
        if (lastTxHash != null) {
            const latestProcessedEventIndex = (0, Utils_1.findLastIndex)(events, (val)=>val.txHash === lastTxHash);
            if (latestProcessedEventIndex !== -1) {
                events.splice(0, latestProcessedEventIndex + 1);
            // this.logger.debug("checkEvents(SpvVaults): Splicing processed events, resulting size: "+events.length);
            }
        }
        if (events.length > 0) {
            await this.processEvents(events, currentBlock === null || currentBlock === void 0 ? void 0 : currentBlock.block_number, currentBlock === null || currentBlock === void 0 ? void 0 : currentBlock.timestamp, Math.floor(Date.now() / 1000));
            lastTxHash = events[events.length - 1].txHash;
        }
        return lastTxHash;
    }
    async checkEvents(lastBlockNumber, lastTxHashes) {
        lastTxHashes !== null && lastTxHashes !== void 0 ? lastTxHashes : lastTxHashes = [];
        const currentBlock = await this.provider.getBlockWithTxHashes("latest");
        const currentBlockNumber = currentBlock.block_number;
        lastTxHashes[0] = await this.checkEventsEcrowManager(lastTxHashes[0], lastBlockNumber, currentBlock);
        lastTxHashes[1] = await this.checkEventsSpvVaults(lastTxHashes[1], lastBlockNumber, currentBlock);
        return {
            txHashes: lastTxHashes,
            blockNumber: currentBlockNumber
        };
    }
    /**
     * Sets up event handlers listening for swap events over websocket
     *
     * @protected
     */ async setupPoll(lastBlockNumber, lastTxHashes, saveLatestProcessedBlockNumber) {
        this.stopped = false;
        let func;
        func = async ()=>{
            await this.checkEvents(lastBlockNumber, lastTxHashes).then((param)=>{
                let { blockNumber, txHashes } = param;
                lastBlockNumber = blockNumber;
                lastTxHashes = txHashes;
                if (saveLatestProcessedBlockNumber != null) return saveLatestProcessedBlockNumber(blockNumber, lastTxHashes);
            }).catch((e)=>{
                this.logger.error("setupPoll(): Failed to fetch starknet log: ", e);
            });
            if (this.stopped) return;
            this.timeout = setTimeout(func, this.pollIntervalSeconds * 1000);
        };
        await func();
    }
    init() {
        this.setupPoll();
        return Promise.resolve();
    }
    async stop() {
        this.stopped = true;
        if (this.timeout != null) clearTimeout(this.timeout);
    }
    registerListener(cbk) {
        this.listeners.push(cbk);
    }
    unregisterListener(cbk) {
        const index = this.listeners.indexOf(cbk);
        if (index >= 0) {
            this.listeners.splice(index, 1);
            return true;
        }
        return false;
    }
    constructor(chainInterface, starknetSwapContract, starknetSpvVaultContract, pollIntervalSeconds = 5){
        this.listeners = [];
        this.logger = (0, Utils_1.getLogger)("StarknetChainEventsBrowser: ");
        this.initFunctionName = "initialize";
        this.initEntryPointSelector = BigInt(starknet_1.hash.starknetKeccak(this.initFunctionName));
        this.provider = chainInterface.provider;
        this.starknetSwapContract = starknetSwapContract;
        this.starknetSpvVaultContract = starknetSpvVaultContract;
        this.pollIntervalSeconds = pollIntervalSeconds;
    }
}
exports.StarknetChainEventsBrowser = StarknetChainEventsBrowser;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/StarknetChainType.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/SpvVaultContractAbi.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpvVaultContractAbi = void 0;
exports.SpvVaultContractAbi = [
    {
        "type": "impl",
        "name": "SpvVaultManagerImpl",
        "interface_name": "spv_swap_vault::ISpvVaultManager"
    },
    {
        "type": "struct",
        "name": "core::integer::u256",
        "members": [
            {
                "name": "low",
                "type": "core::integer::u128"
            },
            {
                "name": "high",
                "type": "core::integer::u128"
            }
        ]
    },
    {
        "type": "struct",
        "name": "spv_swap_vault::structs::BitcoinVaultTransactionData",
        "members": [
            {
                "name": "recipient",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "amount",
                "type": "(core::integer::u64, core::integer::u64)"
            },
            {
                "name": "caller_fee",
                "type": "(core::integer::u64, core::integer::u64)"
            },
            {
                "name": "fronting_fee",
                "type": "(core::integer::u64, core::integer::u64)"
            },
            {
                "name": "execution_handler_fee_amount_0",
                "type": "core::integer::u64"
            },
            {
                "name": "execution_hash",
                "type": "core::felt252"
            },
            {
                "name": "execution_expiry",
                "type": "core::integer::u32"
            }
        ]
    },
    {
        "type": "struct",
        "name": "core::byte_array::ByteArray",
        "members": [
            {
                "name": "data",
                "type": "core::array::Array::<core::bytes_31::bytes31>"
            },
            {
                "name": "pending_word",
                "type": "core::felt252"
            },
            {
                "name": "pending_word_len",
                "type": "core::integer::u32"
            }
        ]
    },
    {
        "type": "struct",
        "name": "btc_relay::structs::blockheader::BlockHeader",
        "members": [
            {
                "name": "reversed_version",
                "type": "core::integer::u32"
            },
            {
                "name": "previous_blockhash",
                "type": "[core::integer::u32; 8]"
            },
            {
                "name": "merkle_root",
                "type": "[core::integer::u32; 8]"
            },
            {
                "name": "reversed_timestamp",
                "type": "core::integer::u32"
            },
            {
                "name": "nbits",
                "type": "core::integer::u32"
            },
            {
                "name": "nonce",
                "type": "core::integer::u32"
            }
        ]
    },
    {
        "type": "struct",
        "name": "btc_relay::structs::stored_blockheader::StoredBlockHeader",
        "members": [
            {
                "name": "blockheader",
                "type": "btc_relay::structs::blockheader::BlockHeader"
            },
            {
                "name": "block_hash",
                "type": "[core::integer::u32; 8]"
            },
            {
                "name": "chain_work",
                "type": "core::integer::u256"
            },
            {
                "name": "block_height",
                "type": "core::integer::u32"
            },
            {
                "name": "last_diff_adjustment",
                "type": "core::integer::u32"
            },
            {
                "name": "prev_block_timestamps",
                "type": "[core::integer::u32; 10]"
            }
        ]
    },
    {
        "type": "struct",
        "name": "core::array::Span::<[core::integer::u32; 8]>",
        "members": [
            {
                "name": "snapshot",
                "type": "@core::array::Array::<[core::integer::u32; 8]>"
            }
        ]
    },
    {
        "type": "interface",
        "name": "spv_swap_vault::ISpvVaultManager",
        "items": [
            {
                "type": "function",
                "name": "open",
                "inputs": [
                    {
                        "name": "vault_id",
                        "type": "core::felt252"
                    },
                    {
                        "name": "relay_contract",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "utxo",
                        "type": "(core::integer::u256, core::integer::u32)"
                    },
                    {
                        "name": "confirmations",
                        "type": "core::integer::u8"
                    },
                    {
                        "name": "token_0",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "token_1",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "token_0_multiplier",
                        "type": "core::felt252"
                    },
                    {
                        "name": "token_1_multiplier",
                        "type": "core::felt252"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "deposit",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "vault_id",
                        "type": "core::felt252"
                    },
                    {
                        "name": "raw_token_0_amount",
                        "type": "core::integer::u64"
                    },
                    {
                        "name": "raw_token_1_amount",
                        "type": "core::integer::u64"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "front",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "vault_id",
                        "type": "core::felt252"
                    },
                    {
                        "name": "withdraw_sequence",
                        "type": "core::integer::u32"
                    },
                    {
                        "name": "btc_tx_hash",
                        "type": "core::integer::u256"
                    },
                    {
                        "name": "data",
                        "type": "spv_swap_vault::structs::BitcoinVaultTransactionData"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            },
            {
                "type": "function",
                "name": "claim",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "vault_id",
                        "type": "core::felt252"
                    },
                    {
                        "name": "transaction",
                        "type": "core::byte_array::ByteArray"
                    },
                    {
                        "name": "blockheader",
                        "type": "btc_relay::structs::stored_blockheader::StoredBlockHeader"
                    },
                    {
                        "name": "merkle_proof",
                        "type": "core::array::Span::<[core::integer::u32; 8]>"
                    },
                    {
                        "name": "position",
                        "type": "core::integer::u32"
                    }
                ],
                "outputs": [],
                "state_mutability": "external"
            }
        ]
    },
    {
        "type": "impl",
        "name": "SpvVaultManagerReadOnlyImpl",
        "interface_name": "spv_swap_vault::ISpvVaultManagerReadOnly"
    },
    {
        "type": "struct",
        "name": "spv_swap_vault::state::SpvVaultState",
        "members": [
            {
                "name": "relay_contract",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "token_0",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "token_1",
                "type": "core::starknet::contract_address::ContractAddress"
            },
            {
                "name": "token_0_multiplier",
                "type": "core::felt252"
            },
            {
                "name": "token_1_multiplier",
                "type": "core::felt252"
            },
            {
                "name": "utxo",
                "type": "(core::integer::u256, core::integer::u32)"
            },
            {
                "name": "confirmations",
                "type": "core::integer::u8"
            },
            {
                "name": "withdraw_count",
                "type": "core::integer::u32"
            },
            {
                "name": "deposit_count",
                "type": "core::integer::u32"
            },
            {
                "name": "token_0_amount",
                "type": "core::integer::u64"
            },
            {
                "name": "token_1_amount",
                "type": "core::integer::u64"
            }
        ]
    },
    {
        "type": "enum",
        "name": "core::option::Option::<spv_swap_vault::structs::BitcoinVaultTransactionData>",
        "variants": [
            {
                "name": "Some",
                "type": "spv_swap_vault::structs::BitcoinVaultTransactionData"
            },
            {
                "name": "None",
                "type": "()"
            }
        ]
    },
    {
        "type": "interface",
        "name": "spv_swap_vault::ISpvVaultManagerReadOnly",
        "items": [
            {
                "type": "function",
                "name": "get_vault",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "vault_id",
                        "type": "core::felt252"
                    }
                ],
                "outputs": [
                    {
                        "type": "spv_swap_vault::state::SpvVaultState"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_fronter_address",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "vault_id",
                        "type": "core::felt252"
                    },
                    {
                        "name": "btc_tx_hash",
                        "type": "core::integer::u256"
                    },
                    {
                        "name": "data",
                        "type": "spv_swap_vault::structs::BitcoinVaultTransactionData"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "get_fronter_address_by_id",
                "inputs": [
                    {
                        "name": "owner",
                        "type": "core::starknet::contract_address::ContractAddress"
                    },
                    {
                        "name": "vault_id",
                        "type": "core::felt252"
                    },
                    {
                        "name": "fronting_id",
                        "type": "core::felt252"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::starknet::contract_address::ContractAddress"
                    }
                ],
                "state_mutability": "view"
            },
            {
                "type": "function",
                "name": "parse_bitcoin_tx",
                "inputs": [
                    {
                        "name": "transaction",
                        "type": "core::byte_array::ByteArray"
                    }
                ],
                "outputs": [
                    {
                        "type": "core::option::Option::<spv_swap_vault::structs::BitcoinVaultTransactionData>"
                    }
                ],
                "state_mutability": "view"
            }
        ]
    },
    {
        "type": "constructor",
        "name": "constructor",
        "inputs": [
            {
                "name": "execution_contract",
                "type": "core::starknet::contract_address::ContractAddress"
            }
        ]
    },
    {
        "type": "event",
        "name": "spv_swap_vault::events::Opened",
        "kind": "struct",
        "members": [
            {
                "name": "btc_tx_hash",
                "type": "core::integer::u256",
                "kind": "key"
            },
            {
                "name": "owner",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "vault_id",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "vout",
                "type": "core::integer::u32",
                "kind": "key"
            }
        ]
    },
    {
        "type": "event",
        "name": "spv_swap_vault::events::Deposited",
        "kind": "struct",
        "members": [
            {
                "name": "owner",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "vault_id",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "amounts",
                "type": "(core::integer::u64, core::integer::u64)",
                "kind": "data"
            },
            {
                "name": "deposit_count",
                "type": "core::integer::u32",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "spv_swap_vault::events::Claimed",
        "kind": "struct",
        "members": [
            {
                "name": "btc_tx_hash",
                "type": "core::integer::u256",
                "kind": "key"
            },
            {
                "name": "owner",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "vault_id",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "recipient",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "execution_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "caller",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "amounts",
                "type": "(core::integer::u64, core::integer::u64)",
                "kind": "data"
            },
            {
                "name": "withdraw_count",
                "type": "core::integer::u32",
                "kind": "data"
            },
            {
                "name": "fronting_address",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "spv_swap_vault::events::Fronted",
        "kind": "struct",
        "members": [
            {
                "name": "btc_tx_hash",
                "type": "core::integer::u256",
                "kind": "key"
            },
            {
                "name": "owner",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "vault_id",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "recipient",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "execution_hash",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "caller",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "amounts",
                "type": "(core::integer::u64, core::integer::u64)",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "spv_swap_vault::events::Closed",
        "kind": "struct",
        "members": [
            {
                "name": "btc_tx_hash",
                "type": "core::integer::u256",
                "kind": "key"
            },
            {
                "name": "owner",
                "type": "core::starknet::contract_address::ContractAddress",
                "kind": "key"
            },
            {
                "name": "vault_id",
                "type": "core::felt252",
                "kind": "key"
            },
            {
                "name": "error",
                "type": "core::felt252",
                "kind": "data"
            }
        ]
    },
    {
        "type": "event",
        "name": "spv_swap_vault::SpvVaultManager::Event",
        "kind": "enum",
        "variants": [
            {
                "name": "Opened",
                "type": "spv_swap_vault::events::Opened",
                "kind": "nested"
            },
            {
                "name": "Deposited",
                "type": "spv_swap_vault::events::Deposited",
                "kind": "nested"
            },
            {
                "name": "Claimed",
                "type": "spv_swap_vault::events::Claimed",
                "kind": "nested"
            },
            {
                "name": "Fronted",
                "type": "spv_swap_vault::events::Fronted",
                "kind": "nested"
            },
            {
                "name": "Closed",
                "type": "spv_swap_vault::events::Closed",
                "kind": "nested"
            }
        ]
    }
];
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvWithdrawalData.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSpvWithdrawalData = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetSpvVaultContract_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultContract.js [app-client] (ecmascript)");
class StarknetSpvWithdrawalData extends base_1.SpvWithdrawalTransactionData {
    fromOpReturnData(data) {
        return StarknetSpvVaultContract_1.StarknetSpvVaultContract.fromOpReturnData(data);
    }
    isRecipient(address) {
        return this.getRecipient().toLowerCase() === address.toLowerCase();
    }
    getTxHash() {
        return BigInt("0x" + buffer_1.Buffer.from(this.btcTx.txid, "hex").reverse().toString("hex"));
    }
    getFrontingAmount() {
        return [
            this.rawAmounts[0] + this.getExecutionFee()[0],
            this.rawAmounts[1]
        ];
    }
    serialize() {
        return {
            type: "STARKNET",
            ...super.serialize()
        };
    }
    serializeToStruct() {
        const callerFee = this.getCallerFee();
        const frontingFee = this.getFrontingFee();
        const executionFee = this.getExecutionFee();
        var _ref;
        return {
            recipient: this.recipient,
            amount: starknet_1.cairo.tuple(this.rawAmounts[0], this.rawAmounts[1]),
            caller_fee: starknet_1.cairo.tuple(callerFee[0], callerFee[1]),
            fronting_fee: starknet_1.cairo.tuple(frontingFee[0], frontingFee[1]),
            execution_handler_fee_amount_0: executionFee[0],
            execution_hash: (_ref = (0, Utils_1.toBigInt)(this.executionHash)) !== null && _ref !== void 0 ? _ref : 0n,
            execution_expiry: BigInt(this.executionExpiry)
        };
    }
    serializeToFelts() {
        const callerFee = this.getCallerFee();
        const frontingFee = this.getFrontingFee();
        const executionFee = this.getExecutionFee();
        var _ref;
        return [
            this.recipient,
            this.rawAmounts[0],
            this.rawAmounts[1],
            callerFee[0],
            callerFee[1],
            frontingFee[0],
            frontingFee[1],
            executionFee[0],
            (_ref = (0, Utils_1.toBigInt)(this.executionHash)) !== null && _ref !== void 0 ? _ref : 0n,
            BigInt(this.executionExpiry)
        ];
    }
}
exports.StarknetSpvWithdrawalData = StarknetSpvWithdrawalData;
base_1.SpvWithdrawalTransactionData.deserializers["STARKNET"] = StarknetSpvWithdrawalData;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultData.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSpvVaultData = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const StarknetSpvWithdrawalData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvWithdrawalData.js [app-client] (ecmascript)");
class StarknetSpvVaultData extends base_1.SpvVaultData {
    getBalances() {
        return [
            {
                ...this.token0,
                scaledAmount: this.token0.rawAmount * this.token0.multiplier
            },
            {
                ...this.token1,
                scaledAmount: this.token1.rawAmount * this.token1.multiplier
            }
        ];
    }
    getConfirmations() {
        return this.confirmations;
    }
    getOwner() {
        return this.owner;
    }
    getTokenData() {
        return [
            this.token0,
            this.token1
        ];
    }
    getUtxo() {
        return this.isOpened() ? this.utxo : this.initialUtxo;
    }
    getVaultId() {
        return this.vaultId;
    }
    getWithdrawalCount() {
        return this.withdrawCount;
    }
    isOpened() {
        return this.utxo !== "0000000000000000000000000000000000000000000000000000000000000000:0";
    }
    serialize() {
        return {
            type: "STARKNET",
            owner: this.owner,
            vaultId: this.vaultId.toString(10),
            relayContract: this.relayContract,
            token0: {
                token: this.token0.token,
                multiplier: this.token0.multiplier.toString(10),
                rawAmount: this.token0.rawAmount.toString(10)
            },
            token1: {
                token: this.token1.token,
                multiplier: this.token1.multiplier.toString(10),
                rawAmount: this.token1.rawAmount.toString(10)
            },
            utxo: this.utxo,
            confirmations: this.confirmations,
            withdrawCount: this.withdrawCount,
            depositCount: this.depositCount,
            initialUtxo: this.initialUtxo
        };
    }
    updateState(withdrawalTxOrEvent) {
        if (withdrawalTxOrEvent instanceof base_1.SpvVaultClaimEvent) {
            if (withdrawalTxOrEvent.withdrawCount <= this.withdrawCount) return;
            this.token0.rawAmount -= withdrawalTxOrEvent.amounts[0];
            this.token1.rawAmount -= withdrawalTxOrEvent.amounts[1];
            this.withdrawCount = withdrawalTxOrEvent.withdrawCount;
            this.utxo = withdrawalTxOrEvent.btcTxId + ":0";
        }
        if (withdrawalTxOrEvent instanceof base_1.SpvVaultCloseEvent) {
            this.token0.rawAmount = 0n;
            this.token1.rawAmount = 0n;
            this.utxo = "0000000000000000000000000000000000000000000000000000000000000000:0";
        }
        if (withdrawalTxOrEvent instanceof base_1.SpvVaultOpenEvent) {
            if (this.isOpened()) return;
            this.utxo = withdrawalTxOrEvent.btcTxId + ":" + withdrawalTxOrEvent.vout;
        }
        if (withdrawalTxOrEvent instanceof base_1.SpvVaultDepositEvent) {
            if (withdrawalTxOrEvent.depositCount <= this.depositCount) return;
            this.token0.rawAmount += withdrawalTxOrEvent.amounts[0];
            this.token1.rawAmount += withdrawalTxOrEvent.amounts[1];
            this.depositCount = withdrawalTxOrEvent.depositCount;
        }
        if (withdrawalTxOrEvent instanceof StarknetSpvWithdrawalData_1.StarknetSpvWithdrawalData) {
            if (withdrawalTxOrEvent.getSpentVaultUtxo() !== this.utxo) return;
            const amounts = withdrawalTxOrEvent.getTotalOutput();
            this.token0.rawAmount -= amounts[0];
            this.token1.rawAmount -= amounts[1];
            this.withdrawCount++;
            this.utxo = withdrawalTxOrEvent.btcTx.txid + ":0";
        }
    }
    getDepositCount() {
        return this.depositCount;
    }
    constructor(ownerOrObj, vaultId, struct, initialUtxo){
        super();
        if (typeof ownerOrObj === "string") {
            this.owner = ownerOrObj;
            this.vaultId = vaultId;
            this.relayContract = (0, Utils_1.toHex)(struct.relay_contract);
            this.token0 = {
                token: (0, Utils_1.toHex)(struct.token_0),
                multiplier: (0, Utils_1.toBigInt)(struct.token_0_multiplier),
                rawAmount: (0, Utils_1.toBigInt)(struct.token_0_amount)
            };
            this.token1 = {
                token: (0, Utils_1.toHex)(struct.token_1),
                multiplier: (0, Utils_1.toBigInt)(struct.token_1_multiplier),
                rawAmount: (0, Utils_1.toBigInt)(struct.token_1_amount)
            };
            const txHash = buffer_1.Buffer.from((0, Utils_1.toBigInt)(struct.utxo["0"]).toString(16).padStart(64, "0"), "hex");
            const vout = (0, Utils_1.toBigInt)(struct.utxo["1"]);
            this.utxo = txHash.reverse().toString("hex") + ":" + vout.toString(10);
            this.confirmations = Number((0, Utils_1.toBigInt)(struct.confirmations));
            this.withdrawCount = Number((0, Utils_1.toBigInt)(struct.withdraw_count));
            this.depositCount = Number((0, Utils_1.toBigInt)(struct.deposit_count));
            this.initialUtxo = initialUtxo;
        } else {
            this.owner = ownerOrObj.owner;
            this.vaultId = BigInt(ownerOrObj.vaultId);
            this.relayContract = ownerOrObj.relayContract;
            this.token0 = {
                token: ownerOrObj.token0.token,
                multiplier: BigInt(ownerOrObj.token0.multiplier),
                rawAmount: BigInt(ownerOrObj.token0.rawAmount)
            };
            this.token1 = {
                token: ownerOrObj.token1.token,
                multiplier: BigInt(ownerOrObj.token1.multiplier),
                rawAmount: BigInt(ownerOrObj.token1.rawAmount)
            };
            this.utxo = ownerOrObj.utxo;
            this.confirmations = ownerOrObj.confirmations;
            this.withdrawCount = ownerOrObj.withdrawCount;
            this.depositCount = ownerOrObj.depositCount;
            this.initialUtxo = ownerOrObj.initialUtxo;
        }
    }
}
exports.StarknetSpvVaultData = StarknetSpvVaultData;
base_1.SpvVaultData.deserializers["STARKNET"] = StarknetSpvVaultData;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultContract.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetSpvVaultContract = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const StarknetContractBase_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/StarknetContractBase.js [app-client] (ecmascript)");
const StarknetBtcRelay_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/StarknetBtcRelay.js [app-client] (ecmascript)");
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const StarknetAction_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)");
const SpvVaultContractAbi_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/SpvVaultContractAbi.js [app-client] (ecmascript)");
const StarknetSpvVaultData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultData.js [app-client] (ecmascript)");
const StarknetSpvWithdrawalData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvWithdrawalData.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
const StarknetAddresses_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetAddresses.js [app-client] (ecmascript)");
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
const spvVaultContractAddreses = {
    [starknet_1.constants.StarknetChainId.SN_SEPOLIA]: "0x02d581ea838cd5ca46ba08660eddd064d50a0392f618e95310432147928d572e",
    [starknet_1.constants.StarknetChainId.SN_MAIN]: "0x01932042992647771f3d0aa6ee526e65359c891fe05a285faaf4d3ffa373e132"
};
const STARK_PRIME_MOD = 2n ** 251n + 17n * 2n ** 192n + 1n;
function decodeUtxo(utxo) {
    const [txId, vout] = utxo.split(":");
    return {
        txHash: BigInt("0x" + buffer_1.Buffer.from(txId, "hex").reverse().toString("hex")),
        vout: BigInt(vout)
    };
}
class StarknetSpvVaultContract extends StarknetContractBase_1.StarknetContractBase {
    //StarknetActions
    Open(signer, vault) {
        const { txHash, vout } = decodeUtxo(vault.getUtxo());
        const tokens = vault.getTokenData();
        if (tokens.length !== 2) throw new Error("Must specify exactly 2 tokens for vault!");
        return new StarknetAction_1.StarknetAction(signer, this.Chain, this.contract.populateTransaction.open(vault.getVaultId(), this.btcRelay.contract.address, starknet_1.cairo.tuple(starknet_1.cairo.uint256(txHash), vout), vault.getConfirmations(), tokens[0].token, tokens[1].token, tokens[0].multiplier, tokens[1].multiplier), StarknetSpvVaultContract.GasCosts.OPEN);
    }
    Deposit(signer, vault, rawAmounts) {
        var _rawAmounts_;
        return new StarknetAction_1.StarknetAction(signer, this.Chain, this.contract.populateTransaction.deposit(vault.getOwner(), vault.getVaultId(), rawAmounts[0], (_rawAmounts_ = rawAmounts[1]) !== null && _rawAmounts_ !== void 0 ? _rawAmounts_ : 0n), StarknetSpvVaultContract.GasCosts.DEPOSIT);
    }
    Front(signer, vault, data, withdrawalSequence) {
        return new StarknetAction_1.StarknetAction(signer, this.Chain, this.contract.populateTransaction.front(vault.getOwner(), vault.getVaultId(), BigInt(withdrawalSequence), data.getTxHash(), data.serializeToStruct()), StarknetSpvVaultContract.GasCosts.FRONT);
    }
    Claim(signer, vault, data, blockheader, merkle, position) {
        return new StarknetAction_1.StarknetAction(signer, this.Chain, {
            contractAddress: this.contract.address,
            entrypoint: "claim",
            calldata: [
                vault.getOwner(),
                vault.getVaultId(),
                ...(0, Utils_1.bufferToByteArray)(buffer_1.Buffer.from(data.btcTx.hex, "hex")),
                ...blockheader.serialize(),
                merkle.length,
                ...merkle.map(Utils_1.bufferToU32Array).flat(),
                position
            ].map((val)=>(0, Utils_1.toHex)(val, 0))
        }, StarknetSpvVaultContract.GasCosts.CLAIM);
    }
    async checkWithdrawalTx(tx) {
        const result = await this.Chain.provider.callContract({
            contractAddress: this.contract.address,
            entrypoint: "parse_bitcoin_tx",
            calldata: (0, Utils_1.bufferToByteArray)(buffer_1.Buffer.from(tx.btcTx.hex, "hex"))
        });
        if (result == null) throw new Error("Failed to parse transaction!");
    }
    createVaultData(owner, vaultId, utxo, confirmations, tokenData) {
        if (tokenData.length !== 2) throw new Error("Must specify 2 tokens in tokenData!");
        return Promise.resolve(new StarknetSpvVaultData_1.StarknetSpvVaultData(owner, vaultId, {
            relay_contract: this.btcRelay.contract.address,
            token_0: tokenData[0].token,
            token_1: tokenData[1].token,
            token_0_multiplier: tokenData[0].multiplier,
            token_1_multiplier: tokenData[1].multiplier,
            utxo: starknet_1.cairo.tuple(starknet_1.cairo.uint256(0), 0),
            confirmations: confirmations,
            withdraw_count: 0,
            deposit_count: 0,
            token_0_amount: 0n,
            token_1_amount: 0n
        }, utxo));
    }
    //Getters
    async getVaultData(owner, vaultId) {
        const struct = await this.contract.get_vault(owner, vaultId);
        if ((0, Utils_1.toHex)(struct.relay_contract) !== (0, Utils_1.toHex)(this.btcRelay.contract.address)) return null;
        return new StarknetSpvVaultData_1.StarknetSpvVaultData(owner, vaultId, struct);
    }
    async getAllVaults(owner) {
        const openedVaults = new Set();
        await this.Events.findInContractEventsForward([
            "spv_swap_vault::events::Opened",
            "spv_swap_vault::events::Closed"
        ], owner == null ? null : [
            null,
            owner
        ], (event)=>{
            const owner = (0, Utils_1.toHex)(event.params.owner);
            const vaultId = (0, Utils_1.toBigInt)(event.params.vault_id);
            const vaultIdentifier = owner + ":" + vaultId.toString(10);
            if (event.name === "spv_swap_vault::events::Opened") {
                openedVaults.add(vaultIdentifier);
            } else {
                openedVaults.delete(vaultIdentifier);
            }
            return null;
        });
        const vaults = [];
        for (let identifier of openedVaults.keys()){
            const [owner, vaultIdStr] = identifier.split(":");
            const vaultData = await this.getVaultData(owner, BigInt(vaultIdStr));
            if (vaultData != null) vaults.push(vaultData);
        }
        return vaults;
    }
    async getWithdrawalState(btcTxId) {
        const txHash = buffer_1.Buffer.from(btcTxId, "hex").reverse();
        const txHashU256 = starknet_1.cairo.uint256("0x" + txHash.toString("hex"));
        let result = {
            type: base_1.SpvWithdrawalStateType.NOT_FOUND
        };
        await this.Events.findInContractEventsForward([
            "spv_swap_vault::events::Fronted",
            "spv_swap_vault::events::Claimed",
            "spv_swap_vault::events::Closed"
        ], [
            (0, Utils_1.toHex)(txHashU256.low),
            (0, Utils_1.toHex)(txHashU256.high)
        ], async (event)=>{
            switch(event.name){
                case "spv_swap_vault::events::Fronted":
                    result = {
                        type: base_1.SpvWithdrawalStateType.FRONTED,
                        txId: event.txHash,
                        owner: (0, Utils_1.toHex)(event.params.owner),
                        vaultId: (0, Utils_1.toBigInt)(event.params.vault_id),
                        recipient: (0, Utils_1.toHex)(event.params.recipient),
                        fronter: (0, Utils_1.toHex)(event.params.fronting_address)
                    };
                    break;
                case "spv_swap_vault::events::Claimed":
                    result = {
                        type: base_1.SpvWithdrawalStateType.CLAIMED,
                        txId: event.txHash,
                        owner: (0, Utils_1.toHex)(event.params.owner),
                        vaultId: (0, Utils_1.toBigInt)(event.params.vault_id),
                        recipient: (0, Utils_1.toHex)(event.params.recipient),
                        claimer: (0, Utils_1.toHex)(event.params.caller),
                        fronter: (0, Utils_1.toHex)(event.params.fronting_address)
                    };
                    break;
                case "spv_swap_vault::events::Closed":
                    result = {
                        type: base_1.SpvWithdrawalStateType.CLOSED,
                        txId: event.txHash,
                        owner: (0, Utils_1.toHex)(event.params.owner),
                        vaultId: (0, Utils_1.toBigInt)(event.params.vault_id),
                        error: (0, Utils_1.bigNumberishToBuffer)(event.params.error).toString()
                    };
                    break;
            }
        });
        return result;
    }
    getWithdrawalData(btcTx) {
        return Promise.resolve(new StarknetSpvWithdrawalData_1.StarknetSpvWithdrawalData(btcTx));
    }
    //OP_RETURN data encoding/decoding
    fromOpReturnData(data) {
        return StarknetSpvVaultContract.fromOpReturnData(data);
    }
    static fromOpReturnData(data) {
        let rawAmount0 = 0n;
        let rawAmount1 = 0n;
        let executionHash = null;
        if (data.length === 40) {
            rawAmount0 = data.readBigInt64LE(32).valueOf();
        } else if (data.length === 48) {
            rawAmount0 = data.readBigInt64LE(32).valueOf();
            rawAmount1 = data.readBigInt64LE(40).valueOf();
        } else if (data.length === 72) {
            rawAmount0 = data.readBigInt64LE(32).valueOf();
            executionHash = data.slice(40, 72).toString("hex");
        } else if (data.length === 80) {
            rawAmount0 = data.readBigInt64LE(32).valueOf();
            rawAmount1 = data.readBigInt64LE(40).valueOf();
            executionHash = data.slice(48, 80).toString("hex");
        } else {
            throw new Error("Invalid OP_RETURN data length!");
        }
        if (executionHash != null) {
            const executionHashValue = BigInt("0x" + executionHash);
            if (executionHashValue >= STARK_PRIME_MOD) throw new Error("Execution hash not in range of starknet prime");
        }
        const recipient = "0x" + data.slice(0, 32).toString("hex");
        if (!StarknetAddresses_1.StarknetAddresses.isValidAddress(recipient)) throw new Error("Invalid recipient specified");
        return {
            executionHash,
            rawAmounts: [
                rawAmount0,
                rawAmount1
            ],
            recipient
        };
    }
    toOpReturnData(recipient, rawAmounts, executionHash) {
        return StarknetSpvVaultContract.toOpReturnData(recipient, rawAmounts, executionHash);
    }
    static toOpReturnData(recipient, rawAmounts, executionHash) {
        if (!StarknetAddresses_1.StarknetAddresses.isValidAddress(recipient)) throw new Error("Invalid recipient specified");
        if (rawAmounts.length < 1) throw new Error("At least 1 amount needs to be specified");
        if (rawAmounts.length > 2) throw new Error("At most 2 amounts need to be specified");
        rawAmounts.forEach((val)=>{
            if (val < 0n) throw new Error("Negative raw amount specified");
            if (val >= 2n ** 64n) throw new Error("Raw amount overflow");
        });
        if (executionHash != null) {
            const executionHashValue = (0, Utils_1.toBigInt)(executionHash);
            if (executionHashValue < 0n) throw new Error("Execution hash negative");
            if (executionHashValue >= STARK_PRIME_MOD) throw new Error("Execution hash not in range of starknet prime");
        }
        const recipientBuffer = buffer_1.Buffer.from(recipient.substring(2).padStart(64, "0"), "hex");
        const amount0Buffer = buffer_1.Buffer.from(rawAmounts[0].toString(16).padStart(16, "0"), "hex");
        const amount1Buffer = rawAmounts[1] == null || rawAmounts[1] === 0n ? buffer_1.Buffer.alloc(0) : buffer_1.Buffer.from(rawAmounts[1].toString(16).padStart(16, "0"), "hex");
        const executionHashBuffer = executionHash == null ? buffer_1.Buffer.alloc(0) : buffer_1.Buffer.from(executionHash.substring(2).padStart(64, "0"), "hex");
        return buffer_1.Buffer.concat([
            recipientBuffer,
            amount0Buffer.reverse(),
            amount1Buffer.reverse(),
            executionHashBuffer
        ]);
    }
    //Actions
    async claim(signer, vault, txs, synchronizer, initAta, txOptions) {
        const result = await this.txsClaim(signer.getAddress(), vault, txs, synchronizer, initAta, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [signature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return signature;
    }
    async deposit(signer, vault, rawAmounts, txOptions) {
        const result = await this.txsDeposit(signer.getAddress(), vault, rawAmounts, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [signature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return signature;
    }
    async frontLiquidity(signer, vault, realWithdrawalTx, withdrawSequence, txOptions) {
        const result = await this.txsFrontLiquidity(signer.getAddress(), vault, realWithdrawalTx, withdrawSequence, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [signature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return signature;
    }
    async open(signer, vault, txOptions) {
        const result = await this.txsOpen(signer.getAddress(), vault, txOptions === null || txOptions === void 0 ? void 0 : txOptions.feeRate);
        const [signature] = await this.Chain.sendAndConfirm(signer, result, txOptions === null || txOptions === void 0 ? void 0 : txOptions.waitForConfirmation, txOptions === null || txOptions === void 0 ? void 0 : txOptions.abortSignal);
        return signature;
    }
    //Transactions
    async txsClaim(signer, vault, txs, synchronizer, initAta, feeRate) {
        if (!vault.isOpened()) throw new Error("Cannot claim from a closed vault!");
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.Chain.Fees.getFeeRate();
        const txsWithMerkleProofs = [];
        for (let tx of txs){
            const merkleProof = await this.bitcoinRpc.getMerkleProof(tx.tx.btcTx.txid, tx.tx.btcTx.blockhash);
            this.logger.debug("txsClaim(): merkle proof computed: ", merkleProof);
            txsWithMerkleProofs.push({
                ...merkleProof,
                ...tx
            });
        }
        const starknetTxs = [];
        const storedHeaders = await StarknetBtcRelay_1.StarknetBtcRelay.getCommitedHeadersAndSynchronize(signer, this.btcRelay, txsWithMerkleProofs.filter((tx)=>tx.storedHeader == null).map((tx)=>{
            return {
                blockhash: tx.tx.btcTx.blockhash,
                blockheight: tx.blockheight,
                requiredConfirmations: vault.getConfirmations()
            };
        }), starknetTxs, synchronizer, feeRate);
        if (storedHeaders == null) throw new Error("Cannot fetch committed header!");
        const actions = txsWithMerkleProofs.map((tx)=>{
            var _tx_storedHeader;
            return this.Claim(signer, vault, tx.tx, (_tx_storedHeader = tx.storedHeader) !== null && _tx_storedHeader !== void 0 ? _tx_storedHeader : storedHeaders[tx.tx.btcTx.blockhash], tx.merkle, tx.pos);
        });
        let starknetAction = new StarknetAction_1.StarknetAction(signer, this.Chain);
        for (let action of actions){
            starknetAction.add(action);
            if (starknetAction.ixsLength() >= this.maxClaimsPerTx) {
                await starknetAction.addToTxs(starknetTxs, feeRate);
                starknetAction = new StarknetAction_1.StarknetAction(signer, this.Chain);
            }
        }
        if (starknetAction.ixsLength() > 0) {
            await starknetAction.addToTxs(starknetTxs, feeRate);
        }
        this.logger.debug("txsClaim(): " + starknetTxs.length + " claim TXs created claiming " + txs.length + " txs, owner: " + vault.getOwner() + " vaultId: " + vault.getVaultId().toString(10));
        return starknetTxs;
    }
    async txsDeposit(signer, vault, rawAmounts, feeRate) {
        if (!vault.isOpened()) throw new Error("Cannot deposit to a closed vault!");
        //Approve first
        const vaultTokens = vault.getTokenData();
        const action = new StarknetAction_1.StarknetAction(signer, this.Chain);
        let realAmount0 = 0n;
        let realAmount1 = 0n;
        if (rawAmounts[0] != null && rawAmounts[0] !== 0n) {
            realAmount0 = rawAmounts[0] * vaultTokens[0].multiplier;
            action.add(this.Chain.Tokens.Approve(signer, this.contract.address, vaultTokens[0].token, realAmount0));
        }
        if (rawAmounts[1] != null && rawAmounts[1] !== 0n) {
            realAmount1 = rawAmounts[1] * vaultTokens[1].multiplier;
            action.add(this.Chain.Tokens.Approve(signer, this.contract.address, vaultTokens[1].token, realAmount1));
        }
        action.add(this.Deposit(signer, vault, rawAmounts));
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.Chain.Fees.getFeeRate();
        var _rawAmounts_;
        this.logger.debug("txsDeposit(): deposit TX created," + " token0: " + vaultTokens[0].token + " rawAmount0: " + rawAmounts[0].toString(10) + " amount0: " + realAmount0.toString(10) + " token1: " + vaultTokens[1].token + " rawAmount1: " + ((_rawAmounts_ = rawAmounts[1]) !== null && _rawAmounts_ !== void 0 ? _rawAmounts_ : 0n).toString(10) + " amount1: " + realAmount1.toString(10));
        return [
            await action.tx(feeRate)
        ];
    }
    async txsFrontLiquidity(signer, vault, realWithdrawalTx, withdrawSequence, feeRate) {
        if (!vault.isOpened()) throw new Error("Cannot front on a closed vault!");
        //Approve first
        const vaultTokens = vault.getTokenData();
        const action = new StarknetAction_1.StarknetAction(signer, this.Chain);
        const rawAmounts = realWithdrawalTx.getFrontingAmount();
        let realAmount0 = 0n;
        let realAmount1 = 0n;
        if (rawAmounts[0] != null && rawAmounts[0] !== 0n) {
            realAmount0 = rawAmounts[0] * vaultTokens[0].multiplier;
            action.add(this.Chain.Tokens.Approve(signer, this.contract.address, vaultTokens[0].token, realAmount0));
        }
        if (rawAmounts[1] != null && rawAmounts[1] !== 0n) {
            realAmount1 = rawAmounts[1] * vaultTokens[1].multiplier;
            action.add(this.Chain.Tokens.Approve(signer, this.contract.address, vaultTokens[1].token, realAmount1));
        }
        action.add(this.Front(signer, vault, realWithdrawalTx, withdrawSequence));
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.Chain.Fees.getFeeRate();
        var _rawAmounts_;
        this.logger.debug("txsFrontLiquidity(): front TX created," + " token0: " + vaultTokens[0].token + " rawAmount0: " + rawAmounts[0].toString(10) + " amount0: " + realAmount0.toString(10) + " token1: " + vaultTokens[1].token + " rawAmount1: " + ((_rawAmounts_ = rawAmounts[1]) !== null && _rawAmounts_ !== void 0 ? _rawAmounts_ : 0n).toString(10) + " amount1: " + realAmount1.toString(10));
        return [
            await action.tx(feeRate)
        ];
    }
    async txsOpen(signer, vault, feeRate) {
        if (vault.isOpened()) throw new Error("Cannot open an already opened vault!");
        const action = this.Open(signer, vault);
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.Chain.Fees.getFeeRate();
        this.logger.debug("txsOpen(): open TX created, owner: " + vault.getOwner() + " vaultId: " + vault.getVaultId().toString(10));
        return [
            await action.tx(feeRate)
        ];
    }
    async getClaimFee(signer, withdrawalData, feeRate) {
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.Chain.Fees.getFeeRate();
        return StarknetFees_1.StarknetFees.getGasFee(withdrawalData == null ? StarknetSpvVaultContract.GasCosts.CLAIM_OPTIMISTIC_ESTIMATE : StarknetSpvVaultContract.GasCosts.CLAIM, feeRate);
    }
    async getFrontFee(signer, withdrawalData, feeRate) {
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.Chain.Fees.getFeeRate();
        return StarknetFees_1.StarknetFees.getGasFee(StarknetSpvVaultContract.GasCosts.FRONT, feeRate);
    }
    constructor(chainInterface, btcRelay, bitcoinRpc, contractAddress = spvVaultContractAddreses[chainInterface.starknetChainId]){
        super(chainInterface, contractAddress, SpvVaultContractAbi_1.SpvVaultContractAbi);
        this.chainId = "STARKNET";
        this.claimTimeout = 180;
        this.maxClaimsPerTx = 10;
        this.logger = (0, Utils_1.getLogger)("StarknetSpvVaultContract: ");
        this.btcRelay = btcRelay;
        this.bitcoinRpc = bitcoinRpc;
    }
}
exports.StarknetSpvVaultContract = StarknetSpvVaultContract;
StarknetSpvVaultContract.GasCosts = {
    DEPOSIT: {
        l1DataGas: 400,
        l2Gas: 4000000,
        l1Gas: 0
    },
    OPEN: {
        l1DataGas: 1200,
        l2Gas: 3200000,
        l1Gas: 0
    },
    FRONT: {
        l1DataGas: 800,
        l2Gas: 12000000,
        l1Gas: 0
    },
    CLAIM: {
        l1DataGas: 1000,
        l2Gas: 400000000,
        l1Gas: 0
    },
    CLAIM_OPTIMISTIC_ESTIMATE: {
        l1DataGas: 1000,
        l2Gas: 80000000,
        l1Gas: 0
    } //If claimer uses sierra 1.7.0 or later
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/provider/RpcProviderWithRetries.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RpcProviderWithRetries = exports.RpcChannelWithRetries = void 0;
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/utils/Utils.js [app-client] (ecmascript)");
class RpcChannelWithRetries extends starknet_1.RpcChannel {
    fetchEndpoint(method, params) {
        return (0, Utils_1.tryWithRetries)(()=>super.fetchEndpoint(method, params), this.retryPolicy, (e)=>{
            if (!e.message.startsWith("RPC: ")) return false;
            const arr = e.message.split("\n");
            const errorCode = parseInt(arr[arr.length - 1]);
            if (isNaN(errorCode)) return false;
            if (errorCode < 0) return false; //Not defined error, e.g. Rate limit (-32097)
            return true;
        });
    }
    constructor(options, retryPolicy){
        super(options);
        this.retryPolicy = retryPolicy;
    }
}
exports.RpcChannelWithRetries = RpcChannelWithRetries;
class RpcProviderWithRetries extends starknet_1.RpcProvider {
    constructor(options, retryPolicy){
        super(options);
        this.channel = new RpcChannelWithRetries({
            ...options,
            waitMode: false
        }, retryPolicy);
    }
}
exports.RpcProviderWithRetries = RpcProviderWithRetries;
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/StarknetInitializer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StarknetInitializer = exports.initializeStarknet = exports.StarknetAssets = void 0;
const starknet_1 = __turbopack_context__.r("[project]/node_modules/starknet/dist/index.js [app-client] (ecmascript)");
const StarknetFees_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)");
const StarknetChainInterface_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetChainInterface.js [app-client] (ecmascript)");
const StarknetBtcRelay_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/StarknetBtcRelay.js [app-client] (ecmascript)");
const StarknetSwapContract_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapContract.js [app-client] (ecmascript)");
const StarknetChainEventsBrowser_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/events/StarknetChainEventsBrowser.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const StarknetSwapData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapData.js [app-client] (ecmascript)");
const StarknetSpvVaultContract_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultContract.js [app-client] (ecmascript)");
const StarknetSpvVaultData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultData.js [app-client] (ecmascript)");
const StarknetSpvWithdrawalData_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvWithdrawalData.js [app-client] (ecmascript)");
const RpcProviderWithRetries_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/provider/RpcProviderWithRetries.js [app-client] (ecmascript)");
exports.StarknetAssets = {
    ETH: {
        address: "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7",
        decimals: 18,
        displayDecimals: 9
    },
    STRK: {
        address: "0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d",
        decimals: 18,
        displayDecimals: 9
    },
    WBTC: {
        address: "0x03fe2b97c1fd336e750087d68b9b867997fd64a2661ff3ca5a7c771641e8e7ac",
        decimals: 8
    },
    TBTC: {
        address: "0x04daa17763b286d1e59b97c283C0b8C949994C361e426A28F743c67bDfE9a32f",
        decimals: 18,
        displayDecimals: 8
    },
    _TESTNET_WBTC_VESU: {
        address: "0x04861ba938aed21f2cd7740acd3765ac4d2974783a3218367233de0153490cb6",
        decimals: 8
    }
};
function initializeStarknet(options, bitcoinRpc, network) {
    const provider = typeof options.rpcUrl === "string" ? new RpcProviderWithRetries_1.RpcProviderWithRetries({
        nodeUrl: options.rpcUrl
    }) : options.rpcUrl;
    var _options_fees;
    const Fees = (_options_fees = options.fees) !== null && _options_fees !== void 0 ? _options_fees : new StarknetFees_1.StarknetFees(provider);
    var _options_chainId;
    const chainId = (_options_chainId = options.chainId) !== null && _options_chainId !== void 0 ? _options_chainId : network === base_1.BitcoinNetwork.MAINNET ? starknet_1.constants.StarknetChainId.SN_MAIN : starknet_1.constants.StarknetChainId.SN_SEPOLIA;
    const chainInterface = new StarknetChainInterface_1.StarknetChainInterface(chainId, provider, options.retryPolicy, Fees);
    const btcRelay = new StarknetBtcRelay_1.StarknetBtcRelay(chainInterface, bitcoinRpc, network, options.btcRelayContract);
    const swapContract = new StarknetSwapContract_1.StarknetSwapContract(chainInterface, btcRelay, options.swapContract, options.handlerContracts);
    const spvVaultContract = new StarknetSpvVaultContract_1.StarknetSpvVaultContract(chainInterface, btcRelay, bitcoinRpc, options.spvVaultContract);
    const chainEvents = new StarknetChainEventsBrowser_1.StarknetChainEventsBrowser(chainInterface, swapContract, spvVaultContract);
    return {
        chainId: "STARKNET",
        btcRelay,
        chainInterface,
        swapContract,
        chainEvents,
        swapDataConstructor: StarknetSwapData_1.StarknetSwapData,
        spvVaultContract,
        spvVaultDataConstructor: StarknetSpvVaultData_1.StarknetSpvVaultData,
        spvVaultWithdrawalDataConstructor: StarknetSpvWithdrawalData_1.StarknetSpvWithdrawalData
    };
}
exports.initializeStarknet = initializeStarknet;
;
exports.StarknetInitializer = {
    chainId: "STARKNET",
    chainType: null,
    initializer: initializeStarknet,
    tokens: exports.StarknetAssets,
    options: null
};
}),
"[project]/node_modules/@atomiqlabs/chain-starknet/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetAction.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetChainInterface.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/StarknetModule.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetFees.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetEvents.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetTokens.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetAddresses.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetTransactions.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/chain/modules/StarknetSignatures.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/headers/StarknetBtcStoredHeader.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/headers/StarknetBtcHeader.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/btcrelay/StarknetBtcRelay.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/modules/StarknetContractEvents.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/contract/StarknetContractBase.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapContract.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapData.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/StarknetSwapModule.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetLpVault.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapClaim.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapInit.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/modules/StarknetSwapRefund.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/IHandler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/refund/TimelockRefundHandler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/ClaimHandlers.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/HashlockClaimHandler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/IBitcoinClaimHandler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinTxIdClaimHandler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinOutputClaimHandler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/swaps/handlers/claim/btc/BitcoinNoncedOutputClaimHandler.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/events/StarknetChainEventsBrowser.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/wallet/StarknetSigner.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/wallet/StarknetKeypairWallet.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/StarknetChainType.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/StarknetInitializer.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultContract.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvVaultData.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/spv_swap/StarknetSpvWithdrawalData.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/chain-starknet/dist/starknet/provider/RpcProviderWithRetries.js [app-client] (ecmascript)"), exports);
}),
]);

//# sourceMappingURL=node_modules_%40atomiqlabs_chain-starknet_dist_087e7763._.js.map