(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OutOfBoundsError = exports.RequestError = void 0;
/**
 * An error returned by the intermediary in a http response
 */ class RequestError extends Error {
    static parse(msg, httpCode) {
        try {
            const parsed = JSON.parse(msg);
            msg = parsed.msg;
            if (parsed.code === 20003 || parsed.code === 20004) {
                return new OutOfBoundsError(parsed.msg, httpCode, BigInt(parsed.data.min), BigInt(parsed.data.max));
            }
        } catch (e) {}
        return new RequestError(msg, httpCode);
    }
    constructor(msg, httpCode){
        try {
            const parsed = JSON.parse(msg);
            if (parsed.msg != null) msg = parsed.msg;
        } catch (e) {}
        super(msg);
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, RequestError.prototype);
        this.httpCode = httpCode;
    }
}
exports.RequestError = RequestError;
/**
 * An error indicating out of bounds (amount too high or too low) on swap initialization
 */ class OutOfBoundsError extends RequestError {
    constructor(msg, httpCode, min, max){
        super(msg, httpCode);
        this.max = max;
        this.min = min;
        Object.setPrototypeOf(this, OutOfBoundsError.prototype);
    }
}
exports.OutOfBoundsError = OutOfBoundsError;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.randomBytes = exports.toCoinselectAddressType = exports.toOutputScript = exports.bigIntCompare = exports.bigIntMax = exports.bigIntMin = exports.timeoutSignal = exports.timeoutPromise = exports.httpPost = exports.httpGet = exports.fetchWithTimeout = exports.tryWithRetries = exports.extendAbortController = exports.mapToArray = exports.objectMap = exports.promiseAny = exports.getLogger = void 0;
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-client] (ecmascript)");
function isConstructor(fn) {
    return typeof fn === 'function' && fn.prototype != null && fn.prototype.constructor === fn;
}
function isConstructorArray(fnArr) {
    return Array.isArray(fnArr) && fnArr.every(isConstructor);
}
/**
 * Checks whether the passed error is allowed to pass through
 *
 * @param e Error in question
 * @param errorAllowed Allowed errors as defined as a callback function, specific error type, or an array of error types
 */ function checkError(e, errorAllowed) {
    if (isConstructorArray(errorAllowed)) return errorAllowed.find((error)=>e instanceof error) != null;
    if (isConstructor(errorAllowed)) return e instanceof errorAllowed;
    return errorAllowed(e);
}
function getLogger(prefix) {
    return {
        debug: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 3 && console.debug(prefix + msg, ...args);
        },
        info: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 2 && console.info(prefix + msg, ...args);
        },
        warn: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return (/*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel == null || /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 1) && console.warn(prefix + msg, ...args);
        },
        error: function(msg) {
            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                args[_key - 1] = arguments[_key];
            }
            return (/*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel == null || /*TURBOPACK member replacement*/ __turbopack_context__.g.atomiqLogLevel >= 0) && console.error(prefix + msg, ...args);
        }
    };
}
exports.getLogger = getLogger;
const logger = getLogger("Utils: ");
/**
 * Returns a promise that resolves when any of the passed promises resolves, and rejects if all the underlying
 *  promises fail with an array of errors returned by the respective promises
 *
 * @param promises
 */ function promiseAny(promises) {
    return new Promise((resolve, reject)=>{
        let numRejected = 0;
        const rejectReasons = Array(promises.length);
        promises.forEach((promise, index)=>{
            promise.then((val)=>{
                if (resolve != null) resolve(val);
                resolve = null;
            }).catch((err)=>{
                rejectReasons[index] = err;
                numRejected++;
                if (numRejected === promises.length) {
                    reject(rejectReasons);
                }
            });
        });
    });
}
exports.promiseAny = promiseAny;
/**
 * Maps a JS object to another JS object based on the translation function, the translation function is called for every
 *  property (value/key) of the old object and returns the new value of for this property
 *
 * @param obj
 * @param translator
 */ function objectMap(obj, translator) {
    const resp = {};
    for(let key in obj){
        resp[key] = translator(obj[key], key);
    }
    return resp;
}
exports.objectMap = objectMap;
/**
 * Maps the entries from the map to the array using the translator function
 *
 * @param map
 * @param translator
 */ function mapToArray(map, translator) {
    const arr = Array(map.size);
    let pointer = 0;
    for (let entry of map.entries()){
        arr[pointer++] = translator(entry[0], entry[1]);
    }
    return arr;
}
exports.mapToArray = mapToArray;
/**
 * Creates a new abort controller that will abort if the passed abort signal aborts
 *
 * @param abortSignal
 */ function extendAbortController(abortSignal) {
    const _abortController = new AbortController();
    if (abortSignal != null) {
        abortSignal.throwIfAborted();
        abortSignal.onabort = ()=>_abortController.abort(abortSignal.reason);
    }
    return _abortController;
}
exports.extendAbortController = extendAbortController;
/**
 * Runs the passed function multiple times if it fails
 *
 * @param func A callback for executing the action
 * @param func.retryCount Count of the current retry, starting from 0 for original request and increasing
 * @param retryPolicy Retry policy
 * @param retryPolicy.maxRetries How many retries to attempt in total
 * @param retryPolicy.delay How long should the delay be
 * @param retryPolicy.exponential Whether to use exponentially increasing delays
 * @param errorAllowed A callback for determining whether a given error is allowed, and we should therefore not retry
 * @param abortSignal
 * @returns Result of the action executing callback
 */ async function tryWithRetries(func, retryPolicy, errorAllowed, abortSignal) {
    retryPolicy = retryPolicy || {};
    retryPolicy.maxRetries = retryPolicy.maxRetries || 5;
    retryPolicy.delay = retryPolicy.delay || 500;
    retryPolicy.exponential = retryPolicy.exponential == null ? true : retryPolicy.exponential;
    let err = null;
    for(let i = 0; i < retryPolicy.maxRetries; i++){
        try {
            return await func(i);
        } catch (e) {
            if (errorAllowed != null && checkError(e, errorAllowed)) throw e;
            err = e;
            logger.warn("tryWithRetries(): Error on try number: " + i, e);
        }
        if (abortSignal != null && abortSignal.aborted) throw abortSignal.reason || new Error("Aborted");
        if (i !== retryPolicy.maxRetries - 1) {
            await timeoutPromise(retryPolicy.exponential ? retryPolicy.delay * Math.pow(2, i) : retryPolicy.delay, abortSignal);
        }
    }
    throw err;
}
exports.tryWithRetries = tryWithRetries;
/**
 * Mimics fetch API byt adds a timeout to the request
 *
 * @param input
 * @param init
 */ function fetchWithTimeout(input, init) {
    if (init == null) init = {};
    if (init.timeout != null) init.signal = timeoutSignal(init.timeout, new Error("Network request timed out"), init.signal);
    return fetch(input, init).catch((e)=>{
        if (e.name === "AbortError") {
            throw init.signal.reason;
        } else {
            throw e;
        }
    });
}
exports.fetchWithTimeout = fetchWithTimeout;
/**
 * Sends an HTTP GET request through a fetch API, handles non 200 response codes as errors
 * @param url Send request to this URL
 * @param timeout Timeout (in milliseconds) for the request to conclude
 * @param abortSignal
 * @param allowNon200 Whether to allow non-200 status code HTTP responses
 * @throws {RequestError} if non 200 response code was returned or body cannot be parsed
 */ async function httpGet(url, timeout, abortSignal) {
    let allowNon200 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const init = {
        method: "GET",
        timeout,
        signal: abortSignal
    };
    const response = await fetchWithTimeout(url, init);
    if (response.status !== 200) {
        let resp;
        try {
            resp = await response.text();
        } catch (e) {
            throw new RequestError_1.RequestError(response.statusText, response.status);
        }
        if (allowNon200) {
            try {
                return JSON.parse(resp);
            } catch (e) {}
        }
        throw RequestError_1.RequestError.parse(resp, response.status);
    }
    return await response.json();
}
exports.httpGet = httpGet;
/**
 * Sends an HTTP POST request through a fetch API, handles non 200 response codes as errors
 * @param url Send request to this URL
 * @param body A HTTP request body to send to the server
 * @param timeout Timeout (in milliseconds) for the request to conclude
 * @param abortSignal
 * @throws {RequestError} if non 200 response code was returned
 */ async function httpPost(url, body, timeout, abortSignal) {
    const init = {
        method: "POST",
        timeout,
        body: JSON.stringify(body),
        headers: {
            'Content-Type': 'application/json'
        },
        signal: abortSignal
    };
    const response = timeout == null ? await fetch(url, init) : await fetchWithTimeout(url, init);
    if (response.status !== 200) {
        let resp;
        try {
            resp = await response.text();
        } catch (e) {
            throw new RequestError_1.RequestError(response.statusText, response.status);
        }
        throw RequestError_1.RequestError.parse(resp, response.status);
    }
    return await response.json();
}
exports.httpPost = httpPost;
/**
 * Returns a promise that resolves after given amount seconds
 *
 * @param timeout how many milliseconds to wait for
 * @param abortSignal
 */ function timeoutPromise(timeout, abortSignal) {
    return new Promise((resolve, reject)=>{
        if (abortSignal != null && abortSignal.aborted) {
            reject(abortSignal.reason);
            return;
        }
        let abortSignalListener;
        let timeoutHandle = setTimeout(()=>{
            if (abortSignalListener != null) abortSignal.removeEventListener("abort", abortSignalListener);
            resolve();
        }, timeout);
        if (abortSignal != null) {
            abortSignal.addEventListener("abort", abortSignalListener = ()=>{
                if (timeoutHandle != null) clearTimeout(timeoutHandle);
                timeoutHandle = null;
                reject(abortSignal.reason);
            });
        }
    });
}
exports.timeoutPromise = timeoutPromise;
/**
 * Returns an abort signal that aborts after a specified timeout in milliseconds
 *
 * @param timeout Milliseconds to wait
 * @param abortReason Abort with this abort reason
 * @param abortSignal Abort signal to extend
 */ function timeoutSignal(timeout, abortReason, abortSignal) {
    if (timeout == null) return abortSignal;
    const abortController = new AbortController();
    const timeoutHandle = setTimeout(()=>abortController.abort(abortReason || new Error("Timed out")), timeout);
    if (abortSignal != null) {
        abortSignal.addEventListener("abort", ()=>{
            clearTimeout(timeoutHandle);
            abortController.abort(abortSignal.reason);
        });
    }
    return abortController.signal;
}
exports.timeoutSignal = timeoutSignal;
function bigIntMin(a, b) {
    return a > b ? b : a;
}
exports.bigIntMin = bigIntMin;
function bigIntMax(a, b) {
    return b > a ? b : a;
}
exports.bigIntMax = bigIntMax;
function bigIntCompare(a, b) {
    return a > b ? 1 : a === b ? 0 : -1;
}
exports.bigIntCompare = bigIntCompare;
function toOutputScript(network, address) {
    const outputScript = (0, btc_signer_1.Address)(network).decode(address);
    switch(outputScript.type){
        case "pkh":
        case "sh":
        case "wpkh":
        case "wsh":
            return buffer_1.Buffer.from(btc_signer_1.OutScript.encode({
                type: outputScript.type,
                hash: outputScript.hash
            }));
        case "tr":
            return buffer_1.Buffer.from(btc_signer_1.OutScript.encode({
                type: "tr",
                pubkey: outputScript.pubkey
            }));
    }
}
exports.toOutputScript = toOutputScript;
function toCoinselectAddressType(outputScript) {
    const data = btc_signer_1.OutScript.decode(outputScript);
    switch(data.type){
        case "pkh":
            return "p2pkh";
        case "sh":
            return "p2sh-p2wpkh";
        case "wpkh":
            return "p2wpkh";
        case "wsh":
            return "p2wsh";
        case "tr":
            return "p2tr";
    }
    throw new Error("Unrecognized address type!");
}
exports.toCoinselectAddressType = toCoinselectAddressType;
function randomBytes(bytesLength) {
    return buffer_1.Buffer.from((0, utils_1.randomBytes)(bytesLength));
}
exports.randomBytes = randomBytes;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/synchronizer/MempoolBtcRelaySynchronizer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MempoolBtcRelaySynchronizer = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("MempoolBtcRelaySynchronizer: ");
class MempoolBtcRelaySynchronizer {
    async syncToLatestTxs(signer, feeRate) {
        const tipData = await this.btcRelay.getTipData();
        let cacheData = {
            forkId: 0,
            lastStoredHeader: null,
            tx: null,
            computedCommitedHeaders: null
        };
        const { resultStoredHeader, resultBitcoinHeader } = await this.btcRelay.retrieveLatestKnownBlockLog();
        cacheData.lastStoredHeader = resultStoredHeader;
        if (resultStoredHeader.getBlockheight() < tipData.blockheight) cacheData.forkId = -1; //Indicate that we will be submitting blocks to fork
        let spvTipBlockHeader = resultBitcoinHeader;
        const btcRelayTipBlockHash = spvTipBlockHeader.getHash();
        logger.debug("Retrieved stored header with commitment: ", cacheData.lastStoredHeader);
        logger.debug("SPV tip bitcoin RPC block header: ", spvTipBlockHeader);
        let spvTipBlockHeight = spvTipBlockHeader.height;
        const txsList = [];
        const blockHeaderMap = {
            [resultBitcoinHeader.getHeight()]: resultBitcoinHeader
        };
        const computedHeaderMap = {
            [resultStoredHeader.getBlockheight()]: resultStoredHeader
        };
        let startForkId = null;
        let forkFee = feeRate;
        let mainFee = feeRate;
        const saveHeaders = async (headerCache)=>{
            if (cacheData.forkId === -1) {
                if (mainFee == null) mainFee = await this.btcRelay.getMainFeeRate(signer);
                cacheData = await this.btcRelay.saveNewForkHeaders(signer, headerCache, cacheData.lastStoredHeader, tipData.chainWork, mainFee);
            } else if (cacheData.forkId === 0) {
                if (mainFee == null) mainFee = await this.btcRelay.getMainFeeRate(signer);
                cacheData = await this.btcRelay.saveMainHeaders(signer, headerCache, cacheData.lastStoredHeader, mainFee);
            } else {
                if (forkFee == null) forkFee = await this.btcRelay.getForkFeeRate(signer, cacheData.forkId);
                cacheData = await this.btcRelay.saveForkHeaders(signer, headerCache, cacheData.lastStoredHeader, cacheData.forkId, tipData.chainWork, forkFee);
            }
            if (cacheData.forkId !== -1 && cacheData.forkId !== 0) startForkId = cacheData.forkId;
            txsList.push(cacheData.tx);
            for (let storedHeader of cacheData.computedCommitedHeaders){
                computedHeaderMap[storedHeader.getBlockheight()] = storedHeader;
            }
        };
        let retrievedHeaders = null;
        let headerCache = [];
        while(retrievedHeaders == null || retrievedHeaders.length > 0){
            retrievedHeaders = await this.bitcoinRpc.getPast15Blocks(spvTipBlockHeight + 15);
            let startIndex = retrievedHeaders.findIndex((val)=>val.height === spvTipBlockHeight);
            if (startIndex === -1) startIndex = retrievedHeaders.length; //Start from the last block
            for(let i = startIndex - 1; i >= 0; i--){
                const header = retrievedHeaders[i];
                blockHeaderMap[header.height] = header;
                headerCache.push(header);
                if (cacheData.forkId === 0 ? headerCache.length >= this.btcRelay.maxHeadersPerTx : headerCache.length >= this.btcRelay.maxForkHeadersPerTx) {
                    await saveHeaders(headerCache);
                    headerCache = [];
                }
            }
            if (retrievedHeaders.length > 0) {
                if (spvTipBlockHeight === retrievedHeaders[0].height) break; //Already at the tip
                spvTipBlockHeight = retrievedHeaders[0].height;
                await (0, Utils_1.timeoutPromise)(1000);
            }
        }
        if (headerCache.length > 0) await saveHeaders(headerCache);
        if (cacheData.forkId !== 0) {
            throw new Error("Unable to synchronize on-chain bitcoin light client! Not enough chainwork at connected RPC.");
        }
        return {
            txs: txsList,
            targetCommitedHeader: cacheData.lastStoredHeader,
            blockHeaderMap,
            computedHeaderMap,
            btcRelayTipCommitedHeader: resultStoredHeader,
            btcRelayTipBlockHeader: resultBitcoinHeader,
            latestBlockHeader: spvTipBlockHeader,
            startForkId
        };
    }
    constructor(btcRelay, bitcoinRpc){
        this.btcRelay = btcRelay;
        this.bitcoinRpc = bitcoinRpc;
    }
}
exports.MempoolBtcRelaySynchronizer = MempoolBtcRelaySynchronizer;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolApi.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MempoolApi = void 0;
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
class MempoolApi {
    /**
     * Returns api url that should be operational
     *
     * @private
     */ getOperationalApi() {
        return this.backends.find((e)=>e.operational === true);
    }
    /**
     * Returns api urls that are maybe operational, in case none is considered operational returns all of the price
     *  apis such that they can be tested again whether they are operational
     *
     * @private
     */ getMaybeOperationalApis() {
        let operational = this.backends.filter((e)=>e.operational === true || e.operational === null);
        if (operational.length === 0) {
            this.backends.forEach((e)=>e.operational = null);
            operational = this.backends;
        }
        return operational;
    }
    /**
     * Sends a GET or POST request to the mempool api, handling the non-200 responses as errors & throwing
     *
     * @param url
     * @param path
     * @param responseType
     * @param type
     * @param body
     */ async _request(url, path, responseType) {
        let type = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "GET", body = arguments.length > 4 ? arguments[4] : void 0;
        const response = await (0, Utils_1.fetchWithTimeout)(url + path, {
            method: type,
            timeout: this.timeout,
            body: typeof body === "string" ? body : JSON.stringify(body)
        });
        if (response.status !== 200) {
            let resp;
            try {
                resp = await response.text();
            } catch (e) {
                throw new RequestError_1.RequestError(response.statusText, response.status);
            }
            throw RequestError_1.RequestError.parse(resp, response.status);
        }
        if (responseType === "str") return await response.text();
        return await response.json();
    }
    /**
     * Sends request in parallel to multiple maybe operational api urls
     *
     * @param path
     * @param responseType
     * @param type
     * @param body
     * @private
     */ async requestFromMaybeOperationalUrls(path, responseType) {
        let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "GET", body = arguments.length > 3 ? arguments[3] : void 0;
        try {
            return await (0, Utils_1.promiseAny)(this.getMaybeOperationalApis().map((obj)=>(async ()=>{
                    try {
                        const result = await this._request(obj.url, path, responseType, type, body);
                        obj.operational = true;
                        return result;
                    } catch (e) {
                        //Only mark as non operational on 5xx server errors!
                        if (e instanceof RequestError_1.RequestError && Math.floor(e.httpCode / 100) !== 5) {
                            obj.operational = true;
                            throw e;
                        } else {
                            obj.operational = false;
                            throw e;
                        }
                    }
                })()));
        } catch (e) {
            throw e.find((err)=>err instanceof RequestError_1.RequestError && Math.floor(err.httpCode / 100) !== 5) || e[0];
        }
    }
    /**
     * Sends a request to mempool API, first tries to use the operational API (if any) and if that fails it falls back
     *  to using maybe operational price APIs
     *
     * @param path
     * @param responseType
     * @param type
     * @param body
     * @private
     */ async request(path, responseType) {
        let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "GET", body = arguments.length > 3 ? arguments[3] : void 0;
        return (0, Utils_1.tryWithRetries)(()=>{
            const operationalPriceApi = this.getOperationalApi();
            if (operationalPriceApi != null) {
                return this._request(operationalPriceApi.url, path, responseType, type, body).catch((err)=>{
                    //Only retry on 5xx server errors!
                    if (err instanceof RequestError_1.RequestError && Math.floor(err.httpCode / 100) !== 5) throw err;
                    operationalPriceApi.operational = false;
                    return this.requestFromMaybeOperationalUrls(path, responseType, type, body);
                });
            }
            return this.requestFromMaybeOperationalUrls(path, responseType, type, body);
        }, null, (err)=>err instanceof RequestError_1.RequestError && Math.floor(err.httpCode / 100) !== 5);
    }
    /**
     * Returns information about a specific lightning network node as identified by the public key (in hex encoding)
     *
     * @param pubkey
     */ getLNNodeInfo(pubkey) {
        return this.request("v1/lightning/nodes/" + pubkey, "obj").catch((e)=>{
            if (e.message === "This node does not exist, or our node is not seeing it yet") return null;
            throw e;
        });
    }
    /**
     * Returns on-chain transaction as identified by its txId
     *
     * @param txId
     */ getTransaction(txId) {
        return this.request("tx/" + txId, "obj").catch((e)=>{
            if (e.message === "Transaction not found") return null;
            throw e;
        });
    }
    /**
     * Returns raw binary encoded bitcoin transaction, also strips the witness data from the transaction
     *
     * @param txId
     */ async getRawTransaction(txId) {
        const rawTransaction = await this.request("tx/" + txId + "/hex", "str").catch((e)=>{
            if (e.message === "Transaction not found") return null;
            throw e;
        });
        return rawTransaction == null ? null : buffer_1.Buffer.from(rawTransaction, "hex");
    }
    /**
     * Returns confirmed & unconfirmed balance of the specific bitcoin address
     *
     * @param address
     */ async getAddressBalances(address) {
        const jsonBody = await this.request("address/" + address, "obj");
        const confirmedInput = BigInt(jsonBody.chain_stats.funded_txo_sum);
        const confirmedOutput = BigInt(jsonBody.chain_stats.spent_txo_sum);
        const unconfirmedInput = BigInt(jsonBody.mempool_stats.funded_txo_sum);
        const unconfirmedOutput = BigInt(jsonBody.mempool_stats.spent_txo_sum);
        return {
            confirmedBalance: confirmedInput - confirmedOutput,
            unconfirmedBalance: unconfirmedInput - unconfirmedOutput
        };
    }
    /**
     * Returns CPFP (children pays for parent) data for a given transaction
     *
     * @param txId
     */ getCPFPData(txId) {
        return this.request("v1/cpfp/" + txId, "obj");
    }
    /**
     * Returns UTXOs (unspent transaction outputs) for a given address
     *
     * @param address
     */ async getAddressUTXOs(address) {
        let jsonBody = await this.request("address/" + address + "/utxo", "obj");
        jsonBody.forEach((e)=>e.value = BigInt(e.value));
        return jsonBody;
    }
    /**
     * Returns current on-chain bitcoin fees
     */ getFees() {
        return this.request("v1/fees/recommended", "obj");
    }
    /**
     * Returns all transactions for a given address
     *
     * @param address
     */ getAddressTransactions(address) {
        return this.request("address/" + address + "/txs", "obj");
    }
    /**
     * Returns expected pending (mempool) blocks
     */ getPendingBlocks() {
        return this.request("v1/fees/mempool-blocks", "obj");
    }
    /**
     * Returns the blockheight of the current bitcoin blockchain's tip
     */ async getTipBlockHeight() {
        const response = await this.request("blocks/tip/height", "str");
        return parseInt(response);
    }
    /**
     * Returns the bitcoin blockheader as identified by its blockhash
     *
     * @param blockhash
     */ getBlockHeader(blockhash) {
        return this.request("block/" + blockhash, "obj");
    }
    /**
     * Returns the block status
     *
     * @param blockhash
     */ getBlockStatus(blockhash) {
        return this.request("block/" + blockhash + "/status", "obj");
    }
    /**
     * Returns the transaction's proof (merkle proof)
     *
     * @param txId
     */ getTransactionProof(txId) {
        return this.request("tx/" + txId + "/merkle-proof", "obj");
    }
    /**
     * Returns the transaction's proof (merkle proof)
     *
     * @param txId
     */ getOutspends(txId) {
        return this.request("tx/" + txId + "/outspends", "obj");
    }
    /**
     * Returns blockhash of a block at a specific blockheight
     *
     * @param height
     */ getBlockHash(height) {
        return this.request("block-height/" + height, "str");
    }
    /**
     * Returns past 15 blockheaders before (and including) the specified height
     *
     * @param endHeight
     */ getPast15BlockHeaders(endHeight) {
        return this.request("v1/blocks/" + endHeight, "obj");
    }
    /**
     * Sends raw hex encoded bitcoin transaction
     *
     * @param transactionHex
     */ sendTransaction(transactionHex) {
        return this.request("tx", "str", "POST", transactionHex);
    }
    constructor(url, timeout){
        url = url !== null && url !== void 0 ? url : "https://mempool.space/testnet/api/";
        if (Array.isArray(url)) {
            this.backends = url.map((val)=>{
                return {
                    url: val,
                    operational: null
                };
            });
        } else {
            this.backends = [
                {
                    url: url,
                    operational: null
                }
            ];
        }
        this.timeout = timeout;
    }
}
exports.MempoolApi = MempoolApi;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolBitcoinBlock.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MempoolBitcoinBlock = void 0;
class MempoolBitcoinBlock {
    getHeight() {
        return this.height;
    }
    getHash() {
        return this.id;
    }
    getMerkleRoot() {
        return this.merkle_root;
    }
    getNbits() {
        return this.bits;
    }
    getNonce() {
        return this.nonce;
    }
    getPrevBlockhash() {
        return this.previousblockhash;
    }
    getTimestamp() {
        return this.timestamp;
    }
    getVersion() {
        return this.version;
    }
    getChainWork() {
        throw new Error("Unsupported");
    }
    constructor(obj){
        this.id = obj.id;
        this.height = obj.height;
        this.version = obj.version;
        this.timestamp = obj.timestamp;
        this.tx_count = obj.tx_count;
        this.size = obj.size;
        this.weight = obj.weight;
        this.merkle_root = obj.merkle_root;
        this.previousblockhash = obj.previousblockhash;
        this.mediantime = obj.mediantime;
        this.nonce = obj.nonce;
        this.bits = obj.bits;
        this.difficulty = obj.difficulty;
    }
}
exports.MempoolBitcoinBlock = MempoolBitcoinBlock;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolBitcoinRpc.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MempoolBitcoinRpc = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const MempoolBitcoinBlock_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolBitcoinBlock.js [app-client] (ecmascript)");
const MempoolApi_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolApi.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
const BITCOIN_BLOCKTIME = 600 * 1000;
const BITCOIN_BLOCKSIZE = 1024 * 1024;
function bitcoinTxToBtcTx(btcTx) {
    return {
        locktime: btcTx.lockTime,
        version: btcTx.version,
        blockhash: null,
        confirmations: 0,
        txid: buffer_1.Buffer.from((0, sha2_1.sha256)((0, sha2_1.sha256)(btcTx.toBytes(true, false)))).reverse().toString("hex"),
        hex: buffer_1.Buffer.from(btcTx.toBytes(true, false)).toString("hex"),
        raw: buffer_1.Buffer.from(btcTx.toBytes(true, true)).toString("hex"),
        vsize: btcTx.isFinal ? btcTx.vsize : null,
        outs: Array.from({
            length: btcTx.outputsLength
        }, (_, i)=>i).map((index)=>{
            const output = btcTx.getOutput(index);
            return {
                value: Number(output.amount),
                n: index,
                scriptPubKey: {
                    asm: btc_signer_1.Script.decode(output.script).map((val)=>typeof val === "object" ? buffer_1.Buffer.from(val).toString("hex") : val.toString()).join(" "),
                    hex: buffer_1.Buffer.from(output.script).toString("hex")
                }
            };
        }),
        ins: Array.from({
            length: btcTx.inputsLength
        }, (_, i)=>i).map((index)=>{
            const input = btcTx.getInput(index);
            return {
                txid: buffer_1.Buffer.from(input.txid).toString("hex"),
                vout: input.index,
                scriptSig: {
                    asm: btc_signer_1.Script.decode(input.finalScriptSig).map((val)=>typeof val === "object" ? buffer_1.Buffer.from(val).toString("hex") : val.toString()).join(" "),
                    hex: buffer_1.Buffer.from(input.finalScriptSig).toString("hex")
                },
                sequence: input.sequence,
                txinwitness: input.finalScriptWitness == null ? [] : input.finalScriptWitness.map((witness)=>buffer_1.Buffer.from(witness).toString("hex"))
            };
        })
    };
}
class MempoolBitcoinRpc {
    /**
     * Returns a txo hash for a specific transaction vout
     *
     * @param vout
     * @private
     */ static getTxoHash(vout) {
        return buffer_1.Buffer.from((0, sha2_1.sha256)(buffer_1.Buffer.concat([
            base_1.BigIntBufferUtils.toBuffer(BigInt(vout.value), "le", 8),
            buffer_1.Buffer.from(vout.scriptpubkey, "hex")
        ])));
    }
    /**
     * Returns delay in milliseconds till an unconfirmed transaction is expected to confirm, returns -1
     *  if the transaction won't confirm any time soon
     *
     * @param feeRate
     * @private
     */ async getTimeTillConfirmation(feeRate) {
        const mempoolBlocks = await this.api.getPendingBlocks();
        const mempoolBlockIndex = mempoolBlocks.findIndex((block)=>block.feeRange[0] <= feeRate);
        if (mempoolBlockIndex === -1) return -1;
        //Last returned block is usually an aggregate (or a stack) of multiple btc blocks, if tx falls in this block
        // and the last returned block really is an aggregate one (size bigger than BITCOIN_BLOCKSIZE) we return -1
        if (mempoolBlockIndex + 1 === mempoolBlocks.length && mempoolBlocks[mempoolBlocks.length - 1].blockVSize > BITCOIN_BLOCKSIZE) return -1;
        return (mempoolBlockIndex + 1) * BITCOIN_BLOCKTIME;
    }
    /**
     * Returns an estimate after which time the tx will confirm with the required amount of confirmations,
     *  confirmationDelay of -1 means the transaction won't confirm in the near future
     *
     * @param tx
     * @param requiredConfirmations
     * @private
     *
     * @returns estimated confirmation delay, -1 if the transaction won't confirm in the near future, null if the
     *  transaction was replaced or was confirmed in the meantime
     */ async getConfirmationDelay(tx, requiredConfirmations) {
        if (tx.confirmations > requiredConfirmations) return 0;
        if (tx.confirmations === 0) {
            //Get CPFP data
            const cpfpData = await this.api.getCPFPData(tx.txid);
            if (cpfpData.effectiveFeePerVsize == null) {
                //Transaction is either confirmed in the meantime, or replaced
                return null;
            }
            let confirmationDelay = await this.getTimeTillConfirmation(cpfpData.effectiveFeePerVsize);
            if (confirmationDelay !== -1) confirmationDelay += (requiredConfirmations - 1) * BITCOIN_BLOCKTIME;
            return confirmationDelay;
        }
        return (requiredConfirmations - tx.confirmations) * BITCOIN_BLOCKTIME;
    }
    /**
     * Converts mempool API's transaction to BtcTx object
     * @param tx Transaction to convert
     * @param getRaw If the raw transaction field should be filled (requires one more network request)
     * @private
     */ async toBtcTx(tx) {
        let getRaw = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        var _tx_status, _tx_status1;
        const rawTx = !getRaw ? null : await this.api.getRawTransaction(tx.txid);
        let confirmations = 0;
        if (tx.status != null && tx.status.confirmed) {
            const blockheight = await this.api.getTipBlockHeight();
            confirmations = blockheight - tx.status.block_height + 1;
        }
        let strippedRawTx;
        if (rawTx != null) {
            //Strip witness data
            const btcTx = btc_signer_1.Transaction.fromRaw(rawTx, {
                allowLegacyWitnessUtxo: true,
                allowUnknownInputs: true,
                allowUnknownOutputs: true,
                disableScriptCheck: true
            });
            strippedRawTx = buffer_1.Buffer.from(btcTx.toBytes(true, false)).toString("hex");
        }
        return {
            locktime: tx.locktime,
            version: tx.version,
            blockheight: (_tx_status = tx.status) === null || _tx_status === void 0 ? void 0 : _tx_status.block_height,
            blockhash: (_tx_status1 = tx.status) === null || _tx_status1 === void 0 ? void 0 : _tx_status1.block_hash,
            confirmations,
            txid: tx.txid,
            vsize: tx.weight / 4,
            hex: strippedRawTx,
            raw: rawTx == null ? null : rawTx.toString("hex"),
            outs: tx.vout.map((e, index)=>{
                return {
                    value: e.value,
                    n: index,
                    scriptPubKey: {
                        hex: e.scriptpubkey,
                        asm: e.scriptpubkey_asm
                    }
                };
            }),
            ins: tx.vin.map((e)=>{
                return {
                    txid: e.txid,
                    vout: e.vout,
                    scriptSig: {
                        hex: e.scriptsig,
                        asm: e.scriptsig_asm
                    },
                    sequence: e.sequence,
                    txinwitness: e.witness
                };
            })
        };
    }
    getTipHeight() {
        return this.api.getTipBlockHeight();
    }
    async getBlockHeader(blockhash) {
        return new MempoolBitcoinBlock_1.MempoolBitcoinBlock(await this.api.getBlockHeader(blockhash));
    }
    async getMerkleProof(txId, blockhash) {
        const proof = await this.api.getTransactionProof(txId);
        return {
            reversedTxId: buffer_1.Buffer.from(txId, "hex").reverse(),
            pos: proof.pos,
            merkle: proof.merkle.map((e)=>buffer_1.Buffer.from(e, "hex").reverse()),
            blockheight: proof.block_height
        };
    }
    async getTransaction(txId) {
        const tx = await this.api.getTransaction(txId);
        if (tx == null) return null;
        return await this.toBtcTx(tx);
    }
    async isInMainChain(blockhash) {
        const blockStatus = await this.api.getBlockStatus(blockhash);
        return blockStatus.in_best_chain;
    }
    getBlockhash(height) {
        return this.api.getBlockHash(height);
    }
    getBlockWithTransactions(blockhash) {
        throw new Error("Unsupported.");
    }
    async getSyncInfo() {
        const tipHeight = await this.api.getTipBlockHeight();
        return {
            verificationProgress: 1,
            blocks: tipHeight,
            headers: tipHeight,
            ibd: false
        };
    }
    async getPast15Blocks(height) {
        return (await this.api.getPast15BlockHeaders(height)).map((blockHeader)=>new MempoolBitcoinBlock_1.MempoolBitcoinBlock(blockHeader));
    }
    async checkAddressTxos(address, txoHash) {
        const allTxs = await this.api.getAddressTransactions(address);
        const relevantTxs = allTxs.map((tx)=>{
            return {
                tx,
                vout: tx.vout.findIndex((vout)=>MempoolBitcoinRpc.getTxoHash(vout).equals(txoHash))
            };
        }).filter((obj)=>obj.vout >= 0).sort((a, b)=>{
            if (a.tx.status.confirmed && !b.tx.status.confirmed) return -1;
            if (!a.tx.status.confirmed && b.tx.status.confirmed) return 1;
            if (a.tx.status.confirmed && b.tx.status.confirmed) return a.tx.status.block_height - b.tx.status.block_height;
            return 0;
        });
        if (relevantTxs.length === 0) return null;
        return {
            tx: await this.toBtcTx(relevantTxs[0].tx, false),
            vout: relevantTxs[0].vout
        };
    }
    /**
     * Waits till the address receives a transaction containing a specific txoHash
     *
     * @param address
     * @param txoHash
     * @param requiredConfirmations
     * @param stateUpdateCbk
     * @param abortSignal
     * @param intervalSeconds
     */ async waitForAddressTxo(address, txoHash, requiredConfirmations, stateUpdateCbk, abortSignal, intervalSeconds) {
        if (abortSignal != null) abortSignal.throwIfAborted();
        while(abortSignal == null || !abortSignal.aborted){
            await (0, Utils_1.timeoutPromise)((intervalSeconds || 5) * 1000, abortSignal);
            const result = await this.checkAddressTxos(address, txoHash);
            if (result == null) {
                stateUpdateCbk(null, null, null, null);
                continue;
            }
            const confirmationDelay = await this.getConfirmationDelay(result.tx, requiredConfirmations);
            if (confirmationDelay == null) continue;
            if (stateUpdateCbk != null) stateUpdateCbk(result.tx.confirmations, result.tx.txid, result.vout, confirmationDelay);
            if (confirmationDelay === 0) return result;
        }
        abortSignal.throwIfAborted();
    }
    async waitForTransaction(txId, requiredConfirmations, stateUpdateCbk, abortSignal, intervalSeconds) {
        if (abortSignal != null) abortSignal.throwIfAborted();
        while(abortSignal == null || !abortSignal.aborted){
            await (0, Utils_1.timeoutPromise)((intervalSeconds || 5) * 1000, abortSignal);
            const result = await this.getTransaction(txId);
            if (result == null) {
                stateUpdateCbk(null, null, null);
                continue;
            }
            const confirmationDelay = await this.getConfirmationDelay(result, requiredConfirmations);
            if (confirmationDelay == null) continue;
            if (stateUpdateCbk != null) stateUpdateCbk(result.confirmations, result.txid, confirmationDelay);
            if (confirmationDelay === 0) return result;
        }
        abortSignal.throwIfAborted();
    }
    async getLNNodeLiquidity(pubkey) {
        const nodeInfo = await this.api.getLNNodeInfo(pubkey);
        return {
            publicKey: nodeInfo.public_key,
            capacity: BigInt(nodeInfo.capacity),
            numChannels: nodeInfo.active_channel_count
        };
    }
    sendRawTransaction(rawTx) {
        return this.api.sendTransaction(rawTx);
    }
    sendRawPackage(rawTx) {
        throw new Error("Unsupported");
    }
    async isSpent(utxo, confirmed) {
        const [txId, voutStr] = utxo.split(":");
        const vout = parseInt(voutStr);
        const outspends = await this.api.getOutspends(txId);
        if (outspends[vout] == null) return true;
        if (confirmed) {
            return outspends[vout].spent && outspends[vout].status.confirmed;
        }
        return outspends[vout].spent;
    }
    parseTransaction(rawTx) {
        const btcTx = btc_signer_1.Transaction.fromRaw(buffer_1.Buffer.from(rawTx, "hex"), {
            allowLegacyWitnessUtxo: true,
            allowUnknownInputs: true,
            allowUnknownOutputs: true,
            disableScriptCheck: true
        });
        return Promise.resolve(bitcoinTxToBtcTx(btcTx));
    }
    getEffectiveFeeRate(btcTx) {
        throw new Error("Unsupported.");
    }
    async getFeeRate() {
        return (await this.api.getFees()).fastestFee;
    }
    getAddressBalances(address) {
        return this.api.getAddressBalances(address);
    }
    async getAddressUTXOs(address) {
        return (await this.api.getAddressUTXOs(address)).map((val)=>({
                txid: val.txid,
                vout: val.vout,
                confirmed: val.status.confirmed,
                block_height: val.status.block_height,
                block_hash: val.status.block_hash,
                block_time: val.status.block_time,
                value: val.value
            }));
    }
    getCPFPData(txId) {
        return this.api.getCPFPData(txId);
    }
    constructor(urlOrMempoolApi){
        this.api = urlOrMempoolApi instanceof MempoolApi_1.MempoolApi ? urlOrMempoolApi : new MempoolApi_1.MempoolApi(urlOrMempoolApi);
    }
}
exports.MempoolBitcoinRpc = MempoolBitcoinRpc;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/BitcoinRpcWithAddressIndex.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/LightningNetworkApi.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/IBitcoinWallet.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isIBitcoinWallet = void 0;
function isIBitcoinWallet(val) {
    return val !== null && typeof val.sendTransaction === "function" && typeof val.fundPsbt === "function" && typeof val.signPsbt === "function" && typeof val.getFeeRate === "function" && typeof val.getTransactionFee === "function" && typeof val.getFundedPsbtFee === "function" && typeof val.getReceiveAddress === "function" && typeof val.getBalance === "function" && typeof val.getSpendableBalance === "function";
}
exports.isIBitcoinWallet = isIBitcoinWallet;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.utils = exports.DUST_THRESHOLDS = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("CoinSelect: ");
// baseline estimates, used to improve performance
const TX_EMPTY_SIZE = 4 + 1 + 1 + 4;
const TX_INPUT_BASE = 32 + 4 + 1 + 4;
const WITNESS_OVERHEAD = 2 / 4;
const P2WPKH_WITNESS = (1 + 1 + 72 + 1 + 33) / 4;
const P2TR_WITNESS = (1 + 1 + 65) / 4;
const TX_INPUT_PUBKEYHASH = 107;
const TX_INPUT_P2SH_P2WPKH = 23 + P2WPKH_WITNESS + 1;
const TX_INPUT_P2WPKH = 0 + P2WPKH_WITNESS;
const TX_INPUT_P2WSH = 0 + (1 + 1 + 64) / 4;
const TX_INPUT_P2TR = 0 + P2TR_WITNESS;
const TX_OUTPUT_BASE = 8 + 1;
const TX_OUTPUT_PUBKEYHASH = 25;
const TX_OUTPUT_P2SH_P2WPKH = 23;
const TX_OUTPUT_P2WPKH = 22;
const TX_OUTPUT_P2WSH = 34;
const TX_OUTPUT_P2TR = 34;
const INPUT_BYTES = {
    "p2sh-p2wpkh": TX_INPUT_P2SH_P2WPKH,
    "p2wpkh": TX_INPUT_P2WPKH,
    "p2tr": TX_INPUT_P2TR,
    "p2pkh": TX_INPUT_PUBKEYHASH,
    "p2wsh": TX_INPUT_P2WSH
};
function inputBytes(input) {
    return TX_INPUT_BASE + (input.script ? input.script.length : INPUT_BYTES[input.type]);
}
const OUTPUT_BYTES = {
    "p2sh-p2wpkh": TX_OUTPUT_P2SH_P2WPKH,
    "p2wpkh": TX_OUTPUT_P2WPKH,
    "p2tr": TX_OUTPUT_P2TR,
    "p2pkh": TX_OUTPUT_PUBKEYHASH,
    "p2wsh": TX_OUTPUT_P2WSH
};
function outputBytes(output) {
    return TX_OUTPUT_BASE + (output.script ? output.script.length : OUTPUT_BYTES[output.type]);
}
exports.DUST_THRESHOLDS = {
    "p2sh-p2wpkh": 540,
    "p2wpkh": 294,
    "p2tr": 330,
    "p2pkh": 546,
    "p2wsh": 330
};
function dustThreshold(output) {
    return exports.DUST_THRESHOLDS[output.type];
}
function transactionBytes(inputs, outputs, changeType) {
    let size = TX_EMPTY_SIZE;
    let isSegwit = false;
    if (changeType !== "p2pkh") {
        size += WITNESS_OVERHEAD;
        let isSegwit = true;
    }
    for (let input of inputs){
        if (!isSegwit && input.type !== "p2pkh") {
            isSegwit = true;
            size += WITNESS_OVERHEAD;
        }
        size += inputBytes(input);
    }
    for (let output of outputs){
        size += outputBytes(output);
    }
    return Math.ceil(size);
}
function uintOrNaN(v) {
    if (typeof v !== 'number') return NaN;
    if (!isFinite(v)) return NaN;
    if (Math.floor(v) !== v) return NaN;
    if (v < 0) return NaN;
    return v;
}
function sumForgiving(range) {
    return range.reduce((a, x)=>a + (isFinite(x.value) ? x.value : 0), 0);
}
function sumOrNaN(range) {
    return range.reduce((a, x)=>a + uintOrNaN(x.value), 0);
}
function finalize(inputs, outputs, feeRate, changeType) {
    let cpfpAddFee = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    const bytesAccum = transactionBytes(inputs, outputs, changeType);
    logger.debug("finalize(): Transaction bytes: ", bytesAccum);
    const feeAfterExtraOutput = feeRate * (bytesAccum + outputBytes({
        type: changeType
    })) + cpfpAddFee;
    logger.debug("finalize(): TX fee after adding change output: ", feeAfterExtraOutput);
    const remainderAfterExtraOutput = Math.floor(sumOrNaN(inputs) - (sumOrNaN(outputs) + feeAfterExtraOutput));
    logger.debug("finalize(): Leaves change (changeType=" + changeType + ") value: ", remainderAfterExtraOutput);
    // is it worth a change output?
    if (remainderAfterExtraOutput >= dustThreshold({
        type: changeType
    })) {
        outputs = outputs.concat({
            value: remainderAfterExtraOutput,
            type: changeType
        });
    }
    const fee = sumOrNaN(inputs) - sumOrNaN(outputs);
    logger.debug("finalize(): Re-calculated total fee: ", fee);
    if (!isFinite(fee)) return {
        fee: feeRate * bytesAccum + cpfpAddFee
    };
    return {
        inputs: inputs,
        outputs: outputs,
        fee: fee
    };
}
exports.utils = {
    dustThreshold: dustThreshold,
    finalize: finalize,
    inputBytes: inputBytes,
    outputBytes: outputBytes,
    sumOrNaN: sumOrNaN,
    sumForgiving: sumForgiving,
    transactionBytes: transactionBytes,
    uintOrNaN: uintOrNaN
};
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/accumulative.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.accumulative = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/utils.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("CoinSelect: ");
// add inputs until we reach or surpass the target value (or deplete)
// worst-case: O(n)
function accumulative(utxos, outputs, feeRate, type, requiredInputs) {
    if (!isFinite(utils_1.utils.uintOrNaN(feeRate))) return null;
    const inputs = requiredInputs == null ? [] : [
        ...requiredInputs
    ];
    let bytesAccum = utils_1.utils.transactionBytes(inputs, outputs, type);
    let fee = feeRate * bytesAccum;
    let cpfpAddFee = 0;
    let inAccum = utils_1.utils.sumOrNaN(inputs);
    const outAccum = utils_1.utils.sumOrNaN(outputs);
    logger.debug("accumulative(): total output: ", outAccum);
    for(let i = 0; i < utxos.length; ++i){
        const utxo = utxos[i];
        const utxoBytes = utils_1.utils.inputBytes(utxo);
        const utxoFee = feeRate * utxoBytes;
        const utxoValue = utils_1.utils.uintOrNaN(utxo.value);
        let cpfpFee = 0;
        if (utxo.cpfp != null && utxo.cpfp.txEffectiveFeeRate < feeRate) cpfpFee = Math.ceil(utxo.cpfp.txVsize * (feeRate - utxo.cpfp.txEffectiveFeeRate));
        // skip detrimental input
        if (utxoFee + cpfpFee > utxo.value) {
            logger.debug("accumulative(" + i + "): Skipping detrimental output, cpfpFee: " + cpfpFee + " utxoFee: " + utxoFee + " value: " + utxo.value);
            if (i === utxos.length - 1) return {
                fee: feeRate * (bytesAccum + utxoBytes) + cpfpAddFee + cpfpFee
            };
            continue;
        }
        bytesAccum += utxoBytes;
        inAccum += utxoValue;
        cpfpAddFee += cpfpFee;
        inputs.push(utxo);
        fee = Math.ceil(feeRate * bytesAccum + cpfpAddFee);
        logger.debug("accumulative(" + i + "): total fee: ", fee);
        logger.debug("accumulative(" + i + "): input value: ", inAccum);
        logger.debug("accumulative(" + i + "): cpfpAddFee: ", cpfpAddFee);
        // go again?
        if (inAccum < outAccum + fee) continue;
        logger.debug("accumulative(" + i + "): Finalizing transaction, inputs: ", inputs);
        logger.debug("accumulative(" + i + "): Finalizing transaction, outputs: ", outputs);
        logger.debug("accumulative(" + i + "): Finalizing transaction, feeRate: ", feeRate);
        return utils_1.utils.finalize(inputs, outputs, feeRate, type, cpfpAddFee);
    }
    return {
        fee
    };
}
exports.accumulative = accumulative;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/blackjack.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blackjack = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/utils.js [app-client] (ecmascript)");
// add inputs until we reach or surpass the target value (or deplete)
// worst-case: O(n)
function blackjack(utxos, outputs, feeRate, type, requiredInputs) {
    if (!isFinite(utils_1.utils.uintOrNaN(feeRate))) return null;
    const inputs = requiredInputs == null ? [] : [
        ...requiredInputs
    ];
    let bytesAccum = utils_1.utils.transactionBytes(inputs, outputs, type);
    let inAccum = utils_1.utils.sumOrNaN(inputs);
    let cpfpAddFee = 0;
    const outAccum = utils_1.utils.sumOrNaN(outputs);
    const threshold = utils_1.utils.dustThreshold({
        type
    });
    for(let i = 0; i < utxos.length; ++i){
        const input = utxos[i];
        const inputBytes = utils_1.utils.inputBytes(input);
        let cpfpFee = 0;
        if (input.cpfp != null && input.cpfp.txEffectiveFeeRate < feeRate) cpfpFee = Math.ceil(input.cpfp.txVsize * (feeRate - input.cpfp.txEffectiveFeeRate));
        const fee = Math.ceil(feeRate * (bytesAccum + inputBytes) + cpfpAddFee + cpfpFee);
        const inputValue = utils_1.utils.uintOrNaN(input.value);
        // would it waste value?
        if (inAccum + inputValue > outAccum + fee + threshold) continue;
        bytesAccum += inputBytes;
        inAccum += inputValue;
        cpfpAddFee += cpfpFee;
        inputs.push(input);
        // go again?
        if (inAccum < outAccum + fee) continue;
        return utils_1.utils.finalize(inputs, outputs, feeRate, type, cpfpAddFee);
    }
    return {
        fee: feeRate * bytesAccum + cpfpAddFee
    };
}
exports.blackjack = blackjack;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.maxSendable = exports.coinSelect = exports.DUST_THRESHOLDS = void 0;
const accumulative_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/accumulative.js [app-client] (ecmascript)");
const blackjack_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/blackjack.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/utils.js [app-client] (ecmascript)");
Object.defineProperty(exports, "DUST_THRESHOLDS", {
    enumerable: true,
    get: function() {
        return utils_1.DUST_THRESHOLDS;
    }
});
// order by descending value, minus the inputs approximate fee
function utxoScore(x, feeRate) {
    let valueAfterFee = x.value - feeRate * utils_1.utils.inputBytes(x);
    if (x.cpfp != null && x.cpfp.txEffectiveFeeRate < feeRate) valueAfterFee -= x.cpfp.txVsize * (feeRate - x.cpfp.txEffectiveFeeRate);
    return valueAfterFee;
}
function coinSelect(utxos, outputs, feeRate, type, requiredInputs) {
    // order by descending value, minus the inputs approximate fee
    utxos = utxos.sort((a, b)=>{
        // if(a.cpfp!=null && b.cpfp==null) return 1;
        // if(a.cpfp==null && b.cpfp!=null) return -1;
        return utxoScore(b, feeRate) - utxoScore(a, feeRate);
    });
    // attempt to use the blackjack strategy first (no change output)
    const base = (0, blackjack_1.blackjack)(utxos, outputs, feeRate, type, requiredInputs);
    if (base.inputs) return base;
    // else, try the accumulative strategy
    return (0, accumulative_1.accumulative)(utxos, outputs, feeRate, type, requiredInputs);
}
exports.coinSelect = coinSelect;
function maxSendable(utxos, output, feeRate, requiredInputs, additionalOutputs) {
    if (!isFinite(utils_1.utils.uintOrNaN(feeRate))) return null;
    const outputs = additionalOutputs !== null && additionalOutputs !== void 0 ? additionalOutputs : [];
    const inputs = requiredInputs !== null && requiredInputs !== void 0 ? requiredInputs : [];
    let bytesAccum = utils_1.utils.transactionBytes(inputs, outputs.concat([
        output
    ]), null);
    let cpfpAddFee = 0;
    let inAccum = utils_1.utils.sumOrNaN(inputs);
    let outAccum = utils_1.utils.sumOrNaN(outputs);
    for(let i = 0; i < utxos.length; ++i){
        const utxo = utxos[i];
        const utxoBytes = utils_1.utils.inputBytes(utxo);
        const utxoFee = feeRate * utxoBytes;
        let cpfpFee = 0;
        if (utxo.cpfp != null && utxo.cpfp.txEffectiveFeeRate < feeRate) cpfpFee = utxo.cpfp.txVsize * (feeRate - utxo.cpfp.txEffectiveFeeRate);
        const utxoValue = utils_1.utils.uintOrNaN(utxo.value);
        // skip detrimental input
        if (utxoFee + cpfpFee > utxo.value) {
            continue;
        }
        bytesAccum += utxoBytes;
        inAccum += utxoValue;
        cpfpAddFee += cpfpFee;
        inputs.push(utxo);
    }
    const fee = feeRate * bytesAccum + cpfpAddFee;
    const outputValue = inAccum - fee - outAccum;
    const dustThreshold = utils_1.DUST_THRESHOLDS[output.type];
    if (outputValue < dustThreshold) return {
        fee,
        value: 0
    };
    return {
        fee,
        value: outputValue
    };
}
exports.maxSendable = maxSendable;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/BitcoinWallet.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BitcoinWallet = exports.identifyAddressType = void 0;
const coinselect2_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/index.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
function identifyAddressType(address, network) {
    switch((0, btc_signer_1.Address)(network).decode(address).type){
        case "pkh":
            return "p2pkh";
        case "wpkh":
            return "p2wpkh";
        case "tr":
            return "p2tr";
        case "sh":
            return "p2sh-p2wpkh";
        case "wsh":
            return "p2wsh";
        default:
            return null;
    }
}
exports.identifyAddressType = identifyAddressType;
const logger = (0, Utils_1.getLogger)("BitcoinWallet: ");
class BitcoinWallet {
    async getFeeRate() {
        if (this.feeOverride != null) {
            return this.feeOverride;
        }
        return Math.floor(await this.rpc.getFeeRate() * this.feeMultiplier);
    }
    _sendTransaction(rawHex) {
        return this.rpc.sendRawTransaction(rawHex);
    }
    _getBalance(address) {
        return this.rpc.getAddressBalances(address);
    }
    async _getUtxoPool(sendingAddress, sendingAddressType) {
        const utxos = await this.rpc.getAddressUTXOs(sendingAddress);
        let totalSpendable = 0;
        const outputScript = (0, Utils_1.toOutputScript)(this.network, sendingAddress);
        const utxoPool = [];
        for (let utxo of utxos){
            const value = Number(utxo.value);
            totalSpendable += value;
            utxoPool.push({
                vout: utxo.vout,
                txId: utxo.txid,
                value: value,
                type: sendingAddressType,
                outputScript: outputScript,
                address: sendingAddress,
                cpfp: !utxo.confirmed ? await this.rpc.getCPFPData(utxo.txid).then((result)=>{
                    if (result.effectiveFeePerVsize == null) return null;
                    return {
                        txVsize: result.adjustedVsize,
                        txEffectiveFeeRate: result.effectiveFeePerVsize
                    };
                }) : null,
                confirmed: utxo.confirmed
            });
        }
        logger.debug("_getUtxoPool(): Total spendable value: " + totalSpendable + " num utxos: " + utxoPool.length);
        return utxoPool;
    }
    async _getPsbt(sendingAccounts, recipient, amount, feeRate) {
        const psbt = new btc_signer_1.Transaction({
            PSBTVersion: 0
        });
        psbt.addOutput({
            amount: BigInt(amount),
            script: (0, Utils_1.toOutputScript)(this.network, recipient)
        });
        return this._fundPsbt(sendingAccounts, psbt, feeRate);
    }
    async _fundPsbt(sendingAccounts, psbt, feeRate) {
        if (feeRate == null) feeRate = await this.getFeeRate();
        const utxoPool = (await Promise.all(sendingAccounts.map((acc)=>this._getUtxoPool(acc.address, acc.addressType)))).flat();
        logger.debug("_fundPsbt(): fee rate: " + feeRate + " utxo pool: ", utxoPool);
        const accountPubkeys = {};
        sendingAccounts.forEach((acc)=>accountPubkeys[acc.address] = acc.pubkey);
        const requiredInputs = [];
        for(let i = 0; i < psbt.inputsLength; i++){
            const input = psbt.getInput(i);
            let amount = input.witnessUtxo != null ? input.witnessUtxo.amount : input.nonWitnessUtxo.outputs[input.index].amount;
            let script = input.witnessUtxo != null ? input.witnessUtxo.script : input.nonWitnessUtxo.outputs[input.index].script;
            requiredInputs.push({
                txId: buffer_1.Buffer.from(input.txid).toString('hex'),
                vout: input.index,
                value: Number(amount),
                type: (0, Utils_1.toCoinselectAddressType)(script)
            });
        }
        const targets = [];
        for(let i = 0; i < psbt.outputsLength; i++){
            const output = psbt.getOutput(i);
            targets.push({
                value: Number(output.amount),
                script: buffer_1.Buffer.from(output.script)
            });
        }
        logger.debug("_fundPsbt(): Coinselect targets: ", targets);
        let coinselectResult = (0, coinselect2_1.coinSelect)(utxoPool, targets, feeRate, sendingAccounts[0].addressType, requiredInputs);
        logger.debug("_fundPsbt(): Coinselect result: ", coinselectResult);
        if (coinselectResult.inputs == null || coinselectResult.outputs == null) {
            return {
                psbt: null,
                fee: coinselectResult.fee,
                inputAddressIndexes: null
            };
        }
        // Remove in/outs that are already in the PSBT
        coinselectResult.inputs.splice(0, psbt.inputsLength);
        coinselectResult.outputs.splice(0, psbt.outputsLength);
        const inputAddressIndexes = {};
        coinselectResult.inputs.forEach((input, index)=>{
            var _inputAddressIndexes, _input_address;
            var _;
            (_ = (_inputAddressIndexes = inputAddressIndexes)[_input_address = input.address]) !== null && _ !== void 0 ? _ : _inputAddressIndexes[_input_address] = [];
            inputAddressIndexes[input.address].push(index);
        });
        const formattedInputs = await Promise.all(coinselectResult.inputs.map(async (input)=>{
            switch(input.type){
                case "p2tr":
                    const parsed = (0, btc_signer_1.p2tr)(buffer_1.Buffer.from(accountPubkeys[input.address], "hex"));
                    return {
                        txid: input.txId,
                        index: input.vout,
                        witnessUtxo: {
                            script: input.outputScript,
                            amount: BigInt(input.value)
                        },
                        tapInternalKey: parsed.tapInternalKey,
                        tapMerkleRoot: parsed.tapMerkleRoot,
                        tapLeafScript: parsed.tapLeafScript
                    };
                case "p2wpkh":
                    return {
                        txid: input.txId,
                        index: input.vout,
                        witnessUtxo: {
                            script: input.outputScript,
                            amount: BigInt(input.value)
                        },
                        sighashType: 0x01
                    };
                case "p2sh-p2wpkh":
                    return {
                        txid: input.txId,
                        index: input.vout,
                        witnessUtxo: {
                            script: input.outputScript,
                            amount: BigInt(input.value)
                        },
                        redeemScript: (0, btc_signer_1.p2wpkh)(buffer_1.Buffer.from(accountPubkeys[input.address], "hex"), this.network).script,
                        sighashType: 0x01
                    };
                case "p2pkh":
                    return {
                        txid: input.txId,
                        index: input.vout,
                        nonWitnessUtxo: (await this.rpc.getTransaction(input.txId)).raw,
                        sighashType: 0x01
                    };
            }
        }));
        formattedInputs.forEach((input)=>psbt.addInput(input));
        coinselectResult.outputs.forEach((output)=>{
            if (output.script == null && output.address == null) {
                //Change output
                psbt.addOutput({
                    script: (0, Utils_1.toOutputScript)(this.network, sendingAccounts[0].address),
                    amount: BigInt(Math.floor(output.value))
                });
            } else {
                var _output_script;
                psbt.addOutput({
                    script: (_output_script = output.script) !== null && _output_script !== void 0 ? _output_script : (0, Utils_1.toOutputScript)(this.network, output.address),
                    amount: BigInt(output.value)
                });
            }
        });
        return {
            psbt,
            fee: coinselectResult.fee,
            inputAddressIndexes
        };
    }
    async _getSpendableBalance(sendingAccounts, psbt, feeRate) {
        feeRate !== null && feeRate !== void 0 ? feeRate : feeRate = await this.getFeeRate();
        const utxoPool = (await Promise.all(sendingAccounts.map((acc)=>this._getUtxoPool(acc.address, acc.addressType)))).flat();
        const requiredInputs = [];
        if (psbt != null) for(let i = 0; i < psbt.inputsLength; i++){
            const input = psbt.getInput(i);
            let amount = input.witnessUtxo != null ? input.witnessUtxo.amount : input.nonWitnessUtxo.outputs[input.index].amount;
            let script = input.witnessUtxo != null ? input.witnessUtxo.script : input.nonWitnessUtxo.outputs[input.index].script;
            requiredInputs.push({
                txId: buffer_1.Buffer.from(input.txid).toString('hex'),
                vout: input.index,
                value: Number(amount),
                type: (0, Utils_1.toCoinselectAddressType)(script)
            });
        }
        const additionalOutputs = [];
        if (psbt != null) for(let i = 0; i < psbt.outputsLength; i++){
            const output = psbt.getOutput(i);
            additionalOutputs.push({
                value: Number(output.amount),
                script: buffer_1.Buffer.from(output.script)
            });
        }
        const target = btc_signer_1.OutScript.encode({
            type: "wsh",
            hash: (0, Utils_1.randomBytes)(32)
        });
        let coinselectResult = (0, coinselect2_1.maxSendable)(utxoPool, {
            script: buffer_1.Buffer.from(target),
            type: "p2wsh"
        }, feeRate, requiredInputs, additionalOutputs);
        logger.debug("_getSpendableBalance(): Max spendable result: ", coinselectResult);
        return {
            feeRate: feeRate,
            balance: BigInt(Math.floor(coinselectResult.value)),
            totalFee: coinselectResult.fee
        };
    }
    constructor(mempoolApi, network, feeMultiplier = 1.25, feeOverride){
        this.rpc = mempoolApi;
        this.network = network;
        this.feeMultiplier = feeMultiplier;
        this.feeOverride = feeOverride;
    }
}
exports.BitcoinWallet = BitcoinWallet;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/SingleAddressBitcoinWallet.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SingleAddressBitcoinWallet = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const BitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/BitcoinWallet.js [app-client] (ecmascript)");
class SingleAddressBitcoinWallet extends BitcoinWallet_1.BitcoinWallet {
    toBitcoinWalletAccounts() {
        return [
            {
                pubkey: buffer_1.Buffer.from(this.pubkey).toString("hex"),
                address: this.address,
                addressType: this.addressType
            }
        ];
    }
    async sendTransaction(address, amount, feeRate) {
        if (!this.privKey) throw new Error("Not supported.");
        const { psbt } = await super._getPsbt(this.toBitcoinWalletAccounts(), address, Number(amount), feeRate);
        psbt.sign(this.privKey);
        psbt.finalize();
        const txHex = buffer_1.Buffer.from(psbt.extract()).toString("hex");
        return await super._sendTransaction(txHex);
    }
    async fundPsbt(inputPsbt, feeRate) {
        const { psbt } = await super._fundPsbt(this.toBitcoinWalletAccounts(), inputPsbt, feeRate);
        if (psbt == null) {
            throw new Error("Not enough balance!");
        }
        return psbt;
    }
    async signPsbt(psbt, signInputs) {
        if (!this.privKey) throw new Error("Not supported.");
        for (let signInput of signInputs){
            psbt.signIdx(this.privKey, signInput);
        }
        return psbt;
    }
    async getTransactionFee(address, amount, feeRate) {
        const { psbt, fee } = await super._getPsbt(this.toBitcoinWalletAccounts(), address, Number(amount), feeRate);
        if (psbt == null) return null;
        return fee;
    }
    async getFundedPsbtFee(basePsbt, feeRate) {
        const { psbt, fee } = await super._fundPsbt(this.toBitcoinWalletAccounts(), basePsbt, feeRate);
        if (psbt == null) return null;
        return fee;
    }
    getReceiveAddress() {
        return this.address;
    }
    getBalance() {
        return this._getBalance(this.address);
    }
    getSpendableBalance(psbt, feeRate) {
        return this._getSpendableBalance([
            {
                address: this.address,
                addressType: this.addressType
            }
        ], psbt, feeRate);
    }
    static generateRandomPrivateKey(network) {
        return (0, btc_signer_1.WIF)(network).encode((0, utils_1.randomPrivateKeyBytes)());
    }
    constructor(mempoolApi, network, addressDataOrWIF, feeMultiplier = 1.25, feeOverride){
        super(mempoolApi, network, feeMultiplier, feeOverride);
        if (typeof addressDataOrWIF === "string") {
            try {
                this.privKey = (0, btc_signer_1.WIF)(network).decode(addressDataOrWIF);
            } catch (e) {
                this.privKey = (0, btc_signer_1.WIF)().decode(addressDataOrWIF);
            }
            this.pubkey = (0, utils_1.pubECDSA)(this.privKey);
            this.address = (0, btc_signer_1.getAddress)("wpkh", this.privKey, network);
        } else {
            this.address = addressDataOrWIF.address;
            this.pubkey = buffer_1.Buffer.from(addressDataOrWIF.publicKey, "hex");
        }
        this.addressType = (0, BitcoinWallet_1.identifyAddressType)(this.address, network);
    }
}
exports.SingleAddressBitcoinWallet = SingleAddressBitcoinWallet;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntermediaryError = void 0;
/**
 * An error or inconsistency in the intermediary's returned data, this will blacklist the intermediary
 */ class IntermediaryError extends Error {
    constructor(msg){
        super(msg);
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, IntermediaryError.prototype);
    }
}
exports.IntermediaryError = IntermediaryError;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/PaymentAuthError.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PaymentAuthError = void 0;
/**
 * An error when the payment authorization returned by the intermediary is invalid
 */ class PaymentAuthError extends Error {
    getCode() {
        return this.code;
    }
    getData() {
        return this.data;
    }
    constructor(msg, code, data){
        super(msg);
        this.data = data;
        this.code = code;
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, PaymentAuthError.prototype);
    }
}
exports.PaymentAuthError = PaymentAuthError;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/UserError.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UserError = void 0;
/**
 * An error on the user side, such as invalid address provided
 */ class UserError extends Error {
    constructor(msg){
        super(msg);
        // Set the prototype explicitly.
        Object.setPrototypeOf(this, UserError.prototype);
    }
}
exports.UserError = UserError;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SwapType = void 0;
var SwapType;
(function(SwapType) {
    SwapType[SwapType["FROM_BTC"] = 0] = "FROM_BTC";
    SwapType[SwapType["FROM_BTCLN"] = 1] = "FROM_BTCLN";
    SwapType[SwapType["TO_BTC"] = 2] = "TO_BTC";
    SwapType[SwapType["TO_BTCLN"] = 3] = "TO_BTCLN";
    SwapType[SwapType["TRUSTED_FROM_BTC"] = 4] = "TRUSTED_FROM_BTC";
    SwapType[SwapType["TRUSTED_FROM_BTCLN"] = 5] = "TRUSTED_FROM_BTCLN";
    SwapType[SwapType["SPV_VAULT_FROM_BTC"] = 6] = "SPV_VAULT_FROM_BTC";
})(SwapType = exports.SwapType || (exports.SwapType = {}));
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/Intermediary.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Intermediary = void 0;
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class Intermediary {
    getSwapLimits(swapType, chainId, tokenAddress) {
        var _this_swapBounds_swapType_chainId, _this_swapBounds_swapType;
        return (_this_swapBounds_swapType = this.swapBounds[swapType]) === null || _this_swapBounds_swapType === void 0 ? void 0 : (_this_swapBounds_swapType_chainId = _this_swapBounds_swapType[chainId]) === null || _this_swapBounds_swapType_chainId === void 0 ? void 0 : _this_swapBounds_swapType_chainId[tokenAddress];
    }
    /**
     * Returns tokens supported by the intermediary, optionally constrained to the specific swap types
     *
     * @param chainIdentifier
     * @param swapTypesArr
     * @private
     */ getSupportedTokens(chainIdentifier) {
        let swapTypesArr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
            SwapType_1.SwapType.TO_BTC,
            SwapType_1.SwapType.TO_BTCLN,
            SwapType_1.SwapType.FROM_BTC,
            SwapType_1.SwapType.FROM_BTCLN,
            SwapType_1.SwapType.SPV_VAULT_FROM_BTC
        ];
        const swapTypes = new Set(swapTypesArr);
        let tokens = new Set();
        swapTypes.forEach((swapType)=>{
            if (this.services[swapType] != null && this.services[swapType].chainTokens != null && this.services[swapType].chainTokens[chainIdentifier] != null) this.services[swapType].chainTokens[chainIdentifier].forEach((token)=>tokens.add(token));
        });
        return tokens;
    }
    /**
     * Fetches, returns and saves the reputation of the intermediary, either for all or just for a single token
     *
     * @param chainIdentifier
     * @param swapContract
     * @param tokens
     * @param abortSignal
     */ async getReputation(chainIdentifier, swapContract, tokens, abortSignal) {
        var _this_reputation, _chainIdentifier;
        const checkReputationTokens = tokens == null ? this.getSupportedTokens(chainIdentifier, [
            SwapType_1.SwapType.TO_BTC,
            SwapType_1.SwapType.TO_BTCLN
        ]) : new Set(tokens);
        const promises = [];
        const reputation = {};
        for (let token of checkReputationTokens){
            promises.push((0, Utils_1.tryWithRetries)(()=>swapContract.getIntermediaryReputation(this.getAddress(chainIdentifier), token), null, null, abortSignal).then((result)=>{
                reputation[token] = result;
            }));
        }
        await Promise.all(promises);
        var _this_reputation1;
        (_this_reputation1 = this.reputation) !== null && _this_reputation1 !== void 0 ? _this_reputation1 : this.reputation = {};
        var _;
        (_ = (_this_reputation = this.reputation)[_chainIdentifier = chainIdentifier]) !== null && _ !== void 0 ? _ : _this_reputation[_chainIdentifier] = {};
        for(let key in reputation){
            this.reputation[chainIdentifier][key] = reputation[key];
        }
        return reputation;
    }
    /**
     * Fetches, returns and saves the liquidity of the intermediaryfor a specific token
     *
     * @param chainIdentifier
     * @param swapContract
     * @param token
     * @param abortSignal
     */ async getLiquidity(chainIdentifier, swapContract, token, abortSignal) {
        var _this_liquidity, _chainIdentifier;
        const result = await (0, Utils_1.tryWithRetries)(()=>swapContract.getBalance(this.getAddress(chainIdentifier), token, true), null, null, abortSignal);
        var _this_liquidity1;
        (_this_liquidity1 = this.liquidity) !== null && _this_liquidity1 !== void 0 ? _this_liquidity1 : this.liquidity = {};
        var _;
        (_ = (_this_liquidity = this.liquidity)[_chainIdentifier = chainIdentifier]) !== null && _ !== void 0 ? _ : _this_liquidity[_chainIdentifier] = {};
        this.liquidity[chainIdentifier][token] = result;
        return result;
    }
    supportsChain(chainIdentifier) {
        if (this.addresses[chainIdentifier] == null) return false;
        return this.getSupportedTokens(chainIdentifier).size !== 0;
    }
    getAddress(chainIdentifier) {
        return this.addresses[chainIdentifier];
    }
    constructor(url, addresses, services, reputation = {}){
        this.reputation = {};
        this.liquidity = {};
        this.url = url;
        this.addresses = addresses;
        this.services = services;
        this.reputation = reputation;
        this.swapBounds = {};
        for(let _swapType in this.services){
            const swapType = parseInt(_swapType);
            const serviceInfo = this.services[_swapType];
            const btcBounds = {
                min: BigInt(serviceInfo.min),
                max: BigInt(serviceInfo.max)
            };
            const isSend = swapType === SwapType_1.SwapType.TO_BTC || swapType === SwapType_1.SwapType.TO_BTCLN;
            this.swapBounds[swapType] = {};
            for(let chainIdentifier in serviceInfo.chainTokens){
                this.swapBounds[swapType][chainIdentifier] = {};
                for (let tokenAddress of serviceInfo.chainTokens[chainIdentifier]){
                    this.swapBounds[swapType][chainIdentifier][tokenAddress] = {
                        input: isSend ? {
                            min: null,
                            max: null
                        } : btcBounds,
                        output: !isSend ? {
                            min: null,
                            max: null
                        } : btcBounds
                    };
                }
            }
        }
    }
}
exports.Intermediary = Intermediary;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/SchemaVerifier.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySchema = exports.verifyField = exports.isOptionalField = exports.FieldTypeEnum = exports.parseBigInt = void 0;
function parseBigInt(str) {
    if (str == null) return null;
    if (typeof str !== "string" && typeof str !== "number") return null;
    try {
        return BigInt(str);
    } catch (e) {
        return null;
    }
}
exports.parseBigInt = parseBigInt;
var FieldTypeEnum;
(function(FieldTypeEnum) {
    FieldTypeEnum[FieldTypeEnum["String"] = 0] = "String";
    FieldTypeEnum[FieldTypeEnum["Boolean"] = 1] = "Boolean";
    FieldTypeEnum[FieldTypeEnum["Number"] = 2] = "Number";
    FieldTypeEnum[FieldTypeEnum["BigInt"] = 3] = "BigInt";
    FieldTypeEnum[FieldTypeEnum["Any"] = 4] = "Any";
    FieldTypeEnum[FieldTypeEnum["StringOptional"] = 100] = "StringOptional";
    FieldTypeEnum[FieldTypeEnum["BooleanOptional"] = 101] = "BooleanOptional";
    FieldTypeEnum[FieldTypeEnum["NumberOptional"] = 102] = "NumberOptional";
    FieldTypeEnum[FieldTypeEnum["BigIntOptional"] = 103] = "BigIntOptional";
    FieldTypeEnum[FieldTypeEnum["AnyOptional"] = 104] = "AnyOptional";
})(FieldTypeEnum = exports.FieldTypeEnum || (exports.FieldTypeEnum = {}));
function isAllOptional(schema) {
    for(let key in schema){
        if (!isOptionalField(schema[key])) return false;
    }
    return true;
}
function isOptionalField(type) {
    if (typeof type === "function") return type(undefined) != null;
    if (typeof type === "object") return isAllOptional(type);
    return type >= 100;
}
exports.isOptionalField = isOptionalField;
function verifyField(fieldType, val) {
    const type = fieldType;
    if (typeof type === "function") {
        const result = type(val);
        if (result == null) return;
        return result;
    }
    if (val == null && isOptionalField(type)) {
        return null;
    }
    if (type === FieldTypeEnum.Any || type === FieldTypeEnum.AnyOptional) {
        return val;
    } else if (type === FieldTypeEnum.Boolean || type === FieldTypeEnum.BooleanOptional) {
        if (typeof val !== "boolean") return;
        return val;
    } else if (type === FieldTypeEnum.Number || type === FieldTypeEnum.NumberOptional) {
        if (typeof val !== "number") return;
        if (isNaN(val)) return;
        return val;
    } else if (type === FieldTypeEnum.BigInt || type === FieldTypeEnum.BigIntOptional) {
        const result = parseBigInt(val);
        if (result == null) return;
        return result;
    } else if (type === FieldTypeEnum.String || type === FieldTypeEnum.StringOptional) {
        if (typeof val !== "string") return;
        return val;
    } else {
        //Probably another request schema
        const result = verifySchema(val, type);
        if (result == null) return;
        return result;
    }
}
exports.verifyField = verifyField;
function verifySchema(req, schema) {
    if (req == null) return null;
    const resultSchema = {};
    for(let fieldName in schema){
        const val = req[fieldName];
        const type = schema[fieldName];
        if (typeof type === "function") {
            const result = type(val);
            if (result == null) return null;
            resultSchema[fieldName] = result;
            continue;
        }
        if (val == null && isOptionalField(type)) {
            resultSchema[fieldName] = null;
            continue;
        }
        if (type === FieldTypeEnum.Any || type === FieldTypeEnum.AnyOptional) {
            resultSchema[fieldName] = val;
        } else if (type === FieldTypeEnum.Boolean || type === FieldTypeEnum.BooleanOptional) {
            if (typeof val !== "boolean") return null;
            resultSchema[fieldName] = val;
        } else if (type === FieldTypeEnum.Number || type === FieldTypeEnum.NumberOptional) {
            if (typeof val !== "number") return null;
            if (isNaN(val)) return null;
            resultSchema[fieldName] = val;
        } else if (type === FieldTypeEnum.BigInt || type === FieldTypeEnum.BigIntOptional) {
            const result = parseBigInt(val);
            if (result == null) return null;
            resultSchema[fieldName] = result;
        } else if (type === FieldTypeEnum.String || type === FieldTypeEnum.StringOptional) {
            if (typeof val !== "string") return null;
            resultSchema[fieldName] = val;
        } else {
            //Probably another request schema
            const result = verifySchema(val, type);
            if (result == null) return null;
            resultSchema[fieldName] = result;
        }
    }
    return resultSchema;
}
exports.verifySchema = verifySchema;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/ParamEncoder.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParamEncoder = void 0;
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
class ParamEncoder {
    /**
     * Write a set of parameters to the underlying sink
     *
     * @param data
     */ writeParams(data) {
        const serialized = buffer_1.Buffer.from(JSON.stringify(data));
        const frameLengthBuffer = buffer_1.Buffer.alloc(4);
        frameLengthBuffer.writeUint32LE(serialized.length);
        return this.writeFN(buffer_1.Buffer.concat([
            frameLengthBuffer,
            serialized
        ]));
    }
    /**
     * Cancels the underlying sink and encoder
     */ end() {
        return this.endFN();
    }
    constructor(write, end){
        this.writeFN = write;
        this.endFN = end;
    }
}
exports.ParamEncoder = ParamEncoder;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/client/StreamParamEncoder.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StreamParamEncoder = void 0;
const ParamEncoder_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/ParamEncoder.js [app-client] (ecmascript)");
class StreamParamEncoder extends ParamEncoder_1.ParamEncoder {
    /**
     * Returns the readable stream to be passed to the fetch API
     */ getReadableStream() {
        return this.stream.readable;
    }
    constructor(){
        let stream = new TransformStream();
        let writeStream = stream.writable.getWriter();
        writeStream.closed.then(()=>this.closed = true);
        super(writeStream.write.bind(writeStream), ()=>{
            if (this.closed) return Promise.resolve();
            this.closed = true;
            return writeStream.close();
        });
        this.closed = false;
        this.stream = stream;
    }
}
exports.StreamParamEncoder = StreamParamEncoder;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/ParamDecoder.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParamDecoder = void 0;
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
class ParamDecoder {
    /**
     * Called when a frame is fully ready such that it can be parsed
     *
     * @param data Frame data
     * @private
     */ onFrameRead(data) {
        const obj = JSON.parse(data.toString());
        for(let key in obj){
            if (this.params[key] == null) {
                this.params[key] = {
                    promise: Promise.resolve(obj[key]),
                    resolve: null,
                    reject: null
                };
            } else {
                if (this.params[key].resolve != null) {
                    this.params[key].resolve(obj[key]);
                    this.params[key].resolve = null;
                    this.params[key].reject = null;
                }
            }
        }
    }
    /**
     * Called when data is read from the underlying source
     *
     * @param data Data that has been read from the underlying source
     * @protected
     */ onData(data) {
        let leavesBuffer = data;
        while(leavesBuffer != null && leavesBuffer.length > 0){
            if (this.frameHeader == null) {
                if (leavesBuffer.length <= 4) {
                    this.frameHeader = leavesBuffer;
                    leavesBuffer = null;
                } else {
                    this.frameHeader = leavesBuffer.subarray(0, 4);
                    leavesBuffer = leavesBuffer.subarray(4);
                }
            } else if (this.frameHeader.length < 4) {
                const requiredLen = 4 - this.frameHeader.length;
                if (leavesBuffer.length <= requiredLen) {
                    this.frameHeader = buffer_1.Buffer.concat([
                        this.frameHeader,
                        leavesBuffer
                    ]);
                    leavesBuffer = null;
                } else {
                    this.frameHeader = buffer_1.Buffer.concat([
                        this.frameHeader,
                        leavesBuffer.subarray(0, requiredLen)
                    ]);
                    leavesBuffer = leavesBuffer.subarray(requiredLen);
                }
            }
            if (leavesBuffer == null) continue;
            if (this.frameHeader == null || this.frameHeader.length < 4) continue;
            const frameLength = this.frameHeader.readUint32LE();
            const requiredLen = frameLength - this.frameDataLength;
            if (leavesBuffer.length <= requiredLen) {
                this.frameData.push(leavesBuffer);
                this.frameDataLength += leavesBuffer.length;
                leavesBuffer = null;
            } else {
                this.frameData.push(leavesBuffer.subarray(0, requiredLen));
                this.frameDataLength += requiredLen;
                leavesBuffer = leavesBuffer.subarray(requiredLen);
            }
            if (frameLength === this.frameDataLength) {
                //Message read success
                this.onFrameRead(buffer_1.Buffer.concat(this.frameData));
                this.frameHeader = null;
                this.frameData = [];
                this.frameDataLength = 0;
            }
        }
    }
    /**
     * Called when the underlying source ends/closes/cancels
     * @protected
     */ onEnd() {
        for(let key in this.params){
            if (this.params[key].reject != null) {
                this.params[key].reject(new Error("EOF before field seen!"));
            }
        }
        this.closed = true;
    }
    /**
     * Called when an error happens with the underlying stream
     *
     * @param e Error
     * @protected
     */ onError(e) {
        for(let key in this.params){
            if (this.params[key].reject != null) {
                this.params[key].reject(e);
            }
        }
        this.closed = true;
    }
    getParam(key) {
        if (this.params[key] == null) {
            if (this.closed) return Promise.reject(new Error("Stream already closed without param received!"));
            let resolve;
            let reject;
            const promise = new Promise((_resolve, _reject)=>{
                resolve = _resolve;
                reject = _reject;
            });
            this.params[key] = {
                resolve,
                reject,
                promise
            };
        }
        return this.params[key].promise;
    }
    constructor(){
        this.frameHeader = null;
        this.frameData = [];
        this.frameDataLength = 0;
        this.closed = false;
        this.params = {};
    }
}
exports.ParamDecoder = ParamDecoder;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/client/ResponseParamDecoder.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResponseParamDecoder = void 0;
const ParamDecoder_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/ParamDecoder.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("ResponseParamDecoder: ");
class ResponseParamDecoder extends ParamDecoder_1.ParamDecoder {
    /**
     * Keeps reading the response until the reader closes
     * @private
     */ async readResponse() {
        while(true){
            const readResp = await this.reader.read().catch((e)=>{
                logger.error("readResponse(): Error reading response: ", e);
                return null;
            });
            if (this.abortSignal != null && this.abortSignal.aborted) return;
            if (readResp == null || readResp.done) {
                super.onEnd();
                return;
            }
            super.onData(buffer_1.Buffer.from(readResp.value));
        }
    }
    constructor(resp, abortSignal){
        super();
        this.abortSignal = abortSignal;
        try {
            //Read from stream
            this.reader = resp.body.getReader();
            this.readResponse();
        } catch (e) {
            //Read in one piece
            resp.arrayBuffer().then((respBuffer)=>{
                super.onData(buffer_1.Buffer.from(respBuffer));
                super.onEnd();
            }).catch((e)=>{
                super.onError(e);
            });
        }
        if (abortSignal != null) abortSignal.addEventListener("abort", ()=>{
            super.onError(abortSignal.reason);
            if (!this.reader.closed) this.reader.cancel(abortSignal.reason);
        });
    }
}
exports.ResponseParamDecoder = ResponseParamDecoder;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/client/StreamingFetchPromise.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.streamingFetchPromise = void 0;
const SchemaVerifier_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/SchemaVerifier.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const StreamParamEncoder_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/client/StreamParamEncoder.js [app-client] (ecmascript)");
const ResponseParamDecoder_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/client/ResponseParamDecoder.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("StreamingFetch: ");
//https://developer.chrome.com/docs/capabilities/web-apis/fetch-streaming-requests#feature_detection
const supportsRequestStreams = (()=>{
    try {
        let duplexAccessed = false;
        const request = new Request('https://example.com/', {
            body: new ReadableStream(),
            method: 'POST',
            get duplex () {
                duplexAccessed = true;
                return 'half';
            }
        });
        const hasContentType = request.headers.has('Content-Type');
        return duplexAccessed && !hasContentType;
    } catch (e) {
        logger.error("supportsRequestStreams: Error checking environment support for HTTP request stream", e);
        return false;
    }
})();
logger.info("Environment supports request stream: " + supportsRequestStreams);
/**
 * Sends a POST request to the specified URL in a streaming request/response mode
 *
 * @param url URL to send the request to
 * @param body An object containing properties that should be sent to the server, can be Promise or any
 * @param schema Schema of the response that should be received from the server
 * @param timeout Timeout in millseconds for the request to succeed & all its response properties to resolve
 * @param signal Abort signal
 * @param streamRequest Whether the request should be streamed or not
 * @throws {RequestError} When the response code is not 200
 */ async function streamingFetchPromise(url, body, schema, timeout, signal, streamRequest) {
    if (streamRequest == null) streamRequest = supportsRequestStreams;
    if (timeout != null) signal = (0, Utils_1.timeoutSignal)(timeout, new Error("Network request timed out"), signal);
    const init = {
        method: "POST",
        headers: {}
    };
    const startTime = Date.now();
    const immediateValues = {};
    const promises = [];
    if (!streamRequest) {
        for(let key in body){
            if (body[key] instanceof Promise) {
                promises.push(body[key].then((val)=>{
                    immediateValues[key] = val;
                }));
            } else {
                immediateValues[key] = body[key];
            }
        }
        try {
            await Promise.all(promises);
        } catch (e) {
            e._inputPromiseError = true;
            throw e;
        }
        if (signal != null) signal.throwIfAborted();
        logger.debug(url + ": Sending request (" + (Date.now() - startTime) + "ms) (non-streaming): ", immediateValues);
        init.body = JSON.stringify(immediateValues);
        init.headers['content-type'] = "application/json";
    } else {
        const outputStream = new StreamParamEncoder_1.StreamParamEncoder();
        let hasPromiseInBody = false;
        for(let key in body){
            if (body[key] instanceof Promise) {
                promises.push(body[key].then((val)=>{
                    logger.debug(url + ": Send param (" + (Date.now() - startTime) + "ms) (streaming): ", {
                        [key]: val
                    });
                    return outputStream.writeParams({
                        [key]: val
                    });
                }));
                hasPromiseInBody = true;
            } else {
                immediateValues[key] = body[key];
            }
        }
        if (hasPromiseInBody) {
            init.body = outputStream.getReadableStream();
            init.headers['content-type'] = "application/x-multiple-json";
            init.duplex = "half";
            logger.debug(url + ": Sending request (" + (Date.now() - startTime) + "ms) (streaming): ", immediateValues);
            promises.push(outputStream.writeParams(immediateValues));
            const abortController = (0, Utils_1.extendAbortController)(signal);
            signal = abortController.signal;
            Promise.all(promises).then(()=>outputStream.end()).catch((e)=>{
                e._inputPromiseError = true;
                abortController.abort(e);
            });
            signal.addEventListener("abort", ()=>outputStream.end());
        } else {
            logger.debug(url + ": Sending request (" + (Date.now() - startTime) + "ms) (non-streaming): ", immediateValues);
            init.body = JSON.stringify(immediateValues);
            init.headers['content-type'] = "application/json";
        }
    }
    if (signal != null) init.signal = signal;
    init.headers['accept'] = "application/x-multiple-json";
    const resp = await fetch(url, init).catch((e)=>{
        if (init.signal != null && e.name === "AbortError") {
            throw init.signal.reason;
        } else {
            if (e.message != null) e.message += streamRequest ? " (streaming req)" : " (non streaming req)";
            throw e;
        }
    });
    logger.debug(url + ": Response status (" + (Date.now() - startTime) + "ms) " + (streamRequest ? "(streaming req)" : "(non streaming req)") + ": ", resp.status);
    if (resp.status !== 200) {
        let respTxt;
        try {
            respTxt = await resp.text();
        } catch (e) {
            throw new RequestError_1.RequestError(resp.statusText, resp.status);
        }
        throw new RequestError_1.RequestError(respTxt, resp.status);
    }
    if (resp.headers.get("content-type") !== "application/x-multiple-json") {
        const respBody = await resp.json();
        logger.debug(url + ": Response read (" + (Date.now() - startTime) + "ms) (non streaming resp): ", respBody);
        return (0, Utils_1.objectMap)(schema, (schemaValue, key)=>{
            const value = respBody[key];
            const result = (0, SchemaVerifier_1.verifyField)(schemaValue, value);
            if (result === undefined) {
                return Promise.reject(new Error("Invalid field value"));
            } else {
                return Promise.resolve(result);
            }
        });
    } else {
        const decoder = new ResponseParamDecoder_1.ResponseParamDecoder(resp, init.signal);
        return (0, Utils_1.objectMap)(schema, (schemaValue, key)=>decoder.getParam(key).catch((e)=>{
                if ((0, SchemaVerifier_1.isOptionalField)(schemaValue)) return undefined;
                throw e;
            }).then((value)=>{
                logger.debug(url + ": Response frame read (" + (Date.now() - startTime) + "ms) (streaming resp): ", {
                    [key]: value
                });
                const result = (0, SchemaVerifier_1.verifyField)(schemaValue, value);
                if (result === undefined) {
                    return Promise.reject(new Error("Invalid field value"));
                } else {
                    return result;
                }
            }));
    }
}
exports.streamingFetchPromise = streamingFetchPromise;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntermediaryAPI = exports.PaymentAuthorizationResponseCodes = exports.RefundAuthorizationResponseCodes = void 0;
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const SchemaVerifier_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/SchemaVerifier.js [app-client] (ecmascript)");
const StreamingFetchPromise_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/client/StreamingFetchPromise.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
var RefundAuthorizationResponseCodes;
(function(RefundAuthorizationResponseCodes) {
    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes["EXPIRED"] = 20010] = "EXPIRED";
    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes["REFUND_DATA"] = 20000] = "REFUND_DATA";
    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes["NOT_FOUND"] = 20007] = "NOT_FOUND";
    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes["PENDING"] = 20008] = "PENDING";
    RefundAuthorizationResponseCodes[RefundAuthorizationResponseCodes["PAID"] = 20006] = "PAID";
})(RefundAuthorizationResponseCodes = exports.RefundAuthorizationResponseCodes || (exports.RefundAuthorizationResponseCodes = {}));
var PaymentAuthorizationResponseCodes;
(function(PaymentAuthorizationResponseCodes) {
    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes["AUTH_DATA"] = 10000] = "AUTH_DATA";
    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes["EXPIRED"] = 10001] = "EXPIRED";
    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes["PAID"] = 10002] = "PAID";
    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes["PENDING"] = 10003] = "PENDING";
    PaymentAuthorizationResponseCodes[PaymentAuthorizationResponseCodes["ALREADY_COMMITTED"] = 10004] = "ALREADY_COMMITTED";
})(PaymentAuthorizationResponseCodes = exports.PaymentAuthorizationResponseCodes || (exports.PaymentAuthorizationResponseCodes = {}));
const SwapResponseSchema = {
    data: SchemaVerifier_1.FieldTypeEnum.Any,
    prefix: SchemaVerifier_1.FieldTypeEnum.String,
    timeout: SchemaVerifier_1.FieldTypeEnum.String,
    signature: SchemaVerifier_1.FieldTypeEnum.String
};
/////////////////////////
///// To BTC
const ToBTCResponseSchema = {
    amount: SchemaVerifier_1.FieldTypeEnum.BigInt,
    address: SchemaVerifier_1.FieldTypeEnum.String,
    satsPervByte: SchemaVerifier_1.FieldTypeEnum.BigInt,
    networkFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    totalFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    total: SchemaVerifier_1.FieldTypeEnum.BigInt,
    minRequiredExpiry: SchemaVerifier_1.FieldTypeEnum.BigInt,
    ...SwapResponseSchema
};
/////////////////////////
///// To BTCLN
const ToBTCLNResponseSchema = {
    maxFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    total: SchemaVerifier_1.FieldTypeEnum.BigInt,
    confidence: SchemaVerifier_1.FieldTypeEnum.Number,
    address: SchemaVerifier_1.FieldTypeEnum.String,
    routingFeeSats: SchemaVerifier_1.FieldTypeEnum.BigInt,
    ...SwapResponseSchema
};
const ToBTCLNPrepareExactInSchema = {
    amount: SchemaVerifier_1.FieldTypeEnum.BigInt,
    reqId: SchemaVerifier_1.FieldTypeEnum.String
};
/////////////////////////
///// From BTC
const FromBTCResponseSchema = {
    amount: SchemaVerifier_1.FieldTypeEnum.BigInt,
    btcAddress: SchemaVerifier_1.FieldTypeEnum.String,
    address: SchemaVerifier_1.FieldTypeEnum.String,
    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    total: SchemaVerifier_1.FieldTypeEnum.BigInt,
    confirmations: SchemaVerifier_1.FieldTypeEnum.NumberOptional,
    ...SwapResponseSchema
};
/////////////////////////
///// From BTCLN
const FromBTCLNResponseSchema = {
    pr: SchemaVerifier_1.FieldTypeEnum.String,
    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    total: SchemaVerifier_1.FieldTypeEnum.BigInt,
    intermediaryKey: SchemaVerifier_1.FieldTypeEnum.String,
    securityDeposit: SchemaVerifier_1.FieldTypeEnum.BigInt
};
/////////////////////////
///// Spv vault from BTC
const SpvFromBTCPrepareResponseSchema = {
    quoteId: SchemaVerifier_1.FieldTypeEnum.String,
    expiry: SchemaVerifier_1.FieldTypeEnum.Number,
    address: SchemaVerifier_1.FieldTypeEnum.String,
    vaultId: SchemaVerifier_1.FieldTypeEnum.BigInt,
    vaultBtcAddress: SchemaVerifier_1.FieldTypeEnum.String,
    btcAddress: SchemaVerifier_1.FieldTypeEnum.String,
    btcUtxo: SchemaVerifier_1.FieldTypeEnum.String,
    btcFeeRate: SchemaVerifier_1.FieldTypeEnum.Number,
    btcAmount: SchemaVerifier_1.FieldTypeEnum.BigInt,
    btcAmountSwap: SchemaVerifier_1.FieldTypeEnum.BigInt,
    btcAmountGas: SchemaVerifier_1.FieldTypeEnum.BigInt,
    total: SchemaVerifier_1.FieldTypeEnum.BigInt,
    totalGas: SchemaVerifier_1.FieldTypeEnum.BigInt,
    totalFeeBtc: SchemaVerifier_1.FieldTypeEnum.BigInt,
    swapFeeBtc: SchemaVerifier_1.FieldTypeEnum.BigInt,
    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    gasSwapFeeBtc: SchemaVerifier_1.FieldTypeEnum.BigInt,
    gasSwapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    callerFeeShare: SchemaVerifier_1.FieldTypeEnum.BigInt,
    frontingFeeShare: SchemaVerifier_1.FieldTypeEnum.BigInt,
    executionFeeShare: SchemaVerifier_1.FieldTypeEnum.BigInt
};
const SpvFromBTCInitResponseSchema = {
    txId: SchemaVerifier_1.FieldTypeEnum.String
};
class IntermediaryAPI {
    /**
     * Returns the information about a specific intermediary
     *
     * @param baseUrl Base URL of the intermediary
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     *
     * @throws {RequestError} If non-200 http response code is returned
     * @throws {Error} If the supplied nonce doesn't match the response
     */ static async getIntermediaryInfo(baseUrl, timeout, abortSignal) {
        const nonce = (0, Utils_1.randomBytes)(32).toString("hex");
        const response = await (0, Utils_1.httpPost)(baseUrl + "/info", {
            nonce
        }, timeout, abortSignal);
        const info = JSON.parse(response.envelope);
        if (nonce !== info.nonce) throw new Error("Invalid response - nonce");
        return response;
    }
    /**
     * Returns the information about an outcome of the To BTC swap
     *
     * @param url URL of the intermediary
     * @param paymentHash Payment hash of the swap
     * @param sequence Swap's sequence number
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static async getRefundAuthorization(url, paymentHash, sequence, timeout, abortSignal) {
        return (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(url + "/getRefundAuthorization" + "?paymentHash=" + encodeURIComponent(paymentHash) + "&sequence=" + encodeURIComponent(sequence.toString(10)), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);
    }
    /**
     * Returns the information about the payment of the From BTCLN swaps
     *
     * @param url URL of the intermediary
     * @param paymentHash Payment hash of the swap
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static async getPaymentAuthorization(url, paymentHash, timeout, abortSignal) {
        return (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(url + "/getInvoicePaymentAuth" + "?paymentHash=" + encodeURIComponent(paymentHash), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);
    }
    /**
     * Initiate To BTC swap with an intermediary
     *
     * @param chainIdentifier
     * @param baseUrl Base URL of the intermediary
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static initToBTC(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {
        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + "/tobtc/payInvoice?chain=" + encodeURIComponent(chainIdentifier), {
            ...init.additionalParams,
            address: init.btcAddress,
            amount: init.amount.toString(10),
            exactIn: init.exactIn,
            confirmationTarget: init.confirmationTarget,
            confirmations: init.confirmations,
            nonce: init.nonce.toString(10),
            token: init.token,
            offerer: init.offerer,
            feeRate: init.feeRate
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,
            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional
        }, timeout, abortSignal, streamRequest);
        return {
            signDataPrefetch: responseBodyPromise.then((responseBody)=>responseBody.signDataPrefetch),
            response: responseBodyPromise.then((responseBody)=>Promise.all([
                    responseBody.code,
                    responseBody.msg,
                    responseBody.data
                ])).then((param)=>{
                let [code, msg, data] = param;
                if (code !== 20000) {
                    throw RequestError_1.RequestError.parse(JSON.stringify({
                        code,
                        msg,
                        data
                    }), 400);
                }
                return (0, SchemaVerifier_1.verifySchema)(data, ToBTCResponseSchema);
            })
        };
    }
    /**
     * Initiate From BTC swap with an intermediary
     *
     * @param chainIdentifier
     * @param baseUrl Base URL of the intermediary
     * @param depositToken
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static initFromBTC(chainIdentifier, baseUrl, depositToken, init, timeout, abortSignal, streamRequest) {
        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + "/frombtc/getAddress?chain=" + encodeURIComponent(chainIdentifier) + "&depositToken=" + encodeURIComponent(depositToken), {
            ...init.additionalParams,
            address: init.claimer,
            amount: init.amount.toString(10),
            token: init.token,
            exactOut: init.exactOut,
            sequence: init.sequence.toString(10),
            claimerBounty: init.claimerBounty.then((claimerBounty)=>{
                return {
                    feePerBlock: claimerBounty.feePerBlock.toString(10),
                    safetyFactor: claimerBounty.safetyFactor,
                    startTimestamp: claimerBounty.startTimestamp.toString(10),
                    addBlock: claimerBounty.addBlock,
                    addFee: claimerBounty.addFee.toString(10)
                };
            }),
            feeRate: init.feeRate
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,
            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional
        }, timeout, abortSignal, streamRequest);
        return {
            signDataPrefetch: responseBodyPromise.then((responseBody)=>responseBody.signDataPrefetch),
            response: responseBodyPromise.then((responseBody)=>Promise.all([
                    responseBody.code,
                    responseBody.msg,
                    responseBody.data
                ])).then((param)=>{
                let [code, msg, data] = param;
                if (code !== 20000) {
                    throw RequestError_1.RequestError.parse(JSON.stringify({
                        code,
                        msg,
                        data
                    }), 400);
                }
                return (0, SchemaVerifier_1.verifySchema)(data, FromBTCResponseSchema);
            })
        };
    }
    /**
     * Initiate From BTCLN swap with an intermediary
     *
     * @param chainIdentifier
     * @param baseUrl Base URL of the intermediary
     * @param depositToken
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static initFromBTCLN(chainIdentifier, baseUrl, depositToken, init, timeout, abortSignal, streamRequest) {
        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + "/frombtcln/createInvoice?chain=" + encodeURIComponent(chainIdentifier) + "&depositToken=" + encodeURIComponent(depositToken), {
            ...init.additionalParams,
            paymentHash: init.paymentHash.toString("hex"),
            amount: init.amount.toString(),
            address: init.claimer,
            token: init.token,
            descriptionHash: init.descriptionHash == null ? null : init.descriptionHash.toString("hex"),
            exactOut: init.exactOut,
            feeRate: init.feeRate
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,
            lnPublicKey: SchemaVerifier_1.FieldTypeEnum.StringOptional
        }, timeout, abortSignal, streamRequest);
        return {
            lnPublicKey: responseBodyPromise.then((responseBody)=>responseBody.lnPublicKey),
            response: responseBodyPromise.then((responseBody)=>Promise.all([
                    responseBody.code,
                    responseBody.msg,
                    responseBody.data
                ])).then((param)=>{
                let [code, msg, data] = param;
                if (code !== 20000) {
                    throw RequestError_1.RequestError.parse(JSON.stringify({
                        code,
                        msg,
                        data
                    }), 400);
                }
                return (0, SchemaVerifier_1.verifySchema)(data, FromBTCLNResponseSchema);
            })
        };
    }
    /**
     * Initiate To BTCLN swap with an intermediary
     *
     * @param chainIdentifier
     * @param baseUrl Base URL of the intermediary
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static initToBTCLN(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {
        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + "/tobtcln/payInvoice?chain=" + encodeURIComponent(chainIdentifier), {
            exactIn: false,
            ...init.additionalParams,
            pr: init.pr,
            maxFee: init.maxFee.toString(10),
            expiryTimestamp: init.expiryTimestamp.toString(10),
            token: init.token,
            offerer: init.offerer,
            feeRate: init.feeRate,
            amount: null
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,
            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional
        }, timeout, abortSignal, streamRequest);
        return {
            signDataPrefetch: responseBodyPromise.then((responseBody)=>responseBody.signDataPrefetch),
            response: responseBodyPromise.then((responseBody)=>Promise.all([
                    responseBody.code,
                    responseBody.msg,
                    responseBody.data
                ])).then((param)=>{
                let [code, msg, data] = param;
                if (code !== 20000) {
                    throw RequestError_1.RequestError.parse(JSON.stringify({
                        code,
                        msg,
                        data
                    }), 400);
                }
                return (0, SchemaVerifier_1.verifySchema)(data, ToBTCLNResponseSchema);
            })
        };
    }
    /**
     * Initiate To BTCLN exact in swap with an intermediary
     *
     * @param baseUrl Base URL of the intermediary
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static async initToBTCLNExactIn(baseUrl, init, timeout, abortSignal, streamRequest) {
        const responseBody = await (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + "/tobtcln/payInvoiceExactIn", {
            ...init.additionalParams,
            pr: init.pr,
            reqId: init.reqId,
            feeRate: init.feeRate
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional
        }, timeout, abortSignal, streamRequest);
        const [code, msg, data] = await Promise.all([
            responseBody.code,
            responseBody.msg,
            responseBody.data
        ]);
        if (code !== 20000) throw RequestError_1.RequestError.parse(JSON.stringify({
            code,
            msg,
            data
        }), 400);
        return (0, SchemaVerifier_1.verifySchema)(data, ToBTCLNResponseSchema);
    }
    /**
     * Prepare To BTCLN exact in swap with an intermediary
     *
     * @param chainIdentifier
     * @param baseUrl Base URL of the intermediary
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static prepareToBTCLNExactIn(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {
        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + "/tobtcln/payInvoice?chain=" + encodeURIComponent(chainIdentifier), {
            exactIn: true,
            ...init.additionalParams,
            pr: init.pr,
            maxFee: init.maxFee.toString(10),
            expiryTimestamp: init.expiryTimestamp.toString(10),
            token: init.token,
            offerer: init.offerer,
            amount: init.amount.toString(10)
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional,
            signDataPrefetch: SchemaVerifier_1.FieldTypeEnum.AnyOptional
        }, timeout, abortSignal, streamRequest);
        return {
            signDataPrefetch: responseBodyPromise.then((responseBody)=>responseBody.signDataPrefetch),
            response: responseBodyPromise.then((responseBody)=>Promise.all([
                    responseBody.code,
                    responseBody.msg,
                    responseBody.data
                ])).then((param)=>{
                let [code, msg, data] = param;
                if (code !== 20000) {
                    throw RequestError_1.RequestError.parse(JSON.stringify({
                        code,
                        msg,
                        data
                    }), 400);
                }
                return (0, SchemaVerifier_1.verifySchema)(data, ToBTCLNPrepareExactInSchema);
            })
        };
    }
    /**
     * Prepare From BTC swap via new spv vault swaps with an intermediary
     *
     * @param chainIdentifier
     * @param baseUrl Base URL of the intermediary
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static prepareSpvFromBTC(chainIdentifier, baseUrl, init, timeout, abortSignal, streamRequest) {
        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(baseUrl + "/frombtc_spv/getQuote?chain=" + encodeURIComponent(chainIdentifier), {
            exactOut: init.exactOut,
            ...init.additionalParams,
            address: init.address,
            amount: init.amount.toString(10),
            token: init.token,
            gasAmount: init.gasAmount.toString(10),
            gasToken: init.gasToken,
            frontingFeeRate: init.frontingFeeRate.toString(10),
            callerFeeRate: init.callerFeeRate.then((val)=>val.toString(10))
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional
        }, timeout, abortSignal, streamRequest);
        return responseBodyPromise.then((responseBody)=>Promise.all([
                responseBody.code,
                responseBody.msg,
                responseBody.data
            ])).then((param)=>{
            let [code, msg, data] = param;
            if (code !== 20000) {
                throw RequestError_1.RequestError.parse(JSON.stringify({
                    code,
                    msg,
                    data
                }), 400);
            }
            return (0, SchemaVerifier_1.verifySchema)(data, SpvFromBTCPrepareResponseSchema);
        });
    }
    /**
     * Prepare From BTC swap via new spv vault swaps with an intermediary
     *
     * @param chainIdentifier
     * @param url
     * @param init Swap initialization parameters
     * @param timeout Timeout in milliseconds for the HTTP request
     * @param abortSignal
     * @param streamRequest Whether to force streaming (or not streaming) the request, default is autodetect
     *
     * @throws {RequestError} If non-200 http response code is returned
     */ static initSpvFromBTC(chainIdentifier, url, init, timeout, abortSignal, streamRequest) {
        const responseBodyPromise = (0, StreamingFetchPromise_1.streamingFetchPromise)(url + "/postQuote?chain=" + encodeURIComponent(chainIdentifier), {
            quoteId: init.quoteId,
            psbtHex: init.psbtHex
        }, {
            code: SchemaVerifier_1.FieldTypeEnum.Number,
            msg: SchemaVerifier_1.FieldTypeEnum.String,
            data: SchemaVerifier_1.FieldTypeEnum.AnyOptional
        }, timeout, abortSignal, streamRequest);
        return responseBodyPromise.then((responseBody)=>Promise.all([
                responseBody.code,
                responseBody.msg,
                responseBody.data
            ])).then((param)=>{
            let [code, msg, data] = param;
            if (code !== 20000) {
                throw RequestError_1.RequestError.parse(JSON.stringify({
                    code,
                    msg,
                    data
                }), 400);
            }
            return (0, SchemaVerifier_1.verifySchema)(data, SpvFromBTCInitResponseSchema);
        });
    }
}
exports.IntermediaryAPI = IntermediaryAPI;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryDiscovery.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IntermediaryDiscovery = exports.SwapHandlerType = void 0;
const Intermediary_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/Intermediary.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const events_1 = __turbopack_context__.r("[project]/node_modules/events/events.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
var SwapHandlerType;
(function(SwapHandlerType) {
    SwapHandlerType["TO_BTC"] = "TO_BTC";
    SwapHandlerType["FROM_BTC"] = "FROM_BTC";
    SwapHandlerType["TO_BTCLN"] = "TO_BTCLN";
    SwapHandlerType["FROM_BTCLN"] = "FROM_BTCLN";
    SwapHandlerType["FROM_BTC_TRUSTED"] = "FROM_BTC_TRUSTED";
    SwapHandlerType["FROM_BTCLN_TRUSTED"] = "FROM_BTCLN_TRUSTED";
    SwapHandlerType["FROM_BTC_SPV"] = "FROM_BTC_SPV";
})(SwapHandlerType = exports.SwapHandlerType || (exports.SwapHandlerType = {}));
/**
 * Converts SwapHandlerType (represented as string & used in REST API communication with intermediaries) to regular
 *  SwapType
 *
 * @param swapHandlerType
 */ function swapHandlerTypeToSwapType(swapHandlerType) {
    switch(swapHandlerType){
        case SwapHandlerType.FROM_BTC:
            return SwapType_1.SwapType.FROM_BTC;
        case SwapHandlerType.TO_BTC:
            return SwapType_1.SwapType.TO_BTC;
        case SwapHandlerType.FROM_BTCLN:
            return SwapType_1.SwapType.FROM_BTCLN;
        case SwapHandlerType.TO_BTCLN:
            return SwapType_1.SwapType.TO_BTCLN;
        case SwapHandlerType.FROM_BTC_TRUSTED:
            return SwapType_1.SwapType.TRUSTED_FROM_BTC;
        case SwapHandlerType.FROM_BTCLN_TRUSTED:
            return SwapType_1.SwapType.TRUSTED_FROM_BTCLN;
        case SwapHandlerType.FROM_BTC_SPV:
            return SwapType_1.SwapType.SPV_VAULT_FROM_BTC;
    }
}
/**
 * A default intermediary comparator, only takes to announced fee into consideration
 *
 * @param swapType
 * @param tokenAddress
 * @param swapAmount
 */ function getIntermediaryComparator(swapType, tokenAddress, swapAmount) {
    if (swapType === SwapType_1.SwapType.TO_BTC) {
    //TODO: Also take reputation into account
    }
    return (a, b)=>{
        if (swapAmount == null) {
            return a.services[swapType].swapFeePPM - b.services[swapType].swapFeePPM;
        } else {
            const feeA = BigInt(a.services[swapType].swapBaseFee) + swapAmount * BigInt(a.services[swapType].swapFeePPM) / 1000000n;
            const feeB = BigInt(b.services[swapType].swapBaseFee) + swapAmount * BigInt(b.services[swapType].swapFeePPM) / 1000000n;
            return feeA - feeB > 0n ? 1 : feeA === feeB ? 0 : -1;
        }
    };
}
const logger = (0, Utils_1.getLogger)("IntermediaryDiscovery: ");
const REGISTRY_URL = "https://api.github.com/repos/adambor/SolLightning-registry/contents/registry.json?ref=main";
//To allow for legacy responses from not-yet updated LPs
const DEFAULT_CHAIN = "SOLANA";
class IntermediaryDiscovery extends events_1.EventEmitter {
    /**
     * Fetches the URLs of swap intermediaries from registry or from a pre-defined array of node urls
     *
     * @param abortSignal
     */ async getIntermediaryUrls(abortSignal) {
        if (this.overrideNodeUrls != null && this.overrideNodeUrls.length > 0) {
            return this.overrideNodeUrls;
        }
        const response = await (0, Utils_1.httpGet)(this.registryUrl, this.httpRequestTimeout, abortSignal);
        const content = response.content.replace(new RegExp("\\n", "g"), "");
        return JSON.parse(buffer_1.Buffer.from(content, "base64").toString());
    }
    /**
     * Returns data as reported by a specific node (as identified by its URL)
     *
     * @param url
     * @param abortSignal
     */ async getNodeInfo(url, abortSignal) {
        const response = await (0, Utils_1.tryWithRetries)(()=>IntermediaryAPI_1.IntermediaryAPI.getIntermediaryInfo(url, this.httpRequestTimeout, abortSignal), {
            maxRetries: 3,
            delay: 100,
            exponential: true
        }, undefined, abortSignal);
        const addresses = {};
        for(let chain in response.chains){
            if (this.swapContracts[chain] != null) {
                const { signature, address } = response.chains[chain];
                try {
                    await (0, Utils_1.tryWithRetries)(()=>this.swapContracts[chain].isValidDataSignature(buffer_1.Buffer.from(response.envelope), signature, address), {
                        maxRetries: 3,
                        delay: 100,
                        exponential: true
                    }, base_1.SignatureVerificationError, abortSignal);
                    addresses[chain] = address;
                } catch (e) {
                    logger.warn("Failed to verify " + chain + " signature for intermediary: " + url);
                }
            }
        }
        if (abortSignal != null) abortSignal.throwIfAborted();
        //Handle legacy responses
        const info = JSON.parse(response.envelope);
        for(let swapType in info.services){
            const serviceData = info.services[swapType];
            if (serviceData.chainTokens == null) serviceData.chainTokens = {
                [DEFAULT_CHAIN]: serviceData.tokens
            };
            for(let chain in serviceData.chainTokens){
                if (addresses[chain] == null) delete serviceData.chainTokens[chain];
            }
        }
        return {
            addresses,
            info
        };
    }
    async loadIntermediary(url, abortSignal) {
        try {
            const nodeInfo = await this.getNodeInfo(url, abortSignal);
            const services = {};
            for(let key in nodeInfo.info.services){
                services[swapHandlerTypeToSwapType(key)] = nodeInfo.info.services[key];
            }
            return new Intermediary_1.Intermediary(url, nodeInfo.addresses, services);
        } catch (e) {
            logger.warn("fetchIntermediaries(): Error contacting intermediary " + url + ": ", e);
            return null;
        }
    }
    /**
     * Fetches data about all intermediaries in the network, pinging every one of them and ensuring they are online
     *
     * @param abortSignal
     * @private
     * @throws {Error} When no online intermediary was found
     */ async fetchIntermediaries(abortSignal) {
        const urls = await this.getIntermediaryUrls(abortSignal);
        logger.debug("fetchIntermediaries(): Pinging intermediaries: ", urls.join());
        const promises = urls.map((url)=>this.loadIntermediary(url, abortSignal));
        const activeNodes = (await Promise.all(promises)).filter((intermediary)=>intermediary != null);
        if (activeNodes.length === 0) throw new Error("No online intermediary found!");
        return activeNodes;
    }
    /**
     * Returns the intermediary at the provided URL, either from the already fetched list of LPs or fetches the data on-demand
     *
     * @param url
     */ getIntermediary(url) {
        const foundLp = this.intermediaries.find((lp)=>lp.url === url);
        if (foundLp != null) return Promise.resolve(foundLp);
        return this.loadIntermediary(url);
    }
    /**
     * Reloads the saves a list of intermediaries
     * @param abortSignal
     */ async reloadIntermediaries(abortSignal) {
        const fetchedIntermediaries = await (0, Utils_1.tryWithRetries)(()=>this.fetchIntermediaries(abortSignal), null, null, abortSignal);
        this.intermediaries = fetchedIntermediaries;
        this.emit("added", fetchedIntermediaries);
        logger.info("reloadIntermediaries(): Using active intermediaries: ", fetchedIntermediaries.map((lp)=>lp.url).join());
    }
    /**
     * Initializes the discovery by fetching/reloading intermediaries
     *
     * @param abortSignal
     */ init(abortSignal) {
        logger.info("init(): Initializing with registryUrl: " + this.registryUrl + " intermediary array: " + (this.overrideNodeUrls || []).join());
        return this.reloadIntermediaries(abortSignal);
    }
    getMultichainSwapBounds() {
        const bounds = {};
        this.intermediaries.forEach((intermediary)=>{
            for(let swapType in intermediary.services){
                var _bounds, _swapType;
                const swapService = intermediary.services[swapType];
                var _;
                (_ = (_bounds = bounds)[_swapType = swapType]) !== null && _ !== void 0 ? _ : _bounds[_swapType] = {};
                const multichainBounds = bounds[swapType];
                for(let chainId in swapService.chainTokens){
                    var _multichainBounds, _chainId;
                    var _1;
                    (_1 = (_multichainBounds = multichainBounds)[_chainId = chainId]) !== null && _1 !== void 0 ? _1 : _multichainBounds[_chainId] = {};
                    const tokenBounds = multichainBounds[chainId];
                    for (let token of swapService.chainTokens[chainId]){
                        const tokenMinMax = tokenBounds[token];
                        if (tokenMinMax == null) {
                            tokenBounds[token] = {
                                min: BigInt(swapService.min),
                                max: BigInt(swapService.max)
                            };
                        } else {
                            tokenMinMax.min = (0, Utils_1.bigIntMin)(tokenMinMax.min, BigInt(swapService.min));
                            tokenMinMax.max = (0, Utils_1.bigIntMax)(tokenMinMax.max, BigInt(swapService.max));
                        }
                    }
                }
            }
        });
        return bounds;
    }
    /**
     * Returns aggregate swap bounds (in sats - BTC) as indicated by the intermediaries
     */ getSwapBounds(chainIdentifier) {
        const bounds = {};
        this.intermediaries.forEach((intermediary)=>{
            for(let swapType in intermediary.services){
                const swapService = intermediary.services[swapType];
                if (bounds[swapType] == null) bounds[swapType] = {};
                const tokenBounds = bounds[swapType];
                if (swapService.chainTokens != null && swapService.chainTokens[chainIdentifier] != null) {
                    for (let token of swapService.chainTokens[chainIdentifier]){
                        const tokenMinMax = tokenBounds[token];
                        if (tokenMinMax == null) {
                            tokenBounds[token] = {
                                min: BigInt(swapService.min),
                                max: BigInt(swapService.max)
                            };
                        } else {
                            tokenMinMax.min = (0, Utils_1.bigIntMin)(tokenMinMax.min, BigInt(swapService.min));
                            tokenMinMax.max = (0, Utils_1.bigIntMax)(tokenMinMax.max, BigInt(swapService.max));
                        }
                    }
                }
            }
        });
        return bounds;
    }
    /**
     * Returns the aggregate swap minimum (in sats - BTC) for a specific swap type & token
     *  as indicated by the intermediaries
     *
     * @param chainIdentifier
     * @param swapType
     * @param token
     */ getSwapMinimum(chainIdentifier, swapType, token) {
        const tokenStr = token.toString();
        return this.intermediaries.reduce((prevMin, intermediary)=>{
            const swapService = intermediary.services[swapType];
            if (swapService != null && swapService.chainTokens != null && swapService.chainTokens[chainIdentifier] != null && swapService.chainTokens[chainIdentifier].includes(tokenStr)) return prevMin == null ? swapService.min : Math.min(prevMin, swapService.min);
            return prevMin;
        }, null);
    }
    /**
     * Returns the aggregate swap maximum (in sats - BTC) for a specific swap type & token
     *  as indicated by the intermediaries
     *
     * @param chainIdentifier
     * @param swapType
     * @param token
     */ getSwapMaximum(chainIdentifier, swapType, token) {
        const tokenStr = token.toString();
        return this.intermediaries.reduce((prevMax, intermediary)=>{
            const swapService = intermediary.services[swapType];
            if (swapService != null && swapService.chainTokens != null && swapService.chainTokens[chainIdentifier] != null && swapService.chainTokens[chainIdentifier].includes(tokenStr)) return prevMax == null ? swapService.max : Math.max(prevMax, swapService.max);
            return prevMax;
        }, null);
    }
    /**
     * Returns swap candidates for a specific swap type & token address
     *
     * @param chainIdentifier
     * @param swapType
     * @param tokenAddress
     * @param amount Amount to be swapped in sats - BTC
     * @param count How many intermediaries to return at most
     */ getSwapCandidates(chainIdentifier, swapType, tokenAddress, amount, count) {
        const candidates = this.intermediaries.filter((e)=>{
            const swapService = e.services[swapType];
            if (swapService == null) return false;
            if (amount != null && amount < BigInt(swapService.min)) return false;
            if (amount != null && amount > BigInt(swapService.max)) return false;
            if (swapService.chainTokens == null) return false;
            if (swapService.chainTokens[chainIdentifier] == null) return false;
            if (!swapService.chainTokens[chainIdentifier].includes(tokenAddress.toString())) return false;
            return true;
        });
        candidates.sort(getIntermediaryComparator(swapType, tokenAddress, amount));
        if (count == null) {
            return candidates;
        } else {
            return candidates.slice(0, count);
        }
    }
    /**
     * Removes a specific intermediary from the list of active intermediaries (used for blacklisting)
     *
     * @param intermediary
     */ removeIntermediary(intermediary) {
        const index = this.intermediaries.indexOf(intermediary);
        if (index >= 0) {
            logger.info("removeIntermediary(): Removing intermediary: " + intermediary.url);
            this.intermediaries.splice(index, 1);
            this.emit("removed", [
                intermediary
            ]);
            return true;
        }
        return false;
    }
    constructor(swapContracts, registryUrl = REGISTRY_URL, nodeUrls, httpRequestTimeout){
        super();
        this.intermediaries = [];
        this.swapContracts = swapContracts;
        this.registryUrl = registryUrl;
        this.overrideNodeUrls = nodeUrls;
        this.httpRequestTimeout = httpRequestTimeout;
    }
}
exports.IntermediaryDiscovery = IntermediaryDiscovery;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ISwapPrice.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ISwapPrice = exports.isPriceInfoType = void 0;
function isPriceInfoType(obj) {
    return obj != null && typeof obj.isValid === "boolean" && typeof obj.differencePPM === "bigint" && typeof obj.satsBaseFee === "bigint" && typeof obj.feePPM === "bigint" && typeof obj.realPriceUSatPerToken === "bigint" && typeof obj.swapPriceUSatPerToken === "bigint";
}
exports.isPriceInfoType = isPriceInfoType;
class ISwapPrice {
    /**
     * Recomputes pricing info without fetching the current price
     *
     * @param chainIdentifier
     * @param amountSats
     * @param satsBaseFee
     * @param feePPM
     * @param paidToken
     * @param token
     */ recomputePriceInfoSend(chainIdentifier, amountSats, satsBaseFee, feePPM, paidToken, token) {
        const totalSats = amountSats * (1000000n + feePPM) / 1000000n + satsBaseFee;
        const totalUSats = totalSats * 1000000n;
        const swapPriceUSatPerToken = totalUSats * 10n ** BigInt(this.getDecimals(chainIdentifier, token)) / paidToken;
        return {
            isValid: true,
            differencePPM: 0n,
            satsBaseFee,
            feePPM,
            realPriceUSatPerToken: this.shouldIgnore(chainIdentifier, token) ? null : swapPriceUSatPerToken,
            swapPriceUSatPerToken
        };
    }
    /**
     * Checks whether the swap amounts are valid given the current market rate for a given pair
     *
     * @param chainIdentifier
     * @param amountSats Amount of sats (BTC) to be received from the swap
     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary
     * @param feePPM PPM fee rate as reported by the intermediary
     * @param paidToken Amount of token to be paid to the swap
     * @param token
     * @param abortSignal
     * @param preFetchedPrice Already pre-fetched price
     */ async isValidAmountSend(chainIdentifier, amountSats, satsBaseFee, feePPM, paidToken, token, abortSignal, preFetchedPrice) {
        const totalSats = amountSats * (1000000n + feePPM) / 1000000n + satsBaseFee;
        const totalUSats = totalSats * 1000000n;
        const swapPriceUSatPerToken = totalUSats * 10n ** BigInt(this.getDecimals(chainIdentifier, token)) / paidToken;
        if (this.shouldIgnore(chainIdentifier, token)) return {
            isValid: true,
            differencePPM: 0n,
            satsBaseFee,
            feePPM,
            realPriceUSatPerToken: null,
            swapPriceUSatPerToken
        };
        const calculatedAmtInToken = await this.getFromBtcSwapAmount(chainIdentifier, totalSats, token, abortSignal, preFetchedPrice);
        const realPriceUSatPerToken = totalUSats * 10n ** BigInt(this.getDecimals(chainIdentifier, token)) / calculatedAmtInToken;
        const difference = paidToken - calculatedAmtInToken; //Will be >0 if we need to pay more than we should've
        const differencePPM = difference * 1000000n / calculatedAmtInToken;
        return {
            isValid: differencePPM <= this.maxAllowedFeeDifferencePPM,
            differencePPM,
            satsBaseFee,
            feePPM,
            realPriceUSatPerToken,
            swapPriceUSatPerToken
        };
    }
    /**
     * Recomputes pricing info without fetching the current price
     *
     * @param chainIdentifier
     * @param amountSats
     * @param satsBaseFee
     * @param feePPM
     * @param receiveToken
     * @param token
     */ recomputePriceInfoReceive(chainIdentifier, amountSats, satsBaseFee, feePPM, receiveToken, token) {
        const totalSats = amountSats * (1000000n - feePPM) / 1000000n - satsBaseFee;
        const totalUSats = totalSats * 1000000n;
        const swapPriceUSatPerToken = totalUSats * 10n ** BigInt(this.getDecimals(chainIdentifier, token)) / receiveToken;
        return {
            isValid: true,
            differencePPM: 0n,
            satsBaseFee,
            feePPM,
            realPriceUSatPerToken: this.shouldIgnore(chainIdentifier, token) ? null : swapPriceUSatPerToken,
            swapPriceUSatPerToken
        };
    }
    /**
     * Checks whether the swap amounts are valid given the current market rate for a given pair
     *
     * @param chainIdentifier
     * @param amountSats Amount of sats (BTC) to be paid to the swap
     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary
     * @param feePPM PPM fee rate as reported by the intermediary
     * @param receiveToken Amount of token to be received from the swap
     * @param token
     * @param abortSignal
     * @param preFetchedPrice Already pre-fetched price
     */ async isValidAmountReceive(chainIdentifier, amountSats, satsBaseFee, feePPM, receiveToken, token, abortSignal, preFetchedPrice) {
        const totalSats = amountSats * (1000000n - feePPM) / 1000000n - satsBaseFee;
        const totalUSats = totalSats * 1000000n;
        const swapPriceUSatPerToken = totalUSats * 10n ** BigInt(this.getDecimals(chainIdentifier, token)) / receiveToken;
        if (this.shouldIgnore(chainIdentifier, token)) return {
            isValid: true,
            differencePPM: 0n,
            satsBaseFee,
            feePPM,
            realPriceUSatPerToken: null,
            swapPriceUSatPerToken
        };
        const calculatedAmtInToken = await this.getFromBtcSwapAmount(chainIdentifier, totalSats, token, abortSignal, preFetchedPrice);
        const realPriceUSatPerToken = totalUSats * 10n ** BigInt(this.getDecimals(chainIdentifier, token)) / calculatedAmtInToken;
        const difference = calculatedAmtInToken - receiveToken; //Will be >0 if we receive less than we should've
        const differencePPM = difference * 100000n / calculatedAmtInToken;
        return {
            isValid: differencePPM <= this.maxAllowedFeeDifferencePPM,
            differencePPM,
            satsBaseFee,
            feePPM,
            realPriceUSatPerToken,
            swapPriceUSatPerToken
        };
    }
    preFetchPrice(chainIdentifier, token, abortSignal) {
        return this.getPrice(chainIdentifier, token, abortSignal);
    }
    preFetchUsdPrice(abortSignal) {
        return this.getUsdPrice(abortSignal);
    }
    /**
     * Returns amount of {toToken} that are equivalent to {fromAmount} satoshis
     *
     * @param chainIdentifier
     * @param fromAmount        Amount of satoshis
     * @param toToken           Token
     * @param abortSignal
     * @param preFetchedPrice
     * @throws {Error} when token is not found
     */ async getFromBtcSwapAmount(chainIdentifier, fromAmount, toToken, abortSignal, preFetchedPrice) {
        if (this.getDecimals(chainIdentifier, toToken.toString()) == null) throw new Error("Token not found!");
        const price = preFetchedPrice || await this.getPrice(chainIdentifier, toToken, abortSignal);
        return fromAmount * 10n ** BigInt(this.getDecimals(chainIdentifier, toToken.toString())) * 1000000n / price;
    }
    /**
     * Returns amount of satoshis that are equivalent to {fromAmount} of {fromToken}
     *
     * @param chainIdentifier
     * @param fromAmount Amount of the token
     * @param fromToken Token
     * @param abortSignal
     * @param preFetchedPrice Pre-fetched swap price if available
     * @throws {Error} when token is not found
     */ async getToBtcSwapAmount(chainIdentifier, fromAmount, fromToken, abortSignal, preFetchedPrice) {
        if (this.getDecimals(chainIdentifier, fromToken.toString()) == null) throw new Error("Token not found");
        const price = preFetchedPrice || await this.getPrice(chainIdentifier, fromToken, abortSignal);
        return fromAmount * price / 1000000n / 10n ** BigInt(this.getDecimals(chainIdentifier, fromToken.toString()));
    }
    /**
     * Returns whether the token should be ignored and pricing for it not calculated
     * @param chainIdentifier
     * @param tokenAddress
     * @throws {Error} if token is not found
     */ shouldIgnore(chainIdentifier, tokenAddress) {
        const coin = this.getDecimals(chainIdentifier, tokenAddress.toString());
        if (coin == null) throw new Error("Token not found");
        return coin === -1;
    }
    async getBtcUsdValue(btcSats, abortSignal, preFetchedPrice) {
        return Number(btcSats) * (preFetchedPrice || await this.getUsdPrice(abortSignal));
    }
    async getTokenUsdValue(chainId, tokenAmount, token, abortSignal, preFetchedPrice) {
        const [btcAmount, usdPrice] = await Promise.all([
            this.getToBtcSwapAmount(chainId, tokenAmount, token, abortSignal),
            preFetchedPrice == null ? this.preFetchUsdPrice(abortSignal) : Promise.resolve(preFetchedPrice)
        ]);
        return Number(btcAmount) * usdPrice;
    }
    getUsdValue(amount, token, abortSignal, preFetchedUsdPrice) {
        if (token.chain === "BTC") {
            return this.getBtcUsdValue(amount, abortSignal, preFetchedUsdPrice);
        } else {
            return this.getTokenUsdValue(token.chainId, amount, token.address, abortSignal, preFetchedUsdPrice);
        }
    }
    constructor(maxAllowedFeeDifferencePPM){
        this.maxAllowedFeeDifferencePPM = maxAllowedFeeDifferencePPM;
    }
}
exports.ISwapPrice = ISwapPrice;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ICachedSwapPrice.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ICachedSwapPrice = void 0;
const ISwapPrice_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ISwapPrice.js [app-client] (ecmascript)");
const DEFAULT_CACHE_DURATION = 10000;
class ICachedSwapPrice extends ISwapPrice_1.ISwapPrice {
    getPrice(chainIdentifier, tokenAddress, abortSignal) {
        var _this_cache, _chainIdentifier;
        const token = tokenAddress.toString();
        const chainCache = this.cache[chainIdentifier];
        if (chainCache != null) {
            const cachedValue = chainCache[token];
            if (cachedValue != null && cachedValue.expiry > Date.now()) {
                //Cache still fresh
                return cachedValue.price.catch((e)=>this.fetchPrice(chainIdentifier, token, abortSignal));
            }
        }
        //Refresh cache
        const thisFetch = this.fetchPrice(chainIdentifier, token);
        var _;
        (_ = (_this_cache = this.cache)[_chainIdentifier = chainIdentifier]) !== null && _ !== void 0 ? _ : _this_cache[_chainIdentifier] = {};
        this.cache[chainIdentifier][token] = {
            price: thisFetch,
            expiry: Date.now() + this.cacheTimeout
        };
        thisFetch.catch((e)=>{
            if (this.cache[chainIdentifier] != null && this.cache[chainIdentifier][token] != null && this.cache[chainIdentifier][token].price === thisFetch) delete this.cache[token];
            throw e;
        });
        return thisFetch;
    }
    /**
     * Returns BTC price in USD (sats/USD)
     *
     * @param abortSignal
     * @throws {Error} if token is not found
     */ getUsdPrice(abortSignal) {
        if (this.usdCache != null && this.usdCache.expiry > Date.now()) {
            //Cache still fresh
            return this.usdCache.price.catch((e)=>this.fetchUsdPrice(abortSignal));
        }
        //Refresh cache
        const thisFetch = this.fetchUsdPrice();
        this.usdCache = {
            price: thisFetch,
            expiry: Date.now() + this.cacheTimeout
        };
        thisFetch.catch((e)=>{
            if (this.usdCache != null && this.usdCache.price === thisFetch) delete this.usdCache;
            throw e;
        });
        return thisFetch;
    }
    constructor(maxAllowedFeeDiffPPM, cacheTimeout){
        super(maxAllowedFeeDiffPPM);
        this.cache = {};
        this.cacheTimeout = cacheTimeout || DEFAULT_CACHE_DURATION;
    }
}
exports.ICachedSwapPrice = ICachedSwapPrice;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/IPriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IPriceProvider = void 0;
class IPriceProvider {
    /**
     * Returns coin price in uSat (microSat)
     *
     * @param chainIdentifier
     * @param token
     * @param abortSignal
     * @throws {Error} if token is not found
     */ getPrice(chainIdentifier, token, abortSignal) {
        let tokenAddress = token.toString();
        const chainTokens = this.coinsMap[chainIdentifier];
        if (chainTokens == null) throw new Error("Chain not found");
        const coin = chainTokens[tokenAddress];
        if (coin == null) throw new Error("Token not found");
        if (coin.coinId.startsWith("$fixed-")) {
            const amt = parseFloat(coin.coinId.substring(7));
            return Promise.resolve(BigInt(Math.floor(amt * 1000000).toString(10)));
        }
        return this.fetchPrice(coin, abortSignal);
    }
    /**
     * Returns coin price in uSat (microSat)
     *
     * @param abortSignal
     * @throws {Error} if token is not found
     */ getUsdPrice(abortSignal) {
        return this.fetchUsdPrice(abortSignal);
    }
    /**
     * Returns the decimal places of the specified token, or -1 if token should be ignored, returns null if
     *  token is not found
     *
     * @param chainIdentifier
     * @param token
     * @protected
     * @throws {Error} If token is not found
     */ getDecimals(chainIdentifier, token) {
        const chainTokens = this.coinsMap[chainIdentifier];
        if (chainTokens == null) throw new Error("Chain not found");
        const coin = chainTokens[token.toString()];
        if (coin == null) throw new Error("Token not found");
        return coin.coinId === "$ignore" ? -1 : coin.decimals;
    }
    constructor(coins){
        this.coinsMap = {};
        for (let coinData of coins){
            if (coinData.coinId == null) continue;
            for(let chainId in coinData.chains){
                var _this_coinsMap, _chainId;
                const { address, decimals } = coinData.chains[chainId];
                var _;
                (_ = (_this_coinsMap = this.coinsMap)[_chainId = chainId]) !== null && _ !== void 0 ? _ : _this_coinsMap[_chainId] = {};
                this.coinsMap[chainId][address.toString()] = {
                    coinId: coinData.coinId,
                    decimals
                };
            }
        }
    }
}
exports.IPriceProvider = IPriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/HttpPriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HttpPriceProvider = void 0;
const IPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/IPriceProvider.js [app-client] (ecmascript)");
class HttpPriceProvider extends IPriceProvider_1.IPriceProvider {
    constructor(coinsMap, url, httpRequestTimeout){
        super(coinsMap);
        this.url = url;
        this.httpRequestTimeout = httpRequestTimeout;
    }
}
exports.HttpPriceProvider = HttpPriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/ExchangePriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExchangePriceProvider = void 0;
const HttpPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/HttpPriceProvider.js [app-client] (ecmascript)");
class ExchangePriceProvider extends HttpPriceProvider_1.HttpPriceProvider {
    async fetchPrice(token, abortSignal) {
        const pairs = token.coinId.split(";");
        const prices = await Promise.all(pairs.map((pair)=>{
            let invert = pair.startsWith("!");
            if (invert) pair = pair.substring(1);
            return this.fetchPair(pair, abortSignal).then((value)=>invert ? 1 / value : value);
        }));
        const price = prices.reduce((previousValue, currentValue)=>previousValue * currentValue, 1);
        return BigInt(Math.floor(price * 100000000000000));
    }
}
exports.ExchangePriceProvider = ExchangePriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/BinancePriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BinancePriceProvider = void 0;
const ExchangePriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/ExchangePriceProvider.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class BinancePriceProvider extends ExchangePriceProvider_1.ExchangePriceProvider {
    async fetchPair(pair, abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/ticker/price?symbol=" + pair, this.httpRequestTimeout, abortSignal);
        return parseFloat(response.price);
    }
    async fetchUsdPrice(abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/ticker/price?symbol=BTCUSDC", this.httpRequestTimeout, abortSignal);
        return parseFloat(response.price) / 100000000;
    }
    constructor(coinsMap, url = "https://api.binance.com/api/v3", httpRequestTimeout){
        super(coinsMap, url, httpRequestTimeout);
    }
}
exports.BinancePriceProvider = BinancePriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CoinGeckoPriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CoinGeckoPriceProvider = void 0;
const HttpPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/HttpPriceProvider.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class CoinGeckoPriceProvider extends HttpPriceProvider_1.HttpPriceProvider {
    async fetchPrice(token, abortSignal) {
        let response = await (0, Utils_1.httpGet)(this.url + "/simple/price?ids=" + token.coinId + "&vs_currencies=sats&precision=6", this.httpRequestTimeout, abortSignal);
        return BigInt(response[token.coinId].sats * 1000000);
    }
    async fetchUsdPrice(abortSignal) {
        let response = await (0, Utils_1.httpGet)(this.url + "/simple/price?ids=bitcoin&vs_currencies=usd&precision=9", this.httpRequestTimeout, abortSignal);
        return response["bitcoin"].usd / 100000000;
    }
    constructor(coinsMap, url = "https://api.coingecko.com/api/v3", httpRequestTimeout){
        super(coinsMap, url, httpRequestTimeout);
    }
}
exports.CoinGeckoPriceProvider = CoinGeckoPriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CoinPaprikaPriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CoinPaprikaPriceProvider = void 0;
const HttpPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/HttpPriceProvider.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class CoinPaprikaPriceProvider extends HttpPriceProvider_1.HttpPriceProvider {
    async fetchPrice(token, abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/tickers/" + token.coinId + "?quotes=BTC", this.httpRequestTimeout, abortSignal);
        return BigInt(Math.floor(response.quotes.BTC.price * 100000000000000));
    }
    async fetchUsdPrice(abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/tickers/btc-bitcoin?quotes=USD", this.httpRequestTimeout, abortSignal);
        return response.quotes.USD.price / 100000000;
    }
    constructor(coinsMap, url = "https://api.coinpaprika.com/v1", httpRequestTimeout){
        super(coinsMap, url, httpRequestTimeout);
    }
}
exports.CoinPaprikaPriceProvider = CoinPaprikaPriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/OKXPriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OKXPriceProvider = void 0;
const ExchangePriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/ExchangePriceProvider.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class OKXPriceProvider extends ExchangePriceProvider_1.ExchangePriceProvider {
    async fetchPair(pair, abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/market/index-tickers?instId=" + pair, this.httpRequestTimeout, abortSignal);
        return parseFloat(response.data[0].idxPx);
    }
    async fetchUsdPrice(abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/market/index-tickers?instId=BTC-USD", this.httpRequestTimeout, abortSignal);
        return parseFloat(response.data[0].idxPx) / 100000000;
    }
    constructor(coinsMap, url = "https://www.okx.com/api/v5", httpRequestTimeout){
        super(coinsMap, url, httpRequestTimeout);
    }
}
exports.OKXPriceProvider = OKXPriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CustomPriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomPriceProvider = void 0;
const IPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/IPriceProvider.js [app-client] (ecmascript)");
class CustomPriceProvider extends IPriceProvider_1.IPriceProvider {
    async fetchPrice(token, abortSignal) {
        const [btcPrice, tokenPrice] = await this.getUsdPriceFn([
            "BTC",
            token.coinId
        ], abortSignal);
        const priceInBtc = tokenPrice / btcPrice;
        return BigInt(Math.floor(priceInBtc * 100000000 * 1000000));
    }
    async fetchUsdPrice(abortSignal) {
        const [btcPrice] = await this.getUsdPriceFn([
            "BTC"
        ], abortSignal);
        return btcPrice / 100000000;
    }
    constructor(coinsMap, getUsdPriceFn){
        super(coinsMap);
        this.getUsdPriceFn = getUsdPriceFn;
    }
}
exports.CustomPriceProvider = CustomPriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/KrakenPriceProvider.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KrakenPriceProvider = void 0;
const ExchangePriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/ExchangePriceProvider.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class KrakenPriceProvider extends ExchangePriceProvider_1.ExchangePriceProvider {
    async fetchPair(pair, abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/public/Ticker?pair=" + pair, this.httpRequestTimeout, abortSignal);
        return parseFloat(response.result[pair].c[0]);
    }
    async fetchUsdPrice(abortSignal) {
        const response = await (0, Utils_1.httpGet)(this.url + "/public/Ticker?pair=XBTUSDC", this.httpRequestTimeout, abortSignal);
        return parseFloat(response.result["XBTUSDC"].c[0]) / 100000000;
    }
    async fetchPrice(token, abortSignal) {
        const pairs = token.coinId.split(";");
        const response = await (0, Utils_1.httpGet)(this.url + "/public/Ticker?pair=" + pairs.map((val)=>val.startsWith("!") ? val.substring(1) : val).join(","), this.httpRequestTimeout, abortSignal);
        const prices = pairs.map((pair)=>{
            let invert = pair.startsWith("!");
            if (invert) pair = pair.substring(1);
            const value = parseFloat(response.result[pair].c[0]);
            return invert ? 1 / value : value;
        });
        const price = prices.reduce((previousValue, currentValue)=>previousValue * currentValue, 1);
        return BigInt(Math.floor(price * 100000000000000));
    }
    constructor(coinsMap, url = "https://api.kraken.com/0", httpRequestTimeout){
        super(coinsMap, url, httpRequestTimeout);
    }
}
exports.KrakenPriceProvider = KrakenPriceProvider;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/RedundantSwapPrice.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RedundantSwapPrice = void 0;
const BinancePriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/BinancePriceProvider.js [app-client] (ecmascript)");
const OKXPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/OKXPriceProvider.js [app-client] (ecmascript)");
const CoinGeckoPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CoinGeckoPriceProvider.js [app-client] (ecmascript)");
const CoinPaprikaPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CoinPaprikaPriceProvider.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const ICachedSwapPrice_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ICachedSwapPrice.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const KrakenPriceProvider_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/KrakenPriceProvider.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("RedundantSwapPrice: ");
/**
 * Swap price API using multiple price sources, handles errors on the APIs and automatically switches between them, such
 *  that there always is a functional API
 */ class RedundantSwapPrice extends ICachedSwapPrice_1.ICachedSwapPrice {
    static createFromTokenMap(maxAllowedFeeDiffPPM, assets, cacheTimeout) {
        const priceApis = [
            new BinancePriceProvider_1.BinancePriceProvider(assets.map((coinData)=>{
                return {
                    coinId: coinData.binancePair,
                    chains: coinData.chains
                };
            })),
            new OKXPriceProvider_1.OKXPriceProvider(assets.map((coinData)=>{
                return {
                    coinId: coinData.okxPair,
                    chains: coinData.chains
                };
            })),
            new CoinGeckoPriceProvider_1.CoinGeckoPriceProvider(assets.map((coinData)=>{
                return {
                    coinId: coinData.coinGeckoCoinId,
                    chains: coinData.chains
                };
            })),
            new CoinPaprikaPriceProvider_1.CoinPaprikaPriceProvider(assets.map((coinData)=>{
                return {
                    coinId: coinData.coinPaprikaCoinId,
                    chains: coinData.chains
                };
            })),
            new KrakenPriceProvider_1.KrakenPriceProvider(assets.map((coinData)=>{
                return {
                    coinId: coinData.krakenPair,
                    chains: coinData.chains
                };
            }))
        ];
        return new RedundantSwapPrice(maxAllowedFeeDiffPPM, assets, priceApis, cacheTimeout);
    }
    /**
     * Returns price api that should be operational
     *
     * @private
     */ getOperationalPriceApi() {
        return this.priceApis.find((e)=>e.operational === true);
    }
    /**
     * Returns price apis that are maybe operational, in case none is considered operational returns all of the price
     *  apis such that they can be tested again whether they are operational
     *
     * @private
     */ getMaybeOperationalPriceApis() {
        let operational = this.priceApis.filter((e)=>e.operational === true || e.operational === null);
        if (operational.length === 0) {
            this.priceApis.forEach((e)=>e.operational = null);
            operational = this.priceApis;
        }
        return operational;
    }
    /**
     * Fetches price in parallel from multiple maybe operational price APIs
     *
     * @param chainIdentifier
     * @param token
     * @param abortSignal
     * @private
     */ async fetchPriceFromMaybeOperationalPriceApis(chainIdentifier, token, abortSignal) {
        try {
            return await (0, Utils_1.promiseAny)(this.getMaybeOperationalPriceApis().map((obj)=>(async ()=>{
                    try {
                        const price = await obj.priceApi.getPrice(chainIdentifier, token, abortSignal);
                        logger.debug("fetchPrice(): Price from " + obj.priceApi.constructor.name + ": ", price.toString(10));
                        obj.operational = true;
                        return price;
                    } catch (e) {
                        if (abortSignal != null) abortSignal.throwIfAborted();
                        obj.operational = false;
                        throw e;
                    }
                })()));
        } catch (e) {
            if (abortSignal != null) abortSignal.throwIfAborted();
            throw e.find((err)=>!(err instanceof RequestError_1.RequestError)) || e[0];
        }
    }
    /**
     * Fetches the prices, first tries to use the operational price API (if any) and if that fails it falls back
     *  to using maybe operational price APIs
     *
     * @param chainIdentifier
     * @param token
     * @param abortSignal
     * @private
     */ fetchPrice(chainIdentifier, token, abortSignal) {
        return (0, Utils_1.tryWithRetries)(async ()=>{
            const operationalPriceApi = this.getOperationalPriceApi();
            if (operationalPriceApi != null) {
                try {
                    return await operationalPriceApi.priceApi.getPrice(chainIdentifier, token, abortSignal);
                } catch (err) {
                    if (abortSignal != null) abortSignal.throwIfAborted();
                    operationalPriceApi.operational = false;
                    return await this.fetchPriceFromMaybeOperationalPriceApis(chainIdentifier, token, abortSignal);
                }
            }
            return await this.fetchPriceFromMaybeOperationalPriceApis(chainIdentifier, token, abortSignal);
        }, null, RequestError_1.RequestError, abortSignal);
    }
    getDecimals(chainIdentifier, token) {
        if (this.coinsDecimals[chainIdentifier] == null) return null;
        return this.coinsDecimals[chainIdentifier][token.toString()];
    }
    /**
     * Fetches BTC price in USD in parallel from multiple maybe operational price APIs
     *
     * @param abortSignal
     * @private
     */ async fetchUsdPriceFromMaybeOperationalPriceApis(abortSignal) {
        try {
            return await (0, Utils_1.promiseAny)(this.getMaybeOperationalPriceApis().map((obj)=>(async ()=>{
                    try {
                        const price = await obj.priceApi.getUsdPrice(abortSignal);
                        logger.debug("fetchPrice(): USD price from " + obj.priceApi.constructor.name + ": ", price.toString(10));
                        obj.operational = true;
                        return price;
                    } catch (e) {
                        if (abortSignal != null) abortSignal.throwIfAborted();
                        obj.operational = false;
                        throw e;
                    }
                })()));
        } catch (e) {
            if (abortSignal != null) abortSignal.throwIfAborted();
            throw e.find((err)=>!(err instanceof RequestError_1.RequestError)) || e[0];
        }
    }
    fetchUsdPrice(abortSignal) {
        return (0, Utils_1.tryWithRetries)(()=>{
            const operationalPriceApi = this.getOperationalPriceApi();
            if (operationalPriceApi != null) {
                return operationalPriceApi.priceApi.getUsdPrice(abortSignal).catch((err)=>{
                    if (abortSignal != null) abortSignal.throwIfAborted();
                    operationalPriceApi.operational = false;
                    return this.fetchUsdPriceFromMaybeOperationalPriceApis(abortSignal);
                });
            }
            return this.fetchUsdPriceFromMaybeOperationalPriceApis(abortSignal);
        }, null, RequestError_1.RequestError, abortSignal);
    }
    constructor(maxAllowedFeeDiffPPM, coinsDecimals, priceApis, cacheTimeout){
        super(maxAllowedFeeDiffPPM, cacheTimeout);
        this.coinsDecimals = {};
        for (let coinData of coinsDecimals){
            for(let chainId in coinData.chains){
                var _this_coinsDecimals, _chainId;
                const { address, decimals } = coinData.chains[chainId];
                var _;
                (_ = (_this_coinsDecimals = this.coinsDecimals)[_chainId = chainId]) !== null && _ !== void 0 ? _ : _this_coinsDecimals[_chainId] = {};
                this.coinsDecimals[chainId][address.toString()] = decimals;
            }
        }
        this.priceApis = priceApis.map((api)=>{
            return {
                priceApi: api,
                operational: null
            };
        });
    }
}
exports.RedundantSwapPrice = RedundantSwapPrice;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/SingleSwapPrice.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SingleSwapPrice = void 0;
const ICachedSwapPrice_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ICachedSwapPrice.js [app-client] (ecmascript)");
/**
 * Swap price API using single price source
 */ class SingleSwapPrice extends ICachedSwapPrice_1.ICachedSwapPrice {
    /**
     * Fetch price in uSats (micro sats) for a given token against BTC
     *
     * @param chainIdentifier
     * @param token
     * @param abortSignal
     * @protected
     * @returns token price in uSats (micro sats)
     */ fetchPrice(chainIdentifier, token, abortSignal) {
        return this.priceProvider.getPrice(chainIdentifier, token, abortSignal);
    }
    /**
     * Returns the decimal places of the specified token, or -1 if token should be ignored, returns null if
     *  token is not found
     *
     * @param chainIdentifier
     * @param token
     * @protected
     */ getDecimals(chainIdentifier, token) {
        return this.priceProvider.getDecimals(chainIdentifier, token.toString());
    }
    fetchUsdPrice(abortSignal) {
        return this.priceProvider.getUsdPrice(abortSignal);
    }
    constructor(maxAllowedFeeDiffPPM, priceProvider, cacheTimeout){
        super(maxAllowedFeeDiffPPM, cacheTimeout);
        this.priceProvider = priceProvider;
    }
}
exports.SingleSwapPrice = SingleSwapPrice;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/SwapPriceWithChain.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SwapPriceWithChain = void 0;
class SwapPriceWithChain {
    /**
     * Checks whether the swap amounts are valid given the current market rate for a given pair
     *
     * @param amountSats Amount of sats (BTC) to be received from the swap
     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary
     * @param feePPM PPM fee rate as reported by the intermediary
     * @param paidToken Amount of token to be paid to the swap
     * @param token
     * @param abortSignal
     * @param preFetchedPrice Already pre-fetched price
     */ async isValidAmountSend(amountSats, satsBaseFee, feePPM, paidToken, token, abortSignal, preFetchedPrice) {
        return this.swapPrice.isValidAmountSend(this.chainIdentifier, amountSats, satsBaseFee, feePPM, paidToken, token, abortSignal, preFetchedPrice);
    }
    /**
     * Checks whether the swap amounts are valid given the current market rate for a given pair
     *
     * @param amountSats Amount of sats (BTC) to be paid to the swap
     * @param satsBaseFee Base fee in sats (BTC) as reported by the intermediary
     * @param feePPM PPM fee rate as reported by the intermediary
     * @param receiveToken Amount of token to be received from the swap
     * @param token
     * @param abortSignal
     * @param preFetchedPrice Already pre-fetched price
     */ async isValidAmountReceive(amountSats, satsBaseFee, feePPM, receiveToken, token, abortSignal, preFetchedPrice) {
        return this.swapPrice.isValidAmountReceive(this.chainIdentifier, amountSats, satsBaseFee, feePPM, receiveToken, token, abortSignal, preFetchedPrice);
    }
    preFetchPrice(token, abortSignal) {
        return this.swapPrice.preFetchPrice(this.chainIdentifier, token, abortSignal);
    }
    preFetchUsdPrice(abortSignal) {
        return this.swapPrice.preFetchUsdPrice(abortSignal);
    }
    /**
     * Returns amount of {toToken} that are equivalent to {fromAmount} satoshis
     *
     * @param fromAmount        Amount of satoshis
     * @param toToken           Token
     * @param abortSignal
     * @param preFetchedPrice
     * @throws {Error} when token is not found
     */ async getFromBtcSwapAmount(fromAmount, toToken, abortSignal, preFetchedPrice) {
        return this.swapPrice.getFromBtcSwapAmount(this.chainIdentifier, fromAmount, toToken, abortSignal, preFetchedPrice);
    }
    /**
     * Returns amount of satoshis that are equivalent to {fromAmount} of {fromToken}
     *
     * @param fromAmount Amount of the token
     * @param fromToken Token
     * @param abortSignal
     * @param preFetchedPrice Pre-fetched swap price if available
     * @throws {Error} when token is not found
     */ async getToBtcSwapAmount(fromAmount, fromToken, abortSignal, preFetchedPrice) {
        return this.swapPrice.getToBtcSwapAmount(this.chainIdentifier, fromAmount, fromToken, abortSignal, preFetchedPrice);
    }
    /**
     * Returns whether the token should be ignored and pricing for it not calculated
     *
     * @param tokenAddress
     * @throws {Error} if token is not found
     */ shouldIgnore(tokenAddress) {
        return this.swapPrice.shouldIgnore(this.chainIdentifier, tokenAddress);
    }
    async getBtcUsdValue(btcSats, abortSignal, preFetchedPrice) {
        return this.swapPrice.getBtcUsdValue(btcSats, abortSignal, preFetchedPrice);
    }
    async getTokenUsdValue(tokenAmount, token, abortSignal, preFetchedPrice) {
        return this.swapPrice.getTokenUsdValue(this.chainIdentifier, tokenAmount, token, abortSignal, preFetchedPrice);
    }
    getUsdValue(amount, token, abortSignal, preFetchedUsdPrice) {
        return this.swapPrice.getUsdValue(amount, token, abortSignal, preFetchedUsdPrice);
    }
    constructor(swapPrice, chainIdentifier){
        this.swapPrice = swapPrice;
        this.chainIdentifier = chainIdentifier;
    }
}
exports.SwapPriceWithChain = SwapPriceWithChain;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toTokenAmount = exports.toDecimal = exports.fromDecimal = exports.isToken = exports.isSCToken = exports.BitcoinTokens = exports.isBtcToken = void 0;
function isBtcToken(obj) {
    return typeof obj === "object" && obj.chain === "BTC" && typeof obj.lightning === "boolean" && typeof obj.ticker === "string" && typeof obj.decimals === "number" && typeof obj.name === "string";
}
exports.isBtcToken = isBtcToken;
exports.BitcoinTokens = {
    BTC: {
        chain: "BTC",
        lightning: false,
        ticker: "BTC",
        decimals: 8,
        name: "Bitcoin (on-chain L1)"
    },
    BTCLN: {
        chain: "BTC",
        lightning: true,
        ticker: "BTC",
        decimals: 8,
        name: "Bitcoin (lightning L2)"
    }
};
function isSCToken(obj) {
    return typeof obj === "object" && obj.chain === "SC" && typeof obj.chainId === "string" && typeof obj.address === "string" && typeof obj.ticker === "string" && typeof obj.decimals === "number" && typeof obj.name === "string";
}
exports.isSCToken = isSCToken;
function isToken(obj) {
    return isBtcToken(obj) || isSCToken(obj);
}
exports.isToken = isToken;
function fromDecimal(amount, decimalCount) {
    if (amount.includes(".")) {
        const [before, after] = amount.split(".");
        if (decimalCount < 0) {
            return BigInt(before.substring(0, before.length + decimalCount));
        }
        if (after.length > decimalCount) {
            //Cut the last digits
            return BigInt((before === "0" ? "" : before) + after.substring(0, decimalCount));
        }
        return BigInt((before === "0" ? "" : before) + after.padEnd(decimalCount, "0"));
    } else {
        if (decimalCount < 0) {
            return BigInt(amount.substring(0, amount.length + decimalCount));
        } else {
            return BigInt(amount + "0".repeat(decimalCount));
        }
    }
}
exports.fromDecimal = fromDecimal;
function toDecimal(amount, decimalCount, cut, displayDecimals) {
    if (decimalCount <= 0) {
        return amount.toString(10) + "0".repeat(-decimalCount);
    }
    const amountStr = amount.toString(10).padStart(decimalCount + 1, "0");
    const splitPoint = amountStr.length - decimalCount;
    const decimalPart = amountStr.substring(splitPoint, amountStr.length);
    let cutTo = decimalPart.length;
    if (cut && cutTo > 0) {
        for(let i = decimalPart.length - 1; i--; i >= 0){
            if (decimalPart.charAt(i) === "0") {
                cutTo = i;
            } else break;
        }
        if (cutTo === 0) cutTo = 1;
    }
    if (displayDecimals === 0) return amountStr.substring(0, splitPoint);
    if (displayDecimals != null && cutTo > displayDecimals) cutTo = displayDecimals;
    return amountStr.substring(0, splitPoint) + "." + decimalPart.substring(0, cutTo);
}
exports.toDecimal = toDecimal;
function toTokenAmount(amount, token, prices) {
    if (amount == null) return null;
    let amountStr = toDecimal(amount, token.decimals, undefined, token.displayDecimals);
    return {
        rawAmount: amount,
        amount: amountStr,
        _amount: parseFloat(amountStr),
        token,
        usdValue: (abortSignal, preFetchedUsdPrice)=>prices.getUsdValue(amount, token, abortSignal, preFetchedUsdPrice),
        toString: ()=>amountStr + " " + token.ticker
    };
}
exports.toTokenAmount = toTokenAmount;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapDirection.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SwapDirection = void 0;
var SwapDirection;
(function(SwapDirection) {
    SwapDirection[SwapDirection["FROM_BTC"] = 0] = "FROM_BTC";
    SwapDirection[SwapDirection["TO_BTC"] = 1] = "TO_BTC";
})(SwapDirection = exports.SwapDirection || (exports.SwapDirection = {}));
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ISwap = exports.ppmToPercentage = exports.isISwapInit = void 0;
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const events_1 = __turbopack_context__.r("[project]/node_modules/events/events.js [app-client] (ecmascript)");
const ISwapPrice_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ISwapPrice.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const SwapDirection_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapDirection.js [app-client] (ecmascript)");
function isISwapInit(obj) {
    return typeof obj === 'object' && obj != null && (0, ISwapPrice_1.isPriceInfoType)(obj.pricingInfo) && typeof obj.url === 'string' && typeof obj.expiry === 'number' && typeof obj.swapFee === "bigint" && (obj.swapFeeBtc == null || typeof obj.swapFeeBtc === "bigint") && typeof obj.exactIn === 'boolean';
}
exports.isISwapInit = isISwapInit;
function ppmToPercentage(ppm) {
    if (ppm == null) return null;
    const percentage = Number(ppm) / 10000;
    return {
        ppm,
        decimal: Number(ppm) / 1000000,
        percentage: percentage,
        toString: (decimals)=>(decimals != null ? percentage.toFixed(decimals) : percentage) + "%"
    };
}
exports.ppmToPercentage = ppmToPercentage;
class ISwap {
    /**
     * Waits till the swap reaches a specific state
     *
     * @param targetState The state to wait for
     * @param type Whether to wait for the state exactly or also to a state with a higher number
     * @param abortSignal
     * @protected
     */ waitTillState(targetState) {
        let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "eq", abortSignal = arguments.length > 2 ? arguments[2] : void 0;
        return new Promise((resolve, reject)=>{
            let listener;
            listener = (swap)=>{
                if (type === "eq" ? swap.state === targetState : type === "gte" ? swap.state >= targetState : swap.state != targetState) {
                    resolve();
                    this.events.removeListener("swapState", listener);
                }
            };
            this.events.on("swapState", listener);
            if (abortSignal != null) abortSignal.addEventListener("abort", ()=>{
                this.events.removeListener("swapState", listener);
                reject(abortSignal.reason);
            });
        });
    }
    //////////////////////////////
    //// Pricing
    tryRecomputeSwapPrice() {
        if (this.pricingInfo.swapPriceUSatPerToken == null) {
            if (this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC) {
                const input = this.getInput();
                this.pricingInfo = this.wrapper.prices.recomputePriceInfoSend(this.chainIdentifier, this.getOutput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, input.rawAmount, input.token.address);
            } else {
                const output = this.getOutput();
                this.pricingInfo = this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier, this.getInput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, output.rawAmount, output.token.address);
            }
        }
    }
    /**
     * Re-fetches & revalidates the price data
     */ async refreshPriceData() {
        if (this.pricingInfo == null) return null;
        if (this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC) {
            const input = this.getInput();
            this.pricingInfo = await this.wrapper.prices.isValidAmountSend(this.chainIdentifier, this.getOutput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, input.rawAmount, input.token.address);
        } else {
            const output = this.getOutput();
            this.pricingInfo = await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier, this.getInput().rawAmount, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, output.rawAmount, output.token.address);
        }
    }
    /**
     * Checks if the pricing for the swap is valid, according to max allowed price difference set in the ISwapPrice
     */ hasValidPrice() {
        return this.pricingInfo == null ? null : this.pricingInfo.isValid;
    }
    /**
     * Returns pricing info about the swap
     */ getPriceInfo() {
        const swapPrice = this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC ? 100000000000000 / Number(this.pricingInfo.swapPriceUSatPerToken) : Number(this.pricingInfo.swapPriceUSatPerToken) / 100000000000000;
        const marketPrice = this.getDirection() === SwapDirection_1.SwapDirection.TO_BTC ? 100000000000000 / Number(this.pricingInfo.realPriceUSatPerToken) : Number(this.pricingInfo.swapPriceUSatPerToken) / 100000000000000;
        return {
            marketPrice,
            swapPrice,
            difference: ppmToPercentage(this.pricingInfo.differencePPM)
        };
    }
    /**
     * @param signer Signer to check with this swap's initiator
     * @throws {Error} When signer's address doesn't match with the swap's initiator one
     */ checkSigner(signer) {
        if ((typeof signer === "string" ? signer : signer.getAddress()) !== this._getInitiator()) throw new Error("Invalid signer provided!");
    }
    isInitiated() {
        return this.initiated;
    }
    _setInitiated() {
        this.initiated = true;
    }
    /**
     * Returns quote expiry in UNIX millis
     */ getQuoteExpiry() {
        return this.expiry;
    }
    /**
     * Returns the type of the swap
     */ getType() {
        return this.TYPE;
    }
    /**
     * Returns the direction of the swap
     */ getDirection() {
        return this.TYPE === SwapType_1.SwapType.TO_BTC || this.TYPE === SwapType_1.SwapType.TO_BTCLN ? SwapDirection_1.SwapDirection.TO_BTC : SwapDirection_1.SwapDirection.FROM_BTC;
    }
    /**
     * Returns the current state of the swap
     */ getState() {
        return this.state;
    }
    //////////////////////////////
    //// Storage
    serialize() {
        if (this.pricingInfo == null) return {};
        return {
            id: this.getId(),
            type: this.getType(),
            escrowHash: this._getEscrowHash(),
            initiator: this._getInitiator(),
            _isValid: this.pricingInfo.isValid,
            _differencePPM: this.pricingInfo.differencePPM == null ? null : this.pricingInfo.differencePPM.toString(10),
            _satsBaseFee: this.pricingInfo.satsBaseFee == null ? null : this.pricingInfo.satsBaseFee.toString(10),
            _feePPM: this.pricingInfo.feePPM == null ? null : this.pricingInfo.feePPM.toString(10),
            _realPriceUSatPerToken: this.pricingInfo.realPriceUSatPerToken == null ? null : this.pricingInfo.realPriceUSatPerToken.toString(10),
            _swapPriceUSatPerToken: this.pricingInfo.swapPriceUSatPerToken == null ? null : this.pricingInfo.swapPriceUSatPerToken.toString(10),
            state: this.state,
            url: this.url,
            swapFee: this.swapFee == null ? null : this.swapFee.toString(10),
            swapFeeBtc: this.swapFeeBtc == null ? null : this.swapFeeBtc.toString(10),
            expiry: this.expiry,
            version: this.version,
            initiated: this.initiated,
            exactIn: this.exactIn,
            createdAt: this.createdAt,
            randomNonce: this.randomNonce
        };
    }
    _save() {
        if (this.isQuoteExpired()) {
            return this.wrapper.removeSwapData(this);
        } else {
            return this.wrapper.saveSwapData(this);
        }
    }
    async _saveAndEmit(state) {
        if (state != null) this.state = state;
        await this._save();
        this._emitEvent();
    }
    //////////////////////////////
    //// Events
    _emitEvent() {
        this.wrapper.events.emit("swapState", this);
        this.events.emit("swapState", this);
    }
    constructor(wrapper, swapInitOrObj){
        this.currentVersion = 1;
        this.initiated = false;
        /**
         * Event emitter emitting "swapState" event when swap's state changes
         */ this.events = new events_1.EventEmitter();
        this.chainIdentifier = wrapper.chainIdentifier;
        this.wrapper = wrapper;
        if (isISwapInit(swapInitOrObj)) {
            Object.assign(this, swapInitOrObj);
            this.version = this.currentVersion;
            this.createdAt = Date.now();
            this.randomNonce = (0, Utils_1.randomBytes)(16).toString("hex");
        } else {
            this.expiry = swapInitOrObj.expiry;
            this.url = swapInitOrObj.url;
            this.state = swapInitOrObj.state;
            this.pricingInfo = {
                isValid: swapInitOrObj._isValid,
                differencePPM: swapInitOrObj._differencePPM == null ? null : BigInt(swapInitOrObj._differencePPM),
                satsBaseFee: swapInitOrObj._satsBaseFee == null ? null : BigInt(swapInitOrObj._satsBaseFee),
                feePPM: swapInitOrObj._feePPM == null ? null : BigInt(swapInitOrObj._feePPM),
                realPriceUSatPerToken: swapInitOrObj._realPriceUSatPerToken == null ? null : BigInt(swapInitOrObj._realPriceUSatPerToken),
                swapPriceUSatPerToken: swapInitOrObj._swapPriceUSatPerToken == null ? null : BigInt(swapInitOrObj._swapPriceUSatPerToken)
            };
            this.swapFee = swapInitOrObj.swapFee == null ? null : BigInt(swapInitOrObj.swapFee);
            this.swapFeeBtc = swapInitOrObj.swapFeeBtc == null ? null : BigInt(swapInitOrObj.swapFeeBtc);
            this.version = swapInitOrObj.version;
            this.initiated = swapInitOrObj.initiated;
            this.exactIn = swapInitOrObj.exactIn;
            var _swapInitOrObj_createdAt;
            this.createdAt = (_swapInitOrObj_createdAt = swapInitOrObj.createdAt) !== null && _swapInitOrObj_createdAt !== void 0 ? _swapInitOrObj_createdAt : swapInitOrObj.expiry;
            this.randomNonce = swapInitOrObj.randomNonce;
        }
        if (this.version !== this.currentVersion) {
            this.upgradeVersion();
        }
        if (this.initiated == null) this.initiated = true;
    }
}
exports.ISwap = ISwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/IAddressSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwapWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ISwapWrapper = void 0;
const events_1 = __turbopack_context__.r("[project]/node_modules/events/events.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class ISwapWrapper {
    /**
     * Pre-fetches swap price for a given swap
     *
     * @param amountData
     * @param abortSignal
     * @protected
     * @returns Price of the token in uSats (micro sats)
     */ preFetchPrice(amountData, abortSignal) {
        return this.prices.preFetchPrice(this.chainIdentifier, amountData.token, abortSignal).catch((e)=>{
            this.logger.error("preFetchPrice(): Error: ", e);
            return null;
        });
    }
    /**
     * Verifies returned  price for swaps
     *
     * @param lpServiceData Service data for the service in question (TO_BTCLN, TO_BTC, etc.) of the given intermediary
     * @param send Whether this is a send (SOL -> SC) or receive (BTC -> SC) swap
     * @param amountSats Amount in BTC
     * @param amountToken Amount in token
     * @param token Token used in the swap
     * @param feeData Fee data as returned by the intermediary
     * @param pricePrefetchPromise Price pre-fetch promise
     * @param abortSignal
     * @protected
     * @returns Price info object
     * @throws {IntermediaryError} if the calculated fee is too high
     */ async verifyReturnedPrice(lpServiceData, send, amountSats, amountToken, token, feeData) {
        let pricePrefetchPromise = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : Promise.resolve(null), abortSignal = arguments.length > 7 ? arguments[7] : void 0;
        const swapBaseFee = BigInt(lpServiceData.swapBaseFee);
        const swapFeePPM = BigInt(lpServiceData.swapFeePPM);
        if (send) amountToken = amountToken - feeData.networkFee;
        const isValidAmount = await (send ? this.prices.isValidAmountSend(this.chainIdentifier, amountSats, swapBaseFee, swapFeePPM, amountToken, token, abortSignal, await pricePrefetchPromise) : this.prices.isValidAmountReceive(this.chainIdentifier, amountSats, swapBaseFee, swapFeePPM, amountToken, token, abortSignal, await pricePrefetchPromise));
        if (!isValidAmount.isValid) throw new IntermediaryError_1.IntermediaryError("Fee too high");
        return isValidAmount;
    }
    /**
     * Initializes the swap wrapper, needs to be called before any other action can be taken
     */ async init() {
        let noTimers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false, noCheckPastSwaps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (this.isInitialized) return;
        const hasEventListener = this.processEvent != null;
        //Save events received in the meantime into the event queue and process them only after we've checked and
        // processed all the past swaps
        let eventQueue = [];
        const initListener = (event, swap)=>{
            eventQueue.push({
                event,
                swap
            });
            return Promise.resolve();
        };
        if (hasEventListener) this.unifiedChainEvents.registerListener(this.TYPE, initListener, this.swapDeserializer.bind(null, this));
        if (!noCheckPastSwaps) await this.checkPastSwaps();
        if (hasEventListener) {
            //Process accumulated event queue
            for (let event of eventQueue){
                await this.processEvent(event.event, event.swap);
            }
            //Register the correct event handler
            this.unifiedChainEvents.unregisterListener(this.TYPE);
            this.unifiedChainEvents.registerListener(this.TYPE, this.processEvent.bind(this), this.swapDeserializer.bind(null, this));
        }
        if (!noTimers) this.startTickInterval();
        // this.logger.info("init(): Swap wrapper initialized");
        this.isInitialized = true;
    }
    startTickInterval() {
        if (this.tickSwapState == null || this.tickSwapState.length === 0) return;
        this.tickInterval = setInterval(()=>{
            this.tick();
        }, 1000);
    }
    async checkPastSwaps(pastSwaps) {
        if (pastSwaps == null) pastSwaps = await this.unifiedStorage.query([
            [
                {
                    key: "type",
                    value: this.TYPE
                },
                {
                    key: "state",
                    value: this.pendingSwapStates
                }
            ]
        ], (val)=>new this.swapDeserializer(this, val));
        //Check past swaps
        const changedSwaps = [];
        const removeSwaps = [];
        await Promise.all(pastSwaps.map((swap)=>swap._sync(false).then((changed)=>{
                if (swap.isQuoteExpired()) {
                    removeSwaps.push(swap);
                    this.logger.debug("init(): Removing expired swap: " + swap.getId());
                } else {
                    if (changed) changedSwaps.push(swap);
                }
            }).catch((e)=>this.logger.error("init(): Error when checking swap " + swap.getId() + ": ", e))));
        await this.unifiedStorage.removeAll(removeSwaps);
        await this.unifiedStorage.saveAll(changedSwaps);
    }
    async tick(swaps) {
        if (swaps == null) swaps = await this.unifiedStorage.query([
            [
                {
                    key: "type",
                    value: this.TYPE
                },
                {
                    key: "state",
                    value: this.tickSwapState
                }
            ]
        ], (val)=>new this.swapDeserializer(this, val));
        for (let pendingSwap of this.pendingSwaps.values()){
            const value = pendingSwap.deref();
            if (value != null) value._tick(true);
        }
        swaps.forEach((value)=>{
            value._tick(true);
        });
    }
    saveSwapData(swap) {
        if (!swap.isInitiated()) {
            this.logger.debug("saveSwapData(): Swap " + swap.getId() + " not initiated, saving to pending swaps");
            this.pendingSwaps.set(swap.getId(), new WeakRef(swap));
            return Promise.resolve();
        } else {
            this.pendingSwaps.delete(swap.getId());
        }
        return this.unifiedStorage.save(swap);
    }
    removeSwapData(swap) {
        this.pendingSwaps.delete(swap.getId());
        if (!swap.isInitiated()) return Promise.resolve();
        return this.unifiedStorage.remove(swap);
    }
    /**
     * Un-subscribes from event listeners on Solana
     */ async stop() {
        this.isInitialized = false;
        this.unifiedChainEvents.unregisterListener(this.TYPE);
        this.logger.info("stop(): Swap wrapper stopped");
        if (this.tickInterval != null) clearInterval(this.tickInterval);
    }
    /**
     * Returns the smart chain's native token used to pay for fees
     */ getNativeToken() {
        return this.tokens[this.chain.getNativeCurrencyAddress()];
    }
    /**
     * @param chainIdentifier
     * @param unifiedStorage
     * @param unifiedChainEvents
     * @param chain
     * @param contract Underlying contract handling the swaps
     * @param prices Swap pricing handler
     * @param tokens Chain specific token data
     * @param swapDataDeserializer Deserializer for SwapData
     * @param options
     * @param events Instance to use for emitting events
     */ constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events){
        this.logger = (0, Utils_1.getLogger)(this.constructor.name + ": ");
        this.pendingSwaps = new Map();
        this.isInitialized = false;
        this.tickInterval = null;
        this.unifiedStorage = unifiedStorage;
        this.unifiedChainEvents = unifiedChainEvents;
        this.chainIdentifier = chainIdentifier;
        this.chain = chain;
        this.prices = prices;
        this.events = events || new events_1.EventEmitter();
        this.options = options;
        this.tokens = {};
        for (let tokenData of tokens){
            const chainData = tokenData.chains[chainIdentifier];
            if (chainData == null) continue;
            this.tokens[chainData.address] = {
                chain: "SC",
                chainId: this.chainIdentifier,
                address: chainData.address,
                decimals: chainData.decimals,
                ticker: tokenData.ticker,
                name: tokenData.name,
                displayDecimals: chainData.displayDecimals
            };
        }
    }
}
exports.ISwapWrapper = ISwapWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IEscrowSwap = exports.isIEscrowSwapInit = void 0;
const ISwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
function isIEscrowSwapInit(obj) {
    return typeof obj === 'object' && obj.feeRate != null && (obj.signatureData == null || typeof obj.signatureData === 'object' && typeof obj.signatureData.prefix === "string" && typeof obj.signatureData.timeout === "string" && typeof obj.signatureData.signature === "string") && (obj.data == null || typeof obj.data === 'object') && (0, ISwap_1.isISwapInit)(obj);
}
exports.isIEscrowSwapInit = isIEscrowSwapInit;
class IEscrowSwap extends ISwap_1.ISwap {
    //////////////////////////////
    //// Identifiers
    /**
     * Returns the identification hash of the swap, usually claim data hash, but can be overriden, e.g. for
     *  lightning swaps the identifier hash is used instead of claim data hash
     */ getIdentifierHash() {
        const claimHashBuffer = buffer_1.Buffer.from(this.getClaimHash(), "hex");
        if (this.randomNonce == null) return claimHashBuffer;
        return buffer_1.Buffer.concat([
            claimHashBuffer,
            buffer_1.Buffer.from(this.randomNonce, "hex")
        ]);
    }
    /**
     * Returns the identification hash of the swap, usually claim data hash, but can be overriden, e.g. for
     *  lightning swaps the identifier hash is used instead of claim data hash
     */ getIdentifierHashString() {
        const identifierHash = this.getIdentifierHash();
        if (identifierHash == null) return null;
        return identifierHash.toString("hex");
    }
    _getEscrowHash() {
        var _this_data;
        return (_this_data = this.data) === null || _this_data === void 0 ? void 0 : _this_data.getEscrowHash();
    }
    /**
     * Returns the escrow hash - i.e. hash of the escrow data
     */ getEscrowHash() {
        return this._getEscrowHash();
    }
    /**
     * Returns the claim data hash - i.e. hash passed to the claim handler
     */ getClaimHash() {
        var _this_data;
        return (_this_data = this.data) === null || _this_data === void 0 ? void 0 : _this_data.getClaimHash();
    }
    getId() {
        return this.getIdentifierHashString();
    }
    //////////////////////////////
    //// Watchdogs
    /**
     * Periodically checks for init signature's expiry
     *
     * @param abortSignal
     * @param interval How often to check (in seconds), default to 5s
     * @protected
     */ async watchdogWaitTillSignatureExpiry(abortSignal) {
        let interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        let expired = false;
        while(!expired){
            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);
            try {
                expired = await this.wrapper.contract.isInitAuthorizationExpired(this.data, this.signatureData);
            } catch (e) {
                this.logger.error("watchdogWaitTillSignatureExpiry(): Error when checking signature expiry: ", e);
            }
        }
        if (abortSignal != null) abortSignal.throwIfAborted();
    }
    /**
     * Periodically checks the chain to see whether the swap is committed
     *
     * @param abortSignal
     * @param interval How often to check (in seconds), default to 5s
     * @protected
     */ async watchdogWaitTillCommited(abortSignal) {
        let interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        let status = {
            type: base_1.SwapCommitStateType.NOT_COMMITED
        };
        while((status === null || status === void 0 ? void 0 : status.type) === base_1.SwapCommitStateType.NOT_COMMITED){
            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);
            try {
                status = await this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data);
                if ((status === null || status === void 0 ? void 0 : status.type) === base_1.SwapCommitStateType.NOT_COMMITED && await this.wrapper.contract.isInitAuthorizationExpired(this.data, this.signatureData)) return false;
            } catch (e) {
                this.logger.error("watchdogWaitTillCommited(): Error when fetching commit status or signature expiry: ", e);
            }
        }
        if (abortSignal != null) abortSignal.throwIfAborted();
        return true;
    }
    /**
     * Periodically checks the chain to see whether the swap was finished (claimed or refunded)
     *
     * @param abortSignal
     * @param interval How often to check (in seconds), default to 5s
     * @protected
     */ async watchdogWaitTillResult(abortSignal) {
        let interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        let status = {
            type: base_1.SwapCommitStateType.COMMITED
        };
        while((status === null || status === void 0 ? void 0 : status.type) === base_1.SwapCommitStateType.COMMITED || (status === null || status === void 0 ? void 0 : status.type) === base_1.SwapCommitStateType.REFUNDABLE){
            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);
            try {
                status = await this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data);
            } catch (e) {
                this.logger.error("watchdogWaitTillResult(): Error when fetching commit status: ", e);
            }
        }
        if (abortSignal != null) abortSignal.throwIfAborted();
        return status;
    }
    //////////////////////////////
    //// Quote verification
    /**
     * Checks if the swap's quote is expired for good (i.e. the swap strictly cannot be committed on-chain anymore)
     */ async verifyQuoteDefinitelyExpired() {
        return (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.isInitAuthorizationExpired(this.data, this.signatureData));
    }
    /**
     * Checks if the swap's quote is still valid
     */ async verifyQuoteValid() {
        try {
            await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.isValidInitAuthorization(this._getInitiator(), this.data, this.signatureData, this.feeRate), null, base_1.SignatureVerificationError);
            return true;
        } catch (e) {
            if (e instanceof base_1.SignatureVerificationError) {
                return false;
            }
        }
    }
    //////////////////////////////
    //// Amounts & fees
    /**
     * Get the estimated smart chain fee of the commit transaction
     */ getCommitFee() {
        return this.wrapper.contract.getCommitFee(this.data, this.feeRate);
    }
    /**
     * Returns the transaction fee paid on the smart chain
     */ async getSmartChainNetworkFee() {
        const swapContract = this.wrapper.contract;
        return (0, Tokens_1.toTokenAmount)(await (swapContract.getRawCommitFee != null ? swapContract.getRawCommitFee(this.data, this.feeRate) : swapContract.getCommitFee(this.data, this.feeRate)), this.wrapper.getNativeToken(), this.wrapper.prices);
    }
    serialize() {
        var _this_signatureData, _this_signatureData1, _this_signatureData2;
        return {
            ...super.serialize(),
            data: this.data != null ? this.data.serialize() : null,
            prefix: (_this_signatureData = this.signatureData) === null || _this_signatureData === void 0 ? void 0 : _this_signatureData.prefix,
            timeout: (_this_signatureData1 = this.signatureData) === null || _this_signatureData1 === void 0 ? void 0 : _this_signatureData1.timeout,
            signature: (_this_signatureData2 = this.signatureData) === null || _this_signatureData2 === void 0 ? void 0 : _this_signatureData2.signature,
            feeRate: this.feeRate == null ? null : this.feeRate.toString(),
            commitTxId: this.commitTxId,
            claimTxId: this.claimTxId,
            refundTxId: this.refundTxId
        };
    }
    constructor(wrapper, swapInitOrObj){
        super(wrapper, swapInitOrObj);
        if (!isIEscrowSwapInit(swapInitOrObj)) {
            this.data = swapInitOrObj.data != null ? new wrapper.swapDataDeserializer(swapInitOrObj.data) : null;
            this.signatureData = swapInitOrObj.signature == null ? null : {
                prefix: swapInitOrObj.prefix,
                timeout: swapInitOrObj.timeout,
                signature: swapInitOrObj.signature
            };
            this.feeRate = swapInitOrObj.feeRate;
            this.commitTxId = swapInitOrObj.commitTxId;
            this.claimTxId = swapInitOrObj.claimTxId;
            this.refundTxId = swapInitOrObj.refundTxId;
        }
    }
}
exports.IEscrowSwap = IEscrowSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FeeType = void 0;
var FeeType;
(function(FeeType) {
    FeeType[FeeType["SWAP"] = 0] = "SWAP";
    FeeType[FeeType["NETWORK_OUTPUT"] = 1] = "NETWORK_OUTPUT";
})(FeeType = exports.FeeType || (exports.FeeType = {}));
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ToBTCSwapState = exports.IToBTCSwap = exports.isIToBTCSwapInit = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const IEscrowSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwap.js [app-client] (ecmascript)");
const Fee_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js [app-client] (ecmascript)");
const ISwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)");
function isIToBTCSwapInit(obj) {
    return typeof obj.networkFee === "bigint" && (obj.networkFeeBtc == null || typeof obj.networkFeeBtc === "bigint") && (0, IEscrowSwap_1.isIEscrowSwapInit)(obj);
}
exports.isIToBTCSwapInit = isIToBTCSwapInit;
class IToBTCSwap extends IEscrowSwap_1.IEscrowSwap {
    upgradeVersion() {
        if (this.version == null) {
            switch(this.state){
                case -2:
                    this.state = ToBTCSwapState.REFUNDED;
                    break;
                case -1:
                    this.state = ToBTCSwapState.QUOTE_EXPIRED;
                    break;
                case 0:
                    this.state = ToBTCSwapState.CREATED;
                    break;
                case 1:
                    this.state = ToBTCSwapState.COMMITED;
                    break;
                case 2:
                    this.state = ToBTCSwapState.CLAIMED;
                    break;
                case 3:
                    this.state = ToBTCSwapState.REFUNDABLE;
                    break;
            }
            this.version = 1;
        }
    }
    /**
     * In case swapFee in BTC is not supplied it recalculates it based on swap price
     * @protected
     */ tryRecomputeSwapPrice() {
        if (this.swapFeeBtc == null) {
            this.swapFeeBtc = this.swapFee * this.getOutput().rawAmount / this.getInputWithoutFee().rawAmount;
        }
        if (this.networkFeeBtc == null) {
            this.networkFeeBtc = this.networkFee * this.getOutput().rawAmount / this.getInputWithoutFee().rawAmount;
        }
        super.tryRecomputeSwapPrice();
    }
    /**
     * Returns the payment hash identifier to be sent to the LP for getStatus and getRefund
     * @protected
     */ getLpIdentifier() {
        return this.getClaimHash();
    }
    //////////////////////////////
    //// Getters & utils
    getInputTxId() {
        return this.commitTxId;
    }
    requiresAction() {
        return this.isRefundable();
    }
    /**
     * Returns whether the swap is finished and in its terminal state (this can mean successful, refunded or failed)
     */ isFinished() {
        return this.state === ToBTCSwapState.CLAIMED || this.state === ToBTCSwapState.REFUNDED || this.state === ToBTCSwapState.QUOTE_EXPIRED;
    }
    isRefundable() {
        return this.state === ToBTCSwapState.REFUNDABLE;
    }
    isQuoteExpired() {
        return this.state === ToBTCSwapState.QUOTE_EXPIRED;
    }
    isQuoteSoftExpired() {
        return this.state === ToBTCSwapState.QUOTE_EXPIRED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED;
    }
    isSuccessful() {
        return this.state === ToBTCSwapState.CLAIMED;
    }
    isFailed() {
        return this.state === ToBTCSwapState.REFUNDED;
    }
    _getInitiator() {
        return this.data.getOfferer();
    }
    //////////////////////////////
    //// Amounts & fees
    getSwapFee() {
        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;
        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getOutput().rawAmount;
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, this.outputToken, this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),
            composition: {
                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, this.outputToken, this.wrapper.prices),
                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)
            }
        };
    }
    /**
     * Returns network fee for the swap, the fee is represented in source currency & destination currency, but is
     *  paid only once
     */ getNetworkFee() {
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.networkFee, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.networkFeeBtc, this.outputToken, this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(this.networkFeeBtc, abortSignal, preFetchedUsdPrice)
        };
    }
    getFee() {
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFee + this.networkFee, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc + this.networkFeeBtc, this.outputToken, this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc + this.networkFeeBtc, abortSignal, preFetchedUsdPrice)
        };
    }
    getFeeBreakdown() {
        return [
            {
                type: Fee_1.FeeType.SWAP,
                fee: this.getSwapFee()
            },
            {
                type: Fee_1.FeeType.NETWORK_OUTPUT,
                fee: this.getNetworkFee()
            }
        ];
    }
    getInput() {
        return (0, Tokens_1.toTokenAmount)(this.data.getAmount(), this.wrapper.tokens[this.data.getToken()], this.wrapper.prices);
    }
    getInputWithoutFee() {
        return (0, Tokens_1.toTokenAmount)(this.data.getAmount() - (this.swapFee + this.networkFee), this.wrapper.tokens[this.data.getToken()], this.wrapper.prices);
    }
    /**
     * Checks if the intiator/sender has enough balance to go through with the swap
     */ async hasEnoughBalance() {
        const [balance, commitFee] = await Promise.all([
            this.wrapper.contract.getBalance(this._getInitiator(), this.data.getToken(), false),
            this.data.getToken() === this.wrapper.chain.getNativeCurrencyAddress() ? this.getCommitFee() : Promise.resolve(null)
        ]);
        let required = this.data.getAmount();
        if (commitFee != null) required = required + commitFee;
        return {
            enoughBalance: balance >= required,
            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices),
            required: (0, Tokens_1.toTokenAmount)(required, this.wrapper.tokens[this.data.getToken()], this.wrapper.prices)
        };
    }
    /**
     * Check if the initiator/sender has enough balance to cover the transaction fee for processing the swap
     */ async hasEnoughForTxFees() {
        const [balance, commitFee] = await Promise.all([
            this.wrapper.contract.getBalance(this._getInitiator(), this.wrapper.chain.getNativeCurrencyAddress(), false),
            this.getCommitFee()
        ]);
        return {
            enoughBalance: balance >= commitFee,
            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.getNativeToken(), this.wrapper.prices),
            required: (0, Tokens_1.toTokenAmount)(commitFee, this.wrapper.getNativeToken(), this.wrapper.prices)
        };
    }
    //////////////////////////////
    //// Commit
    /**
     * Returns transactions for committing the swap on-chain, initiating the swap
     *
     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet
     *  (this is handled on swap creation, if you commit right after quoting, you can use skipChecks=true)
     *
     * @throws {Error} When in invalid state (not PR_CREATED)
     */ async txsCommit(skipChecks) {
        if (this.state !== ToBTCSwapState.CREATED) throw new Error("Must be in CREATED state!");
        if (!this.initiated) {
            this.initiated = true;
            await this._saveAndEmit();
        }
        return await this.wrapper.contract.txsInit(this._getInitiator(), this.data, this.signatureData, skipChecks, this.feeRate).catch((e)=>Promise.reject(e instanceof base_1.SignatureVerificationError ? new Error("Request timed out") : e));
    }
    /**
     * Commits the swap on-chain, initiating the swap
     *
     * @param signer Signer to sign the transactions with, must be the same as used in the initialization
     * @param abortSignal Abort signal
     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet
     *  (this is handled on swap creation, if you commit right after quoting, you can skipChecks)`
     * @throws {Error} If invalid signer is provided that doesn't match the swap data
     */ async commit(signer, abortSignal, skipChecks) {
        this.checkSigner(signer);
        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommit(skipChecks), true, abortSignal);
        this.commitTxId = result[result.length - 1];
        if (this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === ToBTCSwapState.QUOTE_EXPIRED) {
            await this._saveAndEmit(ToBTCSwapState.COMMITED);
        }
        return this.commitTxId;
    }
    /**
     * Waits till a swap is committed, should be called after sending the commit transactions manually
     *
     * @param abortSignal   AbortSignal
     * @throws {Error} If swap is not in the correct state (must be CREATED)
     */ async waitTillCommited(abortSignal) {
        if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.CLAIMED) return Promise.resolve();
        if (this.state !== ToBTCSwapState.CREATED && this.state !== ToBTCSwapState.QUOTE_SOFT_EXPIRED) throw new Error("Invalid state (not CREATED)");
        const abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const result = await Promise.race([
            this.watchdogWaitTillCommited(abortController.signal),
            this.waitTillState(ToBTCSwapState.COMMITED, "gte", abortController.signal).then(()=>0)
        ]);
        abortController.abort();
        if (result === 0) this.logger.debug("waitTillCommited(): Resolved from state change");
        if (result === true) this.logger.debug("waitTillCommited(): Resolved from watchdog - commited");
        if (result === false) {
            this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expiry");
            if (this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === ToBTCSwapState.CREATED) {
                await this._saveAndEmit(ToBTCSwapState.QUOTE_EXPIRED);
                throw new Error("Quote expired while waiting for transaction confirmation!");
            }
            return;
        }
        if (this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_EXPIRED) {
            await this._saveAndEmit(ToBTCSwapState.COMMITED);
        }
    }
    //////////////////////////////
    //// Payment
    async waitTillIntermediarySwapProcessed(abortSignal) {
        let checkIntervalSeconds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        let resp = {
            code: IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING,
            msg: ""
        };
        while(!abortSignal.aborted && (resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING || resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.NOT_FOUND)){
            resp = await IntermediaryAPI_1.IntermediaryAPI.getRefundAuthorization(this.url, this.getLpIdentifier(), this.data.getSequence());
            if (resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.PAID) {
                const validResponse = await this._setPaymentResult(resp.data, true);
                if (validResponse) {
                    if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.REFUNDABLE) {
                        await this._saveAndEmit(ToBTCSwapState.SOFT_CLAIMED);
                    }
                } else {
                    resp = {
                        code: IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING,
                        msg: ""
                    };
                }
            }
            if (resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.PENDING || resp.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.NOT_FOUND) await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);
        }
        return resp;
    }
    /**
     * Checks whether the swap was already processed by the LP and is either successful (requires proof which is
     *  either a HTLC pre-image for LN swaps or valid txId for on-chain swap) or failed and we can cooperatively
     *  refund.
     *
     * @param save whether to save the data
     * @returns true if swap is processed, false if the swap is still ongoing
     * @private
     */ async checkIntermediarySwapProcessed() {
        let save = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (this.state === ToBTCSwapState.CREATED || this.state == ToBTCSwapState.QUOTE_EXPIRED) return false;
        if (this.isFinished() || this.isRefundable()) return true;
        //Check if that maybe already concluded according to the LP
        const resp = await IntermediaryAPI_1.IntermediaryAPI.getRefundAuthorization(this.url, this.getLpIdentifier(), this.data.getSequence());
        switch(resp.code){
            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.PAID:
                const processed = await this._setPaymentResult(resp.data, true);
                if (processed) {
                    this.state = ToBTCSwapState.SOFT_CLAIMED;
                    if (save) await this._saveAndEmit();
                }
                return processed;
            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.REFUND_DATA:
                await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.isValidRefundAuthorization(this.data, resp.data), null, base_1.SignatureVerificationError);
                this.state = ToBTCSwapState.REFUNDABLE;
                if (save) await this._saveAndEmit();
                return true;
            default:
                return false;
        }
    }
    /**
     * A blocking promise resolving when swap was concluded by the intermediary,
     *  rejecting in case of failure
     *
     * @param abortSignal           Abort signal
     * @param checkIntervalSeconds  How often to poll the intermediary for answer
     *
     * @returns {Promise<boolean>}  Was the payment successful? If not we can refund.
     * @throws {IntermediaryError} If a swap is determined expired by the intermediary, but it is actually still valid
     * @throws {SignatureVerificationError} If the swap should be cooperatively refundable but the intermediary returned
     *  invalid refund signature
     * @throws {Error} When swap expires or if the swap has invalid state (must be COMMITED)
     */ async waitForPayment(abortSignal, checkIntervalSeconds) {
        if (this.state === ToBTCSwapState.CLAIMED) return Promise.resolve(true);
        if (this.state !== ToBTCSwapState.COMMITED && this.state !== ToBTCSwapState.SOFT_CLAIMED) throw new Error("Invalid state (not COMMITED)");
        const abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const result = await Promise.race([
            this.waitTillState(ToBTCSwapState.CLAIMED, "gte", abortController.signal),
            this.waitTillIntermediarySwapProcessed(abortController.signal, checkIntervalSeconds)
        ]);
        abortController.abort();
        if (typeof result !== "object") {
            if (this.state === ToBTCSwapState.REFUNDABLE) throw new Error("Swap expired");
            this.logger.debug("waitTillRefunded(): Resolved from state change");
            return true;
        }
        this.logger.debug("waitTillRefunded(): Resolved from intermediary response");
        switch(result.code){
            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.PAID:
                return true;
            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.REFUND_DATA:
                await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.isValidRefundAuthorization(this.data, result.data), null, base_1.SignatureVerificationError, abortSignal);
                await this._saveAndEmit(ToBTCSwapState.REFUNDABLE);
                return false;
            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.EXPIRED:
                if (await this.wrapper.contract.isExpired(this._getInitiator(), this.data)) throw new Error("Swap expired");
                throw new IntermediaryError_1.IntermediaryError("Swap expired");
            case IntermediaryAPI_1.RefundAuthorizationResponseCodes.NOT_FOUND:
                if (this.state === ToBTCSwapState.CLAIMED) return true;
                throw new Error("Intermediary swap not found");
        }
    }
    //////////////////////////////
    //// Refund
    /**
     * Get the estimated smart chain transaction fee of the refund transaction
     */ getRefundFee() {
        return this.wrapper.contract.getRefundFee(this.data);
    }
    /**
     * Returns transactions for refunding the swap if the swap is in refundable state, you can check so with isRefundable()
     *
     * @throws {IntermediaryError} If intermediary returns invalid response in case cooperative refund should be used
     * @throws {SignatureVerificationError} If intermediary returned invalid cooperative refund signature
     * @throws {Error} When state is not refundable
     */ async txsRefund(signer) {
        if (!this.isRefundable()) throw new Error("Must be in REFUNDABLE state or expired!");
        signer !== null && signer !== void 0 ? signer : signer = this._getInitiator();
        if (await this.wrapper.contract.isExpired(this._getInitiator(), this.data)) {
            return await this.wrapper.contract.txsRefund(signer, this.data, true, true);
        } else {
            const res = await IntermediaryAPI_1.IntermediaryAPI.getRefundAuthorization(this.url, this.getLpIdentifier(), this.data.getSequence());
            if (res.code === IntermediaryAPI_1.RefundAuthorizationResponseCodes.REFUND_DATA) {
                return await this.wrapper.contract.txsRefundWithAuthorization(signer, this.data, res.data, true, true);
            }
            throw new IntermediaryError_1.IntermediaryError("Invalid intermediary cooperative message returned");
        }
    }
    /**
     * Refunds the swap if the swap is in refundable state, you can check so with isRefundable()
     *
     * @param signer Signer to sign the transactions with, must be the same as used in the initialization
     * @param abortSignal               Abort signal
     * @throws {Error} If invalid signer is provided that doesn't match the swap data
     */ async refund(signer, abortSignal) {
        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsRefund(signer.getAddress()), true, abortSignal);
        this.refundTxId = result[0];
        if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.REFUNDABLE || this.state === ToBTCSwapState.SOFT_CLAIMED) {
            await this._saveAndEmit(ToBTCSwapState.REFUNDED);
        }
        return result[0];
    }
    /**
     * Waits till a swap is refunded, should be called after sending the refund transactions manually
     *
     * @param abortSignal   AbortSignal
     * @throws {Error} When swap is not in a valid state (must be COMMITED)
     * @throws {Error} If we tried to refund but claimer was able to claim first
     */ async waitTillRefunded(abortSignal) {
        if (this.state === ToBTCSwapState.REFUNDED) return Promise.resolve();
        if (this.state !== ToBTCSwapState.COMMITED && this.state !== ToBTCSwapState.SOFT_CLAIMED) throw new Error("Invalid state (not COMMITED)");
        const abortController = new AbortController();
        if (abortSignal != null) abortSignal.addEventListener("abort", ()=>abortController.abort(abortSignal.reason));
        const res = await Promise.race([
            this.watchdogWaitTillResult(abortController.signal),
            this.waitTillState(ToBTCSwapState.REFUNDED, "eq", abortController.signal).then(()=>0),
            this.waitTillState(ToBTCSwapState.CLAIMED, "eq", abortController.signal).then(()=>1)
        ]);
        abortController.abort();
        if (res === 0) {
            this.logger.debug("waitTillRefunded(): Resolved from state change (REFUNDED)");
            return;
        }
        if (res === 1) {
            this.logger.debug("waitTillRefunded(): Resolved from state change (CLAIMED)");
            throw new Error("Tried to refund swap, but claimer claimed it in the meantime!");
        }
        this.logger.debug("waitTillRefunded(): Resolved from watchdog");
        if ((res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.PAID) {
            if (this.claimTxId == null) this.claimTxId = await res.getClaimTxId();
            await this._saveAndEmit(ToBTCSwapState.CLAIMED);
            throw new Error("Tried to refund swap, but claimer claimed it in the meantime!");
        }
        if ((res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.NOT_COMMITED) {
            if (this.refundTxId == null && res.getRefundTxId != null) this.refundTxId = await res.getRefundTxId();
            await this._saveAndEmit(ToBTCSwapState.REFUNDED);
        }
    }
    //////////////////////////////
    //// Storage
    serialize() {
        const obj = super.serialize();
        return {
            ...obj,
            networkFee: this.networkFee == null ? null : this.networkFee.toString(10),
            networkFeeBtc: this.networkFeeBtc == null ? null : this.networkFeeBtc.toString(10)
        };
    }
    //////////////////////////////
    //// Swap ticks & sync
    /**
     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain
     *  data
     *
     * @private
     */ async syncStateFromChain() {
        if (this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.SOFT_CLAIMED || this.state === ToBTCSwapState.REFUNDABLE) {
            let quoteExpired = false;
            if (this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED) {
                //Check if quote is still valid
                quoteExpired = await this.verifyQuoteDefinitelyExpired();
            }
            const res = await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));
            switch(res === null || res === void 0 ? void 0 : res.type){
                case base_1.SwapCommitStateType.PAID:
                    if (this.claimTxId == null) this.claimTxId = await res.getClaimTxId();
                    this.state = ToBTCSwapState.CLAIMED;
                    return true;
                case base_1.SwapCommitStateType.REFUNDABLE:
                    this.state = ToBTCSwapState.REFUNDABLE;
                    return true;
                case base_1.SwapCommitStateType.EXPIRED:
                    if (this.refundTxId == null && res.getRefundTxId) this.refundTxId = await res.getRefundTxId();
                    this.state = ToBTCSwapState.QUOTE_EXPIRED;
                    return true;
                case base_1.SwapCommitStateType.NOT_COMMITED:
                    if (this.refundTxId == null && res.getRefundTxId) this.refundTxId = await res.getRefundTxId();
                    if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.REFUNDABLE) {
                        this.state = ToBTCSwapState.REFUNDED;
                        return true;
                    }
                    break;
                case base_1.SwapCommitStateType.COMMITED:
                    if (this.state !== ToBTCSwapState.COMMITED && this.state !== ToBTCSwapState.REFUNDABLE) {
                        this.state = ToBTCSwapState.COMMITED;
                        return true;
                    }
                    break;
            }
            if (this.state === ToBTCSwapState.CREATED || this.state === ToBTCSwapState.QUOTE_SOFT_EXPIRED) {
                if (quoteExpired) {
                    this.state = ToBTCSwapState.QUOTE_EXPIRED;
                    return true;
                }
            }
        }
    }
    async _sync(save) {
        let changed = await this.syncStateFromChain();
        if (this.state === ToBTCSwapState.COMMITED || this.state === ToBTCSwapState.SOFT_CLAIMED) {
            //Check if that maybe already concluded
            if (await this.checkIntermediarySwapProcessed(false)) changed = true;
        }
        if (save && changed) await this._saveAndEmit();
        return changed;
    }
    async _tick(save) {
        switch(this.state){
            case ToBTCSwapState.CREATED:
                if (this.expiry < Date.now()) {
                    this.state = ToBTCSwapState.QUOTE_SOFT_EXPIRED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                break;
            case ToBTCSwapState.COMMITED:
            case ToBTCSwapState.SOFT_CLAIMED:
                const expired = await this.wrapper.contract.isExpired(this._getInitiator(), this.data);
                if (expired) {
                    this.state = ToBTCSwapState.REFUNDABLE;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                break;
        }
        return false;
    }
    constructor(wrapper, initOrObject){
        super(wrapper, initOrObject);
        if (isIToBTCSwapInit(initOrObject)) {
            this.state = ToBTCSwapState.CREATED;
        } else {
            this.networkFee = initOrObject.networkFee == null ? null : BigInt(initOrObject.networkFee);
            this.networkFeeBtc = initOrObject.networkFeeBtc == null ? null : BigInt(initOrObject.networkFeeBtc);
        }
    }
}
exports.IToBTCSwap = IToBTCSwap;
var ToBTCSwapState;
(function(ToBTCSwapState) {
    ToBTCSwapState[ToBTCSwapState["REFUNDED"] = -3] = "REFUNDED";
    ToBTCSwapState[ToBTCSwapState["QUOTE_EXPIRED"] = -2] = "QUOTE_EXPIRED";
    ToBTCSwapState[ToBTCSwapState["QUOTE_SOFT_EXPIRED"] = -1] = "QUOTE_SOFT_EXPIRED";
    ToBTCSwapState[ToBTCSwapState["CREATED"] = 0] = "CREATED";
    ToBTCSwapState[ToBTCSwapState["COMMITED"] = 1] = "COMMITED";
    ToBTCSwapState[ToBTCSwapState["SOFT_CLAIMED"] = 2] = "SOFT_CLAIMED";
    ToBTCSwapState[ToBTCSwapState["CLAIMED"] = 3] = "CLAIMED";
    ToBTCSwapState[ToBTCSwapState["REFUNDABLE"] = 4] = "REFUNDABLE";
})(ToBTCSwapState = exports.ToBTCSwapState || (exports.ToBTCSwapState = {}));
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LNURL = exports.MAIL_REGEX = exports.BASE64_REGEX = exports.isLNURLPaySuccessAction = exports.isLNURLPayResult = exports.isLNURLWithdrawParams = exports.isLNURLPayParams = exports.isLNURLError = exports.isLNURLWithdraw = exports.isLNURLPay = void 0;
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const UserError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/UserError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@scure/base/lib/index.js [app-client] (ecmascript)");
const aes_1 = __turbopack_context__.r("[project]/node_modules/@noble/ciphers/aes.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
function isLNURLPay(value) {
    return typeof value === "object" && value != null && value.type === "pay" && typeof value.min === "bigint" && typeof value.max === "bigint" && typeof value.commentMaxLength === "number" && typeof value.shortDescription === "string" && (value.longDescription === undefined || typeof value.longDescription === "string") && (value.icon === undefined || typeof value.icon === "string") && isLNURLPayParams(value.params);
}
exports.isLNURLPay = isLNURLPay;
function isLNURLWithdraw(value) {
    return typeof value === "object" && value != null && value.type === "withdraw" && typeof value.min === "bigint" && typeof value.max === "bigint" && isLNURLWithdrawParams(value.params);
}
exports.isLNURLWithdraw = isLNURLWithdraw;
function isLNURLError(obj) {
    return obj.status === "ERROR" && (obj.reason == null || typeof obj.reason === "string");
}
exports.isLNURLError = isLNURLError;
function isLNURLPayParams(obj) {
    return obj.tag === "payRequest";
}
exports.isLNURLPayParams = isLNURLPayParams;
function isLNURLWithdrawParams(obj) {
    return obj.tag === "withdrawRequest";
}
exports.isLNURLWithdrawParams = isLNURLWithdrawParams;
function isLNURLPayResult(obj, domain) {
    return typeof obj.pr === "string" && (obj.routes == null || Array.isArray(obj.routes)) && (obj.disposable === null || obj.disposable === undefined || typeof obj.disposable === "boolean") && (obj.successAction == null || isLNURLPaySuccessAction(obj.successAction, domain));
}
exports.isLNURLPayResult = isLNURLPayResult;
function isLNURLPaySuccessAction(obj, domain) {
    if (obj == null || typeof obj !== 'object' || typeof obj.tag !== 'string') return false;
    switch(obj.tag){
        case "message":
            return obj.message != null && obj.message.length <= 144;
        case "url":
            return obj.description != null && obj.description.length <= 144 && obj.url != null && (domain == null || new URL(obj.url).hostname === domain);
        case "aes":
            return obj.description != null && obj.description.length <= 144 && obj.ciphertext != null && obj.ciphertext.length <= 4096 && exports.BASE64_REGEX.test(obj.ciphertext) && obj.iv != null && obj.iv.length <= 24 && exports.BASE64_REGEX.test(obj.iv);
        default:
            //Unsupported action
            return false;
    }
}
exports.isLNURLPaySuccessAction = isLNURLPaySuccessAction;
exports.BASE64_REGEX = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
exports.MAIL_REGEX = /(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[A-z0-9](?:[A-z0-9-]*[A-z0-9])?\.)+[A-z0-9](?:[A-z0-9-]*[A-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[A-z0-9-]*[A-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/;
class LNURL {
    static findBech32LNURL(str) {
        const arr = /,*?((lnurl)([0-9]{1,}[a-z0-9]+){1})/.exec(str.toLowerCase());
        if (arr == null) return null;
        return arr[1];
    }
    static isBech32LNURL(str) {
        return this.findBech32LNURL(str) != null;
    }
    /**
     * Checks whether a provided string is bare (non bech32 encoded) lnurl
     * @param str
     * @private
     */ static isBareLNURL(str) {
        try {
            return str.startsWith("lnurlw://") || str.startsWith("lnurlp://");
        } catch (e) {}
        return false;
    }
    /**
     * Checks if the provided string is a lightning network address (e.g. satoshi@nakamoto.com)
     * @param str
     * @private
     */ static isLightningAddress(str) {
        return exports.MAIL_REGEX.test(str);
    }
    /**
     * Checks whether a given string is a LNURL or lightning address
     * @param str
     */ static isLNURL(str) {
        return LNURL.isBech32LNURL(str) || LNURL.isLightningAddress(str) || LNURL.isBareLNURL(str);
    }
    /**
     * Extracts the URL that needs to be request from LNURL or lightning address
     * @param str
     * @private
     * @returns An URL to send the request to, or null if it cannot be parsed
     */ static extractCallUrl(str) {
        if (exports.MAIL_REGEX.test(str)) {
            //lightning e-mail like address
            const arr = str.split("@");
            const username = arr[0];
            const domain = arr[1];
            let scheme = "https";
            if (domain.endsWith(".onion")) {
                scheme = "http";
            }
            return scheme + "://" + domain + "/.well-known/lnurlp/" + username;
        } else if (LNURL.isBareLNURL(str)) {
            //non-bech32m encoded lnurl
            const data = str.substring("lnurlw://".length);
            const httpUrl = new URL("http://" + data);
            let scheme = "https";
            if (httpUrl.hostname.endsWith(".onion")) {
                scheme = "http";
            }
            return scheme + "://" + data;
        } else {
            const lnurl = LNURL.findBech32LNURL(str);
            if (lnurl != null) {
                let { prefix: hrp, words: dataPart } = base_1.bech32.decode(lnurl, 2000);
                let requestByteArray = base_1.bech32.fromWords(dataPart);
                return buffer_1.Buffer.from(requestByteArray).toString();
            }
        }
        return null;
    }
    /**
     * Sends a request to obtain data about a specific LNURL or lightning address
     *
     * @param str A lnurl or lightning address
     * @param shouldRetry Whether we should retry in case of network failure
     * @param timeout Request timeout in milliseconds
     * @param abortSignal
     */ static async getLNURL(str) {
        let shouldRetry = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true, timeout = arguments.length > 2 ? arguments[2] : void 0, abortSignal = arguments.length > 3 ? arguments[3] : void 0;
        if (shouldRetry == null) shouldRetry = true;
        const url = LNURL.extractCallUrl(str);
        if (url != null) {
            const sendRequest = ()=>(0, Utils_1.httpGet)(url, timeout, abortSignal, true);
            let response = shouldRetry ? await (0, Utils_1.tryWithRetries)(sendRequest, null, RequestError_1.RequestError, abortSignal) : await sendRequest();
            if (isLNURLError(response)) return null;
            if (response.tag === "payRequest") try {
                response.decodedMetadata = JSON.parse(response.metadata);
            } catch (err) {
                response.decodedMetadata = [];
            }
            if (!isLNURLPayParams(response) && !isLNURLWithdrawParams(response)) return null;
            return {
                ...response,
                url: str
            };
        }
    }
    /**
     * Sends a request to obtain data about a specific LNURL or lightning address
     *
     * @param str A lnurl or lightning address
     * @param shouldRetry Whether we should retry in case of network failure
     * @param timeout Request timeout in milliseconds
     * @param abortSignal
     */ static async getLNURLType(str, shouldRetry, timeout, abortSignal) {
        let res = await LNURL.getLNURL(str, shouldRetry, timeout, abortSignal);
        if (res.tag === "payRequest") {
            const payRequest = res;
            let shortDescription;
            let longDescription;
            let icon;
            payRequest.decodedMetadata.forEach((data)=>{
                switch(data[0]){
                    case "text/plain":
                        shortDescription = data[1];
                        break;
                    case "text/long-desc":
                        longDescription = data[1];
                        break;
                    case "image/png;base64":
                        icon = "data:" + data[0] + "," + data[1];
                        break;
                    case "image/jpeg;base64":
                        icon = "data:" + data[0] + "," + data[1];
                        break;
                }
            });
            return {
                type: "pay",
                min: BigInt(payRequest.minSendable) / 1000n,
                max: BigInt(payRequest.maxSendable) / 1000n,
                commentMaxLength: payRequest.commentAllowed || 0,
                shortDescription,
                longDescription,
                icon,
                params: payRequest
            };
        }
        if (res.tag === "withdrawRequest") {
            const payRequest = res;
            return {
                type: "withdraw",
                min: BigInt(payRequest.minWithdrawable) / 1000n,
                max: BigInt(payRequest.maxWithdrawable) / 1000n,
                params: payRequest
            };
        }
        return null;
    }
    /**
     * Uses a LNURL-pay request by obtaining a lightning network invoice from it
     *
     * @param payRequest LNURL params as returned from the getLNURL call
     * @param amount Amount of sats (BTC) to pay
     * @param comment Optional comment for the payment request
     * @param timeout Request timeout in milliseconds
     * @param abortSignal
     * @throws {RequestError} If the response is non-200, status: ERROR, or invalid format
     */ static async useLNURLPay(payRequest, amount, comment, timeout, abortSignal) {
        const params = [
            "amount=" + (amount * 1000n).toString(10)
        ];
        if (comment != null) {
            params.push("comment=" + encodeURIComponent(comment));
        }
        const queryParams = (payRequest.callback.includes("?") ? "&" : "?") + params.join("&");
        const response = await (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(payRequest.callback + queryParams, timeout, abortSignal, true), null, RequestError_1.RequestError, abortSignal);
        if (isLNURLError(response)) throw new RequestError_1.RequestError("LNURL callback error: " + response.reason, 200);
        if (!isLNURLPayResult(response)) throw new RequestError_1.RequestError("Invalid LNURL response!", 200);
        const parsedPR = (0, bolt11_1.decode)(response.pr);
        const descHash = buffer_1.Buffer.from((0, sha2_1.sha256)(payRequest.metadata)).toString("hex");
        if (parsedPR.tagsObject.purpose_commit_hash !== descHash) throw new RequestError_1.RequestError("Invalid invoice received (description hash)!", 200);
        const invoiceMSats = BigInt(parsedPR.millisatoshis);
        if (invoiceMSats !== amount * 1000n) throw new RequestError_1.RequestError("Invalid invoice received (amount)!", 200);
        return {
            invoice: response.pr,
            parsedInvoice: parsedPR,
            successAction: response.successAction
        };
    }
    /**
     * Submits the bolt11 lightning invoice to the lnurl withdraw url
     *
     * @param withdrawRequest Withdraw request to use
     * @param withdrawRequest.k1 K1 parameter
     * @param withdrawRequest.callback A URL to call
     * @param lnpr bolt11 lightning network invoice to submit to the withdrawal endpoint
     * @throws {RequestError} If the response is non-200 or status: ERROR
     */ static async postInvoiceToLNURLWithdraw(withdrawRequest, lnpr) {
        const params = [
            "pr=" + lnpr,
            "k1=" + withdrawRequest.k1
        ];
        const queryParams = (withdrawRequest.callback.includes("?") ? "&" : "?") + params.join("&");
        const response = await (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(withdrawRequest.callback + queryParams, null, null, true), null, RequestError_1.RequestError);
        if (isLNURLError(response)) throw new RequestError_1.RequestError("LNURL callback error: " + response.reason, 200);
    }
    /**
     * Uses a LNURL-withdraw request by submitting a lightning network invoice to it
     *
     * @param withdrawRequest Withdrawal request as returned from getLNURL call
     * @param lnpr bolt11 lightning network invoice to submit to the withdrawal endpoint
     * @throws {UserError} In case the provided bolt11 lightning invoice has an amount that is out of bounds for
     *  the specified LNURL-withdraw request
     */ static async useLNURLWithdraw(withdrawRequest, lnpr) {
        const min = BigInt(withdrawRequest.minWithdrawable) / 1000n;
        const max = BigInt(withdrawRequest.maxWithdrawable) / 1000n;
        const parsedPR = (0, bolt11_1.decode)(lnpr);
        const amount = (BigInt(parsedPR.millisatoshis) + 999n) / 1000n;
        if (amount < min) throw new UserError_1.UserError("Invoice amount less than minimum LNURL-withdraw limit");
        if (amount > max) throw new UserError_1.UserError("Invoice amount more than maximum LNURL-withdraw limit");
        return await LNURL.postInvoiceToLNURLWithdraw(withdrawRequest, lnpr);
    }
    static decodeSuccessAction(successAction, secret) {
        if (secret == null) return null;
        if (successAction.tag === "message") {
            return {
                description: successAction.message
            };
        }
        if (successAction.tag === "url") {
            return {
                description: successAction.description,
                url: successAction.url
            };
        }
        if (successAction.tag === "aes") {
            const CBC = (0, aes_1.cbc)(buffer_1.Buffer.from(secret, "hex"), buffer_1.Buffer.from(successAction.iv, "hex"));
            let plaintext = CBC.decrypt(buffer_1.Buffer.from(successAction.ciphertext, "base64"));
            // remove padding
            const size = plaintext.length;
            const pad = plaintext[size - 1];
            return {
                description: successAction.description,
                text: buffer_1.Buffer.from(plaintext).toString("utf8", 0, size - pad)
            };
        }
    }
}
exports.LNURL = LNURL;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ToBTCLNSwap = exports.isToBTCLNSwapInit = void 0;
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const IToBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const LNURL_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
function isToBTCLNSwapInit(obj) {
    return typeof obj.confidence === "number" && typeof obj.pr === "string" && (obj.lnurl == null || typeof obj.lnurl === "string") && (obj.successAction == null || (0, LNURL_1.isLNURLPaySuccessAction)(obj.successAction)) && (0, IToBTCSwap_1.isIToBTCSwapInit)(obj);
}
exports.isToBTCLNSwapInit = isToBTCLNSwapInit;
//Set of nodes which disallow probing, resulting in 0 confidence reported by the LP
const SNOWFLAKE_LIST = new Set([
    "038f8f113c580048d847d6949371726653e02b928196bad310e3eda39ff61723f6",
    "03a6ce61fcaacd38d31d4e3ce2d506602818e3856b4b44faff1dde9642ba705976"
]);
class ToBTCLNSwap extends IToBTCSwap_1.IToBTCSwap {
    _setPaymentResult(result) {
        let check = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (result == null) return Promise.resolve(false);
        if (result.secret == null) throw new IntermediaryError_1.IntermediaryError("No payment secret returned!");
        if (check) {
            const secretBuffer = buffer_1.Buffer.from(result.secret, "hex");
            const hash = buffer_1.Buffer.from((0, sha2_1.sha256)(secretBuffer));
            if (!hash.equals(this.getPaymentHash())) throw new IntermediaryError_1.IntermediaryError("Invalid payment secret returned");
        }
        this.secret = result.secret;
        return Promise.resolve(true);
    }
    //////////////////////////////
    //// Amounts & fees
    getOutput() {
        const parsedPR = (0, bolt11_1.decode)(this.pr);
        const amount = (BigInt(parsedPR.millisatoshis) + 999n) / 1000n;
        return (0, Tokens_1.toTokenAmount)(amount, this.outputToken, this.wrapper.prices);
    }
    //////////////////////////////
    //// Getters & utils
    getOutputTxId() {
        return this.getLpIdentifier();
    }
    /**
     * Returns the lightning BOLT11 invoice where the BTC will be sent to
     */ getOutputAddress() {
        var _this_lnurl;
        return (_this_lnurl = this.lnurl) !== null && _this_lnurl !== void 0 ? _this_lnurl : this.pr;
    }
    /**
     * Returns payment secret (pre-image) as a proof of payment
     */ getSecret() {
        return this.secret;
    }
    /**
     * Returns the confidence of the intermediary that this payment will succeed
     * Value between 0 and 1, where 0 is not likely and 1 is very likely
     */ getConfidence() {
        return this.confidence;
    }
    /**
     * Checks whether a swap is likely to fail, based on the confidence as reported by the LP
     */ willLikelyFail() {
        const parsedRequest = (0, bolt11_1.decode)(this.pr);
        if (parsedRequest.tagsObject.routing_info != null) {
            for (let route of parsedRequest.tagsObject.routing_info){
                if (SNOWFLAKE_LIST.has(route.pubkey)) {
                    return false;
                }
            }
        }
        return this.confidence === 0;
    }
    /**
     * Tries to detect if the target lightning invoice is a non-custodial mobile wallet, care must be taken
     *  for such a wallet to be online when attempting to make a swap
     */ isPayingToNonCustodialWallet() {
        const parsedRequest = (0, bolt11_1.decode)(this.pr);
        if (parsedRequest.tagsObject.routing_info != null) {
            return parsedRequest.tagsObject.routing_info.length > 0;
        }
        return false;
    }
    getIdentifierHash() {
        const paymentHashBuffer = this.getPaymentHash();
        if (this.randomNonce == null) return paymentHashBuffer;
        return buffer_1.Buffer.concat([
            paymentHashBuffer,
            buffer_1.Buffer.from(this.randomNonce, "hex")
        ]);
    }
    getPaymentHash() {
        if (this.pr == null) return null;
        const parsed = (0, bolt11_1.decode)(this.pr);
        return buffer_1.Buffer.from(parsed.tagsObject.payment_hash, "hex");
    }
    getLpIdentifier() {
        if (this.pr == null) return null;
        const parsed = (0, bolt11_1.decode)(this.pr);
        return parsed.tagsObject.payment_hash;
    }
    //////////////////////////////
    //// LNURL-pay
    /**
     * Is this an LNURL-pay swap?
     */ isLNURL() {
        return this.lnurl != null;
    }
    /**
     * Gets the used LNURL or null if this is not an LNURL-pay swap
     */ getLNURL() {
        return this.lnurl;
    }
    /**
     * Checks whether this LNURL payment contains a success message
     */ hasSuccessAction() {
        return this.successAction != null;
    }
    /**
     * Returns the success action after a successful payment, else null
     */ getSuccessAction() {
        return LNURL_1.LNURL.decodeSuccessAction(this.successAction, this.secret);
    }
    //////////////////////////////
    //// Storage
    serialize() {
        return {
            ...super.serialize(),
            paymentHash: this.getPaymentHash().toString("hex"),
            pr: this.pr,
            confidence: this.confidence,
            secret: this.secret,
            lnurl: this.lnurl,
            successAction: this.successAction
        };
    }
    constructor(wrapper, initOrObj){
        if (isToBTCLNSwapInit(initOrObj)) initOrObj.url += "/tobtcln";
        super(wrapper, initOrObj);
        this.outputToken = Tokens_1.BitcoinTokens.BTCLN;
        this.TYPE = SwapType_1.SwapType.TO_BTCLN;
        if (!isToBTCLNSwapInit(initOrObj)) {
            this.confidence = initOrObj.confidence;
            this.pr = initOrObj.pr;
            this.lnurl = initOrObj.lnurl;
            this.successAction = initOrObj.successAction;
            this.secret = initOrObj.secret;
        }
        this.paymentHash = this.getPaymentHash().toString("hex");
        this.logger = (0, Utils_1.getLogger)("ToBTCLN(" + this.getIdentifierHashString() + "): ");
        this.tryRecomputeSwapPrice();
    }
}
exports.ToBTCLNSwap = ToBTCLNSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwapWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IEscrowSwapWrapper = void 0;
const ISwapWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwapWrapper.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class IEscrowSwapWrapper extends ISwapWrapper_1.ISwapWrapper {
    /**
     * Pre-fetches signature verification data from the server's pre-sent promise, doesn't throw, instead returns null
     *
     * @param signDataPrefetch Promise that resolves when we receive "signDataPrefetch" from the LP in streaming mode
     * @protected
     * @returns Pre-fetched signature verification data or null if failed
     */ preFetchSignData(signDataPrefetch) {
        if (this.contract.preFetchForInitSignatureVerification == null) return Promise.resolve(null);
        return signDataPrefetch.then((obj)=>{
            if (obj == null) return null;
            return this.contract.preFetchForInitSignatureVerification(obj);
        }).catch((e)=>{
            this.logger.error("preFetchSignData(): Error: ", e);
            return null;
        });
    }
    /**
     * Verifies swap initialization signature returned by the intermediary
     *
     * @param initiator A smart chain account initiating the swap
     * @param data Parsed swap data from the intermediary
     * @param signature Response of the intermediary
     * @param feeRatePromise Pre-fetched fee rate promise
     * @param preFetchSignatureVerificationData Pre-fetched signature verification data
     * @param abortSignal
     * @protected
     * @returns Swap initialization signature expiry
     * @throws {SignatureVerificationError} when swap init signature is invalid
     */ async verifyReturnedSignature(initiator, data, signature, feeRatePromise, preFetchSignatureVerificationData, abortSignal) {
        const [feeRate, preFetchedSignatureData] = await Promise.all([
            feeRatePromise,
            preFetchSignatureVerificationData
        ]);
        await (0, Utils_1.tryWithRetries)(()=>this.contract.isValidInitAuthorization(initiator, data, signature, feeRate, preFetchedSignatureData), null, base_1.SignatureVerificationError, abortSignal);
        return await (0, Utils_1.tryWithRetries)(()=>this.contract.getInitAuthorizationExpiry(data, signature, preFetchedSignatureData), null, base_1.SignatureVerificationError, abortSignal);
    }
    /**
     * Processes a single SC on-chain event
     * @private
     * @param event
     * @param swap
     */ async processEvent(event, swap) {
        if (swap == null) return;
        let swapChanged = false;
        if (event instanceof base_1.InitializeEvent) {
            var _event_meta;
            swapChanged = await this.processEventInitialize(swap, event);
            if (((_event_meta = event.meta) === null || _event_meta === void 0 ? void 0 : _event_meta.txId) != null && swap.commitTxId !== event.meta.txId) {
                swap.commitTxId = event.meta.txId;
                swapChanged || (swapChanged = true);
            }
        }
        if (event instanceof base_1.ClaimEvent) {
            var _event_meta1;
            swapChanged = await this.processEventClaim(swap, event);
            if (((_event_meta1 = event.meta) === null || _event_meta1 === void 0 ? void 0 : _event_meta1.txId) != null && swap.claimTxId !== event.meta.txId) {
                swap.claimTxId = event.meta.txId;
                swapChanged || (swapChanged = true);
            }
        }
        if (event instanceof base_1.RefundEvent) {
            var _event_meta2;
            swapChanged = await this.processEventRefund(swap, event);
            if (((_event_meta2 = event.meta) === null || _event_meta2 === void 0 ? void 0 : _event_meta2.txId) != null && swap.refundTxId !== event.meta.txId) {
                swap.refundTxId = event.meta.txId;
                swapChanged || (swapChanged = true);
            }
        }
        this.logger.info("processEvents(): " + event.constructor.name + " processed for " + swap.getId() + " swap: ", swap);
        if (swapChanged) {
            await swap._saveAndEmit();
        }
        return true;
    }
    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events){
        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events);
        this.swapDataDeserializer = swapDataDeserializer;
        this.contract = contract;
    }
}
exports.IEscrowSwapWrapper = IEscrowSwapWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IToBTCWrapper = void 0;
const IToBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const IEscrowSwapWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwapWrapper.js [app-client] (ecmascript)");
class IToBTCWrapper extends IEscrowSwapWrapper_1.IEscrowSwapWrapper {
    /**
     * Pre-fetches intermediary's reputation, doesn't throw, instead aborts via abortController and returns null
     *
     * @param amountData
     * @param lp Intermediary
     * @param abortController
     * @protected
     * @returns Intermediary's reputation or null if failed
     * @throws {IntermediaryError} If the intermediary vault doesn't exist
     */ preFetchIntermediaryReputation(amountData, lp, abortController) {
        return lp.getReputation(this.chainIdentifier, this.contract, [
            amountData.token.toString()
        ], abortController.signal).then((res)=>{
            if (res == null) throw new IntermediaryError_1.IntermediaryError("Invalid data returned - invalid LP vault");
            return res;
        }).catch((e)=>{
            this.logger.warn("preFetchIntermediaryReputation(): Error: ", e);
            abortController.abort(e);
            return null;
        });
    }
    /**
     * Pre-fetches feeRate for a given swap
     *
     * @param signer Address of the swap initiator
     * @param amountData
     * @param claimHash optional hash of the swap or null
     * @param abortController
     * @protected
     * @returns Fee rate
     */ preFetchFeeRate(signer, amountData, claimHash, abortController) {
        return (0, Utils_1.tryWithRetries)(()=>this.contract.getInitPayInFeeRate(signer, null, amountData.token, claimHash), null, null, abortController.signal).catch((e)=>{
            this.logger.warn("preFetchFeeRate(): Error: ", e);
            abortController.abort(e);
            return null;
        });
    }
    async processEventInitialize(swap, event) {
        if (swap.state === IToBTCSwap_1.ToBTCSwapState.CREATED || swap.state === IToBTCSwap_1.ToBTCSwapState.QUOTE_SOFT_EXPIRED) {
            const swapData = await event.swapData();
            if (swap.data != null && !swap.data.equals(swapData)) return false;
            if (swap.state === IToBTCSwap_1.ToBTCSwapState.CREATED || swap.state === IToBTCSwap_1.ToBTCSwapState.QUOTE_SOFT_EXPIRED) swap.state = IToBTCSwap_1.ToBTCSwapState.COMMITED;
            swap.data = swapData;
            return true;
        }
    }
    processEventClaim(swap, event) {
        if (swap.state !== IToBTCSwap_1.ToBTCSwapState.REFUNDED && swap.state !== IToBTCSwap_1.ToBTCSwapState.CLAIMED) {
            swap.state = IToBTCSwap_1.ToBTCSwapState.CLAIMED;
            swap._setPaymentResult({
                secret: event.result,
                txId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(event.result, "hex").reverse().toString("hex")
            });
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    processEventRefund(swap, event) {
        if (swap.state !== IToBTCSwap_1.ToBTCSwapState.CLAIMED && swap.state !== IToBTCSwap_1.ToBTCSwapState.REFUNDED) {
            swap.state = IToBTCSwap_1.ToBTCSwapState.REFUNDED;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    constructor(){
        super(...arguments);
        this.pendingSwapStates = [
            IToBTCSwap_1.ToBTCSwapState.CREATED,
            IToBTCSwap_1.ToBTCSwapState.QUOTE_SOFT_EXPIRED,
            IToBTCSwap_1.ToBTCSwapState.COMMITED,
            IToBTCSwap_1.ToBTCSwapState.SOFT_CLAIMED,
            IToBTCSwap_1.ToBTCSwapState.REFUNDABLE
        ];
        this.tickSwapState = [
            IToBTCSwap_1.ToBTCSwapState.CREATED,
            IToBTCSwap_1.ToBTCSwapState.COMMITED,
            IToBTCSwap_1.ToBTCSwapState.SOFT_CLAIMED
        ];
        this.refundableSwapStates = [
            IToBTCSwap_1.ToBTCSwapState.REFUNDABLE
        ];
    }
}
exports.IToBTCWrapper = IToBTCWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ToBTCLNWrapper = void 0;
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const ToBTCLNSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNSwap.js [app-client] (ecmascript)");
const IToBTCWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCWrapper.js [app-client] (ecmascript)");
const UserError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/UserError.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const LNURL_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)");
const IToBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js [app-client] (ecmascript)");
class ToBTCLNWrapper extends IToBTCWrapper_1.IToBTCWrapper {
    async checkPaymentHashWasPaid(paymentHash) {
        const swaps = await this.unifiedStorage.query([
            [
                {
                    key: "type",
                    value: this.TYPE
                },
                {
                    key: "paymentHash",
                    value: paymentHash
                }
            ]
        ], (obj)=>new this.swapDeserializer(this, obj));
        for (let value of swaps){
            if (value.state === IToBTCSwap_1.ToBTCSwapState.CLAIMED || value.state === IToBTCSwap_1.ToBTCSwapState.SOFT_CLAIMED) throw new UserError_1.UserError("Lightning invoice was already paid!");
        }
    }
    /**
     * Calculates maximum lightning network routing fee based on amount
     *
     * @param amount BTC amount of the swap in satoshis
     * @param overrideBaseFee Override wrapper's default base fee
     * @param overrideFeePPM Override wrapper's default PPM
     * @private
     * @returns Maximum lightning routing fee in sats
     */ calculateFeeForAmount(amount, overrideBaseFee, overrideFeePPM) {
        return BigInt(overrideBaseFee !== null && overrideBaseFee !== void 0 ? overrideBaseFee : this.options.lightningBaseFee) + amount * BigInt(overrideFeePPM !== null && overrideFeePPM !== void 0 ? overrideFeePPM : this.options.lightningFeePPM) / 1000000n;
    }
    /**
     * Verifies returned LP data
     *
     * @param resp Response as returned by the LP
     * @param parsedPr Parsed bolt11 lightning invoice
     * @param token Smart chain token to be used in the swap
     * @param lp
     * @param options Swap options as passed to the swap create function
     * @param data Parsed swap data returned by the LP
     * @param requiredTotal Required total to be paid on the input (for exactIn swaps)
     * @private
     * @throws {IntermediaryError} In case the response is not valid
     */ async verifyReturnedData(resp, parsedPr, token, lp, options, data, requiredTotal) {
        if (resp.routingFeeSats > await options.maxFee) throw new IntermediaryError_1.IntermediaryError("Invalid max fee sats returned");
        if (requiredTotal != null && resp.total !== requiredTotal) throw new IntermediaryError_1.IntermediaryError("Invalid data returned - total amount");
        const claimHash = this.contract.getHashForHtlc(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(parsedPr.tagsObject.payment_hash, "hex"));
        if (data.getAmount() !== resp.total || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(data.getClaimHash(), "hex").equals(claimHash) || data.getExpiry() !== options.expiryTimestamp || data.getType() !== base_1.ChainSwapType.HTLC || !data.isPayIn() || !data.isToken(token) || data.getClaimer() !== lp.getAddress(this.chainIdentifier)) {
            throw new IntermediaryError_1.IntermediaryError("Invalid data returned");
        }
    }
    /**
     * Returns the quote/swap from a given intermediary
     *
     * @param signer Smartchain signer initiating the swap
     * @param amountData
     * @param lp Intermediary
     * @param pr bolt11 lightning network invoice
     * @param parsedPr Parsed bolt11 lightning network invoice
     * @param options Options as passed to the swap create function
     * @param preFetches
     * @param abort Abort signal or controller, if AbortController is passed it is used as-is, when AbortSignal is passed
     *  it is extended with extendAbortController and then used
     * @param additionalParams Additional params that should be sent to the LP
     * @private
     */ async getIntermediaryQuote(signer, amountData, lp, pr, parsedPr, options, preFetches, abort, additionalParams) {
        var _preFetches;
        const abortController = abort instanceof AbortController ? abort : (0, Utils_1.extendAbortController)(abort);
        var _reputationPromise;
        (_reputationPromise = (_preFetches = preFetches).reputationPromise) !== null && _reputationPromise !== void 0 ? _reputationPromise : _preFetches.reputationPromise = this.preFetchIntermediaryReputation(amountData, lp, abortController);
        try {
            const { signDataPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount)=>{
                const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.initToBTCLN(this.chainIdentifier, lp.url, {
                    offerer: signer,
                    pr,
                    maxFee: await options.maxFee,
                    expiryTimestamp: options.expiryTimestamp,
                    token: amountData.token,
                    feeRate: preFetches.feeRatePromise,
                    additionalParams
                }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);
                return {
                    signDataPromise: this.preFetchSignData(signDataPrefetch),
                    resp: await response
                };
            }, null, (e)=>e instanceof RequestError_1.RequestError, abortController.signal);
            const amountOut = (BigInt(parsedPr.millisatoshis) + 999n) / 1000n;
            const totalFee = resp.swapFee + resp.maxFee;
            const data = new this.swapDataDeserializer(resp.data);
            data.setOfferer(signer);
            await this.verifyReturnedData(resp, parsedPr, amountData.token, lp, options, data);
            const [pricingInfo, signatureExpiry, reputation] = await Promise.all([
                this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.TO_BTCLN], true, amountOut, data.getAmount(), amountData.token, {
                    networkFee: resp.maxFee
                }, preFetches.pricePreFetchPromise, abortController.signal),
                this.verifyReturnedSignature(signer, data, resp, preFetches.feeRatePromise, signDataPromise, abortController.signal),
                preFetches.reputationPromise
            ]);
            abortController.signal.throwIfAborted();
            lp.reputation[amountData.token.toString()] = reputation;
            const quote = new ToBTCLNSwap_1.ToBTCLNSwap(this, {
                pricingInfo,
                url: lp.url,
                expiry: signatureExpiry,
                swapFee: resp.swapFee,
                feeRate: await preFetches.feeRatePromise,
                signatureData: resp,
                data,
                networkFee: resp.maxFee,
                networkFeeBtc: resp.routingFeeSats,
                confidence: resp.confidence,
                pr,
                exactIn: false
            });
            await quote._save();
            return quote;
        } catch (e) {
            abortController.abort(e);
            throw e;
        }
    }
    /**
     * Returns a newly created swap, paying for 'bolt11PayRequest' - a bitcoin LN invoice
     *
     * @param signer                Smartchain signer's address initiating the swap
     * @param bolt11PayRequest      BOLT11 payment request (bitcoin lightning invoice) you wish to pay
     * @param amountData            Amount of token & amount to swap
     * @param lps                   LPs (liquidity providers) to get the quotes from
     * @param options               Quote options
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param abortSignal           Abort signal for aborting the process
     * @param preFetches            Existing pre-fetches for the swap (only used internally for LNURL swaps)
     */ async create(signer, bolt11PayRequest, amountData, lps, options, additionalParams, abortSignal, preFetches) {
        var _options, _options1, _options2;
        options !== null && options !== void 0 ? options : options = {};
        var _expirySeconds;
        (_expirySeconds = (_options = options).expirySeconds) !== null && _expirySeconds !== void 0 ? _expirySeconds : _options.expirySeconds = this.options.paymentTimeoutSeconds;
        var _expiryTimestamp;
        (_expiryTimestamp = (_options1 = options).expiryTimestamp) !== null && _expiryTimestamp !== void 0 ? _expiryTimestamp : _options1.expiryTimestamp = BigInt(Math.floor(Date.now() / 1000) + options.expirySeconds);
        const parsedPr = (0, bolt11_1.decode)(bolt11PayRequest);
        if (parsedPr.millisatoshis == null) throw new UserError_1.UserError("Must be an invoice with amount");
        const amountOut = (BigInt(parsedPr.millisatoshis) + 999n) / 1000n;
        var _maxFee;
        (_maxFee = (_options2 = options).maxFee) !== null && _maxFee !== void 0 ? _maxFee : _options2.maxFee = this.calculateFeeForAmount(amountOut, options.maxRoutingBaseFee, options.maxRoutingPPM);
        await this.checkPaymentHashWasPaid(parsedPr.tagsObject.payment_hash);
        const claimHash = this.contract.getHashForHtlc(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(parsedPr.tagsObject.payment_hash, "hex"));
        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);
        if (preFetches == null) preFetches = {
            pricePreFetchPromise: this.preFetchPrice(amountData, _abortController.signal),
            feeRatePromise: this.preFetchFeeRate(signer, amountData, claimHash.toString("hex"), _abortController)
        };
        return lps.map((lp)=>{
            return {
                intermediary: lp,
                quote: this.getIntermediaryQuote(signer, amountData, lp, bolt11PayRequest, parsedPr, options, preFetches, _abortController.signal, additionalParams)
            };
        });
    }
    /**
     * Parses and fetches lnurl pay params from the specified lnurl
     *
     * @param lnurl LNURL to be parsed and fetched
     * @param abortSignal
     * @private
     * @throws {UserError} if the LNURL is invalid or if it's not a LNURL-pay
     */ async getLNURLPay(lnurl, abortSignal) {
        if (typeof lnurl !== "string") return lnurl;
        const res = await LNURL_1.LNURL.getLNURL(lnurl, true, this.options.getRequestTimeout, abortSignal);
        if (res == null) throw new UserError_1.UserError("Invalid LNURL");
        if (res.tag !== "payRequest") throw new UserError_1.UserError("Not a LNURL-pay");
        return res;
    }
    /**
     * Returns the quote/swap from the given LP
     *
     * @param signer Smartchain signer's address initiating the swap
     * @param amountData
     * @param payRequest Parsed LNURL-pay params
     * @param lp Intermediary
     * @param dummyPr Dummy minimum value bolt11 lightning invoice returned from the LNURL-pay
     * @param options Options as passed to the swap create function
     * @param preFetches
     * @param abortSignal
     * @param additionalParams Additional params to be sent to the intermediary
     * @private
     */ async getIntermediaryQuoteExactIn(signer, amountData, payRequest, lp, dummyPr, options, preFetches, abortSignal, additionalParams) {
        const abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const reputationPromise = this.preFetchIntermediaryReputation(amountData, lp, abortController);
        try {
            const { signDataPromise, prepareResp } = await (0, Utils_1.tryWithRetries)(async (retryCount)=>{
                const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.prepareToBTCLNExactIn(this.chainIdentifier, lp.url, {
                    token: amountData.token,
                    offerer: signer,
                    pr: dummyPr,
                    amount: amountData.amount,
                    maxFee: await options.maxFee,
                    expiryTimestamp: options.expiryTimestamp,
                    additionalParams
                }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);
                return {
                    signDataPromise: this.preFetchSignData(signDataPrefetch),
                    prepareResp: await response
                };
            }, null, (e)=>e instanceof RequestError_1.RequestError, abortController.signal);
            if (prepareResp.amount <= 0n) throw new IntermediaryError_1.IntermediaryError("Invalid amount returned (zero or negative)");
            const min = BigInt(payRequest.minSendable) / 1000n;
            const max = BigInt(payRequest.maxSendable) / 1000n;
            if (prepareResp.amount < min) throw new UserError_1.UserError("Amount less than minimum");
            if (prepareResp.amount > max) throw new UserError_1.UserError("Amount more than maximum");
            const { invoice, parsedInvoice, successAction } = await LNURL_1.LNURL.useLNURLPay(payRequest, prepareResp.amount, options.comment, this.options.getRequestTimeout, abortController.signal);
            const resp = await (0, Utils_1.tryWithRetries)((retryCount)=>IntermediaryAPI_1.IntermediaryAPI.initToBTCLNExactIn(lp.url, {
                    pr: invoice,
                    reqId: prepareResp.reqId,
                    feeRate: preFetches.feeRatePromise,
                    additionalParams
                }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null), null, RequestError_1.RequestError, abortController.signal);
            const totalFee = resp.swapFee + resp.maxFee;
            const data = new this.swapDataDeserializer(resp.data);
            data.setOfferer(signer);
            await this.verifyReturnedData(resp, parsedInvoice, amountData.token, lp, options, data, amountData.amount);
            const [pricingInfo, signatureExpiry, reputation] = await Promise.all([
                this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.TO_BTCLN], true, prepareResp.amount, data.getAmount(), amountData.token, {
                    networkFee: resp.maxFee
                }, preFetches.pricePreFetchPromise, abortSignal),
                this.verifyReturnedSignature(signer, data, resp, preFetches.feeRatePromise, signDataPromise, abortController.signal),
                reputationPromise
            ]);
            abortController.signal.throwIfAborted();
            lp.reputation[amountData.token.toString()] = reputation;
            const quote = new ToBTCLNSwap_1.ToBTCLNSwap(this, {
                pricingInfo,
                url: lp.url,
                expiry: signatureExpiry,
                swapFee: resp.swapFee,
                feeRate: await preFetches.feeRatePromise,
                signatureData: resp,
                data,
                networkFee: resp.maxFee,
                networkFeeBtc: resp.routingFeeSats,
                confidence: resp.confidence,
                pr: invoice,
                lnurl: payRequest.url,
                successAction,
                exactIn: true
            });
            await quote._save();
            return quote;
        } catch (e) {
            abortController.abort(e);
            throw e;
        }
    }
    /**
     * Returns a newly created swap, paying for 'lnurl' - a lightning LNURL-pay
     *
     * @param signer                Smartchain signer's address initiating the swap
     * @param lnurl                 LMURL-pay you wish to pay
     * @param amountData            Amount of token & amount to swap
     * @param lps                   LPs (liquidity providers/intermediaries) to get the quotes from
     * @param options               Quote options
     * @param additionalParams      Additional parameters sent to the intermediary when creating the swap
     * @param abortSignal           Abort signal for aborting the process
     */ async createViaLNURL(signer, lnurl, amountData, lps, options, additionalParams, abortSignal) {
        var _options, _options1, _options2, _options3;
        if (!this.isInitialized) throw new Error("Not initialized, call init() first!");
        options !== null && options !== void 0 ? options : options = {};
        var _expirySeconds;
        (_expirySeconds = (_options = options).expirySeconds) !== null && _expirySeconds !== void 0 ? _expirySeconds : _options.expirySeconds = this.options.paymentTimeoutSeconds;
        var _expiryTimestamp;
        (_expiryTimestamp = (_options1 = options).expiryTimestamp) !== null && _expiryTimestamp !== void 0 ? _expiryTimestamp : _options1.expiryTimestamp = BigInt(Math.floor(Date.now() / 1000) + options.expirySeconds);
        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const pricePreFetchPromise = this.preFetchPrice(amountData, _abortController.signal);
        const feeRatePromise = this.preFetchFeeRate(signer, amountData, null, _abortController);
        var _maxRoutingPPM;
        (_maxRoutingPPM = (_options2 = options).maxRoutingPPM) !== null && _maxRoutingPPM !== void 0 ? _maxRoutingPPM : _options2.maxRoutingPPM = BigInt(this.options.lightningFeePPM);
        var _maxRoutingBaseFee;
        (_maxRoutingBaseFee = (_options3 = options).maxRoutingBaseFee) !== null && _maxRoutingBaseFee !== void 0 ? _maxRoutingBaseFee : _options3.maxRoutingBaseFee = BigInt(this.options.lightningBaseFee);
        if (amountData.exactIn) {
            var _options4;
            var _maxFee;
            (_maxFee = (_options4 = options).maxFee) !== null && _maxFee !== void 0 ? _maxFee : _options4.maxFee = pricePreFetchPromise.then((val)=>this.prices.getFromBtcSwapAmount(this.chainIdentifier, options.maxRoutingBaseFee, amountData.token, abortSignal, val)).then((_maxBaseFee)=>this.calculateFeeForAmount(amountData.amount, _maxBaseFee, options.maxRoutingPPM));
        } else {
            options.maxFee = this.calculateFeeForAmount(amountData.amount, options.maxRoutingBaseFee, options.maxRoutingPPM);
        }
        try {
            let payRequest = await this.getLNURLPay(lnurl, _abortController.signal);
            if (options.comment != null && (payRequest.commentAllowed == null || options.comment.length > payRequest.commentAllowed)) throw new UserError_1.UserError("Comment not allowed or too long");
            if (amountData.exactIn) {
                const { invoice: dummyInvoice } = await LNURL_1.LNURL.useLNURLPay(payRequest, BigInt(payRequest.minSendable) / 1000n, null, this.options.getRequestTimeout, _abortController.signal);
                return lps.map((lp)=>{
                    return {
                        quote: this.getIntermediaryQuoteExactIn(signer, amountData, payRequest, lp, dummyInvoice, options, {
                            pricePreFetchPromise,
                            feeRatePromise
                        }, _abortController.signal, additionalParams),
                        intermediary: lp
                    };
                });
            } else {
                const min = BigInt(payRequest.minSendable) / 1000n;
                const max = BigInt(payRequest.maxSendable) / 1000n;
                if (amountData.amount < min) throw new UserError_1.UserError("Amount less than minimum");
                if (amountData.amount > max) throw new UserError_1.UserError("Amount more than maximum");
                const { invoice, parsedInvoice, successAction } = await LNURL_1.LNURL.useLNURLPay(payRequest, amountData.amount, options.comment, this.options.getRequestTimeout, _abortController.signal);
                return (await this.create(signer, invoice, amountData, lps, options, additionalParams, _abortController.signal, {
                    feeRatePromise,
                    pricePreFetchPromise
                })).map((data)=>{
                    return {
                        quote: data.quote.then((quote)=>{
                            quote.lnurl = payRequest.url;
                            quote.successAction = successAction;
                            return quote;
                        }),
                        intermediary: data.intermediary
                    };
                });
            }
        } catch (e) {
            _abortController.abort(e);
            throw e;
        }
    }
    constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events){
        var _options, _options1, _options2;
        if (options == null) options = {};
        var _paymentTimeoutSeconds;
        (_paymentTimeoutSeconds = (_options = options).paymentTimeoutSeconds) !== null && _paymentTimeoutSeconds !== void 0 ? _paymentTimeoutSeconds : _options.paymentTimeoutSeconds = 4 * 24 * 60 * 60;
        var _lightningBaseFee;
        (_lightningBaseFee = (_options1 = options).lightningBaseFee) !== null && _lightningBaseFee !== void 0 ? _lightningBaseFee : _options1.lightningBaseFee = 10;
        var _lightningFeePPM;
        (_lightningFeePPM = (_options2 = options).lightningFeePPM) !== null && _lightningFeePPM !== void 0 ? _lightningFeePPM : _options2.lightningFeePPM = 2000;
        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);
        this.TYPE = SwapType_1.SwapType.TO_BTCLN;
        this.swapDeserializer = ToBTCLNSwap_1.ToBTCLNSwap;
    }
}
exports.ToBTCLNWrapper = ToBTCLNWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ToBTCSwap = exports.isToBTCSwapInit = void 0;
const IToBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
function isToBTCSwapInit(obj) {
    return typeof obj.address === "string" && typeof obj.amount === "bigint" && typeof obj.confirmationTarget === "number" && typeof obj.satsPerVByte === "number" && (0, IToBTCSwap_1.isIToBTCSwapInit)(obj);
}
exports.isToBTCSwapInit = isToBTCSwapInit;
class ToBTCSwap extends IToBTCSwap_1.IToBTCSwap {
    async _setPaymentResult(result) {
        let check = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (result == null) return false;
        if (result.txId == null) throw new IntermediaryError_1.IntermediaryError("No btc txId returned!");
        if (check) {
            const btcTx = await this.wrapper.btcRpc.getTransaction(result.txId);
            if (btcTx == null) return false;
            const foundVout = btcTx.outs.find((vout)=>this.data.getClaimHash() === this.wrapper.contract.getHashForOnchain(buffer_1.Buffer.from(vout.scriptPubKey.hex, "hex"), BigInt(vout.value), this.requiredConfirmations, this.nonce).toString("hex"));
            if (foundVout == null) throw new IntermediaryError_1.IntermediaryError("Invalid btc txId returned");
        }
        this.txId = result.txId;
        return true;
    }
    //////////////////////////////
    //// Amounts & fees
    getOutput() {
        return (0, Tokens_1.toTokenAmount)(this.amount, this.outputToken, this.wrapper.prices);
    }
    //////////////////////////////
    //// Getters & utils
    /**
     * Returns the bitcoin address where the BTC will be sent to
     */ getOutputAddress() {
        return this.address;
    }
    getOutputTxId() {
        return this.txId;
    }
    /**
     * Returns fee rate of the bitcoin transaction in sats/vB
     */ getBitcoinFeeRate() {
        return this.satsPerVByte;
    }
    //////////////////////////////
    //// Storage
    serialize() {
        return {
            ...super.serialize(),
            address: this.address,
            amount: this.amount.toString(10),
            confirmationTarget: this.confirmationTarget,
            satsPerVByte: this.satsPerVByte,
            nonce: this.nonce == null ? null : this.nonce.toString(10),
            requiredConfirmations: this.requiredConfirmations,
            txId: this.txId
        };
    }
    constructor(wrapper, initOrObject){
        if (isToBTCSwapInit(initOrObject)) initOrObject.url += "/tobtc";
        super(wrapper, initOrObject);
        this.outputToken = Tokens_1.BitcoinTokens.BTC;
        this.TYPE = SwapType_1.SwapType.TO_BTC;
        if (!isToBTCSwapInit(initOrObject)) {
            this.address = initOrObject.address;
            this.amount = BigInt(initOrObject.amount);
            this.confirmationTarget = initOrObject.confirmationTarget;
            this.satsPerVByte = initOrObject.satsPerVByte;
            this.txId = initOrObject.txId;
            var _initOrObject_requiredConfirmations;
            this.requiredConfirmations = (_initOrObject_requiredConfirmations = initOrObject.requiredConfirmations) !== null && _initOrObject_requiredConfirmations !== void 0 ? _initOrObject_requiredConfirmations : this.data.getConfirmationsHint();
            var _ref;
            this.nonce = (_ref = initOrObject.nonce == null ? null : BigInt(initOrObject.nonce)) !== null && _ref !== void 0 ? _ref : this.data.getNonceHint();
        }
        this.logger = (0, Utils_1.getLogger)("ToBTC(" + this.getIdentifierHashString() + "): ");
        this.tryRecomputeSwapPrice();
    }
}
exports.ToBTCSwap = ToBTCSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ToBTCWrapper = void 0;
const ToBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCSwap.js [app-client] (ecmascript)");
const IToBTCWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCWrapper.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const UserError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/UserError.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
class ToBTCWrapper extends IToBTCWrapper_1.IToBTCWrapper {
    /**
     * Returns randomly generated random escrow nonce to be used for to BTC on-chain swaps
     * @private
     * @returns Escrow nonce
     */ getRandomNonce() {
        const firstPart = BigInt(Math.floor(Date.now() / 1000) - 700000000);
        return firstPart << 24n | base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(3));
    }
    /**
     * Converts bitcoin address to its corresponding output script
     *
     * @param addr Bitcoin address to get the output script for
     * @private
     * @returns Output script as Buffer
     * @throws {UserError} if invalid address is specified
     */ btcAddressToOutputScript(addr) {
        try {
            return (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, addr);
        } catch (e) {
            throw new UserError_1.UserError("Invalid address specified");
        }
    }
    /**
     * Verifies returned LP data
     *
     * @param resp LP's response
     * @param amountData
     * @param lp
     * @param options Options as passed to the swap create function
     * @param data LP's returned parsed swap data
     * @param hash Payment hash of the swap
     * @private
     * @throws {IntermediaryError} if returned data are not correct
     */ verifyReturnedData(resp, amountData, lp, options, data, hash) {
        if (resp.totalFee !== resp.swapFee + resp.networkFee) throw new IntermediaryError_1.IntermediaryError("Invalid totalFee returned");
        if (amountData.exactIn) {
            if (resp.total !== amountData.amount) throw new IntermediaryError_1.IntermediaryError("Invalid total returned");
        } else {
            if (resp.amount !== amountData.amount) throw new IntermediaryError_1.IntermediaryError("Invalid amount returned");
        }
        const maxAllowedBlockDelta = BigInt(options.confirmations + options.confirmationTarget + this.options.maxExpectedOnchainSendGracePeriodBlocks);
        const maxAllowedExpiryDelta = maxAllowedBlockDelta * BigInt(this.options.maxExpectedOnchainSendSafetyFactor) * BigInt(this.options.bitcoinBlocktime);
        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
        const maxAllowedExpiryTimestamp = currentTimestamp + maxAllowedExpiryDelta;
        if (data.getExpiry() > maxAllowedExpiryTimestamp) {
            throw new IntermediaryError_1.IntermediaryError("Expiry time returned too high!");
        }
        if (data.getAmount() !== resp.total || data.getClaimHash() !== hash || data.getType() !== base_1.ChainSwapType.CHAIN_NONCED || !data.isPayIn() || !data.isToken(amountData.token) || data.getClaimer() !== lp.getAddress(this.chainIdentifier)) {
            throw new IntermediaryError_1.IntermediaryError("Invalid data returned");
        }
    }
    /**
     * Returns quotes fetched from LPs, paying to an 'address' - a bitcoin address
     *
     * @param signer                Smart-chain signer address initiating the swap
     * @param address               Bitcoin on-chain address you wish to pay to
     * @param amountData            Amount of token & amount to swap
     * @param lps                   LPs (liquidity providers) to get the quotes from
     * @param options               Quote options
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param abortSignal           Abort signal for aborting the process
     */ create(signer, address, amountData, lps, options, additionalParams, abortSignal) {
        var _options, _options1;
        if (!this.isInitialized) throw new Error("Not initialized, call init() first!");
        options !== null && options !== void 0 ? options : options = {};
        var _confirmationTarget;
        (_confirmationTarget = (_options = options).confirmationTarget) !== null && _confirmationTarget !== void 0 ? _confirmationTarget : _options.confirmationTarget = 3;
        var _confirmations;
        (_confirmations = (_options1 = options).confirmations) !== null && _confirmations !== void 0 ? _confirmations : _options1.confirmations = 2;
        const nonce = this.getRandomNonce();
        const outputScript = this.btcAddressToOutputScript(address);
        const _hash = !amountData.exactIn ? this.contract.getHashForOnchain(outputScript, amountData.amount, options.confirmations, nonce).toString("hex") : null;
        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const pricePreFetchPromise = this.preFetchPrice(amountData, _abortController.signal);
        const feeRatePromise = this.preFetchFeeRate(signer, amountData, _hash, _abortController);
        return lps.map((lp)=>{
            return {
                intermediary: lp,
                quote: (async ()=>{
                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);
                    const reputationPromise = this.preFetchIntermediaryReputation(amountData, lp, abortController);
                    try {
                        const { signDataPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount)=>{
                            const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.initToBTC(this.chainIdentifier, lp.url, {
                                btcAddress: address,
                                amount: amountData.amount,
                                confirmationTarget: options.confirmationTarget,
                                confirmations: options.confirmations,
                                nonce: nonce,
                                token: amountData.token,
                                offerer: signer,
                                exactIn: amountData.exactIn,
                                feeRate: feeRatePromise,
                                additionalParams
                            }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);
                            return {
                                signDataPromise: this.preFetchSignData(signDataPrefetch),
                                resp: await response
                            };
                        }, null, RequestError_1.RequestError, abortController.signal);
                        let hash = amountData.exactIn ? this.contract.getHashForOnchain(outputScript, resp.amount, options.confirmations, nonce).toString("hex") : _hash;
                        const data = new this.swapDataDeserializer(resp.data);
                        data.setOfferer(signer);
                        this.verifyReturnedData(resp, amountData, lp, options, data, hash);
                        const [pricingInfo, signatureExpiry, reputation] = await Promise.all([
                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.TO_BTC], true, resp.amount, data.getAmount(), amountData.token, resp, pricePreFetchPromise, abortController.signal),
                            this.verifyReturnedSignature(signer, data, resp, feeRatePromise, signDataPromise, abortController.signal),
                            reputationPromise
                        ]);
                        abortController.signal.throwIfAborted();
                        lp.reputation[amountData.token.toString()] = reputation;
                        var _amountData_exactIn;
                        const quote = new ToBTCSwap_1.ToBTCSwap(this, {
                            pricingInfo,
                            url: lp.url,
                            expiry: signatureExpiry,
                            swapFee: resp.swapFee,
                            feeRate: await feeRatePromise,
                            signatureData: resp,
                            data,
                            networkFee: resp.networkFee,
                            address,
                            amount: resp.amount,
                            confirmationTarget: options.confirmationTarget,
                            satsPerVByte: Number(resp.satsPervByte),
                            exactIn: (_amountData_exactIn = amountData.exactIn) !== null && _amountData_exactIn !== void 0 ? _amountData_exactIn : false,
                            requiredConfirmations: options.confirmations,
                            nonce
                        });
                        await quote._save();
                        return quote;
                    } catch (e) {
                        abortController.abort(e);
                        throw e;
                    }
                })()
            };
        });
    }
    /**
     * @param chainIdentifier
     * @param unifiedStorage Storage interface for the current environment
     * @param unifiedChainEvents Smart chain on-chain event listener
     * @param chain
     * @param contract Chain specific swap contract
     * @param prices Swap pricing handler
     * @param tokens
     * @param swapDataDeserializer Deserializer for chain specific SwapData
     * @param btcRpc Bitcoin RPC api
     * @param options
     * @param events Instance to use for emitting events
     */ constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, btcRpc, options, events){
        if (options == null) options = {};
        var _options_bitcoinNetwork;
        options.bitcoinNetwork = (_options_bitcoinNetwork = options.bitcoinNetwork) !== null && _options_bitcoinNetwork !== void 0 ? _options_bitcoinNetwork : utils_1.TEST_NETWORK;
        options.safetyFactor = options.safetyFactor || 2;
        options.maxConfirmations = options.maxConfirmations || 6;
        options.bitcoinBlocktime = options.bitcoinBlocktime || 60 * 10;
        options.maxExpectedOnchainSendSafetyFactor = options.maxExpectedOnchainSendSafetyFactor || 4;
        options.maxExpectedOnchainSendGracePeriodBlocks = options.maxExpectedOnchainSendGracePeriodBlocks || 12;
        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);
        this.TYPE = SwapType_1.SwapType.TO_BTC;
        this.swapDeserializer = ToBTCSwap_1.ToBTCSwap;
        this.btcRpc = btcRpc;
    }
}
exports.ToBTCWrapper = ToBTCWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IFromBTCSwap = void 0;
const ISwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const IEscrowSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwap.js [app-client] (ecmascript)");
const Fee_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js [app-client] (ecmascript)");
class IFromBTCSwap extends IEscrowSwap_1.IEscrowSwap {
    /**
     * In case swapFee in BTC is not supplied it recalculates it based on swap price
     * @protected
     */ tryRecomputeSwapPrice() {
        if (this.swapFeeBtc == null) {
            this.swapFeeBtc = this.swapFee * this.getInput().rawAmount / this.getOutAmountWithoutFee();
        }
        super.tryRecomputeSwapPrice();
    }
    getSwapData() {
        return this.data;
    }
    _getInitiator() {
        return this.getSwapData().getClaimer();
    }
    getOutputTxId() {
        return this.claimTxId;
    }
    getOutputAddress() {
        return this._getInitiator();
    }
    requiresAction() {
        return this.isClaimable();
    }
    //////////////////////////////
    //// Amounts & fees
    getOutAmountWithoutFee() {
        return this.getSwapData().getAmount() + this.swapFee;
    }
    getSwapFee() {
        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;
        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getInputWithoutFee().rawAmount;
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, this.inputToken, this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.getSwapData().getToken()], this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),
            composition: {
                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, this.inputToken, this.wrapper.prices),
                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)
            }
        };
    }
    getFee() {
        return this.getSwapFee();
    }
    getFeeBreakdown() {
        return [
            {
                type: Fee_1.FeeType.SWAP,
                fee: this.getSwapFee()
            }
        ];
    }
    getOutput() {
        return (0, Tokens_1.toTokenAmount)(this.getSwapData().getAmount(), this.wrapper.tokens[this.getSwapData().getToken()], this.wrapper.prices);
    }
    getInputWithoutFee() {
        return (0, Tokens_1.toTokenAmount)(this.getInput().rawAmount - this.swapFeeBtc, this.inputToken, this.wrapper.prices);
    }
    getSecurityDeposit() {
        return (0, Tokens_1.toTokenAmount)(this.getSwapData().getSecurityDeposit(), this.wrapper.getNativeToken(), this.wrapper.prices);
    }
    getTotalDeposit() {
        return (0, Tokens_1.toTokenAmount)(this.getSwapData().getTotalDeposit(), this.wrapper.getNativeToken(), this.wrapper.prices);
    }
    async hasEnoughForTxFees() {
        const [balance, commitFee] = await Promise.all([
            this.wrapper.contract.getBalance(this._getInitiator(), this.wrapper.chain.getNativeCurrencyAddress(), false),
            this.getCommitFee()
        ]);
        const totalFee = commitFee + this.getSwapData().getTotalDeposit();
        return {
            enoughBalance: balance >= totalFee,
            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.getNativeToken(), this.wrapper.prices),
            required: (0, Tokens_1.toTokenAmount)(totalFee, this.wrapper.getNativeToken(), this.wrapper.prices)
        };
    }
    //////////////////////////////
    //// Commit
    /**
     * Returns the transactions required for committing the swap on-chain, locking the tokens from the intermediary
     *  in an HTLC or PTLC
     *
     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet
     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)
     * @throws {Error} When in invalid state to commit the swap
     */ async txsCommit(skipChecks) {
        if (!this.canCommit()) throw new Error("Must be in CREATED state!");
        if (!this.initiated) {
            this.initiated = true;
            await this._saveAndEmit();
        }
        return await this.wrapper.contract.txsInit(this._getInitiator(), this.data, this.signatureData, skipChecks, this.feeRate).catch((e)=>Promise.reject(e instanceof base_1.SignatureVerificationError ? new Error("Request timed out") : e));
    }
    //////////////////////////////
    //// Claim
    getClaimFee() {
        return this.wrapper.contract.getClaimFee(this._getInitiator(), this.getSwapData());
    }
    constructor(wrapper, initOrObj){
        super(wrapper, initOrObj);
    }
}
exports.IFromBTCSwap = IFromBTCSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FromBTCLNSwap = exports.isFromBTCLNSwapInit = exports.FromBTCLNSwapState = void 0;
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const IFromBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCSwap.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const LNURL_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)");
const UserError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/UserError.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const IEscrowSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwap.js [app-client] (ecmascript)");
var FromBTCLNSwapState;
(function(FromBTCLNSwapState) {
    FromBTCLNSwapState[FromBTCLNSwapState["FAILED"] = -4] = "FAILED";
    FromBTCLNSwapState[FromBTCLNSwapState["QUOTE_EXPIRED"] = -3] = "QUOTE_EXPIRED";
    FromBTCLNSwapState[FromBTCLNSwapState["QUOTE_SOFT_EXPIRED"] = -2] = "QUOTE_SOFT_EXPIRED";
    FromBTCLNSwapState[FromBTCLNSwapState["EXPIRED"] = -1] = "EXPIRED";
    FromBTCLNSwapState[FromBTCLNSwapState["PR_CREATED"] = 0] = "PR_CREATED";
    FromBTCLNSwapState[FromBTCLNSwapState["PR_PAID"] = 1] = "PR_PAID";
    FromBTCLNSwapState[FromBTCLNSwapState["CLAIM_COMMITED"] = 2] = "CLAIM_COMMITED";
    FromBTCLNSwapState[FromBTCLNSwapState["CLAIM_CLAIMED"] = 3] = "CLAIM_CLAIMED";
})(FromBTCLNSwapState = exports.FromBTCLNSwapState || (exports.FromBTCLNSwapState = {}));
function isFromBTCLNSwapInit(obj) {
    return typeof obj.pr === "string" && typeof obj.secret === "string" && (obj.lnurl == null || typeof obj.lnurl === "string") && (obj.lnurlK1 == null || typeof obj.lnurlK1 === "string") && (obj.lnurlCallback == null || typeof obj.lnurlCallback === "string") && (0, IEscrowSwap_1.isIEscrowSwapInit)(obj);
}
exports.isFromBTCLNSwapInit = isFromBTCLNSwapInit;
class FromBTCLNSwap extends IFromBTCSwap_1.IFromBTCSwap {
    getSwapData() {
        var _this_data;
        return (_this_data = this.data) !== null && _this_data !== void 0 ? _this_data : this.initialSwapData;
    }
    upgradeVersion() {
        if (this.version == null) {
            switch(this.state){
                case -2:
                    this.state = FromBTCLNSwapState.QUOTE_EXPIRED;
                    break;
                case -1:
                    this.state = FromBTCLNSwapState.FAILED;
                    break;
                case 0:
                    this.state = FromBTCLNSwapState.PR_CREATED;
                    break;
                case 1:
                    this.state = FromBTCLNSwapState.PR_PAID;
                    break;
                case 2:
                    this.state = FromBTCLNSwapState.CLAIM_COMMITED;
                    break;
                case 3:
                    this.state = FromBTCLNSwapState.CLAIM_CLAIMED;
                    break;
            }
            this.version = 1;
        }
    }
    //////////////////////////////
    //// Getters & utils
    getIdentifierHash() {
        const paymentHashBuffer = this.getPaymentHash();
        if (this.randomNonce == null) return paymentHashBuffer;
        return buffer_1.Buffer.concat([
            paymentHashBuffer,
            buffer_1.Buffer.from(this.randomNonce, "hex")
        ]);
    }
    getPaymentHash() {
        if (this.pr == null) return null;
        const decodedPR = (0, bolt11_1.decode)(this.pr);
        return buffer_1.Buffer.from(decodedPR.tagsObject.payment_hash, "hex");
    }
    canCommit() {
        return this.state === FromBTCLNSwapState.PR_PAID;
    }
    getInputTxId() {
        return this.getPaymentHash().toString("hex");
    }
    /**
     * Returns the lightning network BOLT11 invoice that needs to be paid as an input to the swap
     */ getAddress() {
        return this.pr;
    }
    getHyperlink() {
        return "lightning:" + this.pr.toUpperCase();
    }
    /**
     * Returns timeout time (in UNIX milliseconds) when the LN invoice will expire
     */ getTimeoutTime() {
        if (this.pr == null) return null;
        const decoded = (0, bolt11_1.decode)(this.pr);
        return decoded.timeExpireDate * 1000;
    }
    /**
     * Returns timeout time (in UNIX milliseconds) when the swap htlc will expire
     */ getHtlcTimeoutTime() {
        return Number(this.wrapper.getHtlcTimeout(this.data)) * 1000;
    }
    isFinished() {
        return this.state === FromBTCLNSwapState.CLAIM_CLAIMED || this.state === FromBTCLNSwapState.QUOTE_EXPIRED || this.state === FromBTCLNSwapState.FAILED;
    }
    isClaimable() {
        return this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.CLAIM_COMMITED;
    }
    isSuccessful() {
        return this.state === FromBTCLNSwapState.CLAIM_CLAIMED;
    }
    isFailed() {
        return this.state === FromBTCLNSwapState.FAILED || this.state === FromBTCLNSwapState.EXPIRED;
    }
    isQuoteExpired() {
        return this.state === FromBTCLNSwapState.QUOTE_EXPIRED;
    }
    isQuoteSoftExpired() {
        return this.state === FromBTCLNSwapState.QUOTE_EXPIRED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;
    }
    verifyQuoteValid() {
        if (this.state === FromBTCLNSwapState.PR_CREATED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData == null) {
            return Promise.resolve(this.getTimeoutTime() > Date.now());
        }
        return super.verifyQuoteValid();
    }
    //////////////////////////////
    //// Amounts & fees
    getInput() {
        const parsed = (0, bolt11_1.decode)(this.pr);
        const amount = (BigInt(parsed.millisatoshis) + 999n) / 1000n;
        return (0, Tokens_1.toTokenAmount)(amount, this.inputToken, this.wrapper.prices);
    }
    async getSmartChainNetworkFee() {
        return (0, Tokens_1.toTokenAmount)(await this.getCommitAndClaimFee(), this.wrapper.getNativeToken(), this.wrapper.prices);
    }
    async hasEnoughForTxFees() {
        const [balance, feeRate] = await Promise.all([
            this.wrapper.contract.getBalance(this._getInitiator(), this.wrapper.chain.getNativeCurrencyAddress(), false),
            this.feeRate != null ? Promise.resolve(this.feeRate) : this.wrapper.contract.getInitFeeRate(this.getSwapData().getOfferer(), this.getSwapData().getClaimer(), this.getSwapData().getToken(), this.getSwapData().getClaimHash())
        ]);
        const commitFee = await this.wrapper.contract.getCommitFee(this.getSwapData(), feeRate);
        const claimFee = await this.wrapper.contract.getClaimFee(this._getInitiator(), this.getSwapData(), feeRate);
        const totalFee = commitFee + claimFee + this.getSwapData().getTotalDeposit();
        return {
            enoughBalance: balance >= totalFee,
            balance: (0, Tokens_1.toTokenAmount)(balance, this.wrapper.getNativeToken(), this.wrapper.prices),
            required: (0, Tokens_1.toTokenAmount)(totalFee, this.wrapper.getNativeToken(), this.wrapper.prices)
        };
    }
    //////////////////////////////
    //// Payment
    /**
     * Checks whether the LP received the LN payment and we can continue by committing & claiming the HTLC on-chain
     *
     * @param save If the new swap state should be saved
     */ async checkIntermediaryPaymentReceived() {
        let save = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.CLAIM_COMMITED || this.state === FromBTCLNSwapState.CLAIM_CLAIMED || this.state === FromBTCLNSwapState.FAILED) return true;
        if (this.state === FromBTCLNSwapState.QUOTE_EXPIRED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null) return false;
        const resp = await IntermediaryAPI_1.IntermediaryAPI.getPaymentAuthorization(this.url, this.getPaymentHash().toString("hex"));
        switch(resp.code){
            case IntermediaryAPI_1.PaymentAuthorizationResponseCodes.AUTH_DATA:
                const data = new this.wrapper.swapDataDeserializer(resp.data.data);
                try {
                    await this.checkIntermediaryReturnedAuthData(this._getInitiator(), data, resp.data);
                    this.expiry = await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getInitAuthorizationExpiry(data, resp.data));
                    this.state = FromBTCLNSwapState.PR_PAID;
                    delete this.initialSwapData;
                    this.data = data;
                    this.signatureData = {
                        prefix: resp.data.prefix,
                        timeout: resp.data.timeout,
                        signature: resp.data.signature
                    };
                    this.initiated = true;
                    if (save) await this._saveAndEmit();
                    return true;
                } catch (e) {}
                return null;
            case IntermediaryAPI_1.PaymentAuthorizationResponseCodes.EXPIRED:
                this.state = FromBTCLNSwapState.QUOTE_EXPIRED;
                this.initiated = true;
                if (save) await this._saveAndEmit();
                return false;
            default:
                return null;
        }
    }
    /**
     * Checks the data returned by the intermediary in the payment auth request
     *
     * @param signer Smart chain signer's address initiating the swap
     * @param data Parsed swap data as returned by the intermediary
     * @param signature Signature data as returned by the intermediary
     * @protected
     * @throws {IntermediaryError} If the returned are not valid
     * @throws {SignatureVerificationError} If the returned signature is not valid
     * @throws {Error} If the swap is already committed on-chain
     */ async checkIntermediaryReturnedAuthData(signer, data, signature) {
        data.setClaimer(signer);
        if (data.getOfferer() !== this.getSwapData().getOfferer()) throw new IntermediaryError_1.IntermediaryError("Invalid offerer used");
        if (!data.isToken(this.getSwapData().getToken())) throw new IntermediaryError_1.IntermediaryError("Invalid token used");
        if (data.getSecurityDeposit() > this.getSwapData().getSecurityDeposit()) throw new IntermediaryError_1.IntermediaryError("Invalid security deposit!");
        if (data.getAmount() < this.getSwapData().getAmount()) throw new IntermediaryError_1.IntermediaryError("Invalid amount received!");
        if (data.getClaimHash() !== this.getSwapData().getClaimHash()) throw new IntermediaryError_1.IntermediaryError("Invalid payment hash used!");
        if (!data.isDepositToken(this.getSwapData().getDepositToken())) throw new IntermediaryError_1.IntermediaryError("Invalid deposit token used!");
        await Promise.all([
            (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.isValidInitAuthorization(this._getInitiator(), data, signature, this.feeRate), null, base_1.SignatureVerificationError),
            (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(data.getClaimer(), data)).then((status)=>{
                if ((status === null || status === void 0 ? void 0 : status.type) !== base_1.SwapCommitStateType.NOT_COMMITED) throw new Error("Swap already committed on-chain!");
            })
        ]);
    }
    /**
     * Waits till an LN payment is received by the intermediary and client can continue commiting & claiming the HTLC
     *
     * @param abortSignal Abort signal to stop waiting for payment
     * @param checkIntervalSeconds How often to poll the intermediary for answer
     */ async waitForPayment(abortSignal) {
        let checkIntervalSeconds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        if (this.state !== FromBTCLNSwapState.PR_CREATED && (this.state !== FromBTCLNSwapState.QUOTE_SOFT_EXPIRED || this.signatureData != null)) throw new Error("Must be in PR_CREATED state!");
        const abortController = new AbortController();
        if (abortSignal != null) abortSignal.addEventListener("abort", ()=>abortController.abort(abortSignal.reason));
        let save = false;
        if (this.lnurl != null && !this.prPosted) {
            LNURL_1.LNURL.postInvoiceToLNURLWithdraw({
                k1: this.lnurlK1,
                callback: this.lnurlCallback
            }, this.pr).catch((e)=>{
                this.lnurlFailSignal.abort(e);
            });
            this.prPosted = true;
            save || (save = true);
        }
        if (!this.initiated) {
            this.initiated = true;
            save || (save = true);
        }
        if (save) await this._saveAndEmit();
        let lnurlFailListener = ()=>abortController.abort(this.lnurlFailSignal.signal.reason);
        this.lnurlFailSignal.signal.addEventListener("abort", lnurlFailListener);
        this.lnurlFailSignal.signal.throwIfAborted();
        let resp = {
            code: IntermediaryAPI_1.PaymentAuthorizationResponseCodes.PENDING,
            msg: ""
        };
        while(!abortController.signal.aborted && resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.PENDING){
            resp = await IntermediaryAPI_1.IntermediaryAPI.getPaymentAuthorization(this.url, this.getPaymentHash().toString("hex"));
            if (resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.PENDING) await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortController.signal);
        }
        this.lnurlFailSignal.signal.removeEventListener("abort", lnurlFailListener);
        abortController.signal.throwIfAborted();
        if (resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.AUTH_DATA) {
            const sigData = resp.data;
            const swapData = new this.wrapper.swapDataDeserializer(resp.data.data);
            await this.checkIntermediaryReturnedAuthData(this._getInitiator(), swapData, sigData);
            this.expiry = await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getInitAuthorizationExpiry(swapData, sigData));
            if (this.state === FromBTCLNSwapState.PR_CREATED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {
                delete this.initialSwapData;
                this.data = swapData;
                this.signatureData = {
                    prefix: sigData.prefix,
                    timeout: sigData.timeout,
                    signature: sigData.signature
                };
                await this._saveAndEmit(FromBTCLNSwapState.PR_PAID);
            }
            return true;
        }
        if (this.state === FromBTCLNSwapState.PR_CREATED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {
            if (resp.code === IntermediaryAPI_1.PaymentAuthorizationResponseCodes.EXPIRED) {
                await this._saveAndEmit(FromBTCLNSwapState.QUOTE_EXPIRED);
            }
            return false;
        }
    }
    //////////////////////////////
    //// Commit
    /**
     * Commits the swap on-chain, locking the tokens from the intermediary in an HTLC
     *
     * @param signer Signer to sign the transactions with, must be the same as used in the initialization
     * @param abortSignal Abort signal to stop waiting for the transaction confirmation and abort
     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet
     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)
     * @throws {Error} If invalid signer is provided that doesn't match the swap data
     */ async commit(signer, abortSignal, skipChecks) {
        this.checkSigner(signer);
        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommit(skipChecks), true, abortSignal);
        this.commitTxId = result[0];
        if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {
            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_COMMITED);
        }
        return result[0];
    }
    async waitTillCommited(abortSignal) {
        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED || this.state === FromBTCLNSwapState.CLAIM_CLAIMED) return Promise.resolve();
        if (this.state !== FromBTCLNSwapState.PR_PAID && this.state !== FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null) throw new Error("Invalid state");
        const abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const result = await Promise.race([
            this.watchdogWaitTillCommited(abortController.signal),
            this.waitTillState(FromBTCLNSwapState.CLAIM_COMMITED, "gte", abortController.signal).then(()=>0)
        ]);
        abortController.abort();
        if (result === 0) this.logger.debug("waitTillCommited(): Resolved from state changed");
        if (result === true) this.logger.debug("waitTillCommited(): Resolved from watchdog - commited");
        if (result === false) {
            this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expired");
            if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {
                await this._saveAndEmit(FromBTCLNSwapState.QUOTE_EXPIRED);
            }
            return;
        }
        if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {
            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_COMMITED);
        }
    }
    //////////////////////////////
    //// Claim
    /**
     * Returns transactions required for claiming the HTLC and finishing the swap by revealing the HTLC secret
     *  (hash preimage)
     *
     * @param signer Optional signer address to use for claiming the swap, can also be different from the initializer
     * @throws {Error} If in invalid state (must be CLAIM_COMMITED)
     */ txsClaim(signer) {
        if (this.state !== FromBTCLNSwapState.CLAIM_COMMITED) throw new Error("Must be in CLAIM_COMMITED state!");
        return this.wrapper.contract.txsClaimWithSecret(signer !== null && signer !== void 0 ? signer : this._getInitiator(), this.data, this.secret, true, true);
    }
    /**
     * Claims and finishes the swap
     *
     * @param signer Signer to sign the transactions with, can also be different to the initializer
     * @param abortSignal Abort signal to stop waiting for transaction confirmation
     */ async claim(signer, abortSignal) {
        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsClaim(), true, abortSignal);
        this.claimTxId = result[0];
        if (FromBTCLNSwapState.CLAIM_COMMITED || FromBTCLNSwapState.EXPIRED || FromBTCLNSwapState.FAILED) {
            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_CLAIMED);
        }
        return result[0];
    }
    /**
     * Waits till the swap is successfully claimed
     *
     * @param abortSignal AbortSignal
     * @throws {Error} If swap is in invalid state (must be BTC_TX_CONFIRMED)
     * @throws {Error} If the LP refunded sooner than we were able to claim
     */ async waitTillClaimed(abortSignal) {
        if (this.state === FromBTCLNSwapState.CLAIM_CLAIMED) return Promise.resolve();
        if (this.state !== FromBTCLNSwapState.CLAIM_COMMITED) throw new Error("Invalid state (not CLAIM_COMMITED)");
        const abortController = new AbortController();
        if (abortSignal != null) abortSignal.addEventListener("abort", ()=>abortController.abort(abortSignal.reason));
        const res = await Promise.race([
            this.watchdogWaitTillResult(abortController.signal),
            this.waitTillState(FromBTCLNSwapState.CLAIM_CLAIMED, "eq", abortController.signal).then(()=>0),
            this.waitTillState(FromBTCLNSwapState.EXPIRED, "eq", abortController.signal).then(()=>1)
        ]);
        abortController.abort();
        if (res === 0) {
            this.logger.debug("waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)");
            return;
        }
        if (res === 1) {
            this.logger.debug("waitTillClaimed(): Resolved from state change (EXPIRED)");
            throw new Error("Swap expired during claiming");
        }
        this.logger.debug("waitTillClaimed(): Resolved from watchdog");
        if ((res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.PAID) {
            if (this.state !== FromBTCLNSwapState.CLAIM_CLAIMED) {
                this.claimTxId = await res.getClaimTxId();
                await this._saveAndEmit(FromBTCLNSwapState.CLAIM_CLAIMED);
            }
        }
        if ((res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.NOT_COMMITED || (res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.EXPIRED) {
            if (this.state !== FromBTCLNSwapState.CLAIM_CLAIMED && this.state !== FromBTCLNSwapState.FAILED) {
                this.refundTxId = res.getRefundTxId == null ? null : await res.getRefundTxId();
                await this._saveAndEmit(FromBTCLNSwapState.FAILED);
            }
        }
    }
    //////////////////////////////
    //// Commit & claim
    /**
     * Estimated transaction fee for commit & claim txs combined
     */ async getCommitAndClaimFee() {
        const swapContract = this.wrapper.contract;
        var _this_feeRate;
        const feeRate = (_this_feeRate = this.feeRate) !== null && _this_feeRate !== void 0 ? _this_feeRate : await swapContract.getInitFeeRate(this.getSwapData().getOfferer(), this.getSwapData().getClaimer(), this.getSwapData().getToken(), this.getSwapData().getClaimHash());
        const commitFee = await (swapContract.getRawCommitFee != null ? swapContract.getRawCommitFee(this.getSwapData(), feeRate) : swapContract.getCommitFee(this.getSwapData(), feeRate));
        const claimFee = await (swapContract.getRawClaimFee != null ? swapContract.getRawClaimFee(this._getInitiator(), this.getSwapData(), feeRate) : swapContract.getClaimFee(this._getInitiator(), this.getSwapData(), feeRate));
        return commitFee + claimFee;
    }
    canCommitAndClaimInOneShot() {
        return this.wrapper.contract.initAndClaimWithSecret != null;
    }
    /**
     * Returns transactions for both commit & claim operation together, such that they can be signed all at once by
     *  the wallet. CAUTION: transactions must be sent sequentially, such that the claim (2nd) transaction is only
     *  sent after the commit (1st) transaction confirms. Failure to do so can reveal the HTLC pre-image too soon,
     *  opening a possibility for the LP to steal funds.
     *
     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet
     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)
     *
     * @throws {Error} If in invalid state (must be PR_PAID or CLAIM_COMMITED)
     */ async txsCommitAndClaim(skipChecks) {
        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED) return await this.txsClaim();
        if (this.state !== FromBTCLNSwapState.PR_PAID && (this.state !== FromBTCLNSwapState.QUOTE_SOFT_EXPIRED || this.signatureData == null)) throw new Error("Must be in PR_PAID state!");
        const initTxs = await this.txsCommit(skipChecks);
        const claimTxs = await this.wrapper.contract.txsClaimWithSecret(this._getInitiator(), this.data, this.secret, true, true, null, true);
        return initTxs.concat(claimTxs);
    }
    /**
     * Commits and claims the swap, in a way that the transactions can be signed together by the underlying provider and
     *  then sent sequentially
     *
     * @param signer Signer to sign the transactions with, must be the same as used in the initialization
     * @param abortSignal Abort signal to stop waiting for the transaction confirmation and abort
     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet
     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)
     * @throws {Error} If in invalid state (must be PR_PAID or CLAIM_COMMITED)
     * @throws {Error} If invalid signer is provided that doesn't match the swap data
     */ async commitAndClaim(signer, abortSignal, skipChecks) {
        if (!this.canCommitAndClaimInOneShot()) throw new Error("Cannot commitAndClaim in single action, please run commit and claim separately!");
        this.checkSigner(signer);
        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED) return [
            null,
            await this.claim(signer)
        ];
        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommitAndClaim(skipChecks), true, abortSignal);
        this.commitTxId = result[0] || this.commitTxId;
        this.claimTxId = result[result.length - 1] || this.claimTxId;
        if (this.state !== FromBTCLNSwapState.CLAIM_CLAIMED) {
            await this._saveAndEmit(FromBTCLNSwapState.CLAIM_CLAIMED);
        }
        return result;
    }
    //////////////////////////////
    //// LNURL
    /**
     * Is this an LNURL-withdraw swap?
     */ isLNURL() {
        return this.lnurl != null;
    }
    /**
     * Gets the used LNURL or null if this is not an LNURL-withdraw swap
     */ getLNURL() {
        return this.lnurl;
    }
    /**
     * Pay the generated lightning network invoice with LNURL-withdraw
     */ async settleWithLNURLWithdraw(lnurl) {
        if (this.lnurl != null) throw new Error("Cannot settle LNURL-withdraw swap with different LNURL");
        let lnurlParams;
        if (typeof lnurl === "string") {
            const parsedLNURL = await LNURL_1.LNURL.getLNURL(lnurl);
            if (parsedLNURL == null || parsedLNURL.tag !== "withdrawRequest") throw new UserError_1.UserError("Invalid LNURL-withdraw to settle the swap");
            lnurlParams = parsedLNURL;
        } else {
            lnurlParams = lnurl.params;
        }
        LNURL_1.LNURL.useLNURLWithdraw(lnurlParams, this.pr).catch((e)=>this.lnurlFailSignal.abort(e));
        this.lnurl = lnurlParams.url;
        this.lnurlCallback = lnurlParams.callback;
        this.lnurlK1 = lnurlParams.k1;
        this.prPosted = true;
        await this._saveAndEmit();
    }
    //////////////////////////////
    //// Storage
    serialize() {
        return {
            ...super.serialize(),
            pr: this.pr,
            secret: this.secret,
            lnurl: this.lnurl,
            lnurlK1: this.lnurlK1,
            lnurlCallback: this.lnurlCallback,
            prPosted: this.prPosted,
            initialSwapData: this.initialSwapData == null ? null : this.initialSwapData.serialize()
        };
    }
    //////////////////////////////
    //// Swap ticks & sync
    /**
     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain
     *  data
     *
     * @private
     */ async syncStateFromChain() {
        //Check for expiry before the getCommitStatus to prevent race conditions
        let quoteExpired = false;
        if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null) {
            quoteExpired = await this.verifyQuoteDefinitelyExpired();
        }
        if (this.state === FromBTCLNSwapState.CLAIM_COMMITED || this.state === FromBTCLNSwapState.EXPIRED) {
            //Check if it's already successfully paid
            const commitStatus = await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));
            if ((commitStatus === null || commitStatus === void 0 ? void 0 : commitStatus.type) === base_1.SwapCommitStateType.PAID) {
                if (this.claimTxId == null) this.claimTxId = await commitStatus.getClaimTxId();
                this.state = FromBTCLNSwapState.CLAIM_CLAIMED;
                return true;
            }
            if ((commitStatus === null || commitStatus === void 0 ? void 0 : commitStatus.type) === base_1.SwapCommitStateType.NOT_COMMITED || (commitStatus === null || commitStatus === void 0 ? void 0 : commitStatus.type) === base_1.SwapCommitStateType.EXPIRED) {
                if (this.refundTxId == null && commitStatus.getRefundTxId) this.refundTxId = await commitStatus.getRefundTxId();
                this.state = FromBTCLNSwapState.FAILED;
                return true;
            }
        }
        if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null) {
            //Check if it's already committed
            const status = await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));
            switch(status === null || status === void 0 ? void 0 : status.type){
                case base_1.SwapCommitStateType.COMMITED:
                    this.state = FromBTCLNSwapState.CLAIM_COMMITED;
                    return true;
                case base_1.SwapCommitStateType.EXPIRED:
                    if (this.refundTxId == null && status.getRefundTxId) this.refundTxId = await status.getRefundTxId();
                    this.state = FromBTCLNSwapState.QUOTE_EXPIRED;
                    return true;
                case base_1.SwapCommitStateType.PAID:
                    if (this.claimTxId == null) this.claimTxId = await status.getClaimTxId();
                    this.state = FromBTCLNSwapState.CLAIM_CLAIMED;
                    return true;
            }
        }
        //Set the state on expiry here
        if (this.state === FromBTCLNSwapState.PR_PAID || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData != null) {
            if (quoteExpired) {
                this.state = FromBTCLNSwapState.QUOTE_EXPIRED;
                return true;
            }
        }
    }
    async _sync(save) {
        let changed = false;
        if (this.state === FromBTCLNSwapState.PR_CREATED || this.state === FromBTCLNSwapState.QUOTE_SOFT_EXPIRED && this.signatureData == null) {
            if (this.getTimeoutTime() < Date.now()) {
                this.state = FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;
                changed || (changed = true);
            }
            const result = await this.checkIntermediaryPaymentReceived(false);
            if (result !== null) changed || (changed = true);
        }
        if (await this.syncStateFromChain()) changed = true;
        if (save && changed) await this._saveAndEmit();
        return changed;
    }
    async _tick(save) {
        switch(this.state){
            case FromBTCLNSwapState.PR_CREATED:
                if (this.getTimeoutTime() < Date.now()) {
                    this.state = FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                break;
            case FromBTCLNSwapState.PR_PAID:
                if (this.expiry < Date.now()) {
                    this.state = FromBTCLNSwapState.QUOTE_SOFT_EXPIRED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                break;
            case FromBTCLNSwapState.CLAIM_COMMITED:
                const expired = await this.wrapper.contract.isExpired(this._getInitiator(), this.data);
                if (expired) {
                    this.state = FromBTCLNSwapState.EXPIRED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                break;
        }
    }
    constructor(wrapper, initOrObject){
        if (isFromBTCLNSwapInit(initOrObject)) initOrObject.url += "/frombtcln";
        super(wrapper, initOrObject);
        this.inputToken = Tokens_1.BitcoinTokens.BTCLN;
        this.TYPE = SwapType_1.SwapType.FROM_BTCLN;
        this.lnurlFailSignal = new AbortController();
        this.prPosted = false;
        if (isFromBTCLNSwapInit(initOrObject)) {
            this.state = FromBTCLNSwapState.PR_CREATED;
        } else {
            this.pr = initOrObject.pr;
            this.secret = initOrObject.secret;
            this.initialSwapData = initOrObject.initialSwapData == null ? null : base_1.SwapData.deserialize(initOrObject.initialSwapData);
            this.lnurl = initOrObject.lnurl;
            this.lnurlK1 = initOrObject.lnurlK1;
            this.lnurlCallback = initOrObject.lnurlCallback;
            this.prPosted = initOrObject.prPosted;
            if (this.state === FromBTCLNSwapState.PR_CREATED && this.data != null) {
                this.initialSwapData = this.data;
                delete this.data;
            }
        }
        this.tryRecomputeSwapPrice();
        this.logger = (0, Utils_1.getLogger)("FromBTCLN(" + this.getIdentifierHashString() + "): ");
    }
}
exports.FromBTCLNSwap = FromBTCLNSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IFromBTCWrapper = void 0;
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const IEscrowSwapWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwapWrapper.js [app-client] (ecmascript)");
class IFromBTCWrapper extends IEscrowSwapWrapper_1.IEscrowSwapWrapper {
    /**
     * Returns a random sequence to be used for swaps
     *
     * @protected
     * @returns Random 64-bit sequence number
     */ getRandomSequence() {
        return base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(8));
    }
    /**
     * Pre-fetches feeRate for a given swap
     *
     * @param signer Address initiating the swap
     * @param amountData
     * @param claimHash optional claim hash of the swap or null
     * @param abortController
     * @protected
     * @returns Fee rate
     */ preFetchFeeRate(signer, amountData, claimHash, abortController) {
        return (0, Utils_1.tryWithRetries)(()=>this.contract.getInitFeeRate(null, signer, amountData.token, claimHash), null, null, abortController.signal).catch((e)=>{
            this.logger.warn("preFetchFeeRate(): Error: ", e);
            abortController.abort(e);
            return null;
        });
    }
    /**
     * Pre-fetches intermediary's available SC on-chain liquidity
     * @param amountData
     * @param lp Intermediary
     * @param abortController
     * @protected
     * @returns Intermediary's liquidity balance
     */ preFetchIntermediaryLiquidity(amountData, lp, abortController) {
        return lp.getLiquidity(this.chainIdentifier, this.contract, amountData.token.toString(), abortController.signal).catch((e)=>{
            this.logger.warn("preFetchIntermediaryLiquidity(): Error: ", e);
            abortController.abort(e);
            return null;
        });
    }
    /**
     * Verifies whether the intermediary has enough available liquidity such that we can initiate the swap
     *
     * @param amount Swap amount that we should receive
     * @param liquidityPromise pre-fetched liquidity promise as obtained from preFetchIntermediaryLiquidity()
     * @protected
     * @throws {IntermediaryError} if intermediary's liquidity is lower than what's required for the swap
     */ async verifyIntermediaryLiquidity(amount, liquidityPromise) {
        const liquidity = await liquidityPromise;
        if (liquidity < amount) throw new IntermediaryError_1.IntermediaryError("Intermediary doesn't have enough liquidity");
    }
}
exports.IFromBTCWrapper = IFromBTCWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FromBTCLNWrapper = void 0;
const FromBTCLNSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNSwap.js [app-client] (ecmascript)");
const IFromBTCWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCWrapper.js [app-client] (ecmascript)");
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const UserError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/UserError.js [app-client] (ecmascript)");
const sha2_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha2.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const LNURL_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)");
class FromBTCLNWrapper extends IFromBTCWrapper_1.IFromBTCWrapper {
    processEventInitialize(swap, event) {
        if (swap.state === FromBTCLNSwap_1.FromBTCLNSwapState.PR_PAID || swap.state === FromBTCLNSwap_1.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED) {
            swap.state = FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_COMMITED;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    processEventClaim(swap, event) {
        if (swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.FAILED && swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_CLAIMED) {
            swap.state = FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_CLAIMED;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    processEventRefund(swap, event) {
        if (swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_CLAIMED && swap.state !== FromBTCLNSwap_1.FromBTCLNSwapState.FAILED) {
            swap.state = FromBTCLNSwap_1.FromBTCLNSwapState.FAILED;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    /**
     * Returns the swap expiry, leaving enough time for the user to claim the HTLC
     *
     * @param data Parsed swap data
     */ getHtlcTimeout(data) {
        return data.getExpiry() - 600n;
    }
    /**
     * Generates a new 32-byte secret to be used as pre-image for lightning network invoice & HTLC swap\
     *
     * @private
     * @returns Hash pre-image & payment hash
     */ getSecretAndHash() {
        const secret = (0, Utils_1.randomBytes)(32);
        const paymentHash = buffer_1.Buffer.from((0, sha2_1.sha256)(secret));
        return {
            secret,
            paymentHash
        };
    }
    /**
     * Pre-fetches intermediary's LN node capacity, doesn't throw, instead returns null
     *
     * @param pubkeyPromise Promise that resolves when we receive "lnPublicKey" param from the intermediary thorugh
     *  streaming
     * @private
     * @returns LN Node liquidity
     */ preFetchLnCapacity(pubkeyPromise) {
        return pubkeyPromise.then((pubkey)=>{
            if (pubkey == null) return null;
            return this.lnApi.getLNNodeLiquidity(pubkey);
        }).catch((e)=>{
            this.logger.warn("preFetchLnCapacity(): Error: ", e);
            return null;
        });
    }
    /**
     * Verifies response returned from intermediary
     *
     * @param resp Response as returned by the intermediary
     * @param amountData
     * @param lp Intermediary
     * @param options Options as passed to the swap creation function
     * @param decodedPr Decoded bolt11 lightning network invoice
     * @param amountIn Amount in sats that will be paid for the swap
     * @private
     * @throws {IntermediaryError} in case the response is invalid
     */ verifyReturnedData(resp, amountData, lp, options, decodedPr, amountIn) {
        if (lp.getAddress(this.chainIdentifier) !== resp.intermediaryKey) throw new IntermediaryError_1.IntermediaryError("Invalid intermediary address/pubkey");
        if (options.descriptionHash != null && decodedPr.tagsObject.purpose_commit_hash !== options.descriptionHash.toString("hex")) throw new IntermediaryError_1.IntermediaryError("Invalid pr returned - description hash");
        if (!amountData.exactIn) {
            if (resp.total != amountData.amount) throw new IntermediaryError_1.IntermediaryError("Invalid amount returned");
        } else {
            if (amountIn !== amountData.amount) throw new IntermediaryError_1.IntermediaryError("Invalid payment request returned, amount mismatch");
        }
    }
    /**
     * Verifies whether the intermediary's lightning node has enough inbound capacity to receive the LN payment
     *
     * @param lp Intermediary
     * @param decodedPr Decoded bolt11 lightning network invoice
     * @param amountIn Amount to be paid for the swap in sats
     * @param lnCapacityPrefetchPromise Pre-fetch for LN node capacity, preFetchLnCapacity()
     * @param abortSignal
     * @private
     * @throws {IntermediaryError} if the lightning network node doesn't have enough inbound liquidity
     * @throws {Error} if the lightning network node's inbound liquidity might be enough, but the swap would
     *  deplete more than half of the liquidity
     */ async verifyLnNodeCapacity(lp, decodedPr, amountIn, lnCapacityPrefetchPromise, abortSignal) {
        let result = lnCapacityPrefetchPromise == null ? null : await lnCapacityPrefetchPromise;
        if (result == null) result = await this.lnApi.getLNNodeLiquidity(decodedPr.payeeNodeKey);
        if (abortSignal != null) abortSignal.throwIfAborted();
        if (result === null) throw new IntermediaryError_1.IntermediaryError("LP's lightning node not found in the lightning network graph!");
        lp.lnData = result;
        if (decodedPr.payeeNodeKey !== result.publicKey) throw new IntermediaryError_1.IntermediaryError("Invalid pr returned - payee pubkey");
        if (result.capacity < amountIn) throw new IntermediaryError_1.IntermediaryError("LP's lightning node doesn't have enough inbound capacity for the swap!");
        if (result.capacity / 2n < amountIn) throw new Error("LP's lightning node probably doesn't have enough inbound capacity for the swap!");
    }
    /**
     * Returns a newly created swap, receiving 'amount' on lightning network
     *
     * @param signer                Smart chain signer's address intiating the swap
     * @param amountData            Amount of token & amount to swap
     * @param lps                   LPs (liquidity providers) to get the quotes from
     * @param options               Quote options
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param abortSignal           Abort signal for aborting the process
     * @param preFetches
     */ create(signer, amountData, lps, options, additionalParams, abortSignal, preFetches) {
        var _options, _preFetches, _preFetches1;
        if (options == null) options = {};
        var _unsafeSkipLnNodeCheck;
        (_unsafeSkipLnNodeCheck = (_options = options).unsafeSkipLnNodeCheck) !== null && _unsafeSkipLnNodeCheck !== void 0 ? _unsafeSkipLnNodeCheck : _options.unsafeSkipLnNodeCheck = this.options.unsafeSkipLnNodeCheck;
        if (preFetches == null) preFetches = {};
        if (options.descriptionHash != null && options.descriptionHash.length !== 32) throw new UserError_1.UserError("Invalid description hash length");
        const { secret, paymentHash } = this.getSecretAndHash();
        const claimHash = this.contract.getHashForHtlc(paymentHash);
        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);
        var _pricePrefetchPromise;
        (_pricePrefetchPromise = (_preFetches = preFetches).pricePrefetchPromise) !== null && _pricePrefetchPromise !== void 0 ? _pricePrefetchPromise : _preFetches.pricePrefetchPromise = this.preFetchPrice(amountData, _abortController.signal);
        const nativeTokenAddress = this.chain.getNativeCurrencyAddress();
        var _feeRatePromise;
        (_feeRatePromise = (_preFetches1 = preFetches).feeRatePromise) !== null && _feeRatePromise !== void 0 ? _feeRatePromise : _preFetches1.feeRatePromise = this.preFetchFeeRate(signer, amountData, claimHash.toString("hex"), _abortController);
        return lps.map((lp)=>{
            return {
                intermediary: lp,
                quote: (async ()=>{
                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);
                    const liquidityPromise = this.preFetchIntermediaryLiquidity(amountData, lp, abortController);
                    const { lnCapacityPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount)=>{
                        const { lnPublicKey, response } = IntermediaryAPI_1.IntermediaryAPI.initFromBTCLN(this.chainIdentifier, lp.url, nativeTokenAddress, {
                            paymentHash,
                            amount: amountData.amount,
                            claimer: signer,
                            token: amountData.token.toString(),
                            descriptionHash: options.descriptionHash,
                            exactOut: !amountData.exactIn,
                            feeRate: preFetches.feeRatePromise,
                            additionalParams
                        }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);
                        return {
                            lnCapacityPromise: options.unsafeSkipLnNodeCheck ? null : this.preFetchLnCapacity(lnPublicKey),
                            resp: await response
                        };
                    }, null, RequestError_1.RequestError, abortController.signal);
                    const decodedPr = (0, bolt11_1.decode)(resp.pr);
                    const amountIn = (BigInt(decodedPr.millisatoshis) + 999n) / 1000n;
                    try {
                        this.verifyReturnedData(resp, amountData, lp, options, decodedPr, amountIn);
                        const [pricingInfo] = await Promise.all([
                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.FROM_BTCLN], false, amountIn, resp.total, amountData.token, {}, preFetches.pricePrefetchPromise, abortController.signal),
                            this.verifyIntermediaryLiquidity(resp.total, liquidityPromise),
                            options.unsafeSkipLnNodeCheck ? Promise.resolve() : this.verifyLnNodeCapacity(lp, decodedPr, amountIn, lnCapacityPromise, abortController.signal)
                        ]);
                        var _amountData_exactIn;
                        const quote = new FromBTCLNSwap_1.FromBTCLNSwap(this, {
                            pricingInfo,
                            url: lp.url,
                            expiry: decodedPr.timeExpireDate * 1000,
                            swapFee: resp.swapFee,
                            feeRate: await preFetches.feeRatePromise,
                            initialSwapData: await this.contract.createSwapData(base_1.ChainSwapType.HTLC, lp.getAddress(this.chainIdentifier), signer, amountData.token, resp.total, claimHash.toString("hex"), this.getRandomSequence(), BigInt(Math.floor(Date.now() / 1000)), false, true, resp.securityDeposit, 0n, nativeTokenAddress),
                            pr: resp.pr,
                            secret: secret.toString("hex"),
                            exactIn: (_amountData_exactIn = amountData.exactIn) !== null && _amountData_exactIn !== void 0 ? _amountData_exactIn : true
                        });
                        await quote._save();
                        return quote;
                    } catch (e) {
                        abortController.abort(e);
                        throw e;
                    }
                })()
            };
        });
    }
    /**
     * Parses and fetches lnurl withdraw params from the specified lnurl
     *
     * @param lnurl LNURL to be parsed and fetched
     * @param abortSignal
     * @private
     * @throws {UserError} if the LNURL is invalid or if it's not a LNURL-withdraw
     */ async getLNURLWithdraw(lnurl, abortSignal) {
        if (typeof lnurl !== "string") return lnurl;
        const res = await LNURL_1.LNURL.getLNURL(lnurl, true, this.options.getRequestTimeout, abortSignal);
        if (res == null) throw new UserError_1.UserError("Invalid LNURL");
        if (res.tag !== "withdrawRequest") throw new UserError_1.UserError("Not a LNURL-withdrawal");
        return res;
    }
    /**
     * Returns a newly created swap, receiving 'amount' from the lnurl-withdraw
     *
     * @param signer                Smart chains signer's address intiating the swap
     * @param lnurl                 LNURL-withdraw to withdraw funds from
     * @param amountData            Amount of token & amount to swap
     * @param lps                   LPs (liquidity providers) to get the quotes from
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param abortSignal           Abort signal for aborting the process
     */ async createViaLNURL(signer, lnurl, amountData, lps, additionalParams, abortSignal) {
        if (!this.isInitialized) throw new Error("Not initialized, call init() first!");
        const abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const preFetches = {
            pricePrefetchPromise: this.preFetchPrice(amountData, abortController.signal),
            feeRatePromise: this.preFetchFeeRate(signer, amountData, null, abortController)
        };
        try {
            const exactOutAmountPromise = !amountData.exactIn ? preFetches.pricePrefetchPromise.then((price)=>this.prices.getToBtcSwapAmount(this.chainIdentifier, amountData.amount, amountData.token, abortController.signal, price)).catch((e)=>{
                abortController.abort(e);
                return null;
            }) : null;
            const withdrawRequest = await this.getLNURLWithdraw(lnurl, abortController.signal);
            const min = BigInt(withdrawRequest.minWithdrawable) / 1000n;
            const max = BigInt(withdrawRequest.maxWithdrawable) / 1000n;
            if (amountData.exactIn) {
                if (amountData.amount < min) throw new UserError_1.UserError("Amount less than LNURL-withdraw minimum");
                if (amountData.amount > max) throw new UserError_1.UserError("Amount more than LNURL-withdraw maximum");
            } else {
                const amount = await exactOutAmountPromise;
                abortController.signal.throwIfAborted();
                if (amount * 95n / 100n < min) throw new UserError_1.UserError("Amount less than LNURL-withdraw minimum");
                if (amount * 105n / 100n > max) throw new UserError_1.UserError("Amount more than LNURL-withdraw maximum");
            }
            return this.create(signer, amountData, lps, null, additionalParams, abortSignal, preFetches).map((data)=>{
                return {
                    quote: data.quote.then((quote)=>{
                        quote.lnurl = withdrawRequest.url;
                        quote.lnurlK1 = withdrawRequest.k1;
                        quote.lnurlCallback = withdrawRequest.callback;
                        const amountIn = quote.getInput().rawAmount;
                        if (amountIn < min) throw new UserError_1.UserError("Amount less than LNURL-withdraw minimum");
                        if (amountIn > max) throw new UserError_1.UserError("Amount more than LNURL-withdraw maximum");
                        return quote;
                    }),
                    intermediary: data.intermediary
                };
            });
        } catch (e) {
            abortController.abort(e);
            throw e;
        }
    }
    /**
     * @param chainIdentifier
     * @param unifiedStorage Storage interface for the current environment
     * @param unifiedChainEvents On-chain event listener
     * @param chain
     * @param contract Underlying contract handling the swaps
     * @param prices Swap pricing handler
     * @param tokens
     * @param swapDataDeserializer Deserializer for SwapData
     * @param lnApi
     * @param options
     * @param events Instance to use for emitting events
     */ constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, lnApi, options, events){
        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);
        this.TYPE = SwapType_1.SwapType.FROM_BTCLN;
        this.swapDeserializer = FromBTCLNSwap_1.FromBTCLNSwap;
        this.pendingSwapStates = [
            FromBTCLNSwap_1.FromBTCLNSwapState.PR_CREATED,
            FromBTCLNSwap_1.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED,
            FromBTCLNSwap_1.FromBTCLNSwapState.PR_PAID,
            FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_COMMITED,
            FromBTCLNSwap_1.FromBTCLNSwapState.EXPIRED
        ];
        this.tickSwapState = [
            FromBTCLNSwap_1.FromBTCLNSwapState.PR_CREATED,
            FromBTCLNSwap_1.FromBTCLNSwapState.PR_PAID,
            FromBTCLNSwap_1.FromBTCLNSwapState.CLAIM_COMMITED
        ];
        this.lnApi = lnApi;
    }
}
exports.FromBTCLNWrapper = FromBTCLNWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FromBTCSwap = exports.isFromBTCSwapInit = exports.FromBTCSwapState = void 0;
const IFromBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCSwap.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IEscrowSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwap.js [app-client] (ecmascript)");
const IBitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/IBitcoinWallet.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const SingleAddressBitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/SingleAddressBitcoinWallet.js [app-client] (ecmascript)");
var FromBTCSwapState;
(function(FromBTCSwapState) {
    FromBTCSwapState[FromBTCSwapState["FAILED"] = -4] = "FAILED";
    FromBTCSwapState[FromBTCSwapState["EXPIRED"] = -3] = "EXPIRED";
    FromBTCSwapState[FromBTCSwapState["QUOTE_EXPIRED"] = -2] = "QUOTE_EXPIRED";
    FromBTCSwapState[FromBTCSwapState["QUOTE_SOFT_EXPIRED"] = -1] = "QUOTE_SOFT_EXPIRED";
    FromBTCSwapState[FromBTCSwapState["PR_CREATED"] = 0] = "PR_CREATED";
    FromBTCSwapState[FromBTCSwapState["CLAIM_COMMITED"] = 1] = "CLAIM_COMMITED";
    FromBTCSwapState[FromBTCSwapState["BTC_TX_CONFIRMED"] = 2] = "BTC_TX_CONFIRMED";
    FromBTCSwapState[FromBTCSwapState["CLAIM_CLAIMED"] = 3] = "CLAIM_CLAIMED";
})(FromBTCSwapState = exports.FromBTCSwapState || (exports.FromBTCSwapState = {}));
function isFromBTCSwapInit(obj) {
    return typeof obj.address === "string" && typeof obj.amount === "bigint" && (0, IEscrowSwap_1.isIEscrowSwapInit)(obj);
}
exports.isFromBTCSwapInit = isFromBTCSwapInit;
class FromBTCSwap extends IFromBTCSwap_1.IFromBTCSwap {
    upgradeVersion() {
        if (this.version == null) {
            switch(this.state){
                case -2:
                    this.state = FromBTCSwapState.FAILED;
                    break;
                case -1:
                    this.state = FromBTCSwapState.QUOTE_EXPIRED;
                    break;
                case 0:
                    this.state = FromBTCSwapState.PR_CREATED;
                    break;
                case 1:
                    this.state = FromBTCSwapState.CLAIM_COMMITED;
                    break;
                case 2:
                    this.state = FromBTCSwapState.BTC_TX_CONFIRMED;
                    break;
                case 3:
                    this.state = FromBTCSwapState.CLAIM_CLAIMED;
                    break;
            }
            this.version = 1;
        }
    }
    //////////////////////////////
    //// Getters & utils
    /**
     * Returns bitcoin address where the on-chain BTC should be sent to
     */ getAddress() {
        if (this.state === FromBTCSwapState.PR_CREATED) return null;
        return this.address;
    }
    getHyperlink() {
        if (this.state === FromBTCSwapState.PR_CREATED) return null;
        return "bitcoin:" + this.address + "?amount=" + encodeURIComponent((Number(this.amount) / 100000000).toString(10));
    }
    getInputTxId() {
        return this.txId;
    }
    /**
     * Returns timeout time (in UNIX milliseconds) when the on-chain address will expire and no funds should be sent
     *  to that address anymore
     */ getTimeoutTime() {
        return Number(this.wrapper.getOnchainSendTimeout(this.data, this.requiredConfirmations)) * 1000;
    }
    requiresAction() {
        return this.isClaimable() || this.state === FromBTCSwapState.CLAIM_COMMITED && this.getTimeoutTime() > Date.now();
    }
    isFinished() {
        return this.state === FromBTCSwapState.CLAIM_CLAIMED || this.state === FromBTCSwapState.QUOTE_EXPIRED || this.state === FromBTCSwapState.FAILED;
    }
    isClaimable() {
        return this.state === FromBTCSwapState.BTC_TX_CONFIRMED;
    }
    isSuccessful() {
        return this.state === FromBTCSwapState.CLAIM_CLAIMED;
    }
    isFailed() {
        return this.state === FromBTCSwapState.FAILED || this.state === FromBTCSwapState.EXPIRED && this.txId != null;
    }
    isQuoteExpired() {
        return this.state === FromBTCSwapState.QUOTE_EXPIRED;
    }
    isQuoteSoftExpired() {
        return this.state === FromBTCSwapState.QUOTE_EXPIRED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED;
    }
    canCommit() {
        if (this.state !== FromBTCSwapState.PR_CREATED) return false;
        const expiry = this.wrapper.getOnchainSendTimeout(this.data, this.requiredConfirmations);
        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
        return expiry - currentTimestamp >= this.wrapper.options.minSendWindow;
    }
    //////////////////////////////
    //// Amounts & fees
    getInput() {
        return (0, Tokens_1.toTokenAmount)(this.amount, this.inputToken, this.wrapper.prices);
    }
    /**
     * Returns claimer bounty, acting as a reward for watchtowers to claim the swap automatically
     */ getClaimerBounty() {
        return (0, Tokens_1.toTokenAmount)(this.data.getClaimerBounty(), this.wrapper.tokens[this.data.getDepositToken()], this.wrapper.prices);
    }
    //////////////////////////////
    //// Bitcoin tx
    getRequiredConfirmationsCount() {
        return this.requiredConfirmations;
    }
    /**
     * Checks whether a bitcoin payment was already made, returns the payment or null when no payment has been made.
     */ async getBitcoinPayment() {
        const result = await this.wrapper.btcRpc.checkAddressTxos(this.address, buffer_1.Buffer.from(this.data.getTxoHashHint(), "hex"));
        if (result == null) return null;
        return {
            txId: result.tx.txid,
            vout: result.vout,
            confirmations: result.tx.confirmations,
            targetConfirmations: this.requiredConfirmations
        };
    }
    /**
     * Waits till the bitcoin transaction confirms and swap becomes claimable
     *
     * @param abortSignal Abort signal
     * @param checkIntervalSeconds How often to check the bitcoin transaction
     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations
     * @throws {Error} if in invalid state (must be CLAIM_COMMITED)
     */ async waitForBitcoinTransaction(abortSignal, checkIntervalSeconds, updateCallback) {
        if (this.state !== FromBTCSwapState.CLAIM_COMMITED && this.state !== FromBTCSwapState.EXPIRED) throw new Error("Must be in COMMITED state!");
        const result = await this.wrapper.btcRpc.waitForAddressTxo(this.address, buffer_1.Buffer.from(this.data.getTxoHashHint(), "hex"), this.requiredConfirmations, (confirmations, txId, vout, txEtaMs)=>{
            if (updateCallback != null) updateCallback(txId, confirmations, this.requiredConfirmations, txEtaMs);
        }, abortSignal, checkIntervalSeconds);
        if (abortSignal != null) abortSignal.throwIfAborted();
        this.txId = result.tx.txid;
        this.vout = result.vout;
        if (this.state !== FromBTCSwapState.CLAIM_CLAIMED && this.state !== FromBTCSwapState.FAILED) {
            this.state = FromBTCSwapState.BTC_TX_CONFIRMED;
        }
        await this._saveAndEmit();
        return result.tx.txid;
    }
    async getFundedPsbt(_bitcoinWallet, feeRate) {
        if (this.state !== FromBTCSwapState.CLAIM_COMMITED) throw new Error("Swap not committed yet, please initiate the swap first with commit() call!");
        let bitcoinWallet;
        if ((0, IBitcoinWallet_1.isIBitcoinWallet)(_bitcoinWallet)) {
            bitcoinWallet = _bitcoinWallet;
        } else {
            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.wrapper.btcRpc, this.wrapper.options.bitcoinNetwork, _bitcoinWallet);
        }
        //TODO: Maybe re-introduce fee rate check here if passed from the user
        if (feeRate == null) {
            feeRate = await bitcoinWallet.getFeeRate();
        }
        const basePsbt = new btc_signer_1.Transaction({
            allowUnknownOutputs: true,
            allowLegacyWitnessUtxo: true
        });
        basePsbt.addOutput({
            amount: this.amount,
            script: (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address)
        });
        const psbt = await bitcoinWallet.fundPsbt(basePsbt, feeRate);
        //Sign every input
        const signInputs = [];
        for(let i = 0; i < psbt.inputsLength; i++){
            signInputs.push(i);
        }
        return {
            psbt,
            signInputs
        };
    }
    async submitPsbt(psbt) {
        if (this.state !== FromBTCSwapState.CLAIM_COMMITED) throw new Error("Swap not committed yet, please initiate the swap first with commit() call!");
        //Ensure not expired
        if (this.getTimeoutTime() < Date.now()) {
            throw new Error("Swap address expired!");
        }
        const output0 = psbt.getOutput(0);
        if (output0.amount !== this.amount) throw new Error("PSBT output amount invalid, expected: " + this.amount + " got: " + output0.amount);
        const expectedOutputScript = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address);
        if (!expectedOutputScript.equals(output0.script)) throw new Error("PSBT output script invalid!");
        if (!psbt.isFinal) psbt.finalize();
        return await this.wrapper.btcRpc.sendRawTransaction(buffer_1.Buffer.from(psbt.toBytes(true, true)).toString("hex"));
    }
    async estimateBitcoinFee(wallet, feeRate) {
        const txFee = await wallet.getTransactionFee(this.address, this.amount, feeRate);
        return (0, Tokens_1.toTokenAmount)(txFee == null ? null : BigInt(txFee), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);
    }
    async sendBitcoinTransaction(wallet, feeRate) {
        if (this.state !== FromBTCSwapState.CLAIM_COMMITED) throw new Error("Swap not committed yet, please initiate the swap first with commit() call!");
        return await wallet.sendTransaction(this.address, this.amount, feeRate);
    }
    //////////////////////////////
    //// Commit
    /**
     * Commits the swap on-chain, locking the tokens from the intermediary in a PTLC
     *
     * @param signer Signer to sign the transactions with, must be the same as used in the initialization
     * @param abortSignal Abort signal to stop waiting for the transaction confirmation and abort
     * @param skipChecks Skip checks like making sure init signature is still valid and swap wasn't commited yet
     *  (this is handled when swap is created (quoted), if you commit right after quoting, you can use skipChecks=true)
     * @throws {Error} If invalid signer is provided that doesn't match the swap data
     */ async commit(signer, abortSignal, skipChecks) {
        this.checkSigner(signer);
        const result = await this.wrapper.chain.sendAndConfirm(signer, await this.txsCommit(skipChecks), true, abortSignal);
        this.commitTxId = result[0];
        if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {
            await this._saveAndEmit(FromBTCSwapState.CLAIM_COMMITED);
        }
        return result[0];
    }
    async waitTillCommited(abortSignal) {
        if (this.state === FromBTCSwapState.CLAIM_COMMITED || this.state === FromBTCSwapState.CLAIM_CLAIMED) return Promise.resolve();
        if (this.state !== FromBTCSwapState.PR_CREATED && this.state !== FromBTCSwapState.QUOTE_SOFT_EXPIRED) throw new Error("Invalid state");
        const abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const result = await Promise.race([
            this.watchdogWaitTillCommited(abortController.signal),
            this.waitTillState(FromBTCSwapState.CLAIM_COMMITED, "gte", abortController.signal).then(()=>0)
        ]);
        abortController.abort();
        if (result === 0) this.logger.debug("waitTillCommited(): Resolved from state changed");
        if (result === true) this.logger.debug("waitTillCommited(): Resolved from watchdog - commited");
        if (result === false) {
            this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expired");
            if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {
                await this._saveAndEmit(FromBTCSwapState.QUOTE_EXPIRED);
            }
            return;
        }
        if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {
            await this._saveAndEmit(FromBTCSwapState.CLAIM_COMMITED);
        }
    }
    //////////////////////////////
    //// Claim
    /**
     * Returns transactions required to claim the swap on-chain (and possibly also sync the bitcoin light client)
     *  after a bitcoin transaction was sent and confirmed
     *
     * @throws {Error} If the swap is in invalid state (must be BTC_TX_CONFIRMED)
     */ async txsClaim(signer) {
        if (this.state !== FromBTCSwapState.BTC_TX_CONFIRMED) throw new Error("Must be in BTC_TX_CONFIRMED state!");
        const tx = await this.wrapper.btcRpc.getTransaction(this.txId);
        return await this.wrapper.contract.txsClaimWithTxData(signer !== null && signer !== void 0 ? signer : this._getInitiator(), this.data, {
            blockhash: tx.blockhash,
            confirmations: tx.confirmations,
            txid: tx.txid,
            hex: tx.hex,
            height: tx.blockheight
        }, this.requiredConfirmations, this.vout, null, this.wrapper.synchronizer, true);
    }
    /**
     * Claims and finishes the swap
     *
     * @param signer Signer to sign the transactions with, can also be different to the initializer
     * @param abortSignal Abort signal to stop waiting for transaction confirmation
     */ async claim(signer, abortSignal) {
        let txIds;
        try {
            txIds = await this.wrapper.chain.sendAndConfirm(signer, await this.txsClaim(signer), true, abortSignal);
        } catch (e) {
            this.logger.info("claim(): Failed to claim ourselves, checking swap claim state...");
            if (this.state === FromBTCSwapState.CLAIM_CLAIMED) {
                this.logger.info("claim(): Transaction state is CLAIM_CLAIMED, swap was successfully claimed by the watchtower");
                return this.claimTxId;
            }
            const status = await this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data);
            if ((status === null || status === void 0 ? void 0 : status.type) === base_1.SwapCommitStateType.PAID) {
                this.logger.info("claim(): Transaction commit status is PAID, swap was successfully claimed by the watchtower");
                if (this.claimTxId == null) this.claimTxId = await status.getClaimTxId();
                await this._saveAndEmit(FromBTCSwapState.CLAIM_CLAIMED);
                return this.claimTxId;
            }
            throw e;
        }
        this.claimTxId = txIds[txIds.length - 1];
        if (this.state === FromBTCSwapState.CLAIM_COMMITED || this.state === FromBTCSwapState.BTC_TX_CONFIRMED || this.state === FromBTCSwapState.EXPIRED || this.state === FromBTCSwapState.FAILED) {
            await this._saveAndEmit(FromBTCSwapState.CLAIM_CLAIMED);
        }
        return txIds[0];
    }
    /**
     * Waits till the swap is successfully claimed
     *
     * @param abortSignal AbortSignal
     * @throws {Error} If swap is in invalid state (must be BTC_TX_CONFIRMED)
     * @throws {Error} If the LP refunded sooner than we were able to claim
     */ async waitTillClaimed(abortSignal) {
        if (this.state === FromBTCSwapState.CLAIM_CLAIMED) return Promise.resolve();
        if (this.state !== FromBTCSwapState.BTC_TX_CONFIRMED) throw new Error("Invalid state (not BTC_TX_CONFIRMED)");
        const abortController = new AbortController();
        if (abortSignal != null) abortSignal.addEventListener("abort", ()=>abortController.abort(abortSignal.reason));
        const res = await Promise.race([
            this.watchdogWaitTillResult(abortController.signal),
            this.waitTillState(FromBTCSwapState.CLAIM_CLAIMED, "eq", abortController.signal).then(()=>0),
            this.waitTillState(FromBTCSwapState.FAILED, "eq", abortController.signal).then(()=>1)
        ]);
        abortController.abort();
        if (res === 0) {
            this.logger.debug("waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)");
            return;
        }
        if (res === 1) {
            this.logger.debug("waitTillClaimed(): Resolved from state change (FAILED)");
            throw new Error("Offerer refunded during claiming");
        }
        this.logger.debug("waitTillClaimed(): Resolved from watchdog");
        if ((res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.PAID) {
            if (this.state !== FromBTCSwapState.CLAIM_CLAIMED) {
                this.claimTxId = await res.getClaimTxId();
                await this._saveAndEmit(FromBTCSwapState.CLAIM_CLAIMED);
            }
        }
        if ((res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.NOT_COMMITED || (res === null || res === void 0 ? void 0 : res.type) === base_1.SwapCommitStateType.EXPIRED) {
            if (this.state !== FromBTCSwapState.CLAIM_CLAIMED && this.state !== FromBTCSwapState.FAILED) {
                this.refundTxId = res.getRefundTxId == null ? null : await res.getRefundTxId();
                await this._saveAndEmit(FromBTCSwapState.FAILED);
            }
        }
    }
    //////////////////////////////
    //// Storage
    serialize() {
        return {
            ...super.serialize(),
            address: this.address,
            amount: this.amount.toString(10),
            requiredConfirmations: this.requiredConfirmations,
            txId: this.txId,
            vout: this.vout
        };
    }
    //////////////////////////////
    //// Swap ticks & sync
    /**
     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain
     *  data
     *
     * @private
     */ async syncStateFromChain() {
        if (this.state === FromBTCSwapState.PR_CREATED || this.state === FromBTCSwapState.QUOTE_SOFT_EXPIRED) {
            const quoteExpired = await this.verifyQuoteDefinitelyExpired(); //Make sure we check for expiry here, to prevent race conditions
            const status = await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));
            switch(status === null || status === void 0 ? void 0 : status.type){
                case base_1.SwapCommitStateType.COMMITED:
                    this.state = FromBTCSwapState.CLAIM_COMMITED;
                    return true;
                case base_1.SwapCommitStateType.EXPIRED:
                    if (this.refundTxId == null && status.getRefundTxId) this.refundTxId = await status.getRefundTxId();
                    this.state = FromBTCSwapState.QUOTE_EXPIRED;
                    return true;
                case base_1.SwapCommitStateType.PAID:
                    if (this.claimTxId == null) this.claimTxId = await status.getClaimTxId();
                    this.state = FromBTCSwapState.CLAIM_CLAIMED;
                    return true;
            }
            if (quoteExpired) {
                this.state = FromBTCSwapState.QUOTE_EXPIRED;
                return true;
            }
            return false;
        }
        if (this.state === FromBTCSwapState.CLAIM_COMMITED || this.state === FromBTCSwapState.BTC_TX_CONFIRMED || this.state === FromBTCSwapState.EXPIRED) {
            const status = await (0, Utils_1.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(), this.data));
            switch(status === null || status === void 0 ? void 0 : status.type){
                case base_1.SwapCommitStateType.PAID:
                    if (this.claimTxId == null) this.claimTxId = await status.getClaimTxId();
                    this.state = FromBTCSwapState.CLAIM_CLAIMED;
                    return true;
                case base_1.SwapCommitStateType.NOT_COMMITED:
                case base_1.SwapCommitStateType.EXPIRED:
                    if (this.refundTxId == null && status.getRefundTxId) this.refundTxId = await status.getRefundTxId();
                    this.state = FromBTCSwapState.FAILED;
                    return true;
                case base_1.SwapCommitStateType.COMMITED:
                    const res = await this.getBitcoinPayment();
                    if (res != null && res.confirmations >= this.requiredConfirmations) {
                        this.txId = res.txId;
                        this.vout = res.vout;
                        this.state = FromBTCSwapState.BTC_TX_CONFIRMED;
                        return true;
                    }
                    break;
            }
        }
    }
    async _sync(save) {
        const changed = await this.syncStateFromChain();
        if (changed && save) await this._saveAndEmit();
        return changed;
    }
    async _tick(save) {
        switch(this.state){
            case FromBTCSwapState.PR_CREATED:
                if (this.expiry < Date.now()) {
                    this.state = FromBTCSwapState.QUOTE_SOFT_EXPIRED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                break;
            case FromBTCSwapState.CLAIM_COMMITED:
                if (this.getTimeoutTime() < Date.now()) {
                    this.state = FromBTCSwapState.EXPIRED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
            case FromBTCSwapState.EXPIRED:
                //Check if bitcoin payment was received every 2 minutes
                if (Math.floor(Date.now() / 1000) % 120 === 0) {
                    try {
                        const res = await this.getBitcoinPayment();
                        if (res != null && res.confirmations >= this.requiredConfirmations) {
                            this.txId = res.txId;
                            this.vout = res.vout;
                            this.state = FromBTCSwapState.BTC_TX_CONFIRMED;
                            if (save) await this._saveAndEmit();
                            return true;
                        }
                    } catch (e) {
                        this.logger.warn("tickSwap(" + this.getIdentifierHashString() + "): ", e);
                    }
                }
                break;
        }
    }
    constructor(wrapper, initOrObject){
        if (isFromBTCSwapInit(initOrObject)) initOrObject.url += "/frombtc";
        super(wrapper, initOrObject);
        this.inputToken = Tokens_1.BitcoinTokens.BTC;
        this.TYPE = SwapType_1.SwapType.FROM_BTC;
        if (isFromBTCSwapInit(initOrObject)) {
            this.state = FromBTCSwapState.PR_CREATED;
        } else {
            this.address = initOrObject.address;
            this.amount = BigInt(initOrObject.amount);
            this.txId = initOrObject.txId;
            this.vout = initOrObject.vout;
            var _initOrObject_requiredConfirmations;
            this.requiredConfirmations = (_initOrObject_requiredConfirmations = initOrObject.requiredConfirmations) !== null && _initOrObject_requiredConfirmations !== void 0 ? _initOrObject_requiredConfirmations : this.data.getConfirmationsHint();
        }
        this.tryRecomputeSwapPrice();
        this.logger = (0, Utils_1.getLogger)("FromBTC(" + this.getIdentifierHashString() + "): ");
    }
}
exports.FromBTCSwap = FromBTCSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FromBTCWrapper = void 0;
const IFromBTCWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCWrapper.js [app-client] (ecmascript)");
const FromBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCSwap.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
class FromBTCWrapper extends IFromBTCWrapper_1.IFromBTCWrapper {
    processEventInitialize(swap, event) {
        if (swap.state === FromBTCSwap_1.FromBTCSwapState.PR_CREATED || swap.state === FromBTCSwap_1.FromBTCSwapState.QUOTE_SOFT_EXPIRED) {
            swap.state = FromBTCSwap_1.FromBTCSwapState.CLAIM_COMMITED;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    processEventClaim(swap, event) {
        if (swap.state !== FromBTCSwap_1.FromBTCSwapState.FAILED && swap.state !== FromBTCSwap_1.FromBTCSwapState.CLAIM_CLAIMED) {
            swap.state = FromBTCSwap_1.FromBTCSwapState.CLAIM_CLAIMED;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    processEventRefund(swap, event) {
        if (swap.state !== FromBTCSwap_1.FromBTCSwapState.CLAIM_CLAIMED && swap.state !== FromBTCSwap_1.FromBTCSwapState.FAILED) {
            swap.state = FromBTCSwap_1.FromBTCSwapState.FAILED;
            return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
    /**
     * Returns the swap expiry, leaving enough time for the user to send a transaction and for it to confirm
     *
     * @param data Parsed swap data
     * @param requiredConfirmations Confirmations required to claim the tx
     */ getOnchainSendTimeout(data, requiredConfirmations) {
        const tsDelta = (this.options.blocksTillTxConfirms + requiredConfirmations) * this.options.bitcoinBlocktime * this.options.safetyFactor;
        return data.getExpiry() - BigInt(tsDelta);
    }
    /**
     * Pre-fetches claimer (watchtower) bounty data for the swap. Doesn't throw, instead returns null and aborts the
     *  provided abortController
     *
     * @param signer Smartchain signer address initiating the swap
     * @param amountData
     * @param options Options as passed to the swap creation function
     * @param abortController
     * @private
     */ async preFetchClaimerBounty(signer, amountData, options, abortController) {
        const startTimestamp = BigInt(Math.floor(Date.now() / 1000));
        if (options.unsafeZeroWatchtowerFee) {
            return {
                feePerBlock: 0n,
                safetyFactor: options.blockSafetyFactor,
                startTimestamp: startTimestamp,
                addBlock: 0,
                addFee: 0n
            };
        }
        const dummyAmount = BigInt(Math.floor(Math.random() * 0x1000000));
        const dummySwapData = await this.contract.createSwapData(base_1.ChainSwapType.CHAIN, signer, signer, amountData.token, dummyAmount, this.contract.getHashForOnchain((0, Utils_1.randomBytes)(20), dummyAmount, 3).toString("hex"), this.getRandomSequence(), startTimestamp, false, true, BigInt(Math.floor(Math.random() * 0x10000)), BigInt(Math.floor(Math.random() * 0x10000)));
        try {
            const [feePerBlock, btcRelayData, currentBtcBlock, claimFeeRate] = await Promise.all([
                (0, Utils_1.tryWithRetries)(()=>this.btcRelay.getFeePerBlock(), null, null, abortController.signal),
                (0, Utils_1.tryWithRetries)(()=>this.btcRelay.getTipData(), null, null, abortController.signal),
                this.btcRpc.getTipHeight(),
                (0, Utils_1.tryWithRetries)(()=>this.contract.getClaimFee(signer, dummySwapData), null, null, abortController.signal)
            ]);
            const currentBtcRelayBlock = btcRelayData.blockheight;
            const addBlock = Math.max(currentBtcBlock - currentBtcRelayBlock, 0);
            return {
                feePerBlock: feePerBlock * options.feeSafetyFactor,
                safetyFactor: options.blockSafetyFactor,
                startTimestamp: startTimestamp,
                addBlock,
                addFee: claimFeeRate * options.feeSafetyFactor
            };
        } catch (e) {
            abortController.abort(e);
            return null;
        }
    }
    /**
     * Returns calculated claimer bounty calculated from the claimer bounty data as fetched from preFetchClaimerBounty()
     *
     * @param data Parsed swap data returned from the intermediary
     * @param options Options as passed to the swap creation function
     * @param claimerBounty Claimer bounty data as fetched from preFetchClaimerBounty() function
     * @private
     */ getClaimerBounty(data, options, claimerBounty) {
        const tsDelta = data.getExpiry() - claimerBounty.startTimestamp;
        const blocksDelta = tsDelta / BigInt(this.options.bitcoinBlocktime) * BigInt(options.blockSafetyFactor);
        const totalBlock = blocksDelta + BigInt(claimerBounty.addBlock);
        return claimerBounty.addFee + totalBlock * claimerBounty.feePerBlock;
    }
    /**
     * Verifies response returned from intermediary
     *
     * @param resp Response as returned by the intermediary
     * @param amountData
     * @param lp Intermediary
     * @param options Options as passed to the swap creation function
     * @param data Parsed swap data returned by the intermediary
     * @param sequence Required swap sequence
     * @param claimerBounty Claimer bount data as returned from the preFetchClaimerBounty() pre-fetch promise
     * @param depositToken
     * @private
     * @throws {IntermediaryError} in case the response is invalid
     */ verifyReturnedData(resp, amountData, lp, options, data, sequence, claimerBounty, depositToken) {
        if (amountData.exactIn) {
            if (resp.amount !== amountData.amount) throw new IntermediaryError_1.IntermediaryError("Invalid amount returned");
        } else {
            if (resp.total !== amountData.amount) throw new IntermediaryError_1.IntermediaryError("Invalid total returned");
        }
        var _resp_confirmations;
        const requiredConfirmations = (_resp_confirmations = resp.confirmations) !== null && _resp_confirmations !== void 0 ? _resp_confirmations : lp.services[SwapType_1.SwapType.FROM_BTC].data.confirmations;
        if (requiredConfirmations > this.options.maxConfirmations) throw new IntermediaryError_1.IntermediaryError("Requires too many confirmations");
        const totalClaimerBounty = this.getClaimerBounty(data, options, claimerBounty);
        if (data.getClaimerBounty() !== totalClaimerBounty || data.getType() != base_1.ChainSwapType.CHAIN || data.getSequence() !== sequence || data.getAmount() !== resp.total || data.isPayIn() || !data.isToken(amountData.token) || data.getOfferer() !== lp.getAddress(this.chainIdentifier) || !data.isDepositToken(depositToken)) {
            throw new IntermediaryError_1.IntermediaryError("Invalid data returned");
        }
        //Check that we have enough time to send the TX and for it to confirm
        const expiry = this.getOnchainSendTimeout(data, requiredConfirmations);
        const currentTimestamp = BigInt(Math.floor(Date.now() / 1000));
        if (expiry - currentTimestamp < BigInt(this.options.minSendWindow)) {
            throw new IntermediaryError_1.IntermediaryError("Send window too low");
        }
        const lockingScript = (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, resp.btcAddress);
        const desiredExtraData = this.contract.getExtraData(lockingScript, resp.amount, requiredConfirmations);
        const desiredClaimHash = this.contract.getHashForOnchain(lockingScript, resp.amount, requiredConfirmations);
        if (!desiredClaimHash.equals(buffer_1.Buffer.from(data.getClaimHash(), "hex"))) {
            throw new IntermediaryError_1.IntermediaryError("Invalid claim hash returned!");
        }
        if (!desiredExtraData.equals(buffer_1.Buffer.from(data.getExtraData(), "hex"))) {
            throw new IntermediaryError_1.IntermediaryError("Invalid extra data returned!");
        }
    }
    /**
     * Returns a newly created swap, receiving 'amount' on chain
     *
     * @param signer                Smartchain signer's address intiating the swap
     * @param amountData            Amount of token & amount to swap
     * @param lps                   LPs (liquidity providers) to get the quotes from
     * @param options               Quote options
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param abortSignal           Abort signal for aborting the process
     */ create(signer, amountData, lps, options, additionalParams, abortSignal) {
        var _options, _options1;
        options !== null && options !== void 0 ? options : options = {};
        var _blockSafetyFactor;
        (_blockSafetyFactor = (_options = options).blockSafetyFactor) !== null && _blockSafetyFactor !== void 0 ? _blockSafetyFactor : _options.blockSafetyFactor = 1;
        var _feeSafetyFactor;
        (_feeSafetyFactor = (_options1 = options).feeSafetyFactor) !== null && _feeSafetyFactor !== void 0 ? _feeSafetyFactor : _options1.feeSafetyFactor = 2n;
        const sequence = this.getRandomSequence();
        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const pricePrefetchPromise = this.preFetchPrice(amountData, _abortController.signal);
        const claimerBountyPrefetchPromise = this.preFetchClaimerBounty(signer, amountData, options, _abortController);
        const nativeTokenAddress = this.chain.getNativeCurrencyAddress();
        const feeRatePromise = this.preFetchFeeRate(signer, amountData, null, _abortController);
        return lps.map((lp)=>{
            return {
                intermediary: lp,
                quote: (async ()=>{
                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);
                    const liquidityPromise = this.preFetchIntermediaryLiquidity(amountData, lp, abortController);
                    try {
                        const { signDataPromise, resp } = await (0, Utils_1.tryWithRetries)(async (retryCount)=>{
                            const { signDataPrefetch, response } = IntermediaryAPI_1.IntermediaryAPI.initFromBTC(this.chainIdentifier, lp.url, nativeTokenAddress, {
                                claimer: signer,
                                amount: amountData.amount,
                                token: amountData.token.toString(),
                                exactOut: !amountData.exactIn,
                                sequence,
                                claimerBounty: claimerBountyPrefetchPromise,
                                feeRate: feeRatePromise,
                                additionalParams
                            }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);
                            return {
                                signDataPromise: this.preFetchSignData(signDataPrefetch),
                                resp: await response
                            };
                        }, null, (e)=>e instanceof RequestError_1.RequestError, abortController.signal);
                        const data = new this.swapDataDeserializer(resp.data);
                        data.setClaimer(signer);
                        this.verifyReturnedData(resp, amountData, lp, options, data, sequence, await claimerBountyPrefetchPromise, nativeTokenAddress);
                        const [pricingInfo, signatureExpiry] = await Promise.all([
                            //Get intermediary's liquidity
                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.FROM_BTC], false, resp.amount, resp.total, amountData.token, {}, pricePrefetchPromise, abortController.signal),
                            this.verifyReturnedSignature(signer, data, resp, feeRatePromise, signDataPromise, abortController.signal),
                            this.verifyIntermediaryLiquidity(data.getAmount(), liquidityPromise)
                        ]);
                        var _amountData_exactIn, _resp_confirmations;
                        const quote = new FromBTCSwap_1.FromBTCSwap(this, {
                            pricingInfo,
                            url: lp.url,
                            expiry: signatureExpiry,
                            swapFee: resp.swapFee,
                            feeRate: await feeRatePromise,
                            signatureData: resp,
                            data,
                            address: resp.btcAddress,
                            amount: resp.amount,
                            exactIn: (_amountData_exactIn = amountData.exactIn) !== null && _amountData_exactIn !== void 0 ? _amountData_exactIn : true,
                            requiredConfirmations: (_resp_confirmations = resp.confirmations) !== null && _resp_confirmations !== void 0 ? _resp_confirmations : lp.services[SwapType_1.SwapType.FROM_BTC].data.confirmations
                        });
                        await quote._save();
                        return quote;
                    } catch (e) {
                        abortController.abort(e);
                        throw e;
                    }
                })()
            };
        });
    }
    /**
     * @param chainIdentifier
     * @param unifiedStorage Storage interface for the current environment
     * @param unifiedChainEvents On-chain event listener
     * @param chain
     * @param contract Underlying contract handling the swaps
     * @param prices Pricing to use
     * @param tokens
     * @param swapDataDeserializer Deserializer for SwapData
     * @param btcRelay
     * @param synchronizer Btc relay synchronizer
     * @param btcRpc Bitcoin RPC which also supports getting transactions by txoHash
     * @param options
     * @param events Instance to use for emitting events
     */ constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, btcRelay, synchronizer, btcRpc, options, events){
        if (options == null) options = {};
        var _options_bitcoinNetwork;
        options.bitcoinNetwork = (_options_bitcoinNetwork = options.bitcoinNetwork) !== null && _options_bitcoinNetwork !== void 0 ? _options_bitcoinNetwork : utils_1.TEST_NETWORK;
        options.safetyFactor = options.safetyFactor || 2;
        options.blocksTillTxConfirms = options.blocksTillTxConfirms || 12;
        options.maxConfirmations = options.maxConfirmations || 6;
        options.minSendWindow = options.minSendWindow || 30 * 60; //Minimum time window for user to send in the on-chain funds for From BTC swap
        options.bitcoinBlocktime = options.bitcoinBlocktime || 10 * 60;
        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, swapDataDeserializer, options, events);
        this.TYPE = SwapType_1.SwapType.FROM_BTC;
        this.swapDeserializer = FromBTCSwap_1.FromBTCSwap;
        this.pendingSwapStates = [
            FromBTCSwap_1.FromBTCSwapState.PR_CREATED,
            FromBTCSwap_1.FromBTCSwapState.QUOTE_SOFT_EXPIRED,
            FromBTCSwap_1.FromBTCSwapState.CLAIM_COMMITED,
            FromBTCSwap_1.FromBTCSwapState.BTC_TX_CONFIRMED,
            FromBTCSwap_1.FromBTCSwapState.EXPIRED
        ];
        this.tickSwapState = [
            FromBTCSwap_1.FromBTCSwapState.PR_CREATED,
            FromBTCSwap_1.FromBTCSwapState.CLAIM_COMMITED,
            FromBTCSwap_1.FromBTCSwapState.EXPIRED
        ];
        this.btcRelay = btcRelay;
        this.synchronizer = synchronizer;
        this.btcRpc = btcRpc;
    }
}
exports.FromBTCWrapper = FromBTCWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/TrustedIntermediaryAPI.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TrustedIntermediaryAPI = exports.InvoiceStatusResponseCodes = exports.AddressStatusResponseCodes = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const SchemaVerifier_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/paramcoders/SchemaVerifier.js [app-client] (ecmascript)");
var AddressStatusResponseCodes;
(function(AddressStatusResponseCodes) {
    AddressStatusResponseCodes[AddressStatusResponseCodes["EXPIRED"] = 10001] = "EXPIRED";
    AddressStatusResponseCodes[AddressStatusResponseCodes["PAID"] = 10000] = "PAID";
    AddressStatusResponseCodes[AddressStatusResponseCodes["AWAIT_PAYMENT"] = 10010] = "AWAIT_PAYMENT";
    AddressStatusResponseCodes[AddressStatusResponseCodes["AWAIT_CONFIRMATION"] = 10011] = "AWAIT_CONFIRMATION";
    AddressStatusResponseCodes[AddressStatusResponseCodes["PENDING"] = 10013] = "PENDING";
    AddressStatusResponseCodes[AddressStatusResponseCodes["TX_SENT"] = 10012] = "TX_SENT";
    AddressStatusResponseCodes[AddressStatusResponseCodes["REFUNDED"] = 10014] = "REFUNDED";
    AddressStatusResponseCodes[AddressStatusResponseCodes["DOUBLE_SPENT"] = 10015] = "DOUBLE_SPENT";
    AddressStatusResponseCodes[AddressStatusResponseCodes["REFUNDABLE"] = 10016] = "REFUNDABLE";
})(AddressStatusResponseCodes = exports.AddressStatusResponseCodes || (exports.AddressStatusResponseCodes = {}));
const TrustedFromBTCResponseSchema = {
    paymentHash: SchemaVerifier_1.FieldTypeEnum.String,
    sequence: SchemaVerifier_1.FieldTypeEnum.BigInt,
    btcAddress: SchemaVerifier_1.FieldTypeEnum.String,
    amountSats: SchemaVerifier_1.FieldTypeEnum.BigInt,
    swapFeeSats: SchemaVerifier_1.FieldTypeEnum.BigInt,
    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    total: SchemaVerifier_1.FieldTypeEnum.BigInt,
    intermediaryKey: SchemaVerifier_1.FieldTypeEnum.String,
    recommendedFee: SchemaVerifier_1.FieldTypeEnum.Number,
    expiresAt: SchemaVerifier_1.FieldTypeEnum.Number
};
var InvoiceStatusResponseCodes;
(function(InvoiceStatusResponseCodes) {
    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes["EXPIRED"] = 10001] = "EXPIRED";
    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes["PAID"] = 10000] = "PAID";
    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes["AWAIT_PAYMENT"] = 10010] = "AWAIT_PAYMENT";
    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes["PENDING"] = 10011] = "PENDING";
    InvoiceStatusResponseCodes[InvoiceStatusResponseCodes["TX_SENT"] = 10012] = "TX_SENT";
})(InvoiceStatusResponseCodes = exports.InvoiceStatusResponseCodes || (exports.InvoiceStatusResponseCodes = {}));
const TrustedFromBTCLNResponseSchema = {
    pr: SchemaVerifier_1.FieldTypeEnum.String,
    swapFee: SchemaVerifier_1.FieldTypeEnum.BigInt,
    total: SchemaVerifier_1.FieldTypeEnum.BigInt
};
class TrustedIntermediaryAPI {
    /**
     * Fetches the invoice status from the intermediary node
     *
     * @param url Url of the trusted intermediary
     * @param paymentHash Payment hash of the lightning invoice
     * @param timeout Timeout in milliseconds
     * @param abortSignal
     * @throws {RequestError} if non-200 http response is returned
     */ static async getInvoiceStatus(url, paymentHash, timeout, abortSignal) {
        return (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(url + "/getInvoiceStatus?paymentHash=" + encodeURIComponent(paymentHash), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);
    }
    /**
     * Initiate a trusted swap from BTCLN to SC native currency, retries!
     *
     * @param chainIdentifier
     * @param baseUrl Base url of the trusted swap intermediary
     * @param init Initialization parameters
     * @param timeout Timeout in milliseconds for the request
     * @param abortSignal
     * @throws {RequestError} If the response is non-200
     */ static async initTrustedFromBTCLN(chainIdentifier, baseUrl, init, timeout, abortSignal) {
        const resp = await (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(baseUrl + "/lnforgas/createInvoice" + "?address=" + encodeURIComponent(init.address) + "&amount=" + encodeURIComponent(init.amount.toString(10)) + "&chain=" + encodeURIComponent(chainIdentifier) + "&token=" + encodeURIComponent(init.token), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);
        if (resp.code !== 10000) throw RequestError_1.RequestError.parse(JSON.stringify(resp), 400);
        return (0, SchemaVerifier_1.verifySchema)(resp.data, TrustedFromBTCLNResponseSchema);
    }
    /**
     * Fetches the address status from the intermediary node
     *
     * @param url Url of the trusted intermediary
     * @param paymentHash Payment hash of the swap
     * @param sequence Sequence number of the swap
     * @param timeout Timeout in milliseconds
     * @param abortSignal
     * @throws {RequestError} if non-200 http response is returned
     */ static async getAddressStatus(url, paymentHash, sequence, timeout, abortSignal) {
        return (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(url + "/getAddressStatus?paymentHash=" + encodeURIComponent(paymentHash) + "&sequence=" + encodeURIComponent(sequence.toString(10)), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);
    }
    /**
     * Sets the refund address for an on-chain gas swap
     *
     * @param url Url of the trusted intermediary
     * @param paymentHash Payment hash of the swap
     * @param sequence Sequence number of the swap
     * @param refundAddress Refund address to set for the swap
     * @param timeout Timeout in milliseconds
     * @param abortSignal
     * @throws {RequestError} if non-200 http response is returned
     */ static async setRefundAddress(url, paymentHash, sequence, refundAddress, timeout, abortSignal) {
        return (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(url + "/setRefundAddress" + "?paymentHash=" + encodeURIComponent(paymentHash) + "&sequence=" + encodeURIComponent(sequence.toString(10)) + "&refundAddress=" + encodeURIComponent(refundAddress), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);
    }
    /**
     * Initiate a trusted swap from BTC to SC native currency, retries!
     *
     * @param chainIdentifier
     * @param baseUrl Base url of the trusted swap intermediary
     * @param init Initialization parameters
     * @param timeout Timeout in milliseconds for the request
     * @param abortSignal
     * @throws {RequestError} If the response is non-200
     */ static async initTrustedFromBTC(chainIdentifier, baseUrl, init, timeout, abortSignal) {
        const resp = await (0, Utils_1.tryWithRetries)(()=>(0, Utils_1.httpGet)(baseUrl + "/frombtc_trusted/getAddress?chain=" + encodeURIComponent(chainIdentifier) + "&address=" + encodeURIComponent(init.address) + "&amount=" + encodeURIComponent(init.amount.toString(10)) + "&refundAddress=" + encodeURIComponent(init.refundAddress) + "&exactIn=true" + "&token=" + encodeURIComponent(init.token), timeout, abortSignal), null, RequestError_1.RequestError, abortSignal);
        if (resp.code !== 10000) throw RequestError_1.RequestError.parse(JSON.stringify(resp), 400);
        return (0, SchemaVerifier_1.verifySchema)(resp.data, TrustedFromBTCResponseSchema);
    }
}
exports.TrustedIntermediaryAPI = TrustedIntermediaryAPI;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LnForGasSwap = exports.isLnForGasSwapInit = exports.LnForGasSwapState = void 0;
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const PaymentAuthError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/PaymentAuthError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const ISwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)");
const TrustedIntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/TrustedIntermediaryAPI.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const Fee_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js [app-client] (ecmascript)");
var LnForGasSwapState;
(function(LnForGasSwapState) {
    LnForGasSwapState[LnForGasSwapState["EXPIRED"] = -2] = "EXPIRED";
    LnForGasSwapState[LnForGasSwapState["FAILED"] = -1] = "FAILED";
    LnForGasSwapState[LnForGasSwapState["PR_CREATED"] = 0] = "PR_CREATED";
    LnForGasSwapState[LnForGasSwapState["PR_PAID"] = 1] = "PR_PAID";
    LnForGasSwapState[LnForGasSwapState["FINISHED"] = 2] = "FINISHED";
})(LnForGasSwapState = exports.LnForGasSwapState || (exports.LnForGasSwapState = {}));
function isLnForGasSwapInit(obj) {
    return typeof obj.pr === "string" && typeof obj.outputAmount === "bigint" && typeof obj.recipient === "string" && typeof obj.token === "string" && (0, ISwap_1.isISwapInit)(obj);
}
exports.isLnForGasSwapInit = isLnForGasSwapInit;
class LnForGasSwap extends ISwap_1.ISwap {
    upgradeVersion() {
        if (this.version == 1) {
            if (this.state === 1) this.state = LnForGasSwapState.FINISHED;
            this.version = 2;
        }
        if (this.version == null) {
            //Noop
            this.version = 1;
        }
    }
    /**
     * In case swapFee in BTC is not supplied it recalculates it based on swap price
     * @protected
     */ tryRecomputeSwapPrice() {
        if (this.swapFeeBtc == null) {
            this.swapFeeBtc = this.swapFee * this.getInput().rawAmount / this.getOutAmountWithoutFee();
        }
        super.tryRecomputeSwapPrice();
    }
    //////////////////////////////
    //// Getters & utils
    _getEscrowHash() {
        return this.getId();
    }
    getOutputAddress() {
        return this.recipient;
    }
    getInputTxId() {
        return this.getId();
    }
    getOutputTxId() {
        return this.scTxId;
    }
    getId() {
        if (this.pr == null) return null;
        const decodedPR = (0, bolt11_1.decode)(this.pr);
        return decodedPR.tagsObject.payment_hash;
    }
    /**
     * Returns the lightning network BOLT11 invoice that needs to be paid as an input to the swap
     */ getAddress() {
        return this.pr;
    }
    /**
     * Returns a string that can be displayed as QR code representation of the lightning invoice (with lightning: prefix)
     */ getHyperlink() {
        return "lightning:" + this.pr.toUpperCase();
    }
    requiresAction() {
        return false;
    }
    isFinished() {
        return this.state === LnForGasSwapState.FINISHED || this.state === LnForGasSwapState.FAILED || this.state === LnForGasSwapState.EXPIRED;
    }
    isQuoteExpired() {
        return this.state === LnForGasSwapState.EXPIRED;
    }
    isQuoteSoftExpired() {
        return this.expiry < Date.now();
    }
    isFailed() {
        return this.state === LnForGasSwapState.FAILED;
    }
    isSuccessful() {
        return this.state === LnForGasSwapState.FINISHED;
    }
    verifyQuoteValid() {
        return Promise.resolve(this.expiry > Date.now());
    }
    //////////////////////////////
    //// Amounts & fees
    getOutAmountWithoutFee() {
        return this.outputAmount + this.swapFee;
    }
    getOutput() {
        return (0, Tokens_1.toTokenAmount)(this.outputAmount, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices);
    }
    getInput() {
        const parsed = (0, bolt11_1.decode)(this.pr);
        const amount = (BigInt(parsed.millisatoshis) + 999n) / 1000n;
        return (0, Tokens_1.toTokenAmount)(amount, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices);
    }
    getInputWithoutFee() {
        const parsed = (0, bolt11_1.decode)(this.pr);
        const amount = (BigInt(parsed.millisatoshis) + 999n) / 1000n;
        return (0, Tokens_1.toTokenAmount)(amount - this.swapFeeBtc, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices);
    }
    getSwapFee() {
        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;
        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getInputWithoutFee().rawAmount;
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),
            composition: {
                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, Tokens_1.BitcoinTokens.BTCLN, this.wrapper.prices),
                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)
            }
        };
    }
    getFee() {
        return this.getSwapFee();
    }
    getFeeBreakdown() {
        return [
            {
                type: Fee_1.FeeType.SWAP,
                fee: this.getSwapFee()
            }
        ];
    }
    //////////////////////////////
    //// Payment
    async checkInvoicePaid() {
        let save = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (this.state === LnForGasSwapState.FAILED || this.state === LnForGasSwapState.EXPIRED) return false;
        if (this.state === LnForGasSwapState.FINISHED) return true;
        const decodedPR = (0, bolt11_1.decode)(this.pr);
        const paymentHash = decodedPR.tagsObject.payment_hash;
        const response = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.getInvoiceStatus(this.url, paymentHash, this.wrapper.options.getRequestTimeout);
        this.logger.debug("checkInvoicePaid(): LP response: ", response);
        switch(response.code){
            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.PAID:
                this.scTxId = response.data.txId;
                const txStatus = await this.wrapper.chain.getTxIdStatus(this.scTxId);
                if (txStatus === "success") {
                    this.state = LnForGasSwapState.FINISHED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                return null;
            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.EXPIRED:
                if (this.state === LnForGasSwapState.PR_CREATED) {
                    this.state = LnForGasSwapState.EXPIRED;
                } else {
                    this.state = LnForGasSwapState.FAILED;
                }
                if (save) await this._saveAndEmit();
                return false;
            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.TX_SENT:
                this.scTxId = response.data.txId;
                if (this.state === LnForGasSwapState.PR_CREATED) {
                    this.state = LnForGasSwapState.PR_PAID;
                    if (save) await this._saveAndEmit();
                }
                return null;
            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.PENDING:
                if (this.state === LnForGasSwapState.PR_CREATED) {
                    this.state = LnForGasSwapState.PR_PAID;
                    if (save) await this._saveAndEmit();
                }
                return null;
            case TrustedIntermediaryAPI_1.InvoiceStatusResponseCodes.AWAIT_PAYMENT:
                return null;
            default:
                this.state = LnForGasSwapState.FAILED;
                if (save) await this._saveAndEmit();
                return false;
        }
    }
    /**
     * A blocking promise resolving when payment was received by the intermediary and client can continue
     * rejecting in case of failure
     *
     * @param abortSignal Abort signal
     * @param checkIntervalSeconds How often to poll the intermediary for answer
     * @throws {PaymentAuthError} If swap expired or failed
     * @throws {Error} When in invalid state (not PR_CREATED)
     */ async waitForPayment(abortSignal) {
        let checkIntervalSeconds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        if (this.state !== LnForGasSwapState.PR_CREATED) throw new Error("Must be in PR_CREATED state!");
        if (!this.initiated) {
            this.initiated = true;
            await this._saveAndEmit();
        }
        while(!abortSignal.aborted && (this.state === LnForGasSwapState.PR_CREATED || this.state === LnForGasSwapState.PR_PAID)){
            await this.checkInvoicePaid(true);
            if (this.state === LnForGasSwapState.PR_CREATED || this.state === LnForGasSwapState.PR_PAID) await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);
        }
        if (this.isFailed()) throw new PaymentAuthError_1.PaymentAuthError("Swap failed");
        return !this.isQuoteExpired();
    }
    //////////////////////////////
    //// Storage
    serialize() {
        return {
            ...super.serialize(),
            pr: this.pr,
            outputAmount: this.outputAmount == null ? null : this.outputAmount.toString(10),
            recipient: this.recipient,
            token: this.token,
            scTxId: this.scTxId
        };
    }
    _getInitiator() {
        return this.recipient;
    }
    //////////////////////////////
    //// Swap ticks & sync
    async _sync(save) {
        if (this.state === LnForGasSwapState.PR_CREATED) {
            //Check if it's maybe already paid
            const res = await this.checkInvoicePaid(false);
            if (res !== null) {
                if (save) await this._saveAndEmit();
                return true;
            }
        }
        return false;
    }
    _tick(save) {
        return Promise.resolve(false);
    }
    constructor(wrapper, initOrObj){
        if (isLnForGasSwapInit(initOrObj)) initOrObj.url += "/lnforgas";
        super(wrapper, initOrObj);
        this.currentVersion = 2;
        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTCLN;
        if (isLnForGasSwapInit(initOrObj)) {
            this.state = LnForGasSwapState.PR_CREATED;
        } else {
            this.pr = initOrObj.pr;
            this.outputAmount = initOrObj.outputAmount == null ? null : BigInt(initOrObj.outputAmount);
            this.recipient = initOrObj.recipient;
            this.token = initOrObj.token;
            this.scTxId = initOrObj.scTxId;
        }
        this.tryRecomputeSwapPrice();
        if (this.pr != null) {
            const decoded = (0, bolt11_1.decode)(this.pr);
            this.expiry = decoded.timeExpireDate * 1000;
        }
        this.logger = (0, Utils_1.getLogger)("LnForGas(" + this.getId() + "): ");
    }
}
exports.LnForGasSwap = LnForGasSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LnForGasWrapper = void 0;
const LnForGasSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasSwap.js [app-client] (ecmascript)");
const ISwapWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwapWrapper.js [app-client] (ecmascript)");
const TrustedIntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/TrustedIntermediaryAPI.js [app-client] (ecmascript)");
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
class LnForGasWrapper extends ISwapWrapper_1.ISwapWrapper {
    /**
     * Returns a newly created swap, receiving 'amount' on lightning network
     *
     * @param signer
     * @param amount            Amount you wish to receive in base units (satoshis)
     * @param lpOrUrl           Intermediary/Counterparty swap service Intermediary object or raw url
     */ async create(signer, amount, lpOrUrl) {
        if (!this.isInitialized) throw new Error("Not initialized, call init() first!");
        const lpUrl = typeof lpOrUrl === "string" ? lpOrUrl : lpOrUrl.url;
        const token = this.chain.getNativeCurrencyAddress();
        const resp = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.initTrustedFromBTCLN(this.chainIdentifier, lpUrl, {
            address: signer,
            amount,
            token
        }, this.options.getRequestTimeout);
        const decodedPr = (0, bolt11_1.decode)(resp.pr);
        const amountIn = (BigInt(decodedPr.millisatoshis) + 999n) / 1000n;
        if (resp.total !== amount) throw new IntermediaryError_1.IntermediaryError("Invalid total returned");
        const pricingInfo = await this.verifyReturnedPrice(typeof lpOrUrl === "string" ? {
            swapFeePPM: 10000,
            swapBaseFee: 10
        } : lpOrUrl.services[SwapType_1.SwapType.TRUSTED_FROM_BTCLN], false, amountIn, amount, token, {});
        const quote = new LnForGasSwap_1.LnForGasSwap(this, {
            pr: resp.pr,
            outputAmount: resp.total,
            recipient: signer,
            pricingInfo,
            url: lpUrl,
            expiry: decodedPr.timeExpireDate * 1000,
            swapFee: resp.swapFee,
            token,
            exactIn: false
        });
        await quote._save();
        return quote;
    }
    constructor(){
        super(...arguments);
        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTCLN;
        this.swapDeserializer = LnForGasSwap_1.LnForGasSwap;
        this.pendingSwapStates = [
            LnForGasSwap_1.LnForGasSwapState.PR_CREATED
        ];
        this.tickSwapState = null;
        this.processEvent = null;
    }
}
exports.LnForGasWrapper = LnForGasWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapWithSigner.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapSwapWithSigner = void 0;
const IToBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js [app-client] (ecmascript)");
const IFromBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCSwap.js [app-client] (ecmascript)");
const FromBTCLNSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNSwap.js [app-client] (ecmascript)");
function wrapSwapWithSigner(swap, signer) {
    return new Proxy(swap, {
        get: (target, prop, receiver)=>{
            // Override the "sayGoodbye" method
            if (prop === "commit") {
                if (swap instanceof IToBTCSwap_1.IToBTCSwap || swap instanceof IFromBTCSwap_1.IFromBTCSwap) {
                    return (abortSignal, skipChecks)=>swap.commit(signer, abortSignal, skipChecks);
                }
            }
            if (prop === "refund") {
                if (swap instanceof IToBTCSwap_1.IToBTCSwap) {
                    return (abortSignal)=>swap.refund(signer, abortSignal);
                }
            }
            if (prop === "claim") {
                if (swap instanceof IFromBTCSwap_1.IFromBTCSwap) {
                    return (abortSignal)=>swap.claim(signer, abortSignal);
                }
            }
            if (prop === "commitAndClaim") {
                if (swap instanceof FromBTCLNSwap_1.FromBTCLNSwap) {
                    return (abortSignal, skipChecks)=>swap.commitAndClaim(signer, abortSignal, skipChecks);
                }
            }
            // Delegate other properties and methods to the original instance
            return Reflect.get(target, prop, receiver);
        }
    });
}
exports.wrapSwapWithSigner = wrapSwapWithSigner;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithSigner.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SwapperWithSigner = void 0;
const SwapWithSigner_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapWithSigner.js [app-client] (ecmascript)");
class SwapperWithSigner {
    get prices() {
        return this.swapper.prices;
    }
    get intermediaryDiscovery() {
        return this.swapper.intermediaryDiscovery;
    }
    get mempoolApi() {
        return this.swapper.mempoolApi;
    }
    get bitcoinRpc() {
        return this.swapper.bitcoinRpc;
    }
    get bitcoinNetwork() {
        return this.swapper.bitcoinNetwork;
    }
    get Utils() {
        return this.swapper.Utils;
    }
    get SwapTypeInfo() {
        return this.swapper.SwapTypeInfo;
    }
    createToBTCSwap(tokenAddress, address, amount, exactIn, additionalParams, options) {
        return this.swapper.createToBTCSwap(this.signer.getAddress(), tokenAddress, address, amount, exactIn, additionalParams, options).then((swap)=>(0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));
    }
    createToBTCLNSwap(tokenAddress, paymentRequest, additionalParams, options) {
        return this.swapper.createToBTCLNSwap(this.signer.getAddress(), tokenAddress, paymentRequest, additionalParams, options).then((swap)=>(0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));
    }
    createToBTCLNSwapViaLNURL(tokenAddress, lnurlPay, amount, exactIn, additionalParams, options) {
        return this.swapper.createToBTCLNSwapViaLNURL(this.signer.getAddress(), tokenAddress, lnurlPay, amount, exactIn, additionalParams, options).then((swap)=>(0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));
    }
    createFromBTCSwap(tokenAddress, amount, exactOut, additionalParams, options) {
        return this.swapper.createFromBTCSwap(this.signer.getAddress(), tokenAddress, amount, exactOut, additionalParams, options).then((swap)=>(0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));
    }
    createFromBTCLNSwap(tokenAddress, amount, exactOut, additionalParams, options) {
        return this.swapper.createFromBTCLNSwap(this.signer.getAddress(), tokenAddress, amount, exactOut, additionalParams, options).then((swap)=>(0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));
    }
    createFromBTCLNSwapViaLNURL(tokenAddress, lnurl, amount, exactOut, additionalParams) {
        return this.swapper.createFromBTCLNSwapViaLNURL(this.signer.getAddress(), tokenAddress, lnurl, amount, exactOut, additionalParams).then((swap)=>(0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));
    }
    createTrustedLNForGasSwap(amount, trustedIntermediaryUrl) {
        return this.swapper.createTrustedLNForGasSwap(this.signer.getAddress(), amount, trustedIntermediaryUrl);
    }
    createTrustedOnchainForGasSwap(amount, refundAddress, trustedIntermediaryUrl) {
        return this.swapper.createTrustedOnchainForGasSwap(this.signer.getAddress(), amount, refundAddress, trustedIntermediaryUrl);
    }
    /**
     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)
     *  or output amount (exactIn=false), NOTE: For regular -> BTC-LN (lightning) swaps the passed amount is ignored and
     *  invoice's pre-set amount is used instead.
     *
     * @param srcToken Source token of the swap, user pays this token
     * @param dstToken Destination token of the swap, user receives this token
     * @param amount Amount of the swap
     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)
     * @param addressLnurlLightningInvoice Bitcoin on-chain address, lightning invoice, LNURL-pay to pay or
     *  LNURL-withdrawal to withdraw money from
     */ create(srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice) {
        return this.swapper.create(this.signer.getAddress(), srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice).then((swap)=>(0, SwapWithSigner_1.wrapSwapWithSigner)(swap, this.signer));
    }
    /**
     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address
     */ getAllSwaps() {
        return this.swapper.getAllSwaps(this.signer.getAddress());
    }
    /**
     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address
     */ getActionableSwaps() {
        return this.swapper.getActionableSwaps(this.signer.getAddress());
    }
    /**
     * Returns swaps that are refundable for the specific chain, optionally also for a specific signer's address
     */ getRefundableSwaps() {
        return this.swapper.getRefundableSwaps(this.signer.getAddress());
    }
    /**
     * Returns swap with a specific id (identifier) on a specific chain and optionally with a signer
     */ getSwapById(id) {
        return this.swapper.getSwapById(id, this.signer.getAddress());
    }
    /**
     * Synchronizes swaps from chain, this is usually ran when SDK is initialized, deletes expired quotes
     */ async _syncSwaps() {
        return this.swapper._syncSwaps(this.signer.getAddress());
    }
    supportsSwapType(swapType) {
        return this.swapper.supportsSwapType(swapType);
    }
    getSwapType(srcToken, dstToken) {
        return this.swapper.getSwapType(srcToken, dstToken);
    }
    /**
     * Returns minimum/maximum limits for inputs and outputs for a swap between given tokens
     *
     * @param srcToken
     * @param dstToken
     */ getSwapLimits(srcToken, dstToken) {
        return this.swapper.getSwapLimits(srcToken, dstToken);
    }
    /**
     * Returns tokens that you can swap to (if input=true) from a given token,
     *  or tokens that you can swap from (if input=false) to a given token
     */ getSwapCounterTokens(token, input) {
        return this.swapper.getSwapCounterTokens(token, input);
    }
    ///////////////////////////////////
    /// Deprecated
    /**
     * Returns swap bounds (minimums & maximums) for different swap types & tokens
     * @deprecated Use getSwapLimits() instead!
     */ getSwapBounds() {
        return this.swapper.getSwapBounds();
    }
    /**
     * Returns maximum possible swap amount
     * @deprecated Use getSwapLimits() instead!
     *
     * @param type      Type of the swap
     * @param token     Token of the swap
     */ getMaximum(type, token) {
        return this.swapper.getMaximum(type, token);
    }
    /**
     * Returns minimum possible swap amount
     * @deprecated Use getSwapLimits() instead!
     *
     * @param type      Type of swap
     * @param token     Token of the swap
     */ getMinimum(type, token) {
        return this.swapper.getMinimum(type, token);
    }
    constructor(swapper, signer){
        this.swapper = swapper;
        this.signer = signer;
    }
}
exports.SwapperWithSigner = SwapperWithSigner;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithChain.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SwapperWithChain = void 0;
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const SwapPriceWithChain_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/SwapPriceWithChain.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const SwapperWithSigner_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithSigner.js [app-client] (ecmascript)");
class SwapperWithChain {
    get intermediaryDiscovery() {
        return this.swapper.intermediaryDiscovery;
    }
    get mempoolApi() {
        return this.swapper.mempoolApi;
    }
    get bitcoinRpc() {
        return this.swapper.bitcoinRpc;
    }
    get bitcoinNetwork() {
        return this.swapper.bitcoinNetwork;
    }
    get Utils() {
        return this.swapper.Utils;
    }
    get SwapTypeInfo() {
        return this.swapper.SwapTypeInfo;
    }
    createToBTCSwap(signer, tokenAddress, address, amount, exactIn, additionalParams, options) {
        return this.swapper.createToBTCSwap(this.chainIdentifier, signer, tokenAddress, address, amount, exactIn, additionalParams, options);
    }
    createToBTCLNSwap(signer, tokenAddress, paymentRequest, additionalParams, options) {
        return this.swapper.createToBTCLNSwap(this.chainIdentifier, signer, tokenAddress, paymentRequest, additionalParams, options);
    }
    createToBTCLNSwapViaLNURL(signer, tokenAddress, lnurlPay, amount, exactIn, additionalParams, options) {
        return this.swapper.createToBTCLNSwapViaLNURL(this.chainIdentifier, signer, tokenAddress, lnurlPay, amount, exactIn, additionalParams, options);
    }
    createFromBTCSwap(signer, tokenAddress, amount, exactOut, additionalParams, options) {
        return this.swapper.createFromBTCSwap(this.chainIdentifier, signer, tokenAddress, amount, exactOut, additionalParams, options);
    }
    createFromBTCLNSwap(signer, tokenAddress, amount, exactOut, additionalParams, options) {
        return this.swapper.createFromBTCLNSwap(this.chainIdentifier, signer, tokenAddress, amount, exactOut, additionalParams, options);
    }
    createFromBTCLNSwapViaLNURL(signer, tokenAddress, lnurl, amount, exactOut, additionalParams) {
        return this.swapper.createFromBTCLNSwapViaLNURL(this.chainIdentifier, signer, tokenAddress, lnurl, amount, exactOut, additionalParams);
    }
    createTrustedLNForGasSwap(signer, amount, trustedIntermediaryUrl) {
        return this.swapper.createTrustedLNForGasSwap(this.chainIdentifier, signer, amount, trustedIntermediaryUrl);
    }
    createTrustedOnchainForGasSwap(signer, amount, refundAddress, trustedIntermediaryUrl) {
        return this.swapper.createTrustedOnchainForGasSwap(this.chainIdentifier, signer, amount, refundAddress, trustedIntermediaryUrl);
    }
    /**
     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)
     *  or output amount (exactIn=false), NOTE: For regular -> BTC-LN (lightning) swaps the passed amount is ignored and
     *  invoice's pre-set amount is used instead.
     * @deprecated Use swap() instead
     *
     * @param signer Smartchain (Solana, Starknet, etc.) address of the user
     * @param srcToken Source token of the swap, user pays this token
     * @param dstToken Destination token of the swap, user receives this token
     * @param amount Amount of the swap
     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)
     * @param addressLnurlLightningInvoice Bitcoin on-chain address, lightning invoice, LNURL-pay to pay or
     *  LNURL-withdrawal to withdraw money from
     */ create(signer, srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice) {
        return this.swapper.create(signer, srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice);
    }
    /**
     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)
     *  or output amount (exactIn=false), NOTE: For regular SmartChain -> BTC-LN (lightning) swaps the passed amount is ignored and
     *  invoice's pre-set amount is used instead, use LNURL-pay for dynamic amounts
     *
     * @param srcToken Source token of the swap, user pays this token
     * @param dstToken Destination token of the swap, user receives this token
     * @param amount Amount of the swap
     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)
     * @param src Source wallet/lnurl-withdraw of the swap
     * @param dst Destination smart chain address, bitcoin on-chain address, lightning invoice, LNURL-pay
     * @param options Options for the swap
     */ swap(srcToken, dstToken, amount, exactIn, src, dst, options) {
        return this.swapper.swap(srcToken, dstToken, amount, exactIn, src, dst, options);
    }
    /**
     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address
     */ getAllSwaps(signer) {
        return this.swapper.getAllSwaps(this.chainIdentifier, signer);
    }
    /**
     * Returns swaps that are in-progress and are claimable for the specific chain, optionally also for a specific signer's address
     */ getActionableSwaps(signer) {
        return this.swapper.getActionableSwaps(this.chainIdentifier, signer);
    }
    /**
     * Returns swaps that are refundable for the specific chain, optionally also for a specific signer's address
     */ getRefundableSwaps(signer) {
        return this.swapper.getRefundableSwaps(this.chainIdentifier, signer);
    }
    /**
     * Returns swap with a specific id (identifier) on a specific chain and optionally with a signer
     */ getSwapById(id, signer) {
        return this.swapper.getSwapById(id, this.chainIdentifier, signer);
    }
    /**
     * Synchronizes swaps from chain, this is usually ran when SDK is initialized, deletes expired quotes
     */ async _syncSwaps(signer) {
        return this.swapper._syncSwaps(this.chainIdentifier, signer);
    }
    supportsSwapType(swapType) {
        return this.swapper.supportsSwapType(this.chainIdentifier, swapType);
    }
    getSwapType(srcToken, dstToken) {
        return this.swapper.getSwapType(srcToken, dstToken);
    }
    /**
     * Returns minimum/maximum limits for inputs and outputs for a swap between given tokens
     *
     * @param srcToken
     * @param dstToken
     */ getSwapLimits(srcToken, dstToken) {
        return this.swapper.getSwapLimits(srcToken, dstToken);
    }
    /**
     * Returns a set of supported tokens by all the intermediaries offering a specific swap service
     *
     * @param _swapType Swap service type to check supported tokens for
     */ getSupportedTokens(_swapType) {
        const tokens = [];
        this.intermediaryDiscovery.intermediaries.forEach((lp)=>{
            let swapType = _swapType;
            if (swapType === SwapType_1.SwapType.FROM_BTC && this.supportsSwapType(SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) swapType = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;
            if (lp.services[swapType] == null) return;
            if (lp.services[swapType].chainTokens == null) return;
            for (let tokenAddress of lp.services[swapType].chainTokens[this.chainIdentifier]){
                var _this_swapper_tokens_this_chainIdentifier, _this_swapper_tokens;
                const token = (_this_swapper_tokens = this.swapper.tokens) === null || _this_swapper_tokens === void 0 ? void 0 : (_this_swapper_tokens_this_chainIdentifier = _this_swapper_tokens[this.chainIdentifier]) === null || _this_swapper_tokens_this_chainIdentifier === void 0 ? void 0 : _this_swapper_tokens_this_chainIdentifier[tokenAddress];
                if (token != null) tokens.push(token);
            }
        });
        return tokens;
    }
    /**
     * Returns the set of supported tokens by all the intermediaries we know of offering a specific swapType service
     *
     * @param swapType Specific swap type for which to obtain supported tokens
     */ getSupportedTokenAddresses(swapType) {
        const set = new Set();
        this.intermediaryDiscovery.intermediaries.forEach((lp)=>{
            if (lp.services[swapType] == null) return;
            if (lp.services[swapType].chainTokens == null || lp.services[swapType].chainTokens[this.chainIdentifier] == null) return;
            lp.services[swapType].chainTokens[this.chainIdentifier].forEach((token)=>set.add(token));
        });
        return set;
    }
    /**
     * Returns tokens that you can swap to (if input=true) from a given token,
     *  or tokens that you can swap from (if input=false) to a given token
     */ getSwapCounterTokens(token, input) {
        if ((0, Tokens_1.isSCToken)(token)) {
            const result = [];
            if (input) {
                //TO_BTC or TO_BTCLN
                if (this.getSupportedTokenAddresses(SwapType_1.SwapType.TO_BTCLN).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTCLN);
                }
                if (this.getSupportedTokenAddresses(SwapType_1.SwapType.TO_BTC).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTC);
                }
            } else {
                //FROM_BTC or FROM_BTCLN
                if (this.getSupportedTokenAddresses(SwapType_1.SwapType.FROM_BTCLN).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTCLN);
                }
                const fromOnchainSwapType = this.supportsSwapType(SwapType_1.SwapType.SPV_VAULT_FROM_BTC) ? SwapType_1.SwapType.SPV_VAULT_FROM_BTC : SwapType_1.SwapType.FROM_BTC;
                if (this.getSupportedTokenAddresses(fromOnchainSwapType).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTC);
                }
            }
            return result;
        } else {
            if (input) {
                if (token.lightning) {
                    return this.getSupportedTokens(SwapType_1.SwapType.FROM_BTCLN);
                } else {
                    return this.getSupportedTokens(SwapType_1.SwapType.FROM_BTC);
                }
            } else {
                if (token.lightning) {
                    return this.getSupportedTokens(SwapType_1.SwapType.TO_BTCLN);
                } else {
                    return this.getSupportedTokens(SwapType_1.SwapType.TO_BTC);
                }
            }
        }
    }
    /**
     * Creates a child swapper instance with a signer
     *
     * @param signer Signer to use for the new swapper instance
     */ withChain(signer) {
        return new SwapperWithSigner_1.SwapperWithSigner(this, signer);
    }
    ///////////////////////////////////
    /// Deprecated
    /**
     * Returns swap bounds (minimums & maximums) for different swap types & tokens
     * @deprecated Use getSwapLimits() instead!
     */ getSwapBounds() {
        return this.swapper.getSwapBounds(this.chainIdentifier);
    }
    /**
     * Returns maximum possible swap amount
     * @deprecated Use getSwapLimits() instead!
     *
     * @param type      Type of the swap
     * @param token     Token of the swap
     */ getMaximum(type, token) {
        return this.swapper.getMaximum(this.chainIdentifier, type, token);
    }
    /**
     * Returns minimum possible swap amount
     * @deprecated Use getSwapLimits() instead!
     *
     * @param type      Type of swap
     * @param token     Token of the swap
     */ getMinimum(type, token) {
        return this.swapper.getMinimum(this.chainIdentifier, type, token);
    }
    constructor(swapper, chainIdentifier){
        this.swapper = swapper;
        this.chainIdentifier = chainIdentifier;
        this.prices = new SwapPriceWithChain_1.SwapPriceWithChain(swapper.prices, chainIdentifier);
    }
}
exports.SwapperWithChain = SwapperWithChain;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OnchainForGasSwap = exports.isOnchainForGasSwapInit = exports.OnchainForGasSwapState = void 0;
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const PaymentAuthError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/PaymentAuthError.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const ISwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)");
const TrustedIntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/TrustedIntermediaryAPI.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const Fee_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js [app-client] (ecmascript)");
const IBitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/IBitcoinWallet.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const SingleAddressBitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/SingleAddressBitcoinWallet.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
var OnchainForGasSwapState;
(function(OnchainForGasSwapState) {
    OnchainForGasSwapState[OnchainForGasSwapState["EXPIRED"] = -3] = "EXPIRED";
    OnchainForGasSwapState[OnchainForGasSwapState["FAILED"] = -2] = "FAILED";
    OnchainForGasSwapState[OnchainForGasSwapState["REFUNDED"] = -1] = "REFUNDED";
    OnchainForGasSwapState[OnchainForGasSwapState["PR_CREATED"] = 0] = "PR_CREATED";
    OnchainForGasSwapState[OnchainForGasSwapState["FINISHED"] = 1] = "FINISHED";
    OnchainForGasSwapState[OnchainForGasSwapState["REFUNDABLE"] = 2] = "REFUNDABLE";
})(OnchainForGasSwapState = exports.OnchainForGasSwapState || (exports.OnchainForGasSwapState = {}));
function isOnchainForGasSwapInit(obj) {
    return typeof obj.paymentHash === "string" && typeof obj.sequence === "bigint" && typeof obj.address === "string" && typeof obj.inputAmount === "bigint" && typeof obj.outputAmount === "bigint" && typeof obj.recipient === "string" && typeof obj.token === "string" && (obj.refundAddress == null || typeof obj.refundAddress === "string") && (0, ISwap_1.isISwapInit)(obj);
}
exports.isOnchainForGasSwapInit = isOnchainForGasSwapInit;
class OnchainForGasSwap extends ISwap_1.ISwap {
    upgradeVersion() {
        if (this.version == null) {
            //Noop
            this.version = 1;
        }
    }
    /**
     * In case swapFee in BTC is not supplied it recalculates it based on swap price
     * @protected
     */ tryRecomputeSwapPrice() {
        if (this.swapFeeBtc == null) {
            this.swapFeeBtc = this.swapFee * this.getInput().rawAmount / this.getOutAmountWithoutFee();
        }
        super.tryRecomputeSwapPrice();
    }
    //////////////////////////////
    //// Getters & utils
    _getEscrowHash() {
        return this.paymentHash;
    }
    getOutputAddress() {
        return this.recipient;
    }
    getInputTxId() {
        return this.txId;
    }
    getOutputTxId() {
        return this.scTxId;
    }
    getId() {
        return this.paymentHash;
    }
    getAddress() {
        return this.address;
    }
    getHyperlink() {
        return "bitcoin:" + this.address + "?amount=" + encodeURIComponent((Number(this.inputAmount) / 100000000).toString(10));
    }
    requiresAction() {
        return this.state === OnchainForGasSwapState.REFUNDABLE;
    }
    isFinished() {
        return this.state === OnchainForGasSwapState.FINISHED || this.state === OnchainForGasSwapState.FAILED || this.state === OnchainForGasSwapState.EXPIRED || this.state === OnchainForGasSwapState.REFUNDED;
    }
    isQuoteExpired() {
        return this.state === OnchainForGasSwapState.EXPIRED;
    }
    isQuoteSoftExpired() {
        return this.expiry < Date.now();
    }
    isFailed() {
        return this.state === OnchainForGasSwapState.FAILED;
    }
    isSuccessful() {
        return this.state === OnchainForGasSwapState.FINISHED;
    }
    verifyQuoteValid() {
        return Promise.resolve(this.expiry > Date.now());
    }
    //////////////////////////////
    //// Amounts & fees
    getOutAmountWithoutFee() {
        return this.outputAmount + this.swapFee;
    }
    getOutput() {
        return (0, Tokens_1.toTokenAmount)(this.outputAmount, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices);
    }
    getInput() {
        return (0, Tokens_1.toTokenAmount)(this.inputAmount, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);
    }
    getInputWithoutFee() {
        return (0, Tokens_1.toTokenAmount)(this.inputAmount - this.swapFeeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);
    }
    getSwapFee() {
        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;
        const swapFeePPM = feeWithoutBaseFee * 1000000n / this.getInputWithoutFee().rawAmount;
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee, this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()], this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc, abortSignal, preFetchedUsdPrice),
            composition: {
                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),
                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)
            }
        };
    }
    getFee() {
        return this.getSwapFee();
    }
    getFeeBreakdown() {
        return [
            {
                type: Fee_1.FeeType.SWAP,
                fee: this.getSwapFee()
            }
        ];
    }
    getRequiredConfirmationsCount() {
        return 1;
    }
    async getFundedPsbt(_bitcoinWallet, feeRate) {
        if (this.state !== OnchainForGasSwapState.PR_CREATED) throw new Error("Swap already paid for!");
        let bitcoinWallet;
        if ((0, IBitcoinWallet_1.isIBitcoinWallet)(_bitcoinWallet)) {
            bitcoinWallet = _bitcoinWallet;
        } else {
            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.wrapper.btcRpc, this.wrapper.options.bitcoinNetwork, _bitcoinWallet);
        }
        //TODO: Maybe re-introduce fee rate check here if passed from the user
        if (feeRate == null) {
            feeRate = await bitcoinWallet.getFeeRate();
        }
        const basePsbt = new btc_signer_1.Transaction({
            allowUnknownOutputs: true,
            allowLegacyWitnessUtxo: true
        });
        basePsbt.addOutput({
            amount: this.outputAmount,
            script: (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address)
        });
        const psbt = await bitcoinWallet.fundPsbt(basePsbt, feeRate);
        //Sign every input
        const signInputs = [];
        for(let i = 0; i < psbt.inputsLength; i++){
            signInputs.push(i);
        }
        return {
            psbt,
            signInputs
        };
    }
    async submitPsbt(psbt) {
        if (this.state !== OnchainForGasSwapState.PR_CREATED) throw new Error("Swap already paid for!");
        //Ensure not expired
        if (this.expiry < Date.now()) {
            throw new Error("Swap expired!");
        }
        const output0 = psbt.getOutput(0);
        if (output0.amount !== this.outputAmount) throw new Error("PSBT output amount invalid, expected: " + this.outputAmount + " got: " + output0.amount);
        const expectedOutputScript = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.address);
        if (!expectedOutputScript.equals(output0.script)) throw new Error("PSBT output script invalid!");
        if (!psbt.isFinal) psbt.finalize();
        return await this.wrapper.btcRpc.sendRawTransaction(buffer_1.Buffer.from(psbt.toBytes(true, true)).toString("hex"));
    }
    async estimateBitcoinFee(wallet, feeRate) {
        const txFee = await wallet.getTransactionFee(this.address, this.inputAmount, feeRate);
        return (0, Tokens_1.toTokenAmount)(txFee == null ? null : BigInt(txFee), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);
    }
    async sendBitcoinTransaction(wallet, feeRate) {
        if (this.state !== OnchainForGasSwapState.PR_CREATED) throw new Error("Swap already paid for!");
        return await wallet.sendTransaction(this.address, this.inputAmount, feeRate);
    }
    //////////////////////////////
    //// Payment
    async checkAddress() {
        let save = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        if (this.state === OnchainForGasSwapState.FAILED || this.state === OnchainForGasSwapState.EXPIRED || this.state === OnchainForGasSwapState.REFUNDED) return false;
        if (this.state === OnchainForGasSwapState.FINISHED) return false;
        const response = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.getAddressStatus(this.url, this.paymentHash, this.sequence, this.wrapper.options.getRequestTimeout);
        switch(response.code){
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.AWAIT_PAYMENT:
                if (this.txId != null) {
                    this.txId = null;
                    if (save) await this._save();
                    return true;
                }
                return false;
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.AWAIT_CONFIRMATION:
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.PENDING:
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.TX_SENT:
                const inputAmount = BigInt(response.data.adjustedAmount);
                const outputAmount = BigInt(response.data.adjustedTotal);
                const adjustedFee = response.data.adjustedFee == null ? null : BigInt(response.data.adjustedFee);
                const adjustedFeeSats = response.data.adjustedFeeSats == null ? null : BigInt(response.data.adjustedFeeSats);
                const txId = response.data.txId;
                if (this.txId != txId || this.inputAmount !== inputAmount || this.outputAmount !== outputAmount) {
                    this.txId = txId;
                    this.inputAmount = inputAmount;
                    this.outputAmount = outputAmount;
                    if (adjustedFee != null) this.swapFee = adjustedFee;
                    if (adjustedFeeSats != null) this.swapFeeBtc = adjustedFeeSats;
                    if (save) await this._save();
                    return true;
                }
                return false;
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.PAID:
                const txStatus = await this.wrapper.chain.getTxIdStatus(response.data.txId);
                if (txStatus === "success") {
                    this.state = OnchainForGasSwapState.FINISHED;
                    this.scTxId = response.data.txId;
                    if (save) await this._saveAndEmit();
                    return true;
                }
                return false;
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.EXPIRED:
                this.state = OnchainForGasSwapState.EXPIRED;
                if (save) await this._saveAndEmit();
                return true;
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.REFUNDABLE:
                if (this.state === OnchainForGasSwapState.REFUNDABLE) return null;
                this.state = OnchainForGasSwapState.REFUNDABLE;
                if (save) await this._saveAndEmit();
                return true;
            case TrustedIntermediaryAPI_1.AddressStatusResponseCodes.REFUNDED:
                this.state = OnchainForGasSwapState.REFUNDED;
                this.refundTxId = response.data.txId;
                if (save) await this._saveAndEmit();
                return true;
            default:
                this.state = OnchainForGasSwapState.FAILED;
                if (save) await this._saveAndEmit();
                return true;
        }
    }
    async setRefundAddress(refundAddress) {
        if (this.refundAddress != null) {
            if (this.refundAddress !== refundAddress) throw new Error("Different refund address already set!");
            return;
        }
        await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.setRefundAddress(this.url, this.paymentHash, this.sequence, refundAddress, this.wrapper.options.getRequestTimeout);
        this.refundAddress = refundAddress;
    }
    /**
     * A blocking promise resolving when payment was received by the intermediary and client can continue
     * rejecting in case of failure
     *
     * @param abortSignal Abort signal
     * @param checkIntervalSeconds How often to poll the intermediary for answer
     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations
     * @throws {PaymentAuthError} If swap expired or failed
     * @throws {Error} When in invalid state (not PR_CREATED)
     */ async waitForBitcoinTransaction(abortSignal) {
        let checkIntervalSeconds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5, updateCallback = arguments.length > 2 ? arguments[2] : void 0;
        if (this.state !== OnchainForGasSwapState.PR_CREATED) throw new Error("Must be in PR_CREATED state!");
        if (!this.initiated) {
            this.initiated = true;
            await this._saveAndEmit();
        }
        while(!abortSignal.aborted && this.state === OnchainForGasSwapState.PR_CREATED){
            await this.checkAddress(true);
            if (this.txId != null && updateCallback != null) {
                const res = await this.wrapper.btcRpc.getTransaction(this.txId);
                if (res == null) {
                    updateCallback(null, null, 1, null);
                } else if (res.confirmations > 0) {
                    updateCallback(res.txid, res.confirmations, 1, 0);
                } else {
                    const delay = await this.wrapper.btcRpc.getConfirmationDelay(res, 1);
                    updateCallback(res.txid, 0, 1, delay);
                }
            }
            if (this.state === OnchainForGasSwapState.PR_CREATED) await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);
        }
        if (this.state === OnchainForGasSwapState.REFUNDABLE || this.state === OnchainForGasSwapState.REFUNDED) return this.txId;
        if (this.isQuoteExpired()) throw new PaymentAuthError_1.PaymentAuthError("Swap expired");
        if (this.isFailed()) throw new PaymentAuthError_1.PaymentAuthError("Swap failed");
        return this.txId;
    }
    async waitTillRefunded(abortSignal) {
        let checkIntervalSeconds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        if (this.state === OnchainForGasSwapState.REFUNDED) return;
        if (this.state !== OnchainForGasSwapState.REFUNDABLE) throw new Error("Must be in REFUNDABLE state!");
        while(!abortSignal.aborted && this.state === OnchainForGasSwapState.REFUNDABLE){
            await this.checkAddress(true);
            if (this.state === OnchainForGasSwapState.REFUNDABLE) await (0, Utils_1.timeoutPromise)(checkIntervalSeconds * 1000, abortSignal);
        }
        if (this.isQuoteExpired()) throw new PaymentAuthError_1.PaymentAuthError("Swap expired");
        if (this.isFailed()) throw new PaymentAuthError_1.PaymentAuthError("Swap failed");
    }
    async requestRefund(refundAddress, abortSignal) {
        if (refundAddress != null) await this.setRefundAddress(refundAddress);
        await this.waitTillRefunded(abortSignal);
    }
    //////////////////////////////
    //// Storage
    serialize() {
        return {
            ...super.serialize(),
            paymentHash: this.paymentHash,
            sequence: this.sequence == null ? null : this.sequence.toString(10),
            address: this.address,
            inputAmount: this.inputAmount == null ? null : this.inputAmount.toString(10),
            outputAmount: this.outputAmount == null ? null : this.outputAmount.toString(10),
            recipient: this.recipient,
            token: this.token,
            refundAddress: this.refundAddress,
            scTxId: this.scTxId,
            txId: this.txId,
            refundTxId: this.refundTxId
        };
    }
    _getInitiator() {
        return this.recipient;
    }
    //////////////////////////////
    //// Swap ticks & sync
    async _sync(save) {
        if (this.state === OnchainForGasSwapState.PR_CREATED) {
            //Check if it's maybe already paid
            const result = await this.checkAddress(false);
            if (result) {
                if (save) await this._saveAndEmit();
                return true;
            }
        }
        return false;
    }
    _tick(save) {
        return Promise.resolve(false);
    }
    constructor(wrapper, initOrObj){
        if (isOnchainForGasSwapInit(initOrObj)) initOrObj.url += "/frombtc_trusted";
        super(wrapper, initOrObj);
        this.getSmartChainNetworkFee = null;
        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTC;
        if (isOnchainForGasSwapInit(initOrObj)) {
            this.state = OnchainForGasSwapState.PR_CREATED;
        } else {
            this.paymentHash = initOrObj.paymentHash;
            this.sequence = initOrObj.sequence == null ? null : BigInt(initOrObj.sequence);
            this.address = initOrObj.address;
            this.inputAmount = initOrObj.inputAmount == null ? null : BigInt(initOrObj.inputAmount);
            this.outputAmount = initOrObj.outputAmount == null ? null : BigInt(initOrObj.outputAmount);
            this.recipient = initOrObj.recipient;
            this.token = initOrObj.token;
            this.refundAddress = initOrObj.refundAddress;
            this.scTxId = initOrObj.scTxId;
            this.txId = initOrObj.txId;
            this.refundTxId = initOrObj.refundTxId;
        }
        this.logger = (0, Utils_1.getLogger)("OnchainForGas(" + this.getId() + "): ");
        this.tryRecomputeSwapPrice();
    }
}
exports.OnchainForGasSwap = OnchainForGasSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OnchainForGasWrapper = void 0;
const ISwapWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwapWrapper.js [app-client] (ecmascript)");
const TrustedIntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/TrustedIntermediaryAPI.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const OnchainForGasSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasSwap.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
class OnchainForGasWrapper extends ISwapWrapper_1.ISwapWrapper {
    /**
     * Returns a newly created swap, receiving 'amount' base units of gas token
     *
     * @param signer
     * @param amount            Amount you wish to receive in base units
     * @param lpOrUrl           Intermediary/Counterparty swap service Intermediary object or raw url
     * @param refundAddress     Bitcoin address to receive refund on in case the counterparty cannot execute the swap
     */ async create(signer, amount, lpOrUrl, refundAddress) {
        if (!this.isInitialized) throw new Error("Not initialized, call init() first!");
        const lpUrl = typeof lpOrUrl === "string" ? lpOrUrl : lpOrUrl.url;
        const token = this.chain.getNativeCurrencyAddress();
        const resp = await TrustedIntermediaryAPI_1.TrustedIntermediaryAPI.initTrustedFromBTC(this.chainIdentifier, lpUrl, {
            address: signer,
            amount,
            refundAddress,
            token
        }, this.options.getRequestTimeout);
        if (resp.total !== amount) throw new IntermediaryError_1.IntermediaryError("Invalid total returned");
        const pricingInfo = await this.verifyReturnedPrice(typeof lpOrUrl === "string" ? {
            swapFeePPM: 10000,
            swapBaseFee: 10
        } : lpOrUrl.services[SwapType_1.SwapType.TRUSTED_FROM_BTC], false, resp.amountSats, amount, this.chain.getNativeCurrencyAddress(), {});
        const quote = new OnchainForGasSwap_1.OnchainForGasSwap(this, {
            paymentHash: resp.paymentHash,
            sequence: resp.sequence,
            address: resp.btcAddress,
            inputAmount: resp.amountSats,
            outputAmount: resp.total,
            recipient: signer,
            refundAddress,
            pricingInfo,
            url: lpUrl,
            expiry: resp.expiresAt,
            swapFee: resp.swapFee,
            swapFeeBtc: resp.swapFeeSats,
            exactIn: false,
            token
        });
        await quote._save();
        return quote;
    }
    /**
     * @param chainIdentifier
     * @param unifiedStorage Storage interface for the current environment
     * @param unifiedChainEvents On-chain event listener
     * @param chain
     * @param prices Pricing to use
     * @param tokens
     * @param btcRpc Bitcoin RPC which also supports getting transactions by txoHash
     * @param options
     * @param events Instance to use for emitting events
     */ constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, btcRpc, options, events){
        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events);
        this.TYPE = SwapType_1.SwapType.TRUSTED_FROM_BTC;
        this.swapDeserializer = OnchainForGasSwap_1.OnchainForGasSwap;
        this.pendingSwapStates = [
            OnchainForGasSwap_1.OnchainForGasSwapState.PR_CREATED
        ];
        this.tickSwapState = null;
        this.processEvent = null;
        this.btcRpc = btcRpc;
    }
}
exports.OnchainForGasWrapper = OnchainForGasWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/browser-storage/IndexedDBUnifiedStorage.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IndexedDBUnifiedStorage = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
function toCompositeIndex(values) {
    if (values.length === 0) return [];
    if (values.length === 1) {
        return values[0];
    } else {
        const compositeArray = [];
        const firstValues = values.shift();
        const restValues = toCompositeIndex(values);
        for (let value of firstValues){
            for (let restValue of restValues){
                compositeArray.push([
                    value
                ].concat(restValue));
            }
        }
        return compositeArray;
    }
}
function matches(conditions, obj) {
    for (let condition of conditions){
        let value = obj[condition.key];
        if (!condition.values.has(value)) return false;
    }
    return true;
}
function toSetConditions(input) {
    return input.map((val)=>{
        return {
            key: val.key,
            values: Array.isArray(val.value) ? new Set(val.value) : new Set([
                val.value
            ])
        };
    });
}
const indexes = {
    "escrowHash": {
        key: "escrowHash",
        unique: true
    },
    "type": {
        key: "type",
        unique: false
    },
    "initiator": {
        key: "initiator",
        unique: false
    },
    "initiator, id": {
        key: [
            "initiator",
            "id"
        ],
        unique: false
    },
    "type, state": {
        key: [
            "type",
            "state"
        ],
        unique: false
    },
    "type, paymentHash": {
        key: [
            "type",
            "paymentHash"
        ],
        unique: false
    },
    "type, initiator, state": {
        key: [
            "type",
            "initiator",
            "state"
        ],
        unique: false
    }
};
class IndexedDBUnifiedStorage {
    //Reviver also needs to update the swap to the latest version
    async tryMigrateLocalStorage(storageKey, swapType, reviver) {
        const txt = window.localStorage.getItem(storageKey);
        if (txt == null) return false;
        let data;
        try {
            data = JSON.parse(txt);
        } catch (e) {
            this.logger.warn("tryMigrate(" + storageKey + "): Tried to migrate the database, but cannot parse old local storage!");
            return false;
        }
        let swaps = Object.keys(data).map((id)=>{
            let swapData = data[id];
            swapData.type = swapType;
            return reviver(swapData);
        });
        await this.saveAll(swaps.map((swap)=>swap.serialize()));
        window.localStorage.removeItem(storageKey);
        this.logger.info("tryMigrate(" + storageKey + "): Database successfully migrated from localStorage to unifiedIndexedDB!");
        return true;
    }
    //Reviver also needs to update the swap to the latest version
    async tryMigrateOldIndexedDB(storageKey, swapType, reviver) {
        const databases = await window.indexedDB.databases();
        if (databases.find((val)=>val.name === storageKey) == null) {
            this.logger.info("tryMigrateOldIndexedDB(" + storageKey + "): Old database not found!");
            return false;
        }
        this.logger.debug("tryMigrateOldIndexedDB(" + storageKey + "): Old database found!");
        let db;
        try {
            db = await new Promise((resolve, reject)=>{
                const request = window.indexedDB.open(storageKey, 1);
                request.onerror = (e)=>reject(e);
                request.onsuccess = (e)=>resolve(e.target.result);
            });
        } catch (e) {
            this.logger.warn("tryMigrateOldIndexedDB(" + storageKey + "): Error opening old IndexedDB!", e);
            return false;
        }
        this.logger.debug("tryMigrateOldIndexedDB(" + storageKey + "): Connection opened!");
        try {
            const data = await new Promise((resolve, reject)=>{
                const tx = db.transaction("swaps", "readonly", {
                    durability: "strict"
                });
                const store = tx.objectStore("swaps");
                const req = store.getAll();
                req.onsuccess = (event)=>resolve(event.target.result);
                req.onerror = (event)=>reject(event);
            });
            this.logger.debug("tryMigrateOldIndexedDB(" + storageKey + "): Data retrieved!");
            let swaps = data.map((param)=>{
                let { id, data } = param;
                data.type = swapType;
                return reviver(data);
            });
            this.logger.debug("tryMigrateOldIndexedDB(" + storageKey + "): Data revived!");
            await this.saveAll(swaps.map((swap)=>swap.serialize()));
            this.logger.debug("tryMigrateOldIndexedDB(" + storageKey + "): Data saved!");
            //Remove the old database
            db.close();
            this.logger.debug("tryMigrateOldIndexedDB(" + storageKey + "): DB connection closed!");
            await new Promise((resolve, reject)=>{
                const res = window.indexedDB.deleteDatabase(storageKey);
                res.onsuccess = ()=>resolve();
                res.onerror = (e)=>reject(e);
            });
            this.logger.info("tryMigrateOldIndexedDB(" + storageKey + "): Database successfully migrated from oldIndexedDB to unifiedIndexedDB!");
            return true;
        } catch (e) {
            this.logger.warn("tryMigrateOldIndexedDB(" + storageKey + "): Tried to migrate the database, but cannot parse oldIndexedDB!", e);
            return false;
        }
    }
    //NOTE: Reviver also needs to update the swap to the latest version
    async tryMigrate(storageKeys, reviver) {
        let someMigrated = false;
        for (let storageKey of storageKeys){
            this.logger.info("tryMigrate(): Trying to migrate...", storageKey);
            if (await this.tryMigrateLocalStorage(storageKey[0], storageKey[1], reviver)) someMigrated = true;
            if (await this.tryMigrateOldIndexedDB(storageKey[0], storageKey[1], reviver)) someMigrated = true;
        }
        return someMigrated;
    }
    executeTransaction(cbk, readonly) {
        return new Promise((resolve, reject)=>{
            const tx = this.db.transaction("swaps", readonly ? "readonly" : "readwrite", {
                durability: "strict"
            });
            const req = cbk(tx.objectStore("swaps"));
            req.onsuccess = (event)=>resolve(event.target.result);
            req.onerror = (event)=>reject(event);
        });
    }
    executeTransactionArr(cbk, readonly) {
        const tx = this.db.transaction("swaps", readonly ? "readonly" : "readwrite", {
            durability: "strict"
        });
        const reqs = cbk(tx.objectStore("swaps"));
        return Promise.all(reqs.map((req)=>new Promise((resolve, reject)=>{
                req.onsuccess = (event)=>resolve(event.target.result);
                req.onerror = (event)=>reject(event);
            })));
    }
    executeTransactionWithCursor(cbk, valueCbk) {
        return new Promise((resolve, reject)=>{
            const tx = this.db.transaction("swaps", "readonly", {
                durability: "strict"
            });
            const cursorRequests = cbk(tx.objectStore("swaps"));
            const resultObjects = [];
            for (let cursorRequest of cursorRequests){
                cursorRequest.onsuccess = (event)=>{
                    const cursor = event.target.result;
                    if (cursor != null) {
                        const value = cursor.value;
                        if (valueCbk(value)) resultObjects.push(value);
                        cursor.continue();
                    } else {
                        resolve(resultObjects);
                    }
                };
                cursorRequest.onerror = (event)=>reject(event);
            }
        });
    }
    async init() {
        if (this.db == null) {
            this.db = await new Promise((resolve, reject)=>{
                const request = window.indexedDB.open(this.storageKey, 1);
                request.onupgradeneeded = (event)=>{
                    const db = event.target.result;
                    const objectStore = db.createObjectStore("swaps", {
                        keyPath: "id"
                    });
                    Object.keys(indexes).forEach((name)=>{
                        const index = indexes[name];
                        objectStore.createIndex(name, index.key, {
                            unique: index.unique
                        });
                    });
                };
                request.onerror = (e)=>reject(e);
                request.onsuccess = (e)=>resolve(e.target.result);
            });
        }
    }
    /**
     * Params are specified in the following way:
     *  - [[condition1, condition2]] - returns all rows where condition1 AND condition2 is met
     *  - [[condition1], [condition2]] - returns all rows where condition1 OR condition2 is met
     *  - [[condition1, condition2], [condition3]] - returns all rows where (condition1 AND condition2) OR condition3 is met
     * @param params
     */ async query(params) {
        if (params.length === 0) return await this.querySingle([]);
        const results = await Promise.all(params.map((singleParam)=>this.querySingle(singleParam)));
        const resultSet = new Set(results.flat()); //Deduplicate
        return Array.from(resultSet);
    }
    async querySingle(params) {
        if (params.length === 0) {
            return await this.executeTransaction((objectStore)=>objectStore.getAll(), true);
        }
        const queryKeys = params.map((param)=>param.key);
        const requiredIndex = queryKeys.join(", ");
        if (requiredIndex === "id") {
            //ID is the index
            const values = Array.isArray(params[0].value) ? params[0].value : [
                params[0].value
            ];
            const res = await this.executeTransactionArr((objectStore)=>{
                return values.map((val)=>objectStore.getAll(val));
            }, true);
            return res.flat();
        } else if (indexes[requiredIndex] != null) {
            //Index exists
            const values = params.map((param)=>Array.isArray(param.value) ? param.value : [
                    param.value
                ]);
            const compositeIndexQueries = toCompositeIndex(values);
            const resp = await this.executeTransactionArr((objectStore)=>{
                const index = objectStore.index(requiredIndex);
                return compositeIndexQueries.map((indexQuery)=>index.getAll(indexQuery));
            }, true);
            return resp.flat();
        } else {
            //Need to go over all values
            this.logger.warn("query(): Index cannot be used for query, required index: " + requiredIndex + " query params: ", params);
            const setConditions = toSetConditions(params);
            return await this.executeTransactionWithCursor((objectStore)=>[
                    objectStore.openCursor()
                ], (val)=>matches(setConditions, val));
        }
    }
    async remove(object) {
        await this.executeTransaction((store)=>store.delete(object.id), false).catch(()=>null);
    }
    async removeAll(arr) {
        if (arr.length === 0) return;
        await this.executeTransactionArr((store)=>arr.map((object)=>{
                return store.delete(object.id);
            }), false);
    }
    async save(object) {
        await this.executeTransaction((store)=>store.put(object), false);
    }
    async saveAll(arr) {
        if (arr.length === 0) return;
        await this.executeTransactionArr((store)=>arr.map((object)=>{
                return store.put(object);
            }), false);
    }
    constructor(storageKey){
        this.storageKey = storageKey;
        this.logger = (0, Utils_1.getLogger)("IndexedDBUnifiedStorage(" + this.storageKey + "): ");
    }
}
exports.IndexedDBUnifiedStorage = IndexedDBUnifiedStorage;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/storage/UnifiedSwapStorage.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnifiedSwapStorage = void 0;
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const logger = (0, Utils_1.getLogger)("UnifiedSwapStorage: ");
const indexes = [
    {
        key: "id",
        type: "string",
        unique: true,
        nullable: false
    },
    {
        key: "escrowHash",
        type: "string",
        unique: true,
        nullable: true
    },
    {
        key: "type",
        type: "number",
        unique: false,
        nullable: false
    },
    {
        key: "initiator",
        type: "string",
        unique: false,
        nullable: false
    },
    {
        key: "state",
        type: "number",
        unique: false,
        nullable: false
    },
    {
        key: "paymentHash",
        type: "string",
        unique: false,
        nullable: true
    }
];
const compositeIndexes = [
    {
        keys: [
            "initiator",
            "id"
        ],
        unique: false
    },
    {
        keys: [
            "type",
            "state"
        ],
        unique: false
    },
    {
        keys: [
            "type",
            "paymentHash"
        ],
        unique: false
    },
    {
        keys: [
            "type",
            "initiator",
            "state"
        ],
        unique: false
    }
];
class UnifiedSwapStorage {
    init() {
        return this.storage.init(indexes, compositeIndexes);
    }
    /**
     * Params are specified in the following way:
     *  - [[condition1, condition2]] - returns all rows where condition1 AND condition2 is met
     *  - [[condition1], [condition2]] - returns all rows where condition1 OR condition2 is met
     *  - [[condition1, condition2], [condition3]] - returns all rows where (condition1 AND condition2) OR condition3 is met
     * @param params
     * @param reviver
     */ async query(params, reviver) {
        const rawSwaps = await this.storage.query(params);
        return rawSwaps.map((rawObj)=>{
            if (!this.noWeakRefMap) {
                var _this_weakRefCache_get;
                const savedRef = (_this_weakRefCache_get = this.weakRefCache.get(rawObj.id)) === null || _this_weakRefCache_get === void 0 ? void 0 : _this_weakRefCache_get.deref();
                if (savedRef != null) return savedRef;
                logger.debug("query(): Reviving new swap instance: " + rawObj.id);
            }
            const value = reviver(rawObj);
            if (!this.noWeakRefMap) this.weakRefCache.set(rawObj.id, new WeakRef(value));
            return value;
        });
    }
    save(value) {
        if (!this.noWeakRefMap) this.weakRefCache.set(value.getId(), new WeakRef(value));
        return this.storage.save(value.serialize());
    }
    saveAll(values) {
        if (!this.noWeakRefMap) values.forEach((value)=>this.weakRefCache.set(value.getId(), new WeakRef(value)));
        return this.storage.saveAll(values.map((obj)=>obj.serialize()));
    }
    remove(value) {
        if (!this.noWeakRefMap) this.weakRefCache.delete(value.getId());
        return this.storage.remove(value.serialize());
    }
    removeAll(values) {
        if (!this.noWeakRefMap) values.forEach((value)=>this.weakRefCache.delete(value.getId()));
        return this.storage.removeAll(values.map((obj)=>obj.serialize()));
    }
    constructor(storage, noWeakRefMap){
        this.weakRefCache = new Map();
        this.storage = storage;
        this.noWeakRefMap = noWeakRefMap;
    }
}
exports.UnifiedSwapStorage = UnifiedSwapStorage;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/events/UnifiedSwapEventListener.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UnifiedSwapEventListener = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
function chainEventToEscrowHash(event) {
    if (event instanceof base_1.SwapEvent) return event.escrowHash;
    if (event instanceof base_1.SpvVaultFrontEvent || event instanceof base_1.SpvVaultClaimEvent || event instanceof base_1.SpvVaultCloseEvent) return event.btcTxId;
}
class UnifiedSwapEventListener {
    async processEvents(events) {
        const swapsByEscrowHash = {};
        events.forEach((event)=>{
            swapsByEscrowHash[chainEventToEscrowHash(event)] = null;
        });
        const swaps = await this.storage.query([
            [
                {
                    key: "escrowHash",
                    value: Object.keys(swapsByEscrowHash)
                }
            ]
        ], (val)=>{
            const obj = this.listeners[val.type];
            if (obj == null) return null;
            return new obj.reviver(val);
        });
        swaps.forEach((swap)=>swapsByEscrowHash[swap._getEscrowHash()] = swap);
        for (let event of events){
            const swap = swapsByEscrowHash[chainEventToEscrowHash(event)];
            if (swap == null) continue;
            const obj = this.listeners[swap.getType()];
            if (obj == null) continue;
            await obj.listener(event, swap);
        }
    }
    async start() {
        if (this.listener != null) return;
        await this.storage.init();
        await this.events.init();
        this.events.registerListener(this.listener = async (events)=>{
            await this.processEvents(events);
            return true;
        });
    }
    stop() {
        this.events.unregisterListener(this.listener);
        return this.events.stop();
    }
    registerListener(type, listener, reviver) {
        this.listeners[type] = {
            listener,
            reviver
        };
    }
    unregisterListener(type) {
        if (this.listeners[type]) return false;
        delete this.listeners[type];
        return true;
    }
    constructor(unifiedStorage, events){
        this.listeners = {};
        this.storage = unifiedStorage;
        this.events = events;
    }
}
exports.UnifiedSwapEventListener = UnifiedSwapEventListener;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCSwap.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpvFromBTCSwap = exports.isSpvFromBTCSwapInit = exports.SpvFromBTCSwapState = void 0;
const ISwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const Fee_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js [app-client] (ecmascript)");
const IBitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/IBitcoinWallet.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const SingleAddressBitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/SingleAddressBitcoinWallet.js [app-client] (ecmascript)");
var SpvFromBTCSwapState;
(function(SpvFromBTCSwapState) {
    SpvFromBTCSwapState[SpvFromBTCSwapState["CLOSED"] = -5] = "CLOSED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["FAILED"] = -4] = "FAILED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["DECLINED"] = -3] = "DECLINED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["QUOTE_EXPIRED"] = -2] = "QUOTE_EXPIRED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["QUOTE_SOFT_EXPIRED"] = -1] = "QUOTE_SOFT_EXPIRED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["CREATED"] = 0] = "CREATED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["SIGNED"] = 1] = "SIGNED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["POSTED"] = 2] = "POSTED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["BROADCASTED"] = 3] = "BROADCASTED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["FRONTED"] = 4] = "FRONTED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["BTC_TX_CONFIRMED"] = 5] = "BTC_TX_CONFIRMED";
    SpvFromBTCSwapState[SpvFromBTCSwapState["CLAIMED"] = 6] = "CLAIMED"; //Funds claimed
})(SpvFromBTCSwapState = exports.SpvFromBTCSwapState || (exports.SpvFromBTCSwapState = {}));
function isSpvFromBTCSwapInit(obj) {
    return typeof obj === "object" && typeof obj.quoteId === "string" && typeof obj.recipient === "string" && typeof obj.vaultOwner === "string" && typeof obj.vaultId === "bigint" && typeof obj.vaultRequiredConfirmations === "number" && Array.isArray(obj.vaultTokenMultipliers) && obj.vaultTokenMultipliers.reduce((prev, curr)=>prev && typeof curr === "bigint", true) && typeof obj.vaultBtcAddress === "string" && typeof obj.vaultUtxo === "string" && typeof obj.vaultUtxoValue === "bigint" && typeof obj.btcDestinationAddress === "string" && typeof obj.btcAmount === "bigint" && typeof obj.btcAmountSwap === "bigint" && typeof obj.btcAmountGas === "bigint" && typeof obj.minimumBtcFeeRate === "number" && typeof obj.outputTotalSwap === "bigint" && typeof obj.outputSwapToken === "string" && typeof obj.outputTotalGas === "bigint" && typeof obj.outputGasToken === "string" && typeof obj.gasSwapFeeBtc === "bigint" && typeof obj.gasSwapFee === "bigint" && typeof obj.callerFeeShare === "bigint" && typeof obj.frontingFeeShare === "bigint" && typeof obj.executionFeeShare === "bigint" && (0, ISwap_1.isISwapInit)(obj);
}
exports.isSpvFromBTCSwapInit = isSpvFromBTCSwapInit;
class SpvFromBTCSwap extends ISwap_1.ISwap {
    upgradeVersion() {}
    /**
     * In case swapFee in BTC is not supplied it recalculates it based on swap price
     * @protected
     */ tryCalculateSwapFee() {
        if (this.swapFeeBtc == null) {
            this.swapFeeBtc = this.swapFee * this.btcAmountSwap / this.getOutputWithoutFee().rawAmount;
        }
        if (this.pricingInfo.swapPriceUSatPerToken == null) {
            this.pricingInfo = this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier, this.btcAmountSwap, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, this.getOutputWithoutFee().rawAmount, this.outputSwapToken);
        }
    }
    //////////////////////////////
    //// Pricing
    async refreshPriceData() {
        if (this.pricingInfo == null) return null;
        this.pricingInfo = await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier, this.btcAmountSwap, this.pricingInfo.satsBaseFee, this.pricingInfo.feePPM, this.getOutputWithoutFee().rawAmount, this.outputSwapToken);
    }
    //////////////////////////////
    //// Getters & utils
    _getInitiator() {
        return this.recipient;
    }
    _getEscrowHash() {
        var _this_data_btcTx, _this_data;
        return (_this_data = this.data) === null || _this_data === void 0 ? void 0 : (_this_data_btcTx = _this_data.btcTx) === null || _this_data_btcTx === void 0 ? void 0 : _this_data_btcTx.txid;
    }
    getId() {
        return this.quoteId + this.randomNonce;
    }
    getQuoteExpiry() {
        return this.expiry - 20 * 1000;
    }
    verifyQuoteValid() {
        return Promise.resolve(this.expiry > Date.now() && (this.state === SpvFromBTCSwapState.CREATED || this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED));
    }
    getOutputAddress() {
        return this.recipient;
    }
    getOutputTxId() {
        var _this_frontTxId;
        return (_this_frontTxId = this.frontTxId) !== null && _this_frontTxId !== void 0 ? _this_frontTxId : this.claimTxId;
    }
    getInputTxId() {
        var _this_data_btcTx, _this_data;
        return (_this_data = this.data) === null || _this_data === void 0 ? void 0 : (_this_data_btcTx = _this_data.btcTx) === null || _this_data_btcTx === void 0 ? void 0 : _this_data_btcTx.txid;
    }
    requiresAction() {
        return this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED;
    }
    isFinished() {
        return this.state === SpvFromBTCSwapState.CLAIMED || this.state === SpvFromBTCSwapState.QUOTE_EXPIRED || this.state === SpvFromBTCSwapState.FAILED;
    }
    isClaimable() {
        return this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED;
    }
    isSuccessful() {
        return this.state === SpvFromBTCSwapState.FRONTED || this.state === SpvFromBTCSwapState.CLAIMED;
    }
    isFailed() {
        return this.state === SpvFromBTCSwapState.FAILED || this.state === SpvFromBTCSwapState.DECLINED || this.state === SpvFromBTCSwapState.CLOSED;
    }
    isQuoteExpired() {
        return this.state === SpvFromBTCSwapState.QUOTE_EXPIRED;
    }
    isQuoteSoftExpired() {
        return this.state === SpvFromBTCSwapState.QUOTE_EXPIRED || this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED;
    }
    //////////////////////////////
    //// Amounts & fees
    getInputSwapAmountWithoutFee() {
        return (this.btcAmountSwap - this.swapFeeBtc) * 100000n / (100000n + this.callerFeeShare + this.frontingFeeShare + this.executionFeeShare);
    }
    getInputGasAmountWithoutFee() {
        return (this.btcAmountGas - this.gasSwapFeeBtc) * 100000n / (100000n + this.callerFeeShare + this.frontingFeeShare);
    }
    getInputAmountWithoutFee() {
        return this.getInputSwapAmountWithoutFee() + this.getInputGasAmountWithoutFee();
    }
    getOutputWithoutFee() {
        return (0, Tokens_1.toTokenAmount)(this.outputTotalSwap * (100000n + this.callerFeeShare + this.frontingFeeShare + this.executionFeeShare) / 100000n + this.swapFee, this.wrapper.tokens[this.outputSwapToken], this.wrapper.prices);
    }
    getSwapFee() {
        const outputToken = this.wrapper.tokens[this.outputSwapToken];
        const gasSwapFeeInOutputToken = this.gasSwapFeeBtc * 10n ** BigInt(outputToken.decimals) * 1000000n / this.pricingInfo.swapPriceUSatPerToken;
        const feeWithoutBaseFee = this.swapFeeBtc - this.pricingInfo.satsBaseFee;
        const swapFeePPM = feeWithoutBaseFee * 1000000n / (this.btcAmount - this.swapFeeBtc - this.gasSwapFeeBtc);
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(this.swapFeeBtc + this.gasSwapFeeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.swapFee + gasSwapFeeInOutputToken, outputToken, this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc + this.gasSwapFeeBtc, abortSignal, preFetchedUsdPrice),
            composition: {
                base: (0, Tokens_1.toTokenAmount)(this.pricingInfo.satsBaseFee, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),
                percentage: (0, ISwap_1.ppmToPercentage)(swapFeePPM)
            }
        };
    }
    getWatchtowerFee() {
        const totalFeeShare = this.callerFeeShare + this.frontingFeeShare;
        const outputToken = this.wrapper.tokens[this.outputSwapToken];
        const watchtowerFeeInOutputToken = this.getInputGasAmountWithoutFee() * totalFeeShare * 10n ** BigInt(outputToken.decimals) * 1000000n / this.pricingInfo.swapPriceUSatPerToken / 100000n;
        const feeBtc = this.getInputAmountWithoutFee() * (totalFeeShare + this.executionFeeShare) / 100000n;
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(feeBtc, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(this.outputTotalSwap * (totalFeeShare + this.executionFeeShare) / 100000n + watchtowerFeeInOutputToken, outputToken, this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(feeBtc, abortSignal, preFetchedUsdPrice)
        };
    }
    getFee() {
        const swapFee = this.getSwapFee();
        const watchtowerFee = this.getWatchtowerFee();
        return {
            amountInSrcToken: (0, Tokens_1.toTokenAmount)(swapFee.amountInSrcToken.rawAmount + watchtowerFee.amountInSrcToken.rawAmount, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices),
            amountInDstToken: (0, Tokens_1.toTokenAmount)(swapFee.amountInDstToken.rawAmount + watchtowerFee.amountInDstToken.rawAmount, this.wrapper.tokens[this.outputSwapToken], this.wrapper.prices),
            usdValue: (abortSignal, preFetchedUsdPrice)=>this.wrapper.prices.getBtcUsdValue(swapFee.amountInSrcToken.rawAmount + watchtowerFee.amountInSrcToken.rawAmount, abortSignal, preFetchedUsdPrice)
        };
    }
    getFeeBreakdown() {
        return [
            {
                type: Fee_1.FeeType.SWAP,
                fee: this.getSwapFee()
            },
            {
                type: Fee_1.FeeType.NETWORK_OUTPUT,
                fee: this.getWatchtowerFee()
            }
        ];
    }
    getOutput() {
        return (0, Tokens_1.toTokenAmount)(this.outputTotalSwap, this.wrapper.tokens[this.outputSwapToken], this.wrapper.prices);
    }
    getGasDropOutput() {
        return (0, Tokens_1.toTokenAmount)(this.outputTotalGas, this.wrapper.tokens[this.outputGasToken], this.wrapper.prices);
    }
    getInputWithoutFee() {
        return (0, Tokens_1.toTokenAmount)(this.getInputAmountWithoutFee(), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);
    }
    getInput() {
        return (0, Tokens_1.toTokenAmount)(this.btcAmount, Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);
    }
    //////////////////////////////
    //// Bitcoin tx
    getRequiredConfirmationsCount() {
        return this.vaultRequiredConfirmations;
    }
    async getTransactionDetails() {
        const [txId, voutStr] = this.vaultUtxo.split(":");
        const vaultScript = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.vaultBtcAddress);
        const out2script = (0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.btcDestinationAddress);
        const opReturnData = this.wrapper.contract.toOpReturnData(this.recipient, [
            this.outputTotalSwap / this.vaultTokenMultipliers[0],
            this.outputTotalGas / this.vaultTokenMultipliers[1]
        ]);
        const out1script = buffer_1.Buffer.concat([
            opReturnData.length > 75 ? buffer_1.Buffer.from([
                0x6a,
                0x4c,
                opReturnData.length
            ]) : buffer_1.Buffer.from([
                0x6a,
                opReturnData.length
            ]),
            opReturnData
        ]);
        if (this.callerFeeShare < 0n || this.callerFeeShare > 0xfffffn) throw new Error("Caller fee out of bounds!");
        if (this.frontingFeeShare < 0n || this.frontingFeeShare > 0xfffffn) throw new Error("Fronting fee out of bounds!");
        if (this.executionFeeShare < 0n || this.executionFeeShare > 0xfffffn) throw new Error("Execution fee out of bounds!");
        const nSequence0 = 0x80000000n | this.callerFeeShare & 0xfffffn | (this.frontingFeeShare & 1047552n) << 10n;
        const nSequence1 = 0x80000000n | this.executionFeeShare & 0xfffffn | (this.frontingFeeShare & 1023n) << 20n;
        return {
            in0txid: txId,
            in0vout: parseInt(voutStr),
            in0sequence: Number(nSequence0),
            vaultAmount: this.vaultUtxoValue,
            vaultScript,
            in1sequence: Number(nSequence1),
            out1script,
            out2amount: this.btcAmount,
            out2script,
            locktime: 500000000 + Math.floor(Math.random() * 1000000000) //Use this as a random salt to make the btc txId unique!
        };
    }
    async getPsbt() {
        const res = await this.getTransactionDetails();
        const psbt = new btc_signer_1.Transaction({
            allowUnknownOutputs: true,
            allowLegacyWitnessUtxo: true,
            lockTime: res.locktime
        });
        psbt.addInput({
            txid: res.in0txid,
            index: res.in0vout,
            witnessUtxo: {
                amount: res.vaultAmount,
                script: res.vaultScript
            },
            sequence: res.in0sequence
        });
        psbt.addOutput({
            amount: res.vaultAmount,
            script: res.vaultScript
        });
        psbt.addOutput({
            amount: 0n,
            script: res.out1script
        });
        psbt.addOutput({
            amount: res.out2amount,
            script: res.out2script
        });
        return {
            psbt,
            in1sequence: res.in1sequence
        };
    }
    async getFundedPsbt(_bitcoinWallet, feeRate) {
        let bitcoinWallet;
        if ((0, IBitcoinWallet_1.isIBitcoinWallet)(_bitcoinWallet)) {
            bitcoinWallet = _bitcoinWallet;
        } else {
            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.wrapper.btcRpc, this.wrapper.options.bitcoinNetwork, _bitcoinWallet);
        }
        if (feeRate != null) {
            if (feeRate < this.minimumBtcFeeRate) throw new Error("Bitcoin tx fee needs to be at least " + this.minimumBtcFeeRate + " sats/vB");
        } else {
            feeRate = Math.max(this.minimumBtcFeeRate, await bitcoinWallet.getFeeRate());
        }
        let { psbt, in1sequence } = await this.getPsbt();
        psbt = await bitcoinWallet.fundPsbt(psbt, feeRate);
        psbt.updateInput(1, {
            sequence: in1sequence
        });
        //Sign every input except the first one
        const signInputs = [];
        for(let i = 1; i < psbt.inputsLength; i++){
            signInputs.push(i);
        }
        return {
            psbt,
            signInputs
        };
    }
    async submitPsbt(psbt) {
        //Ensure not expired
        if (this.expiry < Date.now()) {
            throw new Error("Quote expired!");
        }
        //Ensure valid state
        if (this.state !== SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED && this.state !== SpvFromBTCSwapState.CREATED) {
            throw new Error("Invalid swap state!");
        }
        //Ensure all inputs except the 1st are finalized
        for(let i = 1; i < psbt.inputsLength; i++){
            if ((0, btc_signer_1.getInputType)(psbt.getInput(i)).txType === "legacy") throw new Error("Legacy (non-segwit) inputs are not allowed in the transaction!");
            psbt.finalizeIdx(i);
        }
        const btcTx = await this.wrapper.btcRpc.parseTransaction(buffer_1.Buffer.from(psbt.toBytes(true)).toString("hex"));
        const data = await this.wrapper.contract.getWithdrawalData(btcTx);
        this.logger.debug("submitPsbt(): parsed withdrawal data: ", data);
        var _data_rawAmounts_;
        //Verify correct withdrawal data
        if (!data.isRecipient(this.recipient) || data.rawAmounts[0] * this.vaultTokenMultipliers[0] !== this.outputTotalSwap || ((_data_rawAmounts_ = data.rawAmounts[1]) !== null && _data_rawAmounts_ !== void 0 ? _data_rawAmounts_ : 0n) * this.vaultTokenMultipliers[1] !== this.outputTotalGas || data.callerFeeRate !== this.callerFeeShare || data.frontingFeeRate !== this.frontingFeeShare || data.executionFeeRate !== this.executionFeeShare || data.getSpentVaultUtxo() !== this.vaultUtxo || BigInt(data.getNewVaultBtcAmount()) !== this.vaultUtxoValue || !data.getNewVaultScript().equals((0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.vaultBtcAddress)) || data.getExecutionData() != null) {
            throw new Error("Invalid withdrawal tx data submitted!");
        }
        //Verify correct LP output
        const lpOutput = psbt.getOutput(2);
        if (lpOutput.amount !== this.btcAmount || !(0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.btcDestinationAddress).equals(buffer_1.Buffer.from(lpOutput.script))) {
            throw new Error("Invalid LP bitcoin output in transaction!");
        }
        //Verify vault utxo not spent yet
        if (await this.wrapper.btcRpc.isSpent(this.vaultUtxo)) {
            throw new Error("Vault UTXO already spent, please create new swap!");
        }
        //Verify tx is parsable by the contract
        try {
            await this.wrapper.contract.checkWithdrawalTx(data);
        } catch (e) {
            var _e_message;
            throw new Error("Transaction not parsable by the contract: " + ((_e_message = e.message) !== null && _e_message !== void 0 ? _e_message : e.toString()));
        }
        //Ensure still not expired
        if (this.expiry < Date.now()) {
            throw new Error("Quote expired!");
        }
        this.data = data;
        this.initiated = true;
        await this._saveAndEmit(SpvFromBTCSwapState.SIGNED);
        try {
            await IntermediaryAPI_1.IntermediaryAPI.initSpvFromBTC(this.chainIdentifier, this.url, {
                quoteId: this.quoteId,
                psbtHex: buffer_1.Buffer.from(psbt.toPSBT(0)).toString("hex")
            });
            await this._saveAndEmit(SpvFromBTCSwapState.POSTED);
        } catch (e) {
            await this._saveAndEmit(SpvFromBTCSwapState.DECLINED);
            throw e;
        }
        return this.data.getTxId();
    }
    async estimateBitcoinFee(wallet, feeRate) {
        const txFee = await wallet.getFundedPsbtFee((await this.getPsbt()).psbt, feeRate);
        return (0, Tokens_1.toTokenAmount)(txFee == null ? null : BigInt(txFee), Tokens_1.BitcoinTokens.BTC, this.wrapper.prices);
    }
    async sendBitcoinTransaction(wallet, feeRate) {
        let { psbt, signInputs } = await this.getFundedPsbt(wallet, feeRate);
        psbt = await wallet.signPsbt(psbt, signInputs);
        return await this.submitPsbt(psbt);
    }
    //////////////////////////////
    //// Bitcoin tx listener
    /**
     * Checks whether a bitcoin payment was already made, returns the payment or null when no payment has been made.
     */ async getBitcoinPayment() {
        var _this_data_btcTx, _this_data, _this_data_btcTx1, _this_data1;
        if (((_this_data = this.data) === null || _this_data === void 0 ? void 0 : (_this_data_btcTx = _this_data.btcTx) === null || _this_data_btcTx === void 0 ? void 0 : _this_data_btcTx.txid) == null) return null;
        const result = await this.wrapper.btcRpc.getTransaction((_this_data1 = this.data) === null || _this_data1 === void 0 ? void 0 : (_this_data_btcTx1 = _this_data1.btcTx) === null || _this_data_btcTx1 === void 0 ? void 0 : _this_data_btcTx1.txid);
        if (result == null) return null;
        return {
            txId: result.txid,
            confirmations: result.confirmations,
            targetConfirmations: this.vaultRequiredConfirmations
        };
    }
    /**
     * Waits till the bitcoin transaction confirms and swap becomes claimable
     *
     * @param abortSignal Abort signal
     * @param checkIntervalSeconds How often to check the bitcoin transaction
     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations
     * @throws {Error} if in invalid state (must be CLAIM_COMMITED)
     */ async waitForBitcoinTransaction(abortSignal, checkIntervalSeconds, updateCallback) {
        if (this.state !== SpvFromBTCSwapState.POSTED && this.state !== SpvFromBTCSwapState.BROADCASTED && !(this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED && this.initiated)) throw new Error("Must be in POSTED or BROADCASTED state!");
        const result = await this.wrapper.btcRpc.waitForTransaction(this.data.btcTx.txid, this.vaultRequiredConfirmations, (confirmations, txId, txEtaMs)=>{
            if (updateCallback != null) updateCallback(txId, confirmations, this.vaultRequiredConfirmations, txEtaMs);
            if (txId != null && (this.state === SpvFromBTCSwapState.POSTED || this.state == SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED)) this._saveAndEmit(SpvFromBTCSwapState.BROADCASTED);
        }, abortSignal, checkIntervalSeconds);
        if (abortSignal != null) abortSignal.throwIfAborted();
        if (this.state !== SpvFromBTCSwapState.FRONTED && this.state !== SpvFromBTCSwapState.CLAIMED) {
            await this._saveAndEmit(SpvFromBTCSwapState.BTC_TX_CONFIRMED);
        }
        return result.txid;
    }
    //////////////////////////////
    //// Claim
    /**
     * Returns transactions required to claim the swap on-chain (and possibly also sync the bitcoin light client)
     *  after a bitcoin transaction was sent and confirmed
     *
     * @throws {Error} If the swap is in invalid state (must be BTC_TX_CONFIRMED)
     */ async txsClaim(signer) {
        if (!this.isClaimable()) throw new Error("Must be in BTC_TX_CONFIRMED state!");
        const vaultData = await this.wrapper.contract.getVaultData(this.vaultOwner, this.vaultId);
        const txs = [
            await this.wrapper.btcRpc.getTransaction(this.data.btcTx.txid)
        ];
        //Trace back from current tx to the vaultData-specified UTXO
        const vaultUtxo = vaultData.getUtxo();
        while(txs[0].ins[0].txid + ":" + txs[0].ins[0].vout !== vaultUtxo){
            txs.unshift(await this.wrapper.btcRpc.getTransaction(txs[0].ins[0].txid));
        }
        //Parse transactions to withdrawal data
        const withdrawalData = [];
        for (let tx of txs){
            withdrawalData.push(await this.wrapper.contract.getWithdrawalData(tx));
        }
        return await this.wrapper.contract.txsClaim(signer == null ? this._getInitiator() : signer.getAddress(), vaultData, withdrawalData.map((tx)=>{
            return {
                tx
            };
        }), this.wrapper.synchronizer, true);
    }
    /**
     * Claims and finishes the swap
     *
     * @param signer Signer to sign the transactions with, can also be different to the initializer
     * @param abortSignal Abort signal to stop waiting for transaction confirmation
     */ async claim(signer, abortSignal) {
        let txIds;
        try {
            txIds = await this.wrapper.chain.sendAndConfirm(signer, await this.txsClaim(signer), true, abortSignal);
        } catch (e) {
            this.logger.info("claim(): Failed to claim ourselves, checking swap claim state...");
            if (this.state === SpvFromBTCSwapState.CLAIMED) {
                this.logger.info("claim(): Transaction state is CLAIMED, swap was successfully claimed by the watchtower");
                return this.claimTxId;
            }
            const withdrawalState = await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);
            if (withdrawalState.type === base_1.SpvWithdrawalStateType.CLAIMED) {
                this.logger.info("claim(): Transaction status is CLAIMED, swap was successfully claimed by the watchtower");
                this.claimTxId = withdrawalState.txId;
                await this._saveAndEmit(SpvFromBTCSwapState.CLAIMED);
                return null;
            }
            throw e;
        }
        this.claimTxId = txIds[0];
        if (this.state === SpvFromBTCSwapState.POSTED || this.state === SpvFromBTCSwapState.BROADCASTED || this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED || this.state === SpvFromBTCSwapState.FAILED || this.state === SpvFromBTCSwapState.FRONTED) {
            await this._saveAndEmit(SpvFromBTCSwapState.CLAIMED);
        }
        return txIds[0];
    }
    /**
     * Periodically checks the chain to see whether the swap was finished (claimed or refunded)
     *
     * @param abortSignal
     * @param interval How often to check (in seconds), default to 5s
     * @protected
     */ async watchdogWaitTillResult(abortSignal) {
        let interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
        let status = {
            type: base_1.SpvWithdrawalStateType.NOT_FOUND
        };
        while(status.type === base_1.SpvWithdrawalStateType.NOT_FOUND){
            await (0, Utils_1.timeoutPromise)(interval * 1000, abortSignal);
            try {
                status = await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);
            } catch (e) {
                this.logger.error("watchdogWaitTillResult(): Error when fetching commit status: ", e);
            }
        }
        if (abortSignal != null) abortSignal.throwIfAborted();
        return status;
    }
    /**
     * Waits till the swap is successfully executed
     *
     * @param abortSignal AbortSignal
     * @throws {Error} If swap is in invalid state (must be BTC_TX_CONFIRMED)
     * @throws {Error} If the LP refunded sooner than we were able to claim
     */ async waitTillClaimedOrFronted(abortSignal) {
        if (this.state === SpvFromBTCSwapState.CLAIMED || this.state === SpvFromBTCSwapState.FRONTED) return Promise.resolve();
        const abortController = new AbortController();
        if (abortSignal != null) abortSignal.addEventListener("abort", ()=>abortController.abort(abortSignal.reason));
        const res = await Promise.race([
            this.watchdogWaitTillResult(abortController.signal),
            this.waitTillState(SpvFromBTCSwapState.CLAIMED, "eq", abortController.signal).then(()=>0),
            this.waitTillState(SpvFromBTCSwapState.FRONTED, "eq", abortController.signal).then(()=>1),
            this.waitTillState(SpvFromBTCSwapState.FAILED, "eq", abortController.signal).then(()=>2)
        ]);
        abortController.abort();
        if (typeof res === "number") {
            if (res === 0) {
                this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (CLAIMED)");
                return;
            }
            if (res === 1) {
                this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (FRONTED)");
                return;
            }
            if (res === 2) {
                this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (FAILED)");
                throw new Error("Swap failed while waiting for claim or front");
            }
            return;
        }
        this.logger.debug("waitTillClaimedOrFronted(): Resolved from watchdog");
        if (res.type === base_1.SpvWithdrawalStateType.FRONTED) {
            if (this.state !== SpvFromBTCSwapState.FRONTED || this.state !== SpvFromBTCSwapState.CLAIMED) {
                this.frontTxId = res.txId;
                await this._saveAndEmit(SpvFromBTCSwapState.FRONTED);
            }
        }
        if (res.type === base_1.SpvWithdrawalStateType.CLAIMED) {
            if (this.state !== SpvFromBTCSwapState.CLAIMED) {
                this.claimTxId = res.txId;
                await this._saveAndEmit(SpvFromBTCSwapState.FRONTED);
            }
        }
        if (res.type === base_1.SpvWithdrawalStateType.CLOSED) {
            if (this.state !== SpvFromBTCSwapState.CLOSED) await this._saveAndEmit(SpvFromBTCSwapState.CLOSED);
        }
    }
    /**
     * Waits till the bitcoin transaction confirms and swap is claimed
     *
     * @param abortSignal Abort signal
     * @param checkIntervalSeconds How often to check the bitcoin transaction
     * @param updateCallback Callback called when txId is found, and also called with subsequent confirmations
     * @throws {Error} if in invalid state (must be CLAIM_COMMITED)
     */ async waitTillExecuted(abortSignal, checkIntervalSeconds, updateCallback) {
        await this.waitForBitcoinTransaction(abortSignal, checkIntervalSeconds, updateCallback);
        await this.waitTillClaimedOrFronted(abortSignal);
    }
    //////////////////////////////
    //// Storage
    serialize() {
        var _this_data;
        return {
            ...super.serialize(),
            quoteId: this.quoteId,
            recipient: this.recipient,
            vaultOwner: this.vaultOwner,
            vaultId: this.vaultId.toString(10),
            vaultRequiredConfirmations: this.vaultRequiredConfirmations,
            vaultTokenMultipliers: this.vaultTokenMultipliers.map((val)=>val.toString(10)),
            vaultBtcAddress: this.vaultBtcAddress,
            vaultUtxo: this.vaultUtxo,
            vaultUtxoValue: this.vaultUtxoValue.toString(10),
            btcDestinationAddress: this.btcDestinationAddress,
            btcAmount: this.btcAmount.toString(10),
            btcAmountSwap: this.btcAmountSwap.toString(10),
            btcAmountGas: this.btcAmountGas.toString(10),
            minimumBtcFeeRate: this.minimumBtcFeeRate,
            outputTotalSwap: this.outputTotalSwap.toString(10),
            outputSwapToken: this.outputSwapToken,
            outputTotalGas: this.outputTotalGas.toString(10),
            outputGasToken: this.outputGasToken,
            gasSwapFeeBtc: this.gasSwapFeeBtc.toString(10),
            gasSwapFee: this.gasSwapFee.toString(10),
            callerFeeShare: this.callerFeeShare.toString(10),
            frontingFeeShare: this.frontingFeeShare.toString(10),
            executionFeeShare: this.executionFeeShare.toString(10),
            claimTxId: this.claimTxId,
            frontTxId: this.frontTxId,
            data: (_this_data = this.data) === null || _this_data === void 0 ? void 0 : _this_data.serialize()
        };
    }
    //////////////////////////////
    //// Swap ticks & sync
    async syncStateFromBitcoin(save) {
        var _this_data;
        if (((_this_data = this.data) === null || _this_data === void 0 ? void 0 : _this_data.btcTx) == null) return false;
        //Check if bitcoin payment was confirmed
        const res = await this.getBitcoinPayment();
        if (res == null) {
            //Check inputs double-spent
            for (let input of this.data.btcTx.ins){
                if (await this.wrapper.btcRpc.isSpent(input.txid + ":" + input.vout, true)) {
                    if (this.state === SpvFromBTCSwapState.SIGNED || this.state === SpvFromBTCSwapState.POSTED || this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === SpvFromBTCSwapState.DECLINED) {
                        //One of the inputs was double-spent
                        this.state = SpvFromBTCSwapState.QUOTE_EXPIRED;
                    } else {
                        //One of the inputs was double-spent
                        this.state = SpvFromBTCSwapState.FAILED;
                    }
                    if (save) await this._saveAndEmit();
                    return true;
                }
            }
        } else {
            if (res.confirmations >= this.vaultRequiredConfirmations) {
                if (this.state !== SpvFromBTCSwapState.FRONTED && this.state !== SpvFromBTCSwapState.CLAIMED) {
                    this.state = SpvFromBTCSwapState.BTC_TX_CONFIRMED;
                    if (save) await this._saveAndEmit();
                    return true;
                }
            } else if (this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === SpvFromBTCSwapState.POSTED || this.state === SpvFromBTCSwapState.SIGNED || this.state === SpvFromBTCSwapState.DECLINED) {
                this.state = SpvFromBTCSwapState.BROADCASTED;
                if (save) await this._saveAndEmit();
                return true;
            }
        }
        return false;
    }
    /**
     * Checks the swap's state on-chain and compares it to its internal state, updates/changes it according to on-chain
     *  data
     *
     * @private
     */ async syncStateFromChain() {
        let changed = false;
        if (this.state === SpvFromBTCSwapState.SIGNED || this.state === SpvFromBTCSwapState.POSTED || this.state === SpvFromBTCSwapState.BROADCASTED || this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || this.state === SpvFromBTCSwapState.DECLINED) {
            //Check BTC transaction
            if (await this.syncStateFromBitcoin(false)) changed || (changed = true);
        }
        if (this.state === SpvFromBTCSwapState.BROADCASTED || this.state === SpvFromBTCSwapState.BTC_TX_CONFIRMED) {
            const status = await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);
            this.logger.debug("syncStateFromChain(): status of " + this.data.btcTx.txid, status);
            switch(status.type){
                case base_1.SpvWithdrawalStateType.FRONTED:
                    this.frontTxId = status.txId;
                    this.state = SpvFromBTCSwapState.FRONTED;
                    changed || (changed = true);
                    break;
                case base_1.SpvWithdrawalStateType.CLAIMED:
                    this.claimTxId = status.txId;
                    this.state = SpvFromBTCSwapState.CLAIMED;
                    changed || (changed = true);
                    break;
                case base_1.SpvWithdrawalStateType.CLOSED:
                    this.state = SpvFromBTCSwapState.CLOSED;
                    changed || (changed = true);
                    break;
            }
        }
        if (this.state === SpvFromBTCSwapState.CREATED || this.state === SpvFromBTCSwapState.SIGNED || this.state === SpvFromBTCSwapState.POSTED) {
            if (this.expiry < Date.now()) {
                if (this.state === SpvFromBTCSwapState.CREATED) {
                    this.state = SpvFromBTCSwapState.QUOTE_EXPIRED;
                } else {
                    this.state = SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED;
                }
                changed || (changed = true);
            }
        }
        return changed;
    }
    async _sync(save) {
        const changed = await this.syncStateFromChain();
        if (changed && save) await this._saveAndEmit();
        return changed;
    }
    async _tick(save) {
        if (this.state === SpvFromBTCSwapState.CREATED || this.state === SpvFromBTCSwapState.SIGNED) {
            if (this.getQuoteExpiry() < Date.now()) {
                this.state = SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED;
                if (save) await this._saveAndEmit();
                return true;
            }
        }
        if (this.state === SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED && !this.initiated) {
            if (this.expiry < Date.now()) {
                this.state = SpvFromBTCSwapState.QUOTE_EXPIRED;
                if (save) await this._saveAndEmit();
                return true;
            }
        }
        if (Math.floor(Date.now() / 1000) % 120 === 0) {
            if (this.state === SpvFromBTCSwapState.POSTED || this.state === SpvFromBTCSwapState.BROADCASTED) {
                try {
                    //Check if bitcoin payment was confirmed
                    return await this.syncStateFromBitcoin(save);
                } catch (e) {
                    this.logger.error("tickSwap(" + this.getId() + "): ", e);
                }
            }
        }
    }
    constructor(wrapper, initOrObject){
        if (isSpvFromBTCSwapInit(initOrObject)) initOrObject.url += "/frombtc_spv";
        super(wrapper, initOrObject);
        this.TYPE = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;
        if (isSpvFromBTCSwapInit(initOrObject)) {
            this.state = SpvFromBTCSwapState.CREATED;
            const vaultAddressType = (0, Utils_1.toCoinselectAddressType)((0, Utils_1.toOutputScript)(this.wrapper.options.bitcoinNetwork, this.vaultBtcAddress));
            if (vaultAddressType !== "p2tr" && vaultAddressType !== "p2wpkh" && vaultAddressType !== "p2wsh") throw new Error("Vault address type must be of witness type: p2tr, p2wpkh, p2wsh");
        } else {
            this.quoteId = initOrObject.quoteId;
            this.recipient = initOrObject.recipient;
            this.vaultOwner = initOrObject.vaultOwner;
            this.vaultId = BigInt(initOrObject.vaultId);
            this.vaultRequiredConfirmations = initOrObject.vaultRequiredConfirmations;
            this.vaultTokenMultipliers = initOrObject.vaultTokenMultipliers.map((val)=>BigInt(val));
            this.vaultBtcAddress = initOrObject.vaultBtcAddress;
            this.vaultUtxo = initOrObject.vaultUtxo;
            this.vaultUtxoValue = BigInt(initOrObject.vaultUtxoValue);
            this.btcDestinationAddress = initOrObject.btcDestinationAddress;
            this.btcAmount = BigInt(initOrObject.btcAmount);
            this.btcAmountSwap = BigInt(initOrObject.btcAmountSwap);
            this.btcAmountGas = BigInt(initOrObject.btcAmountGas);
            this.minimumBtcFeeRate = initOrObject.minimumBtcFeeRate;
            this.outputTotalSwap = BigInt(initOrObject.outputTotalSwap);
            this.outputSwapToken = initOrObject.outputSwapToken;
            this.outputTotalGas = BigInt(initOrObject.outputTotalGas);
            this.outputGasToken = initOrObject.outputGasToken;
            this.gasSwapFeeBtc = BigInt(initOrObject.gasSwapFeeBtc);
            this.gasSwapFee = BigInt(initOrObject.gasSwapFee);
            this.callerFeeShare = BigInt(initOrObject.callerFeeShare);
            this.frontingFeeShare = BigInt(initOrObject.frontingFeeShare);
            this.executionFeeShare = BigInt(initOrObject.executionFeeShare);
            this.claimTxId = initOrObject.claimTxId;
            this.frontTxId = initOrObject.frontTxId;
            this.data = initOrObject.data == null ? null : new this.wrapper.spvWithdrawalDataDeserializer(initOrObject.data);
        }
        this.tryCalculateSwapFee();
        this.logger = (0, Utils_1.getLogger)("SPVFromBTC(" + this.getId() + "): ");
    }
}
exports.SpvFromBTCSwap = SpvFromBTCSwap;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCWrapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpvFromBTCWrapper = void 0;
const ISwapWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwapWrapper.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const SpvFromBTCSwap_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCSwap.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const IntermediaryAPI_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryAPI.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
class SpvFromBTCWrapper extends ISwapWrapper_1.ISwapWrapper {
    processEventFront(event, swap) {
        if (swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED) {
            swap.state = SpvFromBTCSwap_1.SpvFromBTCSwapState.FRONTED;
            return true;
        }
        return false;
    }
    processEventClaim(event, swap) {
        if (swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED) {
            swap.state = SpvFromBTCSwap_1.SpvFromBTCSwapState.CLAIMED;
            return true;
        }
        return false;
    }
    processEventClose(event, swap) {
        if (swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED || swap.state === SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED) {
            swap.state = SpvFromBTCSwap_1.SpvFromBTCSwapState.CLOSED;
            return true;
        }
        return false;
    }
    async processEvent(event, swap) {
        if (swap == null) return;
        let swapChanged = false;
        if (event instanceof base_1.SpvVaultFrontEvent) {
            var _event_meta;
            swapChanged = this.processEventFront(event, swap);
            if (((_event_meta = event.meta) === null || _event_meta === void 0 ? void 0 : _event_meta.txId) != null && swap.frontTxId !== event.meta.txId) {
                swap.frontTxId = event.meta.txId;
                swapChanged || (swapChanged = true);
            }
        }
        if (event instanceof base_1.SpvVaultClaimEvent) {
            var _event_meta1;
            swapChanged = this.processEventClaim(event, swap);
            if (((_event_meta1 = event.meta) === null || _event_meta1 === void 0 ? void 0 : _event_meta1.txId) != null && swap.claimTxId !== event.meta.txId) {
                swap.claimTxId = event.meta.txId;
                swapChanged || (swapChanged = true);
            }
        }
        if (event instanceof base_1.SpvVaultCloseEvent) {
            swapChanged = this.processEventClose(event, swap);
        }
        this.logger.info("processEvents(): " + event.constructor.name + " processed for " + swap.getId() + " swap: ", swap);
        if (swapChanged) {
            await swap._saveAndEmit();
        }
        return true;
    }
    /**
     * Pre-fetches caller (watchtower) bounty data for the swap. Doesn't throw, instead returns null and aborts the
     *  provided abortController
     *
     * @param signer Smartchain signer address initiating the swap
     * @param amountData
     * @param options Options as passed to the swap creation function
     * @param pricePrefetch
     * @param nativeTokenPricePrefetch
     * @param abortController
     * @private
     */ async preFetchCallerFeeShare(signer, amountData, options, pricePrefetch, nativeTokenPricePrefetch, abortController) {
        if (options.unsafeZeroWatchtowerFee) return 0n;
        if (amountData.amount === 0n) return 0n;
        try {
            const [feePerBlock, btcRelayData, currentBtcBlock, claimFeeRate, nativeTokenPrice] = await Promise.all([
                (0, Utils_1.tryWithRetries)(()=>this.btcRelay.getFeePerBlock(), null, null, abortController.signal),
                (0, Utils_1.tryWithRetries)(()=>this.btcRelay.getTipData(), null, null, abortController.signal),
                this.btcRpc.getTipHeight(),
                (0, Utils_1.tryWithRetries)(()=>this.contract.getClaimFee(this.chain.randomAddress(), null, null), null, null, abortController.signal),
                nativeTokenPricePrefetch !== null && nativeTokenPricePrefetch !== void 0 ? nativeTokenPricePrefetch : amountData.token === this.chain.getNativeCurrencyAddress() ? pricePrefetch : this.prices.preFetchPrice(this.chainIdentifier, this.chain.getNativeCurrencyAddress(), abortController.signal)
            ]);
            const currentBtcRelayBlock = btcRelayData.blockheight;
            const blockDelta = Math.max(currentBtcBlock - currentBtcRelayBlock + this.options.maxConfirmations, 0);
            const totalFeeInNativeToken = (BigInt(blockDelta) * feePerBlock + claimFeeRate * BigInt(this.options.maxTransactionsDelta)) * BigInt(Math.floor(options.feeSafetyFactor * 1000000)) / 1000000n;
            let payoutAmount;
            if (amountData.exactIn) {
                //Convert input amount in BTC to
                const amountInNativeToken = await this.prices.getFromBtcSwapAmount(this.chainIdentifier, amountData.amount, this.chain.getNativeCurrencyAddress(), abortController.signal, nativeTokenPrice);
                payoutAmount = amountInNativeToken - totalFeeInNativeToken;
            } else {
                if (amountData.token === this.chain.getNativeCurrencyAddress()) {
                    //Both amounts in same currency
                    payoutAmount = amountData.amount;
                } else {
                    //Need to convert both to native currency
                    const btcAmount = await this.prices.getToBtcSwapAmount(this.chainIdentifier, amountData.amount, amountData.token, abortController.signal, await pricePrefetch);
                    payoutAmount = await this.prices.getFromBtcSwapAmount(this.chainIdentifier, btcAmount, this.chain.getNativeCurrencyAddress(), abortController.signal, nativeTokenPrice);
                }
            }
            this.logger.debug("preFetchCallerFeeShare(): Caller fee in native token: " + totalFeeInNativeToken.toString(10) + " total payout in native token: " + payoutAmount.toString(10));
            const callerFeeShare = (totalFeeInNativeToken * 100000n + payoutAmount - 1n) / payoutAmount; //Make sure to round up here
            if (callerFeeShare < 0n) return 0n;
            if (callerFeeShare >= 2n ** 20n) return 2n ** 20n - 1n;
            return callerFeeShare;
        } catch (e) {
            abortController.abort(e);
            return null;
        }
    }
    /**
     * Verifies response returned from intermediary
     *
     * @param resp Response as returned by the intermediary
     * @param amountData
     * @param lp Intermediary
     * @param options Options as passed to the swap creation function
     * @param callerFeeShare
     * @param bitcoinFeeRatePromise Maximum accepted fee rate from the LPs
     * @private
     * @throws {IntermediaryError} in case the response is invalid
     */ async verifyReturnedData(resp, amountData, lp, options, callerFeeShare, bitcoinFeeRatePromise) {
        if (resp.btcFeeRate > await bitcoinFeeRatePromise) throw new IntermediaryError_1.IntermediaryError("Bitcoin fee rate returned too high!");
        //Vault related
        let vaultScript;
        let vaultAddressType;
        let btcAddressScript;
        //Ensure valid btc addresses returned
        try {
            vaultScript = (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, resp.vaultBtcAddress);
            vaultAddressType = (0, Utils_1.toCoinselectAddressType)(vaultScript);
            btcAddressScript = (0, Utils_1.toOutputScript)(this.options.bitcoinNetwork, resp.btcAddress);
        } catch (e) {
            throw new IntermediaryError_1.IntermediaryError("Invalid btc address data returned!");
        }
        const decodedUtxo = resp.btcUtxo.split(":");
        if (resp.address !== lp.getAddress(this.chainIdentifier) || //Ensure the LP is indeed the vault owner
        resp.vaultId < 0n || //Ensure vaultId is not negative
        vaultScript == null || //Make sure vault script is parsable and of known type
        btcAddressScript == null || //Make sure btc address script is parsable and of known type
        vaultAddressType === "p2pkh" || vaultAddressType === "p2sh-p2wpkh" || //Constrain the vault script type to witness types
        decodedUtxo.length !== 2 || decodedUtxo[0].length !== 64 || isNaN(parseInt(decodedUtxo[1])) || //Check valid UTXO
        resp.btcFeeRate < 1 || resp.btcFeeRate > 10000 //Sanity check on the returned BTC fee rate
        ) throw new IntermediaryError_1.IntermediaryError("Invalid vault data returned!");
        //Amounts sanity
        if (resp.btcAmountSwap + resp.btcAmountGas !== resp.btcAmount) throw new Error("Btc amount mismatch");
        if (resp.swapFeeBtc + resp.gasSwapFeeBtc !== resp.totalFeeBtc) throw new Error("Btc fee mismatch");
        //TODO: For now ensure fees are at 0
        if (resp.callerFeeShare !== callerFeeShare || resp.frontingFeeShare !== 0n || resp.executionFeeShare !== 0n) throw new IntermediaryError_1.IntermediaryError("Invalid caller/fronting/execution fee returned");
        //Check expiry
        if (resp.expiry < Math.floor(Date.now() / 1000)) throw new IntermediaryError_1.IntermediaryError("Quote already expired");
        //Fetch vault data
        let vault;
        try {
            vault = await this.contract.getVaultData(resp.address, resp.vaultId);
        } catch (e) {
            this.logger.error("Error getting spv vault (owner: " + resp.address + " vaultId: " + resp.vaultId.toString(10) + "): ", e);
            throw new IntermediaryError_1.IntermediaryError("Spv swap vault not found!");
        }
        //Make sure vault is opened
        if (!vault.isOpened()) throw new IntermediaryError_1.IntermediaryError("Returned spv swap vault is not opened!");
        //Make sure the vault doesn't require insane amount of confirmations
        if (vault.getConfirmations() > this.options.maxConfirmations) throw new IntermediaryError_1.IntermediaryError("SPV swap vault needs too many confirmations: " + vault.getConfirmations());
        const tokenData = vault.getTokenData();
        //Amounts - make sure the amounts match
        if (amountData.exactIn) {
            if (resp.btcAmount !== amountData.amount) throw new IntermediaryError_1.IntermediaryError("Invalid amount returned");
        } else {
            //Check the difference between amount adjusted due to scaling to raw amount
            const adjustedAmount = amountData.amount / tokenData[0].multiplier * tokenData[0].multiplier;
            const adjustmentPPM = (amountData.amount - adjustedAmount) * 1000000n / amountData.amount;
            if (adjustmentPPM > this.options.maxRawAmountAdjustmentDifferencePPM) throw new IntermediaryError_1.IntermediaryError("Invalid amount0 multiplier used, rawAmount diff too high");
            if (resp.total !== adjustedAmount) throw new IntermediaryError_1.IntermediaryError("Invalid total returned");
        }
        if (options.gasAmount == null || options.gasAmount === 0n) {
            if (resp.totalGas !== 0n) throw new IntermediaryError_1.IntermediaryError("Invalid gas total returned");
        } else {
            //Check the difference between amount adjusted due to scaling to raw amount
            const adjustedGasAmount = options.gasAmount / tokenData[0].multiplier * tokenData[0].multiplier;
            const adjustmentPPM = (options.gasAmount - adjustedGasAmount) * 1000000n / options.gasAmount;
            if (adjustmentPPM > this.options.maxRawAmountAdjustmentDifferencePPM) throw new IntermediaryError_1.IntermediaryError("Invalid amount1 multiplier used, rawAmount diff too high");
            if (resp.totalGas !== adjustedGasAmount) throw new IntermediaryError_1.IntermediaryError("Invalid gas total returned");
        }
        //Require the vault UTXO to have at least 1 confirmation
        let utxo = resp.btcUtxo.toLowerCase();
        const [txId, voutStr] = utxo.split(":");
        let btcTx = await this.btcRpc.getTransaction(txId);
        if (btcTx.confirmations == null || btcTx.confirmations < 1) throw new IntermediaryError_1.IntermediaryError("SPV vault UTXO not confirmed");
        const vout = parseInt(voutStr);
        if (btcTx.outs[vout] == null) throw new IntermediaryError_1.IntermediaryError("Invalid UTXO, doesn't exist");
        const vaultUtxoValue = btcTx.outs[vout].value;
        //Require vault UTXO is unspent
        if (await this.btcRpc.isSpent(utxo)) throw new IntermediaryError_1.IntermediaryError("Returned spv vault UTXO is already spent");
        this.logger.debug("verifyReturnedData(): Vault UTXO: " + vault.getUtxo() + " current utxo: " + utxo);
        //Trace returned utxo back to what's saved on-chain
        let pendingWithdrawals = [];
        while(vault.getUtxo() !== utxo){
            const [txId, voutStr] = utxo.split(":");
            //Such that 1st tx isn't fetched twice
            if (btcTx.txid !== txId) btcTx = await this.btcRpc.getTransaction(txId);
            const withdrawalData = await this.contract.getWithdrawalData(btcTx);
            pendingWithdrawals.unshift(withdrawalData);
            utxo = pendingWithdrawals[0].getSpentVaultUtxo();
            this.logger.debug("verifyReturnedData(): Vault UTXO: " + vault.getUtxo() + " current utxo: " + utxo);
            if (pendingWithdrawals.length >= this.options.maxTransactionsDelta) throw new IntermediaryError_1.IntermediaryError("BTC <> SC state difference too deep, maximum: " + this.options.maxTransactionsDelta);
        }
        //Verify that the vault has enough balance after processing all pending withdrawals
        let vaultBalances;
        try {
            vaultBalances = vault.calculateStateAfter(pendingWithdrawals);
        } catch (e) {
            this.logger.error("Error calculating spv vault balance (owner: " + resp.address + " vaultId: " + resp.vaultId.toString(10) + "): ", e);
            throw new IntermediaryError_1.IntermediaryError("Spv swap vault balance prediction failed!");
        }
        if (vaultBalances.balances[0].scaledAmount < resp.total) throw new IntermediaryError_1.IntermediaryError("SPV swap vault, insufficient balance, required: " + resp.total.toString(10) + " has: " + vaultBalances.balances[0].scaledAmount.toString(10));
        if (vaultBalances.balances[1].scaledAmount < resp.totalGas) throw new IntermediaryError_1.IntermediaryError("SPV swap vault, insufficient balance, required: " + resp.totalGas.toString(10) + " has: " + vaultBalances.balances[1].scaledAmount.toString(10));
        //Also verify that all the withdrawal txns are valid, this is an extra sanity check
        try {
            for (let withdrawal of pendingWithdrawals){
                await this.contract.checkWithdrawalTx(withdrawal);
            }
        } catch (e) {
            this.logger.error("Error calculating spv vault balance (owner: " + resp.address + " vaultId: " + resp.vaultId.toString(10) + "): ", e);
            throw new IntermediaryError_1.IntermediaryError("Spv swap vault balance prediction failed!");
        }
        return {
            vault,
            vaultUtxoValue
        };
    }
    /**
     * Returns a newly created swap, receiving 'amount' on chain
     *
     * @param signer                Smartchain signer's address intiating the swap
     * @param amountData            Amount of token & amount to swap
     * @param lps                   LPs (liquidity providers) to get the quotes from
     * @param options               Quote options
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param abortSignal           Abort signal for aborting the process
     */ create(signer, amountData, lps, options, additionalParams, abortSignal) {
        var _options, _options1;
        options !== null && options !== void 0 ? options : options = {};
        var _gasAmount;
        (_gasAmount = (_options = options).gasAmount) !== null && _gasAmount !== void 0 ? _gasAmount : _options.gasAmount = 0n;
        var _feeSafetyFactor;
        (_feeSafetyFactor = (_options1 = options).feeSafetyFactor) !== null && _feeSafetyFactor !== void 0 ? _feeSafetyFactor : _options1.feeSafetyFactor = 1.25;
        const _abortController = (0, Utils_1.extendAbortController)(abortSignal);
        const pricePrefetchPromise = this.preFetchPrice(amountData, _abortController.signal);
        const nativeTokenAddress = this.chain.getNativeCurrencyAddress();
        const gasTokenPricePrefetchPromise = options.gasAmount === 0n ? null : this.preFetchPrice({
            token: nativeTokenAddress
        }, _abortController.signal);
        const callerFeePrefetchPromise = this.preFetchCallerFeeShare(signer, amountData, options, pricePrefetchPromise, gasTokenPricePrefetchPromise, _abortController);
        const bitcoinFeeRatePromise = options.maxAllowedNetworkFeeRate != null ? Promise.resolve(options.maxAllowedNetworkFeeRate) : this.btcRpc.getFeeRate().then((x)=>this.options.maxBtcFeeOffset + x * this.options.maxBtcFeeMultiplier).catch((e)=>{
            _abortController.abort(e);
            return null;
        });
        return lps.map((lp)=>{
            return {
                intermediary: lp,
                quote: (async ()=>{
                    const abortController = (0, Utils_1.extendAbortController)(_abortController.signal);
                    try {
                        const resp = await (0, Utils_1.tryWithRetries)(async (retryCount)=>{
                            return await IntermediaryAPI_1.IntermediaryAPI.prepareSpvFromBTC(this.chainIdentifier, lp.url, {
                                address: signer,
                                amount: amountData.amount,
                                token: amountData.token.toString(),
                                exactOut: !amountData.exactIn,
                                gasToken: nativeTokenAddress,
                                gasAmount: options.gasAmount,
                                callerFeeRate: callerFeePrefetchPromise,
                                frontingFeeRate: 0n,
                                additionalParams
                            }, this.options.postRequestTimeout, abortController.signal, retryCount > 0 ? false : null);
                        }, null, (e)=>e instanceof RequestError_1.RequestError, abortController.signal);
                        this.logger.debug("create(" + lp.url + "): LP response: ", resp);
                        const callerFeeShare = await callerFeePrefetchPromise;
                        const [pricingInfo, gasPricingInfo, { vault, vaultUtxoValue }] = await Promise.all([
                            this.verifyReturnedPrice(lp.services[SwapType_1.SwapType.SPV_VAULT_FROM_BTC], false, resp.btcAmountSwap, resp.total * (100000n + callerFeeShare) / 100000n, amountData.token, {}, pricePrefetchPromise, abortController.signal),
                            options.gasAmount === 0n ? Promise.resolve() : this.verifyReturnedPrice({
                                ...lp.services[SwapType_1.SwapType.SPV_VAULT_FROM_BTC],
                                swapBaseFee: 0
                            }, false, resp.btcAmountGas, resp.totalGas * (100000n + callerFeeShare) / 100000n, nativeTokenAddress, {}, gasTokenPricePrefetchPromise, abortController.signal),
                            this.verifyReturnedData(resp, amountData, lp, options, callerFeeShare, bitcoinFeeRatePromise)
                        ]);
                        var _amountData_exactIn;
                        const swapInit = {
                            pricingInfo,
                            url: lp.url,
                            expiry: resp.expiry * 1000,
                            swapFee: resp.swapFee,
                            swapFeeBtc: resp.swapFeeBtc,
                            exactIn: (_amountData_exactIn = amountData.exactIn) !== null && _amountData_exactIn !== void 0 ? _amountData_exactIn : true,
                            quoteId: resp.quoteId,
                            recipient: signer,
                            vaultOwner: resp.address,
                            vaultId: resp.vaultId,
                            vaultRequiredConfirmations: vault.getConfirmations(),
                            vaultTokenMultipliers: vault.getTokenData().map((val)=>val.multiplier),
                            vaultBtcAddress: resp.vaultBtcAddress,
                            vaultUtxo: resp.btcUtxo,
                            vaultUtxoValue: BigInt(vaultUtxoValue),
                            btcDestinationAddress: resp.btcAddress,
                            btcAmount: resp.btcAmount,
                            btcAmountSwap: resp.btcAmountSwap,
                            btcAmountGas: resp.btcAmountGas,
                            minimumBtcFeeRate: resp.btcFeeRate,
                            outputTotalSwap: resp.total,
                            outputSwapToken: amountData.token,
                            outputTotalGas: resp.totalGas,
                            outputGasToken: nativeTokenAddress,
                            gasSwapFeeBtc: resp.gasSwapFeeBtc,
                            gasSwapFee: resp.gasSwapFee,
                            callerFeeShare: resp.callerFeeShare,
                            frontingFeeShare: resp.frontingFeeShare,
                            executionFeeShare: resp.executionFeeShare
                        };
                        const quote = new SpvFromBTCSwap_1.SpvFromBTCSwap(this, swapInit);
                        await quote._save();
                        return quote;
                    } catch (e) {
                        abortController.abort(e);
                        throw e;
                    }
                })()
            };
        });
    }
    /**
     * Returns a random dummy PSBT that can be used for fee estimation, the last output (the LP output) is omitted
     *  to allow for coinselection algorithm to determine maximum sendable amount there
     *
     * @param includeGasToken   Whether to return the PSBT also with the gas token amount (increases the vSize by 8)
     */ getDummySwapPsbt() {
        let includeGasToken = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        //Construct dummy swap psbt
        const psbt = new btc_signer_1.Transaction({
            allowUnknownInputs: true,
            allowLegacyWitnessUtxo: true,
            allowUnknownOutputs: true
        });
        const randomVaultOutScript = btc_signer_1.OutScript.encode({
            type: "tr",
            pubkey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from("0101010101010101010101010101010101010101010101010101010101010101", "hex")
        });
        psbt.addInput({
            txid: (0, Utils_1.randomBytes)(32),
            index: 0,
            witnessUtxo: {
                script: randomVaultOutScript,
                amount: 600n
            }
        });
        psbt.addOutput({
            script: randomVaultOutScript,
            amount: 600n
        });
        const opReturnData = this.contract.toOpReturnData(this.chain.randomAddress(), includeGasToken ? [
            0xffffffffffffffffn,
            0xffffffffffffffffn
        ] : [
            0xffffffffffffffffn
        ]);
        psbt.addOutput({
            script: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                opReturnData.length <= 75 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
                    0x6a,
                    opReturnData.length
                ]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
                    0x6a,
                    0x4c,
                    opReturnData.length
                ]),
                opReturnData
            ]),
            amount: 0n
        });
        return psbt;
    }
    /**
     * @param chainIdentifier
     * @param unifiedStorage Storage interface for the current environment
     * @param unifiedChainEvents On-chain event listener
     * @param chain
     * @param contract Underlying contract handling the swaps
     * @param prices Pricing to use
     * @param tokens
     * @param spvWithdrawalDataDeserializer Deserializer for SpvVaultWithdrawalData
     * @param btcRelay
     * @param synchronizer Btc relay synchronizer
     * @param btcRpc Bitcoin RPC which also supports getting transactions by txoHash
     * @param options
     * @param events Instance to use for emitting events
     */ constructor(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, contract, prices, tokens, spvWithdrawalDataDeserializer, btcRelay, synchronizer, btcRpc, options, events){
        var _options, _options1, _options2, _options3, _options4, _options5, _options6;
        if (options == null) options = {};
        var _bitcoinNetwork;
        (_bitcoinNetwork = (_options = options).bitcoinNetwork) !== null && _bitcoinNetwork !== void 0 ? _bitcoinNetwork : _options.bitcoinNetwork = utils_1.TEST_NETWORK;
        var _maxConfirmations;
        (_maxConfirmations = (_options1 = options).maxConfirmations) !== null && _maxConfirmations !== void 0 ? _maxConfirmations : _options1.maxConfirmations = 6;
        var _bitcoinBlocktime;
        (_bitcoinBlocktime = (_options2 = options).bitcoinBlocktime) !== null && _bitcoinBlocktime !== void 0 ? _bitcoinBlocktime : _options2.bitcoinBlocktime = 10 * 60;
        var _maxTransactionsDelta;
        (_maxTransactionsDelta = (_options3 = options).maxTransactionsDelta) !== null && _maxTransactionsDelta !== void 0 ? _maxTransactionsDelta : _options3.maxTransactionsDelta = 3;
        var _maxRawAmountAdjustmentDifferencePPM;
        (_maxRawAmountAdjustmentDifferencePPM = (_options4 = options).maxRawAmountAdjustmentDifferencePPM) !== null && _maxRawAmountAdjustmentDifferencePPM !== void 0 ? _maxRawAmountAdjustmentDifferencePPM : _options4.maxRawAmountAdjustmentDifferencePPM = 100;
        var _maxBtcFeeOffset;
        (_maxBtcFeeOffset = (_options5 = options).maxBtcFeeOffset) !== null && _maxBtcFeeOffset !== void 0 ? _maxBtcFeeOffset : _options5.maxBtcFeeOffset = 5;
        var _maxBtcFeeMultiplier;
        (_maxBtcFeeMultiplier = (_options6 = options).maxBtcFeeMultiplier) !== null && _maxBtcFeeMultiplier !== void 0 ? _maxBtcFeeMultiplier : _options6.maxBtcFeeMultiplier = 1.5;
        super(chainIdentifier, unifiedStorage, unifiedChainEvents, chain, prices, tokens, options, events);
        this.TYPE = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;
        this.swapDeserializer = SpvFromBTCSwap_1.SpvFromBTCSwap;
        this.pendingSwapStates = [
            SpvFromBTCSwap_1.SpvFromBTCSwapState.CREATED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.DECLINED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.BTC_TX_CONFIRMED
        ];
        this.tickSwapState = [
            SpvFromBTCSwap_1.SpvFromBTCSwapState.CREATED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.SIGNED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.POSTED,
            SpvFromBTCSwap_1.SpvFromBTCSwapState.BROADCASTED
        ];
        this.spvWithdrawalDataDeserializer = spvWithdrawalDataDeserializer;
        this.contract = contract;
        this.btcRelay = btcRelay;
        this.synchronizer = synchronizer;
        this.btcRpc = btcRpc;
    }
}
exports.SpvFromBTCWrapper = SpvFromBTCWrapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/utils/SwapperUtils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SwapperUtils = void 0;
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const btc_signer_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/index.js [app-client] (ecmascript)");
const LNURL_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const SingleAddressBitcoinWallet_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/SingleAddressBitcoinWallet.js [app-client] (ecmascript)");
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
class SwapperUtils {
    /**
     * Returns true if string is a valid BOLT11 bitcoin lightning invoice
     *
     * @param lnpr
     */ isLightningInvoice(lnpr) {
        try {
            (0, bolt11_1.decode)(lnpr);
            return true;
        } catch (e) {}
        return false;
    }
    /**
     * Returns true if string is a valid bitcoin address
     *
     * @param addr
     */ isValidBitcoinAddress(addr) {
        try {
            (0, btc_signer_1.Address)(this.bitcoinNetwork).decode(addr);
            return true;
        } catch (e) {
            return false;
        }
    }
    /**
     * Returns true if string is a valid BOLT11 bitcoin lightning invoice WITH AMOUNT
     *
     * @param lnpr
     */ isValidLightningInvoice(lnpr) {
        try {
            const parsed = (0, bolt11_1.decode)(lnpr);
            if (parsed.millisatoshis != null) return true;
        } catch (e) {}
        return false;
    }
    /**
     * Returns true if string is a valid LNURL (no checking on type is performed)
     *
     * @param lnurl
     */ isValidLNURL(lnurl) {
        return LNURL_1.LNURL.isLNURL(lnurl);
    }
    /**
     * Returns type and data about an LNURL
     *
     * @param lnurl
     * @param shouldRetry
     */ getLNURLTypeAndData(lnurl, shouldRetry) {
        return LNURL_1.LNURL.getLNURLType(lnurl, shouldRetry);
    }
    /**
     * Returns satoshi value of BOLT11 bitcoin lightning invoice WITH AMOUNT
     *
     * @param lnpr
     */ getLightningInvoiceValue(lnpr) {
        const parsed = (0, bolt11_1.decode)(lnpr);
        if (parsed.millisatoshis != null) return (BigInt(parsed.millisatoshis) + 999n) / 1000n;
        return null;
    }
    parseBitcoinAddress(resultText) {
        let _amount = null;
        if (resultText.includes("?")) {
            const arr = resultText.split("?");
            resultText = arr[0];
            const params = arr[1].split("&");
            for (let param of params){
                const arr2 = param.split("=");
                const key = arr2[0];
                const value = decodeURIComponent(arr2[1]);
                if (key === "amount") {
                    _amount = (0, Tokens_1.fromDecimal)(parseFloat(value).toFixed(8), 8);
                }
            }
        }
        if (this.isValidBitcoinAddress(resultText)) {
            return {
                address: resultText,
                type: "BITCOIN",
                swapType: SwapType_1.SwapType.TO_BTC,
                amount: (0, Tokens_1.toTokenAmount)(_amount, Tokens_1.BitcoinTokens.BTC, this.root.prices)
            };
        }
    }
    parseLNURLSync(resultText) {
        if (this.isValidLNURL(resultText)) {
            return {
                address: resultText,
                type: "LNURL",
                swapType: null
            };
        }
    }
    async parseLNURL(resultText) {
        if (this.isValidLNURL(resultText)) {
            try {
                const result = await this.getLNURLTypeAndData(resultText);
                if (result == null) throw new Error("Invalid LNURL specified!");
                const response = {
                    address: resultText,
                    type: "LNURL",
                    swapType: (0, LNURL_1.isLNURLPay)(result) ? SwapType_1.SwapType.TO_BTCLN : (0, LNURL_1.isLNURLWithdraw)(result) ? SwapType_1.SwapType.FROM_BTCLN : null,
                    lnurl: result
                };
                if (result.min === result.max) {
                    return {
                        ...response,
                        amount: (0, Tokens_1.toTokenAmount)(result.min, Tokens_1.BitcoinTokens.BTCLN, this.root.prices)
                    };
                } else {
                    return {
                        ...response,
                        min: (0, Tokens_1.toTokenAmount)(result.min, Tokens_1.BitcoinTokens.BTCLN, this.root.prices),
                        max: (0, Tokens_1.toTokenAmount)(result.max, Tokens_1.BitcoinTokens.BTCLN, this.root.prices)
                    };
                }
            } catch (e) {
                throw new Error("Failed to contact LNURL service, check your internet connection and retry later.");
            }
        }
    }
    parseLightningInvoice(resultText) {
        if (this.isLightningInvoice(resultText)) {
            if (this.isValidLightningInvoice(resultText)) {
                const amountBN = this.getLightningInvoiceValue(resultText);
                return {
                    address: resultText,
                    type: "LIGHTNING",
                    swapType: SwapType_1.SwapType.TO_BTCLN,
                    amount: (0, Tokens_1.toTokenAmount)(amountBN, Tokens_1.BitcoinTokens.BTCLN, this.root.prices)
                };
            } else {
                throw new Error("Lightning invoice needs to contain an amount!");
            }
        }
    }
    parseSmartchainAddress(resultText) {
        for (let chainId of this.root.getSmartChains()){
            if (this.root.chains[chainId].chainInterface.isValidAddress(resultText)) {
                if (this.root.supportsSwapType(chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {
                    return {
                        address: resultText,
                        type: chainId,
                        swapType: SwapType_1.SwapType.SPV_VAULT_FROM_BTC
                    };
                } else {
                    return {
                        address: resultText,
                        type: chainId,
                        swapType: null
                    };
                }
            }
        }
    }
    /**
     * General parser for bitcoin addresses, LNURLs, lightning invoices, smart chain addresses, also fetches LNURL data
     *  (hence returns Promise)
     *
     * @param addressString Address to parse
     * @throws {Error} Error in address parsing
     * @returns Address data or null if address doesn't conform to any known format
     */ async parseAddress(addressString) {
        if (addressString.startsWith("bitcoin:")) {
            const parsedBitcoinAddress = this.parseBitcoinAddress(addressString.substring(8));
            if (parsedBitcoinAddress != null) return parsedBitcoinAddress;
            throw new Error("Invalid bitcoin address!");
        }
        const parsedBitcoinAddress = this.parseBitcoinAddress(addressString);
        if (parsedBitcoinAddress != null) return parsedBitcoinAddress;
        if (addressString.startsWith("lightning:")) {
            const resultText = addressString.substring(10);
            const resultLnurl = await this.parseLNURL(resultText);
            if (resultLnurl != null) return resultLnurl;
            const resultLightningInvoice = this.parseLightningInvoice(resultText);
            if (resultLightningInvoice != null) return resultLightningInvoice;
            throw new Error("Invalid lightning network invoice or LNURL!");
        }
        const resultLnurl = await this.parseLNURL(addressString);
        if (resultLnurl != null) return resultLnurl;
        const resultLightningInvoice = this.parseLightningInvoice(addressString);
        if (resultLightningInvoice != null) return resultLightningInvoice;
        return this.parseSmartchainAddress(addressString);
    }
    /**
     * Synchronous general parser for bitcoin addresses, LNURLs, lightning invoices, smart chain addresses, doesn't fetch
     *  LNURL data, reports swapType: null instead to prevent returning a Promise
     *
     * @param addressString Address to parse
     * @throws {Error} Error in address parsing
     * @returns Address data or null if address doesn't conform to any known format
     */ parseAddressSync(addressString) {
        if (addressString.startsWith("bitcoin:")) {
            const parsedBitcoinAddress = this.parseBitcoinAddress(addressString.substring(8));
            if (parsedBitcoinAddress != null) return parsedBitcoinAddress;
            throw new Error("Invalid bitcoin address!");
        }
        const parsedBitcoinAddress = this.parseBitcoinAddress(addressString);
        if (parsedBitcoinAddress != null) return parsedBitcoinAddress;
        if (addressString.startsWith("lightning:")) {
            const resultText = addressString.substring(10);
            const resultLnurl = this.parseLNURLSync(resultText);
            if (resultLnurl != null) return resultLnurl;
            const resultLightningInvoice = this.parseLightningInvoice(resultText);
            if (resultLightningInvoice != null) return resultLightningInvoice;
            throw new Error("Invalid lightning network invoice or LNURL!");
        }
        const resultLnurl = this.parseLNURLSync(addressString);
        if (resultLnurl != null) return resultLnurl;
        const resultLightningInvoice = this.parseLightningInvoice(addressString);
        if (resultLightningInvoice != null) return resultLightningInvoice;
        return this.parseSmartchainAddress(addressString);
    }
    /**
     * Returns a random PSBT that can be used for fee estimation, the last output (the LP output) is omitted
     *  to allow for coinselection algorithm to determine maximum sendable amount there
     *
     * @param chainIdentifier
     * @param includeGasToken   Whether to return the PSBT also with the gas token amount (increases the vSize by 8)
     */ getRandomSpvVaultPsbt(chainIdentifier, includeGasToken) {
        const wrapper = this.root.chains[chainIdentifier].wrappers[SwapType_1.SwapType.SPV_VAULT_FROM_BTC];
        if (wrapper == null) throw new Error("Chain doesn't support spv vault swaps!");
        return wrapper.getDummySwapPsbt(includeGasToken);
    }
    /**
     * Returns the spendable balance of a bitcoin wallet
     *
     * @param addressOrWallet
     * @param targetChain
     * @param options Additional options
     */ async getBitcoinSpendableBalance(addressOrWallet, targetChain, options) {
        if (typeof addressOrWallet !== "string" && addressOrWallet.getTransactionFee == null) throw new Error("Wallet must be a string address or IBitcoinWallet");
        let bitcoinWallet;
        if (typeof addressOrWallet === "string") {
            bitcoinWallet = new SingleAddressBitcoinWallet_1.SingleAddressBitcoinWallet(this.root.bitcoinRpc, this.bitcoinNetwork, addressOrWallet);
        } else {
            bitcoinWallet = addressOrWallet;
        }
        var _options_feeRate;
        let feeRate = (_options_feeRate = options === null || options === void 0 ? void 0 : options.feeRate) !== null && _options_feeRate !== void 0 ? _options_feeRate : await bitcoinWallet.getFeeRate();
        if ((options === null || options === void 0 ? void 0 : options.minFeeRate) != null) feeRate = Math.max(feeRate, options.minFeeRate);
        let result;
        if (targetChain != null && this.root.supportsSwapType(targetChain, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {
            result = await bitcoinWallet.getSpendableBalance(this.getRandomSpvVaultPsbt(targetChain, options === null || options === void 0 ? void 0 : options.gasDrop), feeRate);
        } else {
            result = await bitcoinWallet.getSpendableBalance(undefined, feeRate);
        }
        return {
            balance: (0, Tokens_1.toTokenAmount)(result.balance, Tokens_1.BitcoinTokens.BTC, this.root.prices),
            feeRate: result.feeRate
        };
    }
    /**
     * Returns the maximum spendable balance of the wallet, deducting the fee needed to initiate a swap for native balances
     */ async getSpendableBalance(wallet, token, options) {
        if (typeof wallet !== "string" && wallet.getAddress == null) throw new Error("Signer must be a string or smart chain signer");
        if (this.root.chains[token.chainId] == null) throw new Error("Invalid chain identifier! Unknown chain: " + token.chainId);
        const { swapContract, chainInterface } = this.root.chains[token.chainId];
        const signer = typeof wallet === "string" ? wallet : wallet.getAddress();
        let finalBalance;
        if (chainInterface.getNativeCurrencyAddress() !== token.address) {
            finalBalance = await chainInterface.getBalance(signer, token.address);
        } else {
            let [balance, commitFee] = await Promise.all([
                chainInterface.getBalance(signer, token.address),
                swapContract.getCommitFee(//Use large amount, such that the fee for wrapping more tokens is always included!
                await swapContract.createSwapData(base_1.ChainSwapType.HTLC, signer, null, token.address, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn, swapContract.getHashForHtlc((0, Utils_1.randomBytes)(32)).toString("hex"), base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(8)), BigInt(Math.floor(Date.now() / 1000)), true, false, base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(2)), base_1.BigIntBufferUtils.fromBuffer((0, Utils_1.randomBytes)(2))), options === null || options === void 0 ? void 0 : options.feeRate)
            ]);
            if ((options === null || options === void 0 ? void 0 : options.feeMultiplier) != null) {
                commitFee = commitFee * BigInt(Math.floor(options.feeMultiplier * 1000000)) / 1000000n;
            }
            finalBalance = (0, Utils_1.bigIntMax)(balance - commitFee, 0n);
        }
        return (0, Tokens_1.toTokenAmount)(finalBalance, token, this.root.prices);
    }
    /**
     * Returns the address of the native currency of the chain
     */ getNativeToken(chainIdentifier) {
        if (this.root.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        return this.root.tokens[chainIdentifier][this.root.chains[chainIdentifier].chainInterface.getNativeCurrencyAddress()];
    }
    /**
     * Returns a random signer for a given smart chain
     *
     * @param chainIdentifier
     */ randomSigner(chainIdentifier) {
        if (this.root.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        return this.root.chains[chainIdentifier].chainInterface.randomSigner();
    }
    /**
     * Returns a random address for a given smart chain
     *
     * @param chainIdentifier
     */ randomAddress(chainIdentifier) {
        if (this.root.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        return this.root.chains[chainIdentifier].chainInterface.randomAddress();
    }
    constructor(root){
        this.bitcoinNetwork = root.bitcoinNetwork;
        this.root = root;
    }
}
exports.SwapperUtils = SwapperUtils;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/Swapper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Swapper = void 0;
const base_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/base/dist/index.js [app-client] (ecmascript)");
const ToBTCLNWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNWrapper.js [app-client] (ecmascript)");
const ToBTCWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCWrapper.js [app-client] (ecmascript)");
const FromBTCLNWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNWrapper.js [app-client] (ecmascript)");
const FromBTCWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCWrapper.js [app-client] (ecmascript)");
const IntermediaryDiscovery_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryDiscovery.js [app-client] (ecmascript)");
const bolt11_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/bolt11/payreq.js [app-client] (ecmascript)");
const IntermediaryError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)");
const SwapType_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)");
const MempoolBtcRelaySynchronizer_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/synchronizer/MempoolBtcRelaySynchronizer.js [app-client] (ecmascript)");
const LnForGasWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasWrapper.js [app-client] (ecmascript)");
const events_1 = __turbopack_context__.r("[project]/node_modules/events/events.js [app-client] (ecmascript)");
const LNURL_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)");
const Utils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/Utils.js [app-client] (ecmascript)");
const RequestError_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)");
const SwapperWithChain_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithChain.js [app-client] (ecmascript)");
const Tokens_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)");
const OnchainForGasWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasWrapper.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@scure/btc-signer/utils.js [app-client] (ecmascript)");
const IndexedDBUnifiedStorage_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/browser-storage/IndexedDBUnifiedStorage.js [app-client] (ecmascript)");
const UnifiedSwapStorage_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/storage/UnifiedSwapStorage.js [app-client] (ecmascript)");
const UnifiedSwapEventListener_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/events/UnifiedSwapEventListener.js [app-client] (ecmascript)");
const SpvFromBTCWrapper_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCWrapper.js [app-client] (ecmascript)");
const SwapperUtils_1 = __turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/utils/SwapperUtils.js [app-client] (ecmascript)");
class Swapper extends events_1.EventEmitter {
    /**
     * Initializes the swap storage and loads existing swaps, needs to be called before any other action
     */ async init() {
        for(let chainIdentifier in this.chains){
            const { swapContract, unifiedChainEvents, unifiedSwapStorage, wrappers, reviver } = this.chains[chainIdentifier];
            await swapContract.start();
            this.logger.debug("init(): Intialized swap contract: " + chainIdentifier);
            await unifiedSwapStorage.init();
            if (unifiedSwapStorage.storage instanceof IndexedDBUnifiedStorage_1.IndexedDBUnifiedStorage) {
                //Try to migrate the data here
                const storagePrefix = chainIdentifier === "SOLANA" ? "SOLv4-" + this._bitcoinNetwork + "-Swaps-" : "atomiqsdk-" + this._bitcoinNetwork + chainIdentifier + "-Swaps-";
                await unifiedSwapStorage.storage.tryMigrate([
                    [
                        storagePrefix + "FromBTC",
                        SwapType_1.SwapType.FROM_BTC
                    ],
                    [
                        storagePrefix + "FromBTCLN",
                        SwapType_1.SwapType.FROM_BTCLN
                    ],
                    [
                        storagePrefix + "ToBTC",
                        SwapType_1.SwapType.TO_BTC
                    ],
                    [
                        storagePrefix + "ToBTCLN",
                        SwapType_1.SwapType.TO_BTCLN
                    ]
                ], (obj)=>{
                    const swap = reviver(obj);
                    if (swap.randomNonce == null) {
                        const oldIdentifierHash = swap.getId();
                        swap.randomNonce = (0, Utils_1.randomBytes)(16).toString("hex");
                        const newIdentifierHash = swap.getId();
                        this.logger.info("init(): Found older swap version without randomNonce, replacing, old hash: " + oldIdentifierHash + " new hash: " + newIdentifierHash);
                    }
                    return swap;
                });
            }
            if (!this.options.noEvents) await unifiedChainEvents.start();
            this.logger.debug("init(): Intialized events: " + chainIdentifier);
            for(let key in wrappers){
                // this.logger.debug("init(): Initializing "+SwapType[key]+": "+chainIdentifier);
                await wrappers[key].init(this.options.noTimers, this.options.dontCheckPastSwaps);
            }
        }
        this.logger.debug("init(): Initializing intermediary discovery");
        if (!this.options.dontFetchLPs) await this.intermediaryDiscovery.init();
        if (this.options.defaultTrustedIntermediaryUrl != null) {
            this.defaultTrustedIntermediary = await this.intermediaryDiscovery.getIntermediary(this.options.defaultTrustedIntermediaryUrl);
        }
    }
    /**
     * Stops listening for onchain events and closes this Swapper instance
     */ async stop() {
        for(let chainIdentifier in this.chains){
            const { wrappers, unifiedChainEvents } = this.chains[chainIdentifier];
            for(let key in wrappers){
                wrappers[key].events.removeListener("swapState", this.swapStateListener);
                await wrappers[key].stop();
            }
            await unifiedChainEvents.stop();
        }
    }
    /**
     * Creates swap & handles intermediary, quote selection
     *
     * @param chainIdentifier
     * @param create Callback to create the
     * @param amountData Amount data as passed to the function
     * @param swapType Swap type of the execution
     * @param maxWaitTimeMS Maximum waiting time after the first intermediary returns the quote
     * @private
     * @throws {Error} when no intermediary was found
     * @throws {Error} if the chain with the provided identifier cannot be found
     */ async createSwap(chainIdentifier, create, amountData, swapType) {
        let maxWaitTimeMS = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 2000;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        let candidates;
        const inBtc = swapType === SwapType_1.SwapType.TO_BTCLN || swapType === SwapType_1.SwapType.TO_BTC ? !amountData.exactIn : amountData.exactIn;
        if (!inBtc) {
            //Get candidates not based on the amount
            candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token);
        } else {
            candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token, amountData.amount);
        }
        let swapLimitsChanged = false;
        if (candidates.length === 0) {
            this.logger.warn("createSwap(): No valid intermediary found, reloading intermediary database...");
            await this.intermediaryDiscovery.reloadIntermediaries();
            swapLimitsChanged = true;
            if (!inBtc) {
                //Get candidates not based on the amount
                candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token);
            } else {
                candidates = this.intermediaryDiscovery.getSwapCandidates(chainIdentifier, swapType, amountData.token, amountData.amount);
                if (candidates.length === 0) {
                    const min = this.intermediaryDiscovery.getSwapMinimum(chainIdentifier, swapType, amountData.token);
                    const max = this.intermediaryDiscovery.getSwapMaximum(chainIdentifier, swapType, amountData.token);
                    if (min != null && max != null) {
                        if (amountData.amount < BigInt(min)) throw new RequestError_1.OutOfBoundsError("Amount too low!", 200, BigInt(min), BigInt(max));
                        if (amountData.amount > BigInt(max)) throw new RequestError_1.OutOfBoundsError("Amount too high!", 200, BigInt(min), BigInt(max));
                    }
                }
            }
            if (candidates.length === 0) throw new Error("No intermediary found!");
        }
        const abortController = new AbortController();
        this.logger.debug("createSwap() Swap candidates: ", candidates.map((lp)=>lp.url).join());
        const quotePromises = await create(candidates, abortController.signal, this.chains[chainIdentifier]);
        const promiseAll = new Promise((resolve, reject)=>{
            let min;
            let max;
            let error;
            let numResolved = 0;
            let quotes = [];
            let timeout;
            quotePromises.forEach((data)=>{
                data.quote.then((quote)=>{
                    if (numResolved === 0) {
                        timeout = setTimeout(()=>{
                            abortController.abort(new Error("Timed out waiting for quote!"));
                            resolve(quotes);
                        }, maxWaitTimeMS);
                    }
                    numResolved++;
                    quotes.push({
                        quote,
                        intermediary: data.intermediary
                    });
                    if (numResolved === quotePromises.length) {
                        clearTimeout(timeout);
                        resolve(quotes);
                        return;
                    }
                }).catch((e)=>{
                    numResolved++;
                    if (e instanceof IntermediaryError_1.IntermediaryError) {
                        //Blacklist that node
                        this.intermediaryDiscovery.removeIntermediary(data.intermediary);
                        swapLimitsChanged = true;
                    } else if (e instanceof RequestError_1.OutOfBoundsError) {
                        var _data_intermediary_swapBounds, _swapType, _data_intermediary_swapBounds_swapType, _chainIdentifier, _data_intermediary_swapBounds_swapType_chainIdentifier, _amountData_token;
                        if (min == null || max == null) {
                            min = e.min;
                            max = e.max;
                        } else {
                            min = (0, Utils_1.bigIntMin)(min, e.min);
                            max = (0, Utils_1.bigIntMax)(max, e.max);
                        }
                        var _;
                        (_ = (_data_intermediary_swapBounds = data.intermediary.swapBounds)[_swapType = swapType]) !== null && _ !== void 0 ? _ : _data_intermediary_swapBounds[_swapType] = {};
                        var _1;
                        (_1 = (_data_intermediary_swapBounds_swapType = data.intermediary.swapBounds[swapType])[_chainIdentifier = chainIdentifier]) !== null && _1 !== void 0 ? _1 : _data_intermediary_swapBounds_swapType[_chainIdentifier] = {};
                        var _2;
                        const tokenBoundsData = (_2 = (_data_intermediary_swapBounds_swapType_chainIdentifier = data.intermediary.swapBounds[swapType][chainIdentifier])[_amountData_token = amountData.token]) !== null && _2 !== void 0 ? _2 : _data_intermediary_swapBounds_swapType_chainIdentifier[_amountData_token] = {
                            input: null,
                            output: null
                        };
                        if (amountData.exactIn) {
                            tokenBoundsData.input = {
                                min: e.min,
                                max: e.max
                            };
                        } else {
                            tokenBoundsData.output = {
                                min: e.min,
                                max: e.max
                            };
                        }
                        swapLimitsChanged = true;
                    }
                    this.logger.warn("createSwap(): Intermediary " + data.intermediary.url + " error: ", e);
                    error = e;
                    if (numResolved === quotePromises.length) {
                        if (timeout != null) clearTimeout(timeout);
                        if (quotes.length > 0) {
                            resolve(quotes);
                            return;
                        }
                        if (min != null && max != null) {
                            reject(new RequestError_1.OutOfBoundsError("Out of bounds", 400, min, max));
                            return;
                        }
                        reject(error);
                    }
                });
            });
        });
        try {
            const quotes = await promiseAll;
            //TODO: Intermediary's reputation is not taken into account!
            quotes.sort((a, b)=>{
                if (amountData.exactIn) {
                    //Compare outputs
                    return (0, Utils_1.bigIntCompare)(b.quote.getOutput().rawAmount, a.quote.getOutput().rawAmount);
                } else {
                    //Compare inputs
                    return (0, Utils_1.bigIntCompare)(a.quote.getInput().rawAmount, b.quote.getInput().rawAmount);
                }
            });
            this.logger.debug("createSwap(): Sorted quotes, best price to worst: ", quotes);
            if (swapLimitsChanged) this.emit("swapLimitsChanged");
            const quote = quotes[0].quote;
            if (this.options.saveUninitializedSwaps) {
                quote._setInitiated();
                await quote._save();
            }
            return quote;
        } catch (e) {
            if (swapLimitsChanged) this.emit("swapLimitsChanged");
            throw e;
        }
    }
    /**
     * Creates To BTC swap
     *
     * @param chainIdentifier
     * @param signer
     * @param tokenAddress          Token address to pay with
     * @param address               Recipient's bitcoin address
     * @param amount                Amount to send in satoshis (bitcoin's smallest denomination)
     * @param exactIn               Whether to use exact in instead of exact out
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param options
     */ createToBTCSwap(chainIdentifier, signer, tokenAddress, address, amount, exactIn) {
        let additionalParams = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.options.defaultAdditionalParameters, options = arguments.length > 7 ? arguments[7] : void 0;
        var _options, _options1;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        if (address.startsWith("bitcoin:")) {
            address = address.substring(8).split("?")[0];
        }
        if (!this.Utils.isValidBitcoinAddress(address)) throw new Error("Invalid bitcoin address");
        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainIdentifier + " address");
        options !== null && options !== void 0 ? options : options = {};
        var _confirmationTarget;
        (_confirmationTarget = (_options = options).confirmationTarget) !== null && _confirmationTarget !== void 0 ? _confirmationTarget : _options.confirmationTarget = 3;
        var _confirmations;
        (_confirmations = (_options1 = options).confirmations) !== null && _confirmations !== void 0 ? _confirmations : _options1.confirmations = 2;
        const amountData = {
            amount,
            token: tokenAddress,
            exactIn
        };
        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain)=>Promise.resolve(chain.wrappers[SwapType_1.SwapType.TO_BTC].create(signer, address, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.TO_BTC);
    }
    /**
     * Creates To BTCLN swap
     *
     * @param chainIdentifier
     * @param signer
     * @param tokenAddress          Token address to pay with
     * @param paymentRequest        BOLT11 lightning network invoice to be paid (needs to have a fixed amount)
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param options
     */ async createToBTCLNSwap(chainIdentifier, signer, tokenAddress, paymentRequest) {
        let additionalParams = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.options.defaultAdditionalParameters, options = arguments.length > 5 ? arguments[5] : void 0;
        var _options;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        options !== null && options !== void 0 ? options : options = {};
        if (paymentRequest.startsWith("lightning:")) paymentRequest = paymentRequest.substring(10);
        if (!this.Utils.isValidLightningInvoice(paymentRequest)) throw new Error("Invalid lightning network invoice");
        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainIdentifier + " address");
        const parsedPR = (0, bolt11_1.decode)(paymentRequest);
        const amountData = {
            amount: (BigInt(parsedPR.millisatoshis) + 999n) / 1000n,
            token: tokenAddress,
            exactIn: false
        };
        var _expirySeconds;
        (_expirySeconds = (_options = options).expirySeconds) !== null && _expirySeconds !== void 0 ? _expirySeconds : _options.expirySeconds = 5 * 24 * 3600;
        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain)=>chain.wrappers[SwapType_1.SwapType.TO_BTCLN].create(signer, paymentRequest, amountData, candidates, options, additionalParams, abortSignal), amountData, SwapType_1.SwapType.TO_BTCLN);
    }
    /**
     * Creates To BTCLN swap via LNURL-pay
     *
     * @param chainIdentifier
     * @param signer
     * @param tokenAddress          Token address to pay with
     * @param lnurlPay              LNURL-pay link to use for the payment
     * @param amount                Amount to be paid in sats
     * @param exactIn               Whether to do an exact in swap instead of exact out
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param options
     */ async createToBTCLNSwapViaLNURL(chainIdentifier, signer, tokenAddress, lnurlPay, amount, exactIn) {
        let additionalParams = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.options.defaultAdditionalParameters, options = arguments.length > 7 ? arguments[7] : void 0;
        var _options;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        if (typeof lnurlPay === "string" && !this.Utils.isValidLNURL(lnurlPay)) throw new Error("Invalid LNURL-pay link");
        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainIdentifier + " address");
        options !== null && options !== void 0 ? options : options = {};
        const amountData = {
            amount,
            token: tokenAddress,
            exactIn
        };
        var _expirySeconds;
        (_expirySeconds = (_options = options).expirySeconds) !== null && _expirySeconds !== void 0 ? _expirySeconds : _options.expirySeconds = 5 * 24 * 3600;
        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain)=>chain.wrappers[SwapType_1.SwapType.TO_BTCLN].createViaLNURL(signer, typeof lnurlPay === "string" ? lnurlPay.startsWith("lightning:") ? lnurlPay.substring(10) : lnurlPay : lnurlPay.params, amountData, candidates, options, additionalParams, abortSignal), amountData, SwapType_1.SwapType.TO_BTCLN);
    }
    /**
     * Creates From BTC swap
     *
     * @param chainIdentifier
     * @param signer
     * @param tokenAddress          Token address to receive
     * @param amount                Amount to receive, in satoshis (bitcoin's smallest denomination)
     * @param exactOut              Whether to use a exact out instead of exact in
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param options
     */ async createFromBTCSwapNew(chainIdentifier, signer, tokenAddress, amount, exactOut) {
        let additionalParams = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : this.options.defaultAdditionalParameters, options = arguments.length > 6 ? arguments[6] : void 0;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainIdentifier + " address");
        const amountData = {
            amount,
            token: tokenAddress,
            exactIn: !exactOut
        };
        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain)=>Promise.resolve(chain.wrappers[SwapType_1.SwapType.SPV_VAULT_FROM_BTC].create(signer, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.SPV_VAULT_FROM_BTC);
    }
    /**
     * Creates From BTC swap
     *
     * @param chainIdentifier
     * @param signer
     * @param tokenAddress          Token address to receive
     * @param amount                Amount to receive, in satoshis (bitcoin's smallest denomination)
     * @param exactOut              Whether to use a exact out instead of exact in
     * @param additionalParams      Additional parameters sent to the LP when creating the swap
     * @param options
     */ async createFromBTCSwap(chainIdentifier, signer, tokenAddress, amount, exactOut) {
        let additionalParams = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : this.options.defaultAdditionalParameters, options = arguments.length > 6 ? arguments[6] : void 0;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainIdentifier + " address");
        const amountData = {
            amount,
            token: tokenAddress,
            exactIn: !exactOut
        };
        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain)=>Promise.resolve(chain.wrappers[SwapType_1.SwapType.FROM_BTC].create(signer, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.FROM_BTC);
    }
    /**
     * Creates From BTCLN swap
     *
     * @param chainIdentifier
     * @param signer
     * @param tokenAddress      Token address to receive
     * @param amount            Amount to receive, in satoshis (bitcoin's smallest denomination)
     * @param exactOut          Whether to use exact out instead of exact in
     * @param additionalParams  Additional parameters sent to the LP when creating the swap
     * @param options
     */ async createFromBTCLNSwap(chainIdentifier, signer, tokenAddress, amount, exactOut) {
        let additionalParams = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : this.options.defaultAdditionalParameters, options = arguments.length > 6 ? arguments[6] : void 0;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainIdentifier + " address");
        const amountData = {
            amount,
            token: tokenAddress,
            exactIn: !exactOut
        };
        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain)=>Promise.resolve(chain.wrappers[SwapType_1.SwapType.FROM_BTCLN].create(signer, amountData, candidates, options, additionalParams, abortSignal)), amountData, SwapType_1.SwapType.FROM_BTCLN);
    }
    /**
     * Creates From BTCLN swap, withdrawing from LNURL-withdraw
     *
     * @param chainIdentifier
     * @param signer
     * @param tokenAddress      Token address to receive
     * @param lnurl             LNURL-withdraw to pull the funds from
     * @param amount            Amount to receive, in satoshis (bitcoin's smallest denomination)
     * @param exactOut          Whether to use exact out instead of exact in
     * @param additionalParams  Additional parameters sent to the LP when creating the swap
     */ async createFromBTCLNSwapViaLNURL(chainIdentifier, signer, tokenAddress, lnurl, amount, exactOut) {
        let additionalParams = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : this.options.defaultAdditionalParameters;
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        if (typeof lnurl === "string" && !this.Utils.isValidLNURL(lnurl)) throw new Error("Invalid LNURL-withdraw link");
        if (!this.chains[chainIdentifier].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainIdentifier + " address");
        const amountData = {
            amount,
            token: tokenAddress,
            exactIn: !exactOut
        };
        return this.createSwap(chainIdentifier, (candidates, abortSignal, chain)=>chain.wrappers[SwapType_1.SwapType.FROM_BTCLN].createViaLNURL(signer, typeof lnurl === "string" ? lnurl.startsWith("lightning:") ? lnurl.substring(10) : lnurl : lnurl.params, amountData, candidates, additionalParams, abortSignal), amountData, SwapType_1.SwapType.FROM_BTCLN);
    }
    /**
     * Creates trusted LN for Gas swap
     *
     * @param chainId
     * @param signer
     * @param amount                    Amount of native token to receive, in base units
     * @param trustedIntermediaryOrUrl  URL or Intermediary object of the trusted intermediary to use, otherwise uses default
     * @throws {Error}                  If no trusted intermediary specified
     */ createTrustedLNForGasSwap(chainId, signer, amount, trustedIntermediaryOrUrl) {
        if (this.chains[chainId] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainId);
        if (!this.chains[chainId].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainId + " address");
        var _ref;
        const useUrl = (_ref = trustedIntermediaryOrUrl !== null && trustedIntermediaryOrUrl !== void 0 ? trustedIntermediaryOrUrl : this.defaultTrustedIntermediary) !== null && _ref !== void 0 ? _ref : this.options.defaultTrustedIntermediaryUrl;
        if (useUrl == null) throw new Error("No trusted intermediary specified!");
        return this.chains[chainId].wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTCLN].create(signer, amount, useUrl);
    }
    /**
     * Creates trusted BTC on-chain for Gas swap
     *
     * @param chainId
     * @param signer
     * @param amount                    Amount of native token to receive, in base units
     * @param refundAddress             Bitcoin refund address, in case the swap fails
     * @param trustedIntermediaryOrUrl  URL or Intermediary object of the trusted intermediary to use, otherwise uses default
     * @throws {Error}                  If no trusted intermediary specified
     */ createTrustedOnchainForGasSwap(chainId, signer, amount, refundAddress, trustedIntermediaryOrUrl) {
        if (this.chains[chainId] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainId);
        if (!this.chains[chainId].chainInterface.isValidAddress(signer)) throw new Error("Invalid " + chainId + " address");
        var _ref;
        const useUrl = (_ref = trustedIntermediaryOrUrl !== null && trustedIntermediaryOrUrl !== void 0 ? trustedIntermediaryOrUrl : this.defaultTrustedIntermediary) !== null && _ref !== void 0 ? _ref : this.options.defaultTrustedIntermediaryUrl;
        if (useUrl == null) throw new Error("No trusted intermediary specified!");
        return this.chains[chainId].wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTC].create(signer, amount, useUrl, refundAddress);
    }
    /**
     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)
     *  or output amount (exactIn=false), NOTE: For regular -> BTC-LN (lightning) swaps the passed amount is ignored and
     *  invoice's pre-set amount is used instead.
     * @deprecated Use swap() instead
     *
     * @param signer Smartchain (Solana, Starknet, etc.) address of the user
     * @param srcToken Source token of the swap, user pays this token
     * @param dstToken Destination token of the swap, user receives this token
     * @param amount Amount of the swap
     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)
     * @param addressLnurlLightningInvoice Bitcoin on-chain address, lightning invoice, LNURL-pay to pay or
     *  LNURL-withdrawal to withdraw money from
     */ create(signer, srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice) {
        if (srcToken.chain === "BTC") {
            return this.swap(srcToken, dstToken, amount, exactIn, addressLnurlLightningInvoice, signer);
        } else {
            return this.swap(srcToken, dstToken, amount, exactIn, signer, addressLnurlLightningInvoice);
        }
    }
    /**
     * Creates a swap from srcToken to dstToken, of a specific token amount, either specifying input amount (exactIn=true)
     *  or output amount (exactIn=false), NOTE: For regular SmartChain -> BTC-LN (lightning) swaps the passed amount is ignored and
     *  invoice's pre-set amount is used instead, use LNURL-pay for dynamic amounts
     *
     * @param srcToken Source token of the swap, user pays this token
     * @param dstToken Destination token of the swap, user receives this token
     * @param amount Amount of the swap
     * @param exactIn Whether the amount specified is an input amount (exactIn=true) or an output amount (exactIn=false)
     * @param src Source wallet/lnurl-withdraw of the swap
     * @param dst Destination smart chain address, bitcoin on-chain address, lightning invoice, LNURL-pay
     * @param options Options for the swap
     */ swap(srcToken, dstToken, amount, exactIn, src, dst, options) {
        if (srcToken.chain === "BTC") {
            if (dstToken.chain === "SC") {
                if (typeof dst !== "string") throw new Error("Destination for BTC/BTC-LN -> smart chain swaps must be a smart chain address!");
                if (srcToken.lightning) {
                    //FROM_BTCLN
                    if (src != null) {
                        if (typeof src !== "string" && !(0, LNURL_1.isLNURLWithdraw)(src)) throw new Error("LNURL must be a string or LNURLWithdraw object!");
                        return this.createFromBTCLNSwapViaLNURL(dstToken.chainId, dst, dstToken.address, src, amount, !exactIn);
                    } else {
                        return this.createFromBTCLNSwap(dstToken.chainId, dst, dstToken.address, amount, !exactIn, undefined, options);
                    }
                } else {
                    //FROM_BTC
                    if (this.supportsSwapType(dstToken.chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {
                        return this.createFromBTCSwapNew(dstToken.chainId, dst, dstToken.address, amount, !exactIn, undefined, options);
                    } else {
                        return this.createFromBTCSwap(dstToken.chainId, dst, dstToken.address, amount, !exactIn, undefined, options);
                    }
                }
            }
        } else {
            if (dstToken.chain === "BTC") {
                if (typeof src !== "string") throw new Error("Source address for BTC/BTC-LN -> smart chain swaps must be a smart chain address!");
                if (dstToken.lightning) {
                    //TO_BTCLN
                    if (typeof dst !== "string" && !(0, LNURL_1.isLNURLPay)(dst)) throw new Error("Destination LNURL link/lightning invoice must be a string or LNURLPay object!");
                    if ((0, LNURL_1.isLNURLPay)(dst) || this.Utils.isValidLNURL(dst)) {
                        return this.createToBTCLNSwapViaLNURL(srcToken.chainId, src, srcToken.address, dst, amount, exactIn, undefined, options);
                    } else if (this.Utils.isLightningInvoice(dst)) {
                        if (!this.Utils.isValidLightningInvoice(dst)) throw new Error("Invalid lightning invoice specified, lightning invoice MUST contain pre-set amount!");
                        if (exactIn) throw new Error("Only exact out swaps are possible with lightning invoices, use LNURL links for exact in lightning swaps!");
                        return this.createToBTCLNSwap(srcToken.chainId, src, srcToken.address, dst, undefined, options);
                    } else {
                        throw new Error("Supplied parameter is not LNURL link nor lightning invoice (bolt11)!");
                    }
                } else {
                    //TO_BTC
                    if (typeof dst !== "string") throw new Error("Destination bitcoin address must be a string!");
                    return this.createToBTCSwap(srcToken.chainId, src, srcToken.address, dst, amount, exactIn, undefined, options);
                }
            }
        }
        throw new Error("Unsupported swap type");
    }
    async getAllSwaps(chainId, signer) {
        const queryParams = [];
        if (signer != null) queryParams.push({
            key: "intiator",
            value: signer
        });
        if (chainId == null) {
            const res = await Promise.all(Object.keys(this.chains).map((chainId)=>{
                const { unifiedSwapStorage, reviver } = this.chains[chainId];
                return unifiedSwapStorage.query([
                    queryParams
                ], reviver);
            }));
            return res.flat();
        } else {
            const { unifiedSwapStorage, reviver } = this.chains[chainId];
            return await unifiedSwapStorage.query([
                queryParams
            ], reviver);
        }
    }
    async getActionableSwaps(chainId, signer) {
        if (chainId == null) {
            const res = await Promise.all(Object.keys(this.chains).map((chainId)=>{
                const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];
                const queryParams = [];
                for(let key in wrappers){
                    const wrapper = wrappers[key];
                    const swapTypeQueryParams = [
                        {
                            key: "type",
                            value: wrapper.TYPE
                        }
                    ];
                    if (signer != null) swapTypeQueryParams.push({
                        key: "intiator",
                        value: signer
                    });
                    swapTypeQueryParams.push({
                        key: "state",
                        value: wrapper.pendingSwapStates
                    });
                    queryParams.push(swapTypeQueryParams);
                }
                return unifiedSwapStorage.query(queryParams, reviver);
            }));
            return res.flat().filter((swap)=>swap.requiresAction());
        } else {
            const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];
            const queryParams = [];
            for(let key in wrappers){
                const wrapper = wrappers[key];
                const swapTypeQueryParams = [
                    {
                        key: "type",
                        value: wrapper.TYPE
                    }
                ];
                if (signer != null) swapTypeQueryParams.push({
                    key: "intiator",
                    value: signer
                });
                swapTypeQueryParams.push({
                    key: "state",
                    value: wrapper.pendingSwapStates
                });
                queryParams.push(swapTypeQueryParams);
            }
            return (await unifiedSwapStorage.query(queryParams, reviver)).filter((swap)=>swap.requiresAction());
        }
    }
    async getRefundableSwaps(chainId, signer) {
        if (chainId == null) {
            const res = await Promise.all(Object.keys(this.chains).map((chainId)=>{
                const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];
                const queryParams = [];
                for (let wrapper of [
                    wrappers[SwapType_1.SwapType.TO_BTCLN],
                    wrappers[SwapType_1.SwapType.TO_BTC]
                ]){
                    const swapTypeQueryParams = [
                        {
                            key: "type",
                            value: wrapper.TYPE
                        }
                    ];
                    if (signer != null) swapTypeQueryParams.push({
                        key: "initiator",
                        value: signer
                    });
                    swapTypeQueryParams.push({
                        key: "state",
                        value: wrapper.refundableSwapStates
                    });
                    queryParams.push(swapTypeQueryParams);
                }
                return unifiedSwapStorage.query(queryParams, reviver);
            }));
            return res.flat().filter((swap)=>swap.isRefundable());
        } else {
            const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];
            const queryParams = [];
            for (let wrapper of [
                wrappers[SwapType_1.SwapType.TO_BTCLN],
                wrappers[SwapType_1.SwapType.TO_BTC]
            ]){
                const swapTypeQueryParams = [
                    {
                        key: "type",
                        value: wrapper.TYPE
                    }
                ];
                if (signer != null) swapTypeQueryParams.push({
                    key: "initiator",
                    value: signer
                });
                swapTypeQueryParams.push({
                    key: "state",
                    value: wrapper.refundableSwapStates
                });
                queryParams.push(swapTypeQueryParams);
            }
            const result = await unifiedSwapStorage.query(queryParams, reviver);
            return result.filter((swap)=>swap.isRefundable());
        }
    }
    async getSwapById(id, chainId, signer) {
        //Check in pending swaps first
        if (chainId != null) {
            for(let key in this.chains[chainId].wrappers){
                var _wrapper_pendingSwaps_get;
                const wrapper = this.chains[chainId].wrappers[key];
                const result = (_wrapper_pendingSwaps_get = wrapper.pendingSwaps.get(id)) === null || _wrapper_pendingSwaps_get === void 0 ? void 0 : _wrapper_pendingSwaps_get.deref();
                if (result != null) {
                    if (signer != null) {
                        if (result._getInitiator() === signer) return result;
                    } else {
                        return result;
                    }
                }
            }
        } else {
            for(let chainId in this.chains){
                for(let key in this.chains[chainId].wrappers){
                    var _wrapper_pendingSwaps_get1;
                    const wrapper = this.chains[chainId].wrappers[key];
                    const result = (_wrapper_pendingSwaps_get1 = wrapper.pendingSwaps.get(id)) === null || _wrapper_pendingSwaps_get1 === void 0 ? void 0 : _wrapper_pendingSwaps_get1.deref();
                    if (result != null) {
                        if (signer != null) {
                            if (result._getInitiator() === signer) return result;
                        } else {
                            return result;
                        }
                    }
                }
            }
        }
        const queryParams = [];
        if (signer != null) queryParams.push({
            key: "intiator",
            value: signer
        });
        queryParams.push({
            key: "id",
            value: id
        });
        if (chainId == null) {
            const res = await Promise.all(Object.keys(this.chains).map((chainId)=>{
                const { unifiedSwapStorage, reviver } = this.chains[chainId];
                return unifiedSwapStorage.query([
                    queryParams
                ], reviver);
            }));
            return res.flat()[0];
        } else {
            const { unifiedSwapStorage, reviver } = this.chains[chainId];
            return (await unifiedSwapStorage.query([
                queryParams
            ], reviver))[0];
        }
    }
    /**
     * Synchronizes swaps from chain, this is usually ran when SDK is initialized, deletes expired quotes
     *
     * @param chainId
     * @param signer
     */ async _syncSwaps(chainId, signer) {
        if (chainId == null) {
            await Promise.all(Object.keys(this.chains).map(async (chainId)=>{
                const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];
                const queryParams = [];
                for(let key in wrappers){
                    const wrapper = wrappers[key];
                    const swapTypeQueryParams = [
                        {
                            key: "type",
                            value: wrapper.TYPE
                        }
                    ];
                    if (signer != null) swapTypeQueryParams.push({
                        key: "intiator",
                        value: signer
                    });
                    swapTypeQueryParams.push({
                        key: "state",
                        value: wrapper.pendingSwapStates
                    });
                    queryParams.push(swapTypeQueryParams);
                }
                this.logger.debug("_syncSwaps(): Querying swaps swaps for chain " + chainId + "!");
                const swaps = await unifiedSwapStorage.query(queryParams, reviver);
                this.logger.debug("_syncSwaps(): Syncing " + swaps.length + " swaps!");
                const changedSwaps = [];
                const removeSwaps = [];
                for (let swap of swaps){
                    this.logger.debug("_syncSwaps(): Syncing swap: " + swap.getId());
                    const swapChanged = await swap._sync(false).catch((e)=>this.logger.warn("_syncSwaps(): Error in swap: " + swap.getId(), e));
                    this.logger.debug("_syncSwaps(): Synced swap: " + swap.getId());
                    if (swap.isQuoteExpired()) {
                        removeSwaps.push(swap);
                    } else {
                        if (swapChanged) changedSwaps.push(swap);
                    }
                }
                this.logger.debug("_syncSwaps(): Done syncing " + swaps.length + " swaps, saving " + changedSwaps.length + " changed swaps, removing " + removeSwaps.length + " swaps!");
                await unifiedSwapStorage.saveAll(changedSwaps);
                await unifiedSwapStorage.removeAll(removeSwaps);
            }));
        } else {
            const { unifiedSwapStorage, reviver, wrappers } = this.chains[chainId];
            const queryParams = [];
            for(let key in wrappers){
                const wrapper = wrappers[key];
                const swapTypeQueryParams = [
                    {
                        key: "type",
                        value: wrapper.TYPE
                    }
                ];
                if (signer != null) swapTypeQueryParams.push({
                    key: "intiator",
                    value: signer
                });
                swapTypeQueryParams.push({
                    key: "state",
                    value: wrapper.pendingSwapStates
                });
                queryParams.push(swapTypeQueryParams);
            }
            this.logger.debug("_syncSwaps(): Querying swaps swaps for chain " + chainId + "!");
            const swaps = await unifiedSwapStorage.query(queryParams, reviver);
            this.logger.debug("_syncSwaps(): Syncing " + swaps.length + " swaps!");
            const changedSwaps = [];
            const removeSwaps = [];
            for (let swap of swaps){
                this.logger.debug("_syncSwaps(): Syncing swap: " + swap.getId());
                const swapChanged = await swap._sync(false).catch((e)=>this.logger.warn("_syncSwaps(): Error in swap: " + swap.getId(), e));
                this.logger.debug("_syncSwaps(): Synced swap: " + swap.getId());
                if (swap.isQuoteExpired()) {
                    removeSwaps.push(swap);
                } else {
                    if (swapChanged) changedSwaps.push(swap);
                }
            }
            this.logger.debug("_syncSwaps(): Done syncing " + swaps.length + " swaps, saving " + changedSwaps.length + " changed swaps, removing " + removeSwaps.length + " swaps!");
            await unifiedSwapStorage.saveAll(changedSwaps);
            await unifiedSwapStorage.removeAll(removeSwaps);
        }
    }
    /**
     * Creates a child swapper instance with a given smart chain
     *
     * @param chainIdentifier
     */ withChain(chainIdentifier) {
        if (this.chains[chainIdentifier] == null) throw new Error("Invalid chain identifier! Unknown chain: " + chainIdentifier);
        return new SwapperWithChain_1.SwapperWithChain(this, chainIdentifier);
    }
    /**
     * Returns supported smart chains
     */ getSmartChains() {
        return Object.keys(this.chains);
    }
    /**
     * Returns whether the SDK supports a given swap type on a given chain based on currently known LPs
     *
     * @param chainId
     * @param swapType
     */ supportsSwapType(chainId, swapType) {
        var _this_chains_chainId;
        return ((_this_chains_chainId = this.chains[chainId]) === null || _this_chains_chainId === void 0 ? void 0 : _this_chains_chainId.wrappers[swapType]) != null;
    }
    getSwapType(srcToken, dstToken) {
        if ((0, Tokens_1.isSCToken)(srcToken)) {
            if (!(0, Tokens_1.isBtcToken)(dstToken)) throw new Error("Swap not supported");
            if (dstToken.lightning) {
                return SwapType_1.SwapType.TO_BTCLN;
            } else {
                return SwapType_1.SwapType.TO_BTC;
            }
        } else if ((0, Tokens_1.isBtcToken)(srcToken)) {
            if (!(0, Tokens_1.isSCToken)(dstToken)) throw new Error("Swap not supported");
            if (srcToken.lightning) {
                return SwapType_1.SwapType.FROM_BTCLN;
            } else {
                if (this.supportsSwapType(dstToken.chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) {
                    return SwapType_1.SwapType.SPV_VAULT_FROM_BTC;
                } else {
                    return SwapType_1.SwapType.FROM_BTC;
                }
            }
        }
        return null;
    }
    /**
     * Returns minimum/maximum limits for inputs and outputs for a swap between given tokens
     *
     * @param srcToken
     * @param dstToken
     */ getSwapLimits(srcToken, dstToken) {
        const swapType = this.getSwapType(srcToken, dstToken);
        const scToken = (0, Tokens_1.isSCToken)(srcToken) ? srcToken : (0, Tokens_1.isSCToken)(dstToken) ? dstToken : null;
        const result = {
            input: {
                min: null,
                max: null
            },
            output: {
                min: null,
                max: null
            }
        };
        for (let lp of this.intermediaryDiscovery.intermediaries){
            const lpMinMax = lp.getSwapLimits(swapType, scToken.chainId, scToken.address);
            if (lpMinMax == null) continue;
            result.input.min = result.input.min == null ? lpMinMax.input.min : (0, Utils_1.bigIntMin)(result.input.min, lpMinMax.input.min);
            result.input.max = result.input.max == null ? lpMinMax.input.max : (0, Utils_1.bigIntMax)(result.input.max, lpMinMax.input.max);
            result.output.min = result.output.min == null ? lpMinMax.output.min : (0, Utils_1.bigIntMin)(result.output.min, lpMinMax.output.min);
            result.output.max = result.output.max == null ? lpMinMax.output.max : (0, Utils_1.bigIntMax)(result.output.max, lpMinMax.output.max);
        }
        var _result_input_min, _result_output_min;
        return {
            input: {
                min: (0, Tokens_1.toTokenAmount)((_result_input_min = result.input.min) !== null && _result_input_min !== void 0 ? _result_input_min : 1n, srcToken, this.prices),
                max: (0, Tokens_1.toTokenAmount)(result.input.max, srcToken, this.prices)
            },
            output: {
                min: (0, Tokens_1.toTokenAmount)((_result_output_min = result.output.min) !== null && _result_output_min !== void 0 ? _result_output_min : 1n, dstToken, this.prices),
                max: (0, Tokens_1.toTokenAmount)(result.output.max, dstToken, this.prices)
            }
        };
    }
    /**
     * Returns supported tokens for a given direction
     *
     * @param input Whether to return input tokens or output tokens
     */ getSupportedTokens(input) {
        const tokens = {};
        let lightning = false;
        let btc = false;
        this.intermediaryDiscovery.intermediaries.forEach((lp)=>{
            for (let swapType of [
                SwapType_1.SwapType.TO_BTC,
                SwapType_1.SwapType.TO_BTCLN,
                SwapType_1.SwapType.FROM_BTC,
                SwapType_1.SwapType.FROM_BTCLN,
                SwapType_1.SwapType.SPV_VAULT_FROM_BTC
            ]){
                if (lp.services[swapType] == null) continue;
                if (lp.services[swapType].chainTokens == null) continue;
                for (let chainId of this.getSmartChains()){
                    if (this.supportsSwapType(chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC) ? swapType === SwapType_1.SwapType.FROM_BTC : swapType === SwapType_1.SwapType.SPV_VAULT_FROM_BTC) continue;
                    if (lp.services[swapType].chainTokens[chainId] == null) continue;
                    for (let tokenAddress of lp.services[swapType].chainTokens[chainId]){
                        if (input) {
                            if (swapType === SwapType_1.SwapType.TO_BTC || swapType === SwapType_1.SwapType.TO_BTCLN) {
                                var _tokens, _chainId;
                                var _;
                                (_ = (_tokens = tokens)[_chainId = chainId]) !== null && _ !== void 0 ? _ : _tokens[_chainId] = new Set();
                                tokens[chainId].add(tokenAddress);
                            }
                            if (swapType === SwapType_1.SwapType.FROM_BTCLN) {
                                lightning = true;
                            }
                            if (swapType === SwapType_1.SwapType.FROM_BTC || swapType === SwapType_1.SwapType.SPV_VAULT_FROM_BTC) {
                                btc = true;
                            }
                        } else {
                            if (swapType === SwapType_1.SwapType.FROM_BTCLN || swapType === SwapType_1.SwapType.FROM_BTC || swapType === SwapType_1.SwapType.SPV_VAULT_FROM_BTC) {
                                var _tokens1, _chainId1;
                                var _1;
                                (_1 = (_tokens1 = tokens)[_chainId1 = chainId]) !== null && _1 !== void 0 ? _1 : _tokens1[_chainId1] = new Set();
                                tokens[chainId].add(tokenAddress);
                            }
                            if (swapType === SwapType_1.SwapType.TO_BTCLN) {
                                lightning = true;
                            }
                            if (swapType === SwapType_1.SwapType.TO_BTC) {
                                btc = true;
                            }
                        }
                    }
                }
            }
        });
        const output = [];
        if (lightning) output.push(Tokens_1.BitcoinTokens.BTCLN);
        if (btc) output.push(Tokens_1.BitcoinTokens.BTC);
        for(let chainId in tokens){
            tokens[chainId].forEach((tokenAddress)=>{
                var _this_tokens_chainId, _this_tokens;
                const token = (_this_tokens = this.tokens) === null || _this_tokens === void 0 ? void 0 : (_this_tokens_chainId = _this_tokens[chainId]) === null || _this_tokens_chainId === void 0 ? void 0 : _this_tokens_chainId[tokenAddress];
                if (token != null) output.push(token);
            });
        }
        return output;
    }
    /**
     * Returns a set of supported tokens by all the intermediaries offering a specific swap service
     *
     * @param _swapType Swap service type to check supported tokens for
     */ getSupportedTokensForSwapType(_swapType) {
        const tokens = {};
        this.intermediaryDiscovery.intermediaries.forEach((lp)=>{
            for (let chainId of this.getSmartChains()){
                let swapType = _swapType;
                if (swapType === SwapType_1.SwapType.FROM_BTC && this.supportsSwapType(chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC)) swapType = SwapType_1.SwapType.SPV_VAULT_FROM_BTC;
                if (lp.services[swapType] == null) break;
                if (lp.services[swapType].chainTokens == null) break;
                if (lp.services[swapType].chainTokens[chainId] == null) continue;
                for (let tokenAddress of lp.services[swapType].chainTokens[chainId]){
                    var _tokens, _chainId;
                    var _;
                    (_ = (_tokens = tokens)[_chainId = chainId]) !== null && _ !== void 0 ? _ : _tokens[_chainId] = new Set();
                    tokens[chainId].add(tokenAddress);
                }
            }
        });
        const output = [];
        for(let chainId in tokens){
            tokens[chainId].forEach((tokenAddress)=>{
                var _this_tokens_chainId, _this_tokens;
                const token = (_this_tokens = this.tokens) === null || _this_tokens === void 0 ? void 0 : (_this_tokens_chainId = _this_tokens[chainId]) === null || _this_tokens_chainId === void 0 ? void 0 : _this_tokens_chainId[tokenAddress];
                if (token != null) output.push(token);
            });
        }
        return output;
    }
    /**
     * Returns the set of supported token addresses by all the intermediaries we know of offering a specific swapType service
     *
     * @param chainIdentifier
     * @param swapType Specific swap type for which to obtain supported tokens
     */ getSupportedTokenAddresses(chainIdentifier, swapType) {
        const set = new Set();
        this.intermediaryDiscovery.intermediaries.forEach((lp)=>{
            if (lp.services[swapType] == null) return;
            if (lp.services[swapType].chainTokens == null || lp.services[swapType].chainTokens[chainIdentifier] == null) return;
            lp.services[swapType].chainTokens[chainIdentifier].forEach((token)=>set.add(token));
        });
        return set;
    }
    /**
     * Returns tokens that you can swap to (if input=true) from a given token,
     *  or tokens that you can swap from (if input=false) to a given token
     */ getSwapCounterTokens(token, input) {
        if ((0, Tokens_1.isSCToken)(token)) {
            const result = [];
            if (input) {
                //TO_BTC or TO_BTCLN
                if (this.getSupportedTokenAddresses(token.chainId, SwapType_1.SwapType.TO_BTCLN).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTCLN);
                }
                if (this.getSupportedTokenAddresses(token.chainId, SwapType_1.SwapType.TO_BTC).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTC);
                }
            } else {
                //FROM_BTC or FROM_BTCLN
                if (this.getSupportedTokenAddresses(token.chainId, SwapType_1.SwapType.FROM_BTCLN).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTCLN);
                }
                const fromOnchainSwapType = this.supportsSwapType(token.chainId, SwapType_1.SwapType.SPV_VAULT_FROM_BTC) ? SwapType_1.SwapType.SPV_VAULT_FROM_BTC : SwapType_1.SwapType.FROM_BTC;
                if (this.getSupportedTokenAddresses(token.chainId, fromOnchainSwapType).has(token.address)) {
                    result.push(Tokens_1.BitcoinTokens.BTC);
                }
            }
            return result;
        } else {
            if (input) {
                if (token.lightning) {
                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.FROM_BTCLN);
                } else {
                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.FROM_BTC);
                }
            } else {
                if (token.lightning) {
                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.TO_BTCLN);
                } else {
                    return this.getSupportedTokensForSwapType(SwapType_1.SwapType.TO_BTC);
                }
            }
        }
    }
    getSwapBounds(chainIdentifier) {
        if (this.intermediaryDiscovery != null) {
            if (chainIdentifier == null) {
                return this.intermediaryDiscovery.getMultichainSwapBounds();
            } else {
                return this.intermediaryDiscovery.getSwapBounds(chainIdentifier);
            }
        }
        return null;
    }
    /**
     * Returns maximum possible swap amount
     * @deprecated Use getSwapLimits() instead!
     *
     * @param chainIdentifier
     * @param type      Type of the swap
     * @param token     Token of the swap
     */ getMaximum(chainIdentifier, type, token) {
        if (this.intermediaryDiscovery != null) {
            const max = this.intermediaryDiscovery.getSwapMaximum(chainIdentifier, type, token);
            if (max != null) return BigInt(max);
        }
        return 0n;
    }
    /**
     * Returns minimum possible swap amount
     * @deprecated Use getSwapLimits() instead!
     *
     * @param chainIdentifier
     * @param type      Type of swap
     * @param token     Token of the swap
     */ getMinimum(chainIdentifier, type, token) {
        if (this.intermediaryDiscovery != null) {
            const min = this.intermediaryDiscovery.getSwapMinimum(chainIdentifier, type, token);
            if (min != null) return BigInt(min);
        }
        return 0n;
    }
    constructor(bitcoinRpc, chainsData, pricing, tokens, options){
        var _options;
        super();
        this.logger = (0, Utils_1.getLogger)(this.constructor.name + ": ");
        this.SwapTypeInfo = {
            [SwapType_1.SwapType.TO_BTC]: {
                requiresInputWallet: true,
                requiresOutputWallet: false,
                supportsGasDrop: false
            },
            [SwapType_1.SwapType.TO_BTCLN]: {
                requiresInputWallet: true,
                requiresOutputWallet: false,
                supportsGasDrop: false
            },
            [SwapType_1.SwapType.FROM_BTC]: {
                requiresInputWallet: false,
                requiresOutputWallet: true,
                supportsGasDrop: false
            },
            [SwapType_1.SwapType.FROM_BTCLN]: {
                requiresInputWallet: false,
                requiresOutputWallet: true,
                supportsGasDrop: false
            },
            [SwapType_1.SwapType.SPV_VAULT_FROM_BTC]: {
                requiresInputWallet: true,
                requiresOutputWallet: false,
                supportsGasDrop: true
            },
            [SwapType_1.SwapType.TRUSTED_FROM_BTC]: {
                requiresInputWallet: false,
                requiresOutputWallet: false,
                supportsGasDrop: false
            },
            [SwapType_1.SwapType.TRUSTED_FROM_BTCLN]: {
                requiresInputWallet: false,
                requiresOutputWallet: false,
                supportsGasDrop: false
            }
        };
        var _options_storagePrefix;
        const storagePrefix = (_options_storagePrefix = options === null || options === void 0 ? void 0 : options.storagePrefix) !== null && _options_storagePrefix !== void 0 ? _options_storagePrefix : "atomiq-";
        options.bitcoinNetwork = options.bitcoinNetwork == null ? base_1.BitcoinNetwork.TESTNET : options.bitcoinNetwork;
        var _swapStorage;
        (_swapStorage = (_options = options).swapStorage) !== null && _swapStorage !== void 0 ? _swapStorage : _options.swapStorage = (name)=>new IndexedDBUnifiedStorage_1.IndexedDBUnifiedStorage(name);
        this._bitcoinNetwork = options.bitcoinNetwork;
        this.bitcoinNetwork = options.bitcoinNetwork === base_1.BitcoinNetwork.MAINNET ? utils_1.NETWORK : options.bitcoinNetwork === base_1.BitcoinNetwork.TESTNET || options.bitcoinNetwork === base_1.BitcoinNetwork.TESTNET4 ? utils_1.TEST_NETWORK : {
            bech32: 'bcrt',
            pubKeyHash: 111,
            scriptHash: 196,
            wif: 239
        };
        this.Utils = new SwapperUtils_1.SwapperUtils(this);
        this.prices = pricing;
        this.bitcoinRpc = bitcoinRpc;
        this.mempoolApi = bitcoinRpc.api;
        this.options = options;
        this.tokens = {};
        for (let tokenData of tokens){
            for(let chainId in tokenData.chains){
                var _this_tokens, _chainId;
                const chainData = tokenData.chains[chainId];
                var _;
                (_ = (_this_tokens = this.tokens)[_chainId = chainId]) !== null && _ !== void 0 ? _ : _this_tokens[_chainId] = {};
                this.tokens[chainId][chainData.address] = {
                    chain: "SC",
                    chainId,
                    ticker: tokenData.ticker,
                    name: tokenData.name,
                    decimals: chainData.decimals,
                    displayDecimals: chainData.displayDecimals,
                    address: chainData.address
                };
            }
        }
        this.swapStateListener = (swap)=>{
            this.emit("swapState", swap);
        };
        this.chains = (0, Utils_1.objectMap)(chainsData, (chainData, key)=>{
            const { swapContract, chainEvents, btcRelay, chainInterface, spvVaultContract, spvVaultWithdrawalDataConstructor } = chainData;
            const synchronizer = new MempoolBtcRelaySynchronizer_1.MempoolBtcRelaySynchronizer(btcRelay, bitcoinRpc);
            const storageHandler = options.swapStorage(storagePrefix + chainData.chainId);
            const unifiedSwapStorage = new UnifiedSwapStorage_1.UnifiedSwapStorage(storageHandler, this.options.noSwapCache);
            const unifiedChainEvents = new UnifiedSwapEventListener_1.UnifiedSwapEventListener(unifiedSwapStorage, chainEvents);
            const wrappers = {};
            wrappers[SwapType_1.SwapType.TO_BTCLN] = new ToBTCLNWrapper_1.ToBTCLNWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, {
                getRequestTimeout: options.getRequestTimeout,
                postRequestTimeout: options.postRequestTimeout
            });
            wrappers[SwapType_1.SwapType.TO_BTC] = new ToBTCWrapper_1.ToBTCWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, this.bitcoinRpc, {
                getRequestTimeout: options.getRequestTimeout,
                postRequestTimeout: options.postRequestTimeout,
                bitcoinNetwork: this.bitcoinNetwork
            });
            wrappers[SwapType_1.SwapType.FROM_BTCLN] = new FromBTCLNWrapper_1.FromBTCLNWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, bitcoinRpc, {
                getRequestTimeout: options.getRequestTimeout,
                postRequestTimeout: options.postRequestTimeout,
                unsafeSkipLnNodeCheck: this._bitcoinNetwork === base_1.BitcoinNetwork.TESTNET4 || this._bitcoinNetwork === base_1.BitcoinNetwork.REGTEST
            });
            wrappers[SwapType_1.SwapType.FROM_BTC] = new FromBTCWrapper_1.FromBTCWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, swapContract, pricing, tokens, chainData.swapDataConstructor, btcRelay, synchronizer, this.bitcoinRpc, {
                getRequestTimeout: options.getRequestTimeout,
                postRequestTimeout: options.postRequestTimeout,
                bitcoinNetwork: this.bitcoinNetwork
            });
            wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTCLN] = new LnForGasWrapper_1.LnForGasWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, pricing, tokens, {
                getRequestTimeout: options.getRequestTimeout,
                postRequestTimeout: options.postRequestTimeout
            });
            wrappers[SwapType_1.SwapType.TRUSTED_FROM_BTC] = new OnchainForGasWrapper_1.OnchainForGasWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, pricing, tokens, bitcoinRpc, {
                getRequestTimeout: options.getRequestTimeout,
                postRequestTimeout: options.postRequestTimeout,
                bitcoinNetwork: this.bitcoinNetwork
            });
            if (spvVaultContract != null) {
                wrappers[SwapType_1.SwapType.SPV_VAULT_FROM_BTC] = new SpvFromBTCWrapper_1.SpvFromBTCWrapper(key, unifiedSwapStorage, unifiedChainEvents, chainInterface, spvVaultContract, pricing, tokens, spvVaultWithdrawalDataConstructor, btcRelay, synchronizer, bitcoinRpc, {
                    getRequestTimeout: options.getRequestTimeout,
                    postRequestTimeout: options.postRequestTimeout,
                    bitcoinNetwork: this.bitcoinNetwork
                });
            }
            Object.keys(wrappers).forEach((key)=>wrappers[key].events.on("swapState", this.swapStateListener));
            const reviver = (val)=>{
                const wrapper = wrappers[val.type];
                if (wrapper == null) return null;
                return new wrapper.swapDeserializer(wrapper, val);
            };
            return {
                chainEvents,
                spvVaultContract,
                swapContract,
                chainInterface,
                btcRelay,
                synchronizer,
                wrappers,
                unifiedChainEvents,
                unifiedSwapStorage,
                reviver
            };
        });
        const contracts = (0, Utils_1.objectMap)(chainsData, (data)=>data.swapContract);
        if (options.intermediaryUrl != null) {
            this.intermediaryDiscovery = new IntermediaryDiscovery_1.IntermediaryDiscovery(contracts, options.registryUrl, Array.isArray(options.intermediaryUrl) ? options.intermediaryUrl : [
                options.intermediaryUrl
            ], options.getRequestTimeout);
        } else {
            this.intermediaryDiscovery = new IntermediaryDiscovery_1.IntermediaryDiscovery(contracts, options.registryUrl, null, options.getRequestTimeout);
        }
        this.intermediaryDiscovery.on("removed", (intermediaries)=>{
            this.emit("lpsRemoved", intermediaries);
        });
        this.intermediaryDiscovery.on("added", (intermediaries)=>{
            this.emit("lpsAdded", intermediaries);
        });
    }
}
exports.Swapper = Swapper;
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/storage/IUnifiedStorage.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@atomiqlabs/sdk-lib/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/synchronizer/MempoolBtcRelaySynchronizer.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolApi.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolBitcoinRpc.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/mempool/MempoolBitcoinBlock.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/BitcoinRpcWithAddressIndex.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/LightningNetworkApi.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/IBitcoinWallet.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/BitcoinWallet.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/wallet/SingleAddressBitcoinWallet.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/btc/coinselect2/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/IntermediaryError.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/PaymentAuthError.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/RequestError.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/errors/UserError.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/Intermediary.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/intermediaries/IntermediaryDiscovery.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ICachedSwapPrice.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/IPriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/abstract/ISwapPrice.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/ExchangePriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/abstract/HttpPriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/BinancePriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CoinGeckoPriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CoinPaprikaPriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/OKXPriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/providers/CustomPriceProvider.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/RedundantSwapPrice.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/SingleSwapPrice.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/prices/SwapPriceWithChain.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/Tokens.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/IAddressSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/ISwapWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/Swapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithChain.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/SwapperWithSigner.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/swapper/utils/SwapperUtils.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapType.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/enums/SwapDirection.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwapWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/IEscrowSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/IToBTCWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/ln/ToBTCLNWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/tobtc/onchain/ToBTCWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/IFromBTCWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/ln/FromBTCLNWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/escrow_swaps/frombtc/onchain/FromBTCWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/ln/LnForGasWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/trusted/onchain/OnchainForGasWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCSwap.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/spv_swaps/SpvFromBTCWrapper.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/utils/LNURL.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/storage/IUnifiedStorage.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/browser-storage/IndexedDBUnifiedStorage.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@atomiqlabs/sdk-lib/dist/swaps/fee/Fee.js [app-client] (ecmascript)"), exports);
}),
]);

//# sourceMappingURL=node_modules_%40atomiqlabs_sdk-lib_dist_325198df._.js.map