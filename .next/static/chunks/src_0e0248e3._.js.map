{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/src/config/constants.ts"],"sourcesContent":["export const MIXING_DELAY_MS = 200; // legacy placeholder\nexport const MIX_MIN_DELAY_MS = 1_000; // 1s minimal jitter window\nexport const MIX_MAX_DELAY_MS = 15_000; // 15s upper bound (tunable)\nexport const SPLIT_MAX_PARTS = 8;\nexport const SPLIT_MIN_DENOM = 1n; // smallest sat denomination for splitting\nexport const VERSION = '0.0.1-mvp';\n\n\nexport const PRIVACY_MIXER = {\n    CONTRACT_ADDRESS: '0x05effdcfda86066c72c108e174c55a4f8d1249ba69f80e975d7fc814199a376b',\n    CLASS_HASH: '0x00abc35fe33a082fad61df2a88160f16202d1a08cc338f1954063320063be4d5',\n    STRK_TOKEN: '0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d',\n    DEPLOYMENT_PARAMS: {\n        OWNER: '0x01734203d1C5B2699B3dbC50223c86EC59E2B79E2d34CBE8363F0dCCdC1E9634',\n        MIN_DEPOSIT: 1000000000000000000n, // 1 STRK\n        MAX_DEPOSIT: 1000000000000000000000n, // 1000 STRK\n        MIN_DELAY: 0n, // 0 seconds for testing\n        MIN_ANONYMITY: 0n, // 0 for testing\n        FEE_RATE: 10n // 1% (10000 = 100%)\n    }\n} as const;\n\nexport const SHARED_SWAP_ACCOUNT_ADDRESS = '0x075a05264A7D0ebB864abFbE2bbFeE33D085EB77397b939bD17d55c2e69d87D3';\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAO,MAAM,kBAAkB,KAAK,qBAAqB;AAClD,MAAM,mBAAmB,OAAO,2BAA2B;AAC3D,MAAM,mBAAmB,QAAQ,4BAA4B;AAC7D,MAAM,kBAAkB;AACxB,MAAM,kBAAkB,EAAE,EAAE,0CAA0C;AACtE,MAAM,UAAU;AAGhB,MAAM,gBAAgB;IACzB,kBAAkB;IAClB,YAAY;IACZ,YAAY;IACZ,mBAAmB;QACf,OAAO;QACP,aAAa,oBAAoB;QACjC,aAAa,uBAAuB;QACpC,WAAW,EAAE;QACb,eAAe,EAAE;QACjB,UAAU,GAAG,CAAC,oBAAoB;IACtC;AACJ;AAEO,MAAM,8BAA8B","debugId":null}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/src/config/env.ts"],"sourcesContent":["// Centralized environment parsing and defaults\n\nexport const ENV = {\n    NETWORK: (process.env.NEXT_PUBLIC_NETWORK || 'MAINNET') as 'MAINNET' | 'TESTNET',\n\n    // Starknet RPC Configuration\n    STARKNET_RPC: process.env.NEXT_PUBLIC_STARKNET_RPC || process.env.STARKNET_RPC || '',\n    STARKNET_PRIVATE_KEY: process.env.STARKNET_PRIVATE_KEY || '',\n    SHARED_SWAP_ACCOUNT_PRIVATE_KEY: process.env.SHARED_SWAP_ACCOUNT_PRIVATE_KEY || process.env.NEXT_PUBLIC_SHARED_SWAP_ACCOUNT_PRIVATE_KEY || '',\n    // Optional: allow overriding address via env (falls back to constant)\n    SHARED_SWAP_ACCOUNT_ADDRESS: process.env.SHARED_SWAP_ACCOUNT_ADDRESS || '',\n\n    // Privacy Mixer Contract\n    MIXER_CONTRACT_ADDRESS: process.env.NEXT_PUBLIC_MIXER_CONTRACT_ADDRESS || process.env.MIXER_CONTRACT_ADDRESS || '',\n\n    // Lightning Network Configuration\n    LND_URL: process.env.NEXT_PUBLIC_LND_URL || process.env.LND_URL || '',\n    LND_MACAROON: process.env.NEXT_PUBLIC_LND_MACAROON || process.env.LND_MACAROON || '',\n    LND_TLS: process.env.NEXT_PUBLIC_LND_TLS || process.env.LND_TLS || '',\n\n    // Cashu Configuration\n    CASHU_MINTS: (process.env.NEXT_PUBLIC_CASHU_MINTS || process.env.CASHU_MINTS || '')\n        .split(',')\n        .map((s) => s.trim())\n        .filter(Boolean),\n    CASHU_DEFAULT_MINT:\n        process.env.NEXT_PUBLIC_CASHU_MINT || process.env.CASHU_MINT || 'https://mint.coinos.io',\n\n    // Privacy behavior overrides\n    CASHU_SINGLE_MINT:\n        (process.env.NEXT_PUBLIC_CASHU_SINGLE_MINT || process.env.CASHU_SINGLE_MINT || 'false') === 'true',\n    DISABLE_CASHU_SPLIT:\n        (process.env.NEXT_PUBLIC_DISABLE_CASHU_SPLIT || process.env.DISABLE_CASHU_SPLIT || 'false') === 'true',\n\n    // Rate / Pricing Overrides\n    // If STRK_BTC_RATE provided (BTC per STRK), convert to sats; else use explicit STRK_SATS_RATE; else default 125\n    STRK_BTC_RATE: Number(process.env.NEXT_PUBLIC_STRK_BTC_RATE || process.env.STRK_BTC_RATE || '0'),\n    STRK_SATS_RATE: (() => {\n        const explicit = process.env.NEXT_PUBLIC_STRK_SATS_RATE || process.env.STRK_SATS_RATE;\n        if (explicit) return Number(explicit);\n        const btcPerStrk = Number(process.env.NEXT_PUBLIC_STRK_BTC_RATE || process.env.STRK_BTC_RATE || '0');\n        if (btcPerStrk && !isNaN(btcPerStrk) && btcPerStrk > 0) {\n            return Math.floor(btcPerStrk * 100_000_000); // sats\n        }\n        return 125; // updated conservative default\n    })(),\n    DISABLE_ATOMIQ_PRICE_FETCH: (process.env.NEXT_PUBLIC_DISABLE_ATOMIQ_PRICE_FETCH || process.env.DISABLE_ATOMIQ_PRICE_FETCH || 'false') === 'true',\n    ALLOW_SWAP_PRICE_FALLBACK: process.env.ALLOW_SWAP_PRICE_FALLBACK === 'true' || false // Real swaps only\n};\n\nexport type Network = typeof ENV.NETWORK;\n\n// Get default RPC based on network if not configured\nexport function getStarknetRpc(): string {\n    if (ENV.STARKNET_RPC) {\n        return ENV.STARKNET_RPC;\n    }\n\n    // Use network-specific defaults\n    switch (ENV.NETWORK) {\n        case 'MAINNET':\n            return 'https://starknet-mainnet.g.alchemy.com/starknet/version/rpc/v0_8/kwgGr9GGk4YyLXuGfEvpITv1jpvn3PgP';\n        case 'TESTNET':\n            // Prefer newer RPC versions for reliable gas pricing fields\n            return 'https://starknet-sepolia.public.blastapi.io/rpc/v0_10';\n        default:\n            return 'https://starknet-mainnet.g.alchemy.com/starknet/version/rpc/v0_8/kwgGr9GGk4YyLXuGfEvpITv1jpvn3PgP';  // Default to mainnet now\n    }\n}\n\n// Configuration validation\nexport function validateConfig(): { valid: boolean; errors: string[]; warnings: string[] } {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Critical validations\n    if (!ENV.NETWORK || !['MAINNET', 'TESTNET'].includes(ENV.NETWORK)) {\n        errors.push('Invalid network configuration');\n    }\n\n    if (!ENV.CASHU_DEFAULT_MINT) {\n        errors.push('No Cashu mint configured');\n    }\n\n    // Testnet readiness warnings\n    if (!ENV.STARKNET_RPC) {\n        warnings.push(`Using default ${ENV.NETWORK} Starknet RPC - configure STARKNET_RPC for better reliability`);\n    }\n\n    if (!ENV.LND_URL) {\n        warnings.push('Lightning node URL not configured - using fallback mode');\n    }\n\n    if (ENV.CASHU_MINTS.length === 0) {\n        warnings.push('No multi-mint configuration - using single mint mode');\n    }\n\n    if (!ENV.STARKNET_PRIVATE_KEY && typeof window === 'undefined') {\n        warnings.push('No Starknet private key configured for server-side operations');\n    }\n\n    // Shared swap account checks (prototype central account approach)\n    if (!ENV.SHARED_SWAP_ACCOUNT_PRIVATE_KEY) {\n        warnings.push('Shared swap account private key not set (SHARED_SWAP_ACCOUNT_PRIVATE_KEY) - STRK -> Lightning swaps may fail to sign');\n    }\n\n    // Log warnings\n    warnings.forEach(warning => console.warn(warning));\n\n    return {\n        valid: errors.length === 0,\n        errors,\n        warnings\n    };\n}\n\n// Check if configuration is ready for testnet testing\nexport function isTestnetReady(): boolean {\n    const checks = [\n        ENV.NETWORK === 'TESTNET' &&\n        ENV.STARKNET_RPC &&\n        ENV.STARKNET_PRIVATE_KEY &&\n        ENV.CASHU_DEFAULT_MINT\n    ];\n\n    return checks.every(Boolean);\n}\n\n// Check if configuration is ready for mainnet operations\nexport function isMainnetReady(): boolean {\n    const isClientSide = typeof window !== 'undefined';\n\n    const checks = [\n        ENV.NETWORK === 'MAINNET' &&\n        ENV.STARKNET_RPC &&\n        (isClientSide || ENV.STARKNET_PRIVATE_KEY) && // Private key only required server-side\n        ENV.CASHU_DEFAULT_MINT &&\n        ENV.LND_URL && ENV.LND_MACAROON  // Lightning required for mainnet\n    ];\n\n    return checks.every(Boolean);\n}\n\n// Get network configuration status\nexport function getNetworkStatus(): {\n    network: string;\n    starknetRpc: boolean;\n    privateKey: boolean;\n    cashuMint: boolean;\n    lightningNode: boolean;\n    lightningConfigured: boolean;\n    cashuMints: number;\n    ready: boolean;\n    warnings: string[];\n} {\n    const lightningConfigured = Boolean(ENV.LND_URL && ENV.LND_MACAROON);\n    const isReady = ENV.NETWORK === 'MAINNET' ? isMainnetReady() : isTestnetReady();\n\n    return {\n        network: ENV.NETWORK,\n        starknetRpc: Boolean(ENV.STARKNET_RPC),\n        privateKey: Boolean(ENV.STARKNET_PRIVATE_KEY),\n        cashuMint: Boolean(ENV.CASHU_DEFAULT_MINT),\n        lightningNode: Boolean(ENV.LND_URL),\n        lightningConfigured,\n        cashuMints: ENV.CASHU_MINTS.length,\n        ready: isReady,\n        warnings: (() => {\n            const warnings = [];\n            const isClientSide = typeof window !== 'undefined';\n\n            if (!ENV.STARKNET_RPC) warnings.push('STARKNET_RPC not configured');\n            if (!ENV.STARKNET_PRIVATE_KEY && !isClientSide) warnings.push('STARKNET_PRIVATE_KEY not configured');\n            if (!ENV.CASHU_DEFAULT_MINT) warnings.push('CASHU_DEFAULT_MINT not configured');\n            if (ENV.NETWORK === 'MAINNET') {\n                if (!ENV.LND_URL) warnings.push('Lightning node (LND_URL) required for mainnet');\n                if (!ENV.LND_MACAROON) warnings.push('Lightning authentication (LND_MACAROON) required for mainnet');\n            }\n            return warnings;\n        })()\n    };\n}\n\n// Backward compatibility\nexport function getTestnetStatus() {\n    return getNetworkStatus();\n}\n\n// Initialize configuration validation\nexport const CONFIG_STATUS = validateConfig();"],"names":[],"mappings":"AAAA,+CAA+C;;;;;;;;;;;;;;;;;;;AAGjC;AADP,MAAM,MAAM;IACf,SAAU,+CAAmC;IAE7C,6BAA6B;IAC7B,cAAc,yIAAwC,2KAAO,CAAC,GAAG,CAAC,YAAY,IAAI;IAClF,sBAAsB,2KAAO,CAAC,GAAG,CAAC,oBAAoB,IAAI;IAC1D,iCAAiC,2KAAO,CAAC,GAAG,CAAC,+BAA+B,8GAA+D;IAC3I,sEAAsE;IACtE,6BAA6B,2KAAO,CAAC,GAAG,CAAC,2BAA2B,IAAI;IAExE,yBAAyB;IACzB,wBAAwB,0GAAkD,2KAAO,CAAC,GAAG,CAAC,sBAAsB,IAAI;IAEhH,kCAAkC;IAClC,SAAS,8EAAmC,2KAAO,CAAC,GAAG,CAAC,OAAO,IAAI;IACnE,cAAc,4TAAwC,2KAAO,CAAC,GAAG,CAAC,YAAY,IAAI;IAClF,SAAS,g2IAAmC,2KAAO,CAAC,GAAG,CAAC,OAAO,IAAI;IAEnE,sBAAsB;IACtB,aAAa,CAAC,8DAAuC,2KAAO,CAAC,GAAG,CAAC,WAAW,IAAI,EAAE,EAC7E,KAAK,CAAC,KACN,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,IACjB,MAAM,CAAC;IACZ,oBACI,8DAAsC,2KAAO,CAAC,GAAG,CAAC,UAAU,IAAI;IAEpE,6BAA6B;IAC7B,mBACI,CAAC,4CAA6C,2KAAO,CAAC,GAAG,CAAC,iBAAiB,IAAI,OAAO,MAAM;IAChG,qBACI,CAAC,4CAA+C,2KAAO,CAAC,GAAG,CAAC,mBAAmB,IAAI,OAAO,MAAM;IAEpG,2BAA2B;IAC3B,gHAAgH;IAChH,eAAe,OAAO,2KAAO,CAAC,GAAG,CAAC,yBAAyB,IAAI,2KAAO,CAAC,GAAG,CAAC,aAAa,IAAI;IAC5F,gBAAgB,CAAC;QACb,MAAM,WAAW,2KAAO,CAAC,GAAG,CAAC,0BAA0B,IAAI,2KAAO,CAAC,GAAG,CAAC,cAAc;QACrF,IAAI,UAAU,OAAO,OAAO;QAC5B,MAAM,aAAa,OAAO,2KAAO,CAAC,GAAG,CAAC,yBAAyB,IAAI,2KAAO,CAAC,GAAG,CAAC,aAAa,IAAI;QAChG,IAAI,cAAc,CAAC,MAAM,eAAe,aAAa,GAAG;YACpD,OAAO,KAAK,KAAK,CAAC,aAAa,cAAc,OAAO;QACxD;QACA,OAAO,KAAK,+BAA+B;IAC/C,CAAC;IACD,4BAA4B,CAAC,6CAAsD,2KAAO,CAAC,GAAG,CAAC,0BAA0B,IAAI,OAAO,MAAM;IAC1I,2BAA2B,2KAAO,CAAC,GAAG,CAAC,yBAAyB,KAAK,UAAU,MAAM,kBAAkB;AAC3G;AAKO,SAAS;IACZ,IAAI,IAAI,YAAY,EAAE;QAClB,OAAO,IAAI,YAAY;IAC3B;IAEA,gCAAgC;IAChC,OAAQ,IAAI,OAAO;QACf,KAAK;YACD,OAAO;QACX,KAAK;YACD,4DAA4D;YAC5D,OAAO;QACX;YACI,OAAO,qGAAsG,yBAAyB;IAC9I;AACJ;AAGO,SAAS;IACZ,MAAM,SAAmB,EAAE;IAC3B,MAAM,WAAqB,EAAE;IAE7B,uBAAuB;IACvB,IAAI,CAAC,IAAI,OAAO,IAAI,CAAC;QAAC;QAAW;KAAU,CAAC,QAAQ,CAAC,IAAI,OAAO,GAAG;QAC/D,OAAO,IAAI,CAAC;IAChB;IAEA,IAAI,CAAC,IAAI,kBAAkB,EAAE;QACzB,OAAO,IAAI,CAAC;IAChB;IAEA,6BAA6B;IAC7B,IAAI,CAAC,IAAI,YAAY,EAAE;QACnB,SAAS,IAAI,CAAC,AAAC,iBAA4B,OAAZ,IAAI,OAAO,EAAC;IAC/C;IAEA,IAAI,CAAC,IAAI,OAAO,EAAE;QACd,SAAS,IAAI,CAAC;IAClB;IAEA,IAAI,IAAI,WAAW,CAAC,MAAM,KAAK,GAAG;QAC9B,SAAS,IAAI,CAAC;IAClB;IAEA;;IAIA,kEAAkE;IAClE;;IAIA,eAAe;IACf,SAAS,OAAO,CAAC,CAAA,UAAW,QAAQ,IAAI,CAAC;IAEzC,OAAO;QACH,OAAO,OAAO,MAAM,KAAK;QACzB;QACA;IACJ;AACJ;AAGO,SAAS;IACZ,MAAM,SAAS;QACX,IAAI,OAAO,KAAK,aAChB,IAAI,YAAY,IAChB,IAAI,oBAAoB,IACxB,IAAI,kBAAkB;KACzB;IAED,OAAO,OAAO,KAAK,CAAC;AACxB;AAGO,SAAS;IACZ,MAAM,eAAe,aAAkB;IAEvC,MAAM,SAAS;QACX,IAAI,OAAO,KAAK,aAChB,IAAI,YAAY,IAChB,CAAC,gBAAgB,IAAI,oBAAoB,KAAK,wCAAwC;QACtF,IAAI,kBAAkB,IACtB,IAAI,OAAO,IAAI,IAAI,YAAY,CAAE,iCAAiC;KACrE;IAED,OAAO,OAAO,KAAK,CAAC;AACxB;AAGO,SAAS;IAWZ,MAAM,sBAAsB,QAAQ,IAAI,OAAO,IAAI,IAAI,YAAY;IACnE,MAAM,UAAU,IAAI,OAAO,KAAK,YAAY,mBAAmB;IAE/D,OAAO;QACH,SAAS,IAAI,OAAO;QACpB,aAAa,QAAQ,IAAI,YAAY;QACrC,YAAY,QAAQ,IAAI,oBAAoB;QAC5C,WAAW,QAAQ,IAAI,kBAAkB;QACzC,eAAe,QAAQ,IAAI,OAAO;QAClC;QACA,YAAY,IAAI,WAAW,CAAC,MAAM;QAClC,OAAO;QACP,UAAU,CAAC;YACP,MAAM,WAAW,EAAE;YACnB,MAAM,eAAe,aAAkB;YAEvC,IAAI,CAAC,IAAI,YAAY,EAAE,SAAS,IAAI,CAAC;YACrC;;YACA,IAAI,CAAC,IAAI,kBAAkB,EAAE,SAAS,IAAI,CAAC;YAC3C,IAAI,IAAI,OAAO,KAAK,WAAW;gBAC3B,IAAI,CAAC,IAAI,OAAO,EAAE,SAAS,IAAI,CAAC;gBAChC,IAAI,CAAC,IAAI,YAAY,EAAE,SAAS,IAAI,CAAC;YACzC;YACA,OAAO;QACX,CAAC;IACL;AACJ;AAGO,SAAS;IACZ,OAAO;AACX;AAGO,MAAM,gBAAgB","debugId":null}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/src/integrations/starknet/privacy-mixer-contract.ts"],"sourcesContent":["/**\n * TypeScript interface for interacting with the Starknet Privacy Mixer smart contract\n * Provides type-safe access to all contract functions and events\n */\n\nimport { Account, Contract, Provider, RpcProvider, CallData, InvokeFunctionResponse } from 'starknet';\nimport { PRIVACY_MIXER } from '@/config/constants';\nimport { ENV } from '@/config/env';\nimport privacyMixerAbi from '@/config/privacy-mixer-abi.json';\n\nexport interface MixingStats {\n    total_deposits: bigint;\n    total_withdrawals: bigint;\n    active_commitments: bigint;\n    anonymity_set_size: bigint;\n    mixing_efficiency: bigint;\n}\n\nexport interface PrivacyMetrics {\n    min_anonymity_set: bigint;\n    avg_mixing_time: bigint;\n    unlinkability_score: bigint;\n    temporal_privacy_score: bigint;\n}\n\nexport interface AccountInfo {\n    owner: string;\n    account_type: bigint;\n    balance: bigint;\n    metadata: bigint;\n    created_at: bigint;\n    last_activity: bigint;\n}\n\nexport interface DepositEvent {\n    commitment: string;\n    amount: bigint;\n    depositor: string;\n    timestamp: bigint;\n    anonymity_set_size: bigint;\n}\n\nexport interface WithdrawalEvent {\n    nullifier: string;\n    recipient: string;\n    amount: bigint;\n    timestamp: bigint;\n    anonymity_set_size: bigint;\n}\n\nexport interface PrivacyMixerContractInterface {\n    // Deposit operations\n    deposit(commitment: string, amount: bigint): Promise<InvokeFunctionResponse>;\n    batch_deposit(commitments: string[], amounts: bigint[]): Promise<InvokeFunctionResponse>;\n\n    // Withdrawal operations\n    withdraw(\n        nullifier: string,\n        commitment: string,\n        recipient: string,\n        amount: bigint,\n        proof: string[]\n    ): Promise<InvokeFunctionResponse>;\n\n    // View functions\n    get_anonymity_set_size(): Promise<bigint>;\n    get_total_deposits(): Promise<bigint>;\n    get_total_withdrawals(): Promise<bigint>;\n    is_nullifier_used(nullifier: string): Promise<boolean>;\n    is_commitment_valid(commitment: string): Promise<boolean>;\n\n    // Account management\n    register_account(account_type: bigint, metadata: string): Promise<InvokeFunctionResponse>;\n    get_account_balance(account_id: string): Promise<bigint>;\n    transfer_between_accounts(from: string, to: string, amount: bigint): Promise<InvokeFunctionResponse>;\n\n    // Admin functions\n    emergency_pause(): Promise<InvokeFunctionResponse>;\n    emergency_unpause(): Promise<InvokeFunctionResponse>;\n    is_paused(): Promise<boolean>;\n\n    // Analytics\n    get_mixing_stats(): Promise<MixingStats>;\n    verify_privacy_guarantees(): Promise<PrivacyMetrics>;\n}\n\nexport class PrivacyMixerContract implements PrivacyMixerContractInterface {\n    private contract: Contract;\n    private account: Account;\n    private provider: Provider;\n\n    constructor(\n        contractAddress: string,\n        account: Account,\n        provider: Provider\n    ) {\n        this.account = account;\n        this.provider = provider;\n        this.contract = new Contract(privacyMixerAbi, contractAddress, provider);\n        this.contract.connect(account);\n    }\n\n    async deposit(commitment: string, amount: bigint): Promise<InvokeFunctionResponse> {\n        // Convert hex string to felt252 format for Cairo\n        const commitmentFelt = commitment.startsWith('0x') ? commitment : '0x' + commitment;\n        return await this.contract.deposit(commitmentFelt, amount);\n    }\n\n    async batch_deposit(commitments: string[], amounts: bigint[]): Promise<InvokeFunctionResponse> {\n        return await this.contract.batch_deposit(commitments, amounts);\n    }\n\n    async withdraw(\n        nullifier: string,\n        commitment: string,\n        recipient: string,\n        amount: bigint,\n        proof: string[]\n    ): Promise<InvokeFunctionResponse> {\n        // Convert hex strings to felt252 format for Cairo\n        const nullifierFelt = nullifier.startsWith('0x') ? nullifier : '0x' + nullifier;\n        const commitmentFelt = commitment.startsWith('0x') ? commitment : '0x' + commitment;\n\n        return await this.contract.withdraw(nullifierFelt, commitmentFelt, recipient, amount, proof);\n    }\n\n    async get_anonymity_set_size(): Promise<bigint> {\n        const result = await this.contract.get_anonymity_set_size();\n        return BigInt(result.toString());\n    }\n\n    async get_total_deposits(): Promise<bigint> {\n        const result = await this.contract.get_total_deposits();\n        return BigInt(result.toString());\n    }\n\n    async get_total_withdrawals(): Promise<bigint> {\n        const result = await this.contract.get_total_withdrawals();\n        return BigInt(result.toString());\n    }\n\n    async is_nullifier_used(nullifier: string): Promise<boolean> {\n        const result = await this.contract.is_nullifier_used(nullifier);\n        return Boolean(result);\n    }\n\n    async is_commitment_valid(commitment: string): Promise<boolean> {\n        const result = await this.contract.is_commitment_valid(commitment);\n        return Boolean(result);\n    }\n\n    async register_account(account_type: bigint, metadata: string): Promise<InvokeFunctionResponse> {\n        return await this.contract.register_account(account_type, metadata);\n    }\n\n    async get_account_balance(account_id: string): Promise<bigint> {\n        const result = await this.contract.get_account_balance(account_id);\n        return BigInt(result.toString());\n    }\n\n    async transfer_between_accounts(from: string, to: string, amount: bigint): Promise<InvokeFunctionResponse> {\n        return await this.contract.transfer_between_accounts(from, to, amount);\n    }\n\n    async emergency_pause(): Promise<InvokeFunctionResponse> {\n        return await this.contract.emergency_pause();\n    }\n\n    async emergency_unpause(): Promise<InvokeFunctionResponse> {\n        return await this.contract.emergency_unpause();\n    }\n\n    async is_paused(): Promise<boolean> {\n        const result = await this.contract.is_paused();\n        return Boolean(result);\n    }\n\n    async get_mixing_stats(): Promise<MixingStats> {\n        const result = await this.contract.get_mixing_stats();\n        return {\n            total_deposits: BigInt(result.total_deposits.toString()),\n            total_withdrawals: BigInt(result.total_withdrawals.toString()),\n            active_commitments: BigInt(result.active_commitments.toString()),\n            anonymity_set_size: BigInt(result.anonymity_set_size.toString()),\n            mixing_efficiency: BigInt(result.mixing_efficiency.toString()),\n        };\n    }\n\n    async verify_privacy_guarantees(): Promise<PrivacyMetrics> {\n        const result = await this.contract.verify_privacy_guarantees();\n        return {\n            min_anonymity_set: BigInt(result.min_anonymity_set.toString()),\n            avg_mixing_time: BigInt(result.avg_mixing_time.toString()),\n            unlinkability_score: BigInt(result.unlinkability_score.toString()),\n            temporal_privacy_score: BigInt(result.temporal_privacy_score.toString()),\n        };\n    }\n\n    // Event handling methods\n    async getDepositEvents(fromBlock?: number, toBlock?: number): Promise<DepositEvent[]> {\n        const events = await this.provider.getEvents({\n            address: this.contract.address,\n            from_block: fromBlock ? { block_number: fromBlock } : undefined,\n            to_block: toBlock ? { block_number: toBlock } : undefined,\n            keys: [['Deposit']], // Event selector\n            chunk_size: 100,\n        });\n\n        return events.events.map(event => ({\n            commitment: event.data[0],\n            amount: BigInt(event.data[1]),\n            depositor: event.data[2],\n            timestamp: BigInt(event.data[3]),\n            anonymity_set_size: BigInt(event.data[4]),\n        }));\n    }\n\n    async getWithdrawalEvents(fromBlock?: number, toBlock?: number): Promise<WithdrawalEvent[]> {\n        const events = await this.provider.getEvents({\n            address: this.contract.address,\n            from_block: fromBlock ? { block_number: fromBlock } : undefined,\n            to_block: toBlock ? { block_number: toBlock } : undefined,\n            keys: [['Withdrawal']], // Event selector\n            chunk_size: 100,\n        });\n\n        return events.events.map(event => ({\n            nullifier: event.data[0],\n            recipient: event.data[1],\n            amount: BigInt(event.data[2]),\n            timestamp: BigInt(event.data[3]),\n            anonymity_set_size: BigInt(event.data[4]),\n        }));\n    }\n\n    // Privacy-specific helper methods\n    async generateCommitment(secret: string, amount: bigint): Promise<string> {\n        // Generate a Pedersen hash commitment\n        // In a real implementation, this would use proper cryptographic libraries\n        const crypto = await import('crypto');\n        const hash = crypto.createHash('sha256')\n            .update(secret)\n            .update(amount.toString())\n            .digest('hex');\n        return '0x' + hash;\n    }\n\n    async generateNullifier(secret: string, commitment: string): Promise<string> {\n        // Generate nullifier from secret and commitment\n        // In a real implementation, this would use proper cryptographic libraries\n        const crypto = await import('crypto');\n        const hash = crypto.createHash('sha256')\n            .update(secret)\n            .update(commitment)\n            .digest('hex');\n        return '0x' + hash;\n    }\n\n    async generateZKProof(\n        secret: string,\n        commitment: string,\n        nullifier: string,\n        recipient: string,\n        amount: bigint\n    ): Promise<string[]> {\n        // Generate zero-knowledge proof for withdrawal\n        // In a real implementation, this would use a proper ZK proving system like circom/snarkjs\n        // For now, we return a mock proof\n        return [\n            nullifier,\n            commitment,\n            recipient,\n            amount.toString(),\n            'mock_proof_element_1',\n            'mock_proof_element_2',\n            'mock_proof_element_3',\n        ];\n    }\n\n    // Utility methods for privacy analysis\n    async calculatePrivacyScore(): Promise<number> {\n        const metrics = await this.verify_privacy_guarantees();\n        const stats = await this.get_mixing_stats();\n\n        // Simple privacy score calculation\n        const anonymityScore = Number(metrics.unlinkability_score);\n        const temporalScore = Number(metrics.temporal_privacy_score);\n        const volumeScore = stats.anonymity_set_size > 10n ? 100 : Number(stats.anonymity_set_size) * 10;\n\n        return Math.min(100, (anonymityScore + temporalScore + volumeScore) / 3);\n    }\n\n    async estimateOptimalMixingTime(): Promise<number> {\n        const metrics = await this.verify_privacy_guarantees();\n        const baseTime = Number(metrics.avg_mixing_time);\n        const anonymitySet = await this.get_anonymity_set_size();\n\n        // Recommend longer mixing time for smaller anonymity sets\n        if (anonymitySet < 5n) {\n            return baseTime * 2;\n        } else if (anonymitySet < 10n) {\n            return Math.floor(baseTime * 1.5);\n        } else {\n            return baseTime;\n        }\n    }\n\n    async recommendOptimalAmount(targetAmount: bigint): Promise<{\n        suggestedAmounts: bigint[];\n        reason: string;\n    }> {\n        const stats = await this.get_mixing_stats();\n\n        // Analyze common amounts to suggest better privacy\n        // In practice, this would analyze recent deposits to find common denominations\n        const commonDenominations = [\n            BigInt(1e18), // 1 STRK\n            BigInt(5e18), // 5 STRK\n            BigInt(10e18), // 10 STRK\n            BigInt(50e18), // 50 STRK\n            BigInt(100e18), // 100 STRK\n        ];\n\n        if (commonDenominations.includes(targetAmount)) {\n            return {\n                suggestedAmounts: [targetAmount],\n                reason: 'Amount matches common denomination for better privacy',\n            };\n        }\n\n        // Find closest common denominations\n        const smaller = commonDenominations.filter(d => d < targetAmount).pop();\n        const larger = commonDenominations.find(d => d > targetAmount);\n\n        const suggestions: bigint[] = [];\n        if (smaller) suggestions.push(smaller);\n        if (larger) suggestions.push(larger);\n\n        return {\n            suggestedAmounts: suggestions,\n            reason: 'Consider using common denominations to blend with other users',\n        };\n    }\n}\n\n// Factory function to create contract instance\nexport async function createPrivacyMixerContract(\n    accountPrivateKey: string,\n    accountAddress: string,\n    rpcUrl: string = 'https://starknet-mainnet.g.alchemy.com/starknet/version/rpc/v0_8/kwgGr9GGk4YyLXuGfEvpITv1jpvn3PgP',\n    contractAddress: string = ENV.MIXER_CONTRACT_ADDRESS || PRIVACY_MIXER.CONTRACT_ADDRESS\n): Promise<PrivacyMixerContract> {\n    const provider = new RpcProvider({ nodeUrl: rpcUrl });\n    const account = new Account(provider, accountAddress, accountPrivateKey);\n\n    return new PrivacyMixerContract(contractAddress, account, provider);\n}\n\n// Contract deployment helper\nexport async function deployPrivacyMixerContract(\n    account: Account,\n    constructorArgs: {\n        owner: string;\n        minDeposit: bigint;\n        maxDeposit: bigint;\n        mixingFee: bigint;\n        minAnonymity: bigint;\n        minDelay: bigint;\n    }\n): Promise<{\n    contract: PrivacyMixerContract;\n    transactionHash: string;\n    contractAddress: string;\n}> {\n    // In practice, this would compile and deploy the Cairo contract\n    // For now, we return a mock deployment result\n    throw new Error('Contract deployment not implemented - requires Starknet toolchain');\n}\n\nexport default PrivacyMixerContract;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/src/integrations/starknet/wallet.ts"],"sourcesContent":["// Starknet wallet integration for ArgentX and Braavos\nimport { connect, disconnect } from '@starknet-io/get-starknet';\nimport { Account, Provider, Contract, CallData, cairo, RpcProvider, num } from 'starknet';\nimport { PrivacyMixerContract, createPrivacyMixerContract } from './privacy-mixer-contract';\n\nexport type WalletType = 'argentX' | 'braavos' | 'bitkeep' | 'okx';\n\nexport interface StarknetAccount {\n    address: string;\n    publicKey: string;\n    walletType: WalletType;\n    chainId: string;\n}\n\nexport interface WalletConnection {\n    account: Account;\n    provider: Provider;\n    walletProvider: any; // Raw wallet provider (StarknetWindowObject) for WalletAccount creation\n    isConnected: boolean;\n    walletType: WalletType;\n}\n\nexport interface TransactionResult {\n    transactionHash: string;\n    status: 'PENDING' | 'ACCEPTED_ON_L2' | 'ACCEPTED_ON_L1' | 'REJECTED';\n    blockNumber?: number;\n    actualFee?: string;\n}\n\nexport interface TokenBalance {\n    symbol: string;\n    address: string;\n    balance: bigint;\n    decimals: number;\n}\n\nexport interface StarknetWalletClient {\n    // Connection management\n    connect(preferredWallet?: WalletType): Promise<WalletConnection>;\n    disconnect(): Promise<void>;\n    isConnected(): boolean;\n\n    // Account operations\n    getAccount(): StarknetAccount | null;\n    getBalance(tokenAddress?: string): Promise<TokenBalance>;\n\n    // Transaction operations\n    sendTransaction(calls: Array<{\n        contractAddress: string;\n        entrypoint: string;\n        calldata: any[];\n    }>): Promise<TransactionResult>;\n\n    waitForTransaction(txHash: string, retryInterval?: number): Promise<TransactionResult>;\n\n    // Token operations\n    transfer(tokenAddress: string, recipient: string, amount: bigint): Promise<TransactionResult>;\n    approve(tokenAddress: string, spender: string, amount: bigint): Promise<TransactionResult>;\n\n    // Multi-account support for privacy\n    switchAccount(accountIndex: number): Promise<StarknetAccount>;\n    listAccounts(): Promise<StarknetAccount[]>;\n\n    // Contract interactions\n    callContract(contractAddress: string, entrypoint: string, calldata: any[]): Promise<any>;\n\n    // Privacy mixer integration methods\n    initMixerContract(contractAddress: string): Promise<void>;\n    depositToMixer(commitment: string, amount: bigint): Promise<string>;\n    withdrawFromMixer(nullifier: string, commitment: string, recipient: string, amount: bigint, proof: string[]): Promise<string>;\n    getMixerStats(): Promise<any>;\n    getPrivacyMetrics(): Promise<any>;\n}\n\nexport class RealStarknetWalletClient implements StarknetWalletClient {\n    private connection: WalletConnection | null = null;\n    private rpcProvider: RpcProvider;\n    private mixerContract: PrivacyMixerContract | null = null;\n    // Maintain a static/shared connection across instances to avoid duplicate wallet popups\n    private static sharedConnection: WalletConnection | null = null;\n\n    constructor(rpcUrl?: string) {\n        this.rpcProvider = new RpcProvider({\n            nodeUrl: rpcUrl || 'https://starknet-mainnet.public.blastapi.io/rpc/v0_7'\n        });\n    }\n\n    async connect(preferredWallet?: WalletType): Promise<WalletConnection> {\n        try {\n            // Check if we have a shared connection and validate it's still working\n            if (RealStarknetWalletClient.sharedConnection) {\n                try {\n                    // Test the connection by trying to access the account address\n                    const testAddress = RealStarknetWalletClient.sharedConnection.account.address;\n                    if (testAddress) {\n                        this.connection = RealStarknetWalletClient.sharedConnection;\n                        console.log('ðŸ”„ Reusing existing wallet connection', {\n                            address: testAddress,\n                            walletType: this.connection.walletType\n                        });\n                        return this.connection;\n                    }\n                } catch (validationError) {\n                    console.warn('âš ï¸ Cached connection is stale, creating new connection:', validationError);\n                    RealStarknetWalletClient.sharedConnection = null;\n                }\n            }\n\n            if (typeof window === 'undefined') {\n                throw new Error('Wallet connection is only available in the browser');\n            }\n\n            // Try to connect to a specific injected wallet first\n            const w = window as any;\n            let injected: any | null = null;\n            const want = (preferredWallet || 'argentX').toLowerCase();\n            if (want === 'argentx') injected = w.starknet_argentX || null;\n            if (want === 'braavos') injected = w.starknet_braavos || injected;\n            if (want === 'okx') injected = w.starknet_okxwallet || injected;\n\n            // Only use fallback modal if no injected wallet found AND no shared connection\n            let provider: any = injected;\n            if (!provider) {\n                console.log('ðŸ” No injected wallet found, trying modal fallback...');\n                try {\n                    provider = await connect({ modalMode: 'always' } as any);\n                } catch (modalError) {\n                    console.warn('âš ï¸ Modal connection failed:', modalError);\n                    // ignore and handle below\n                }\n            }\n\n            if (!provider) {\n                throw new Error('No compatible Starknet wallet found');\n            }\n\n            // Ask for permissions/enable\n            if (typeof provider.enable === 'function') {\n                await provider.enable({ showModal: false }).catch(() => { });\n            }\n\n            const walletType = this.detectWalletType(provider);\n            const account = (provider.account || provider) as unknown as Account;\n\n            // IMPORTANT: Use the wallet's provider, not our RPC provider for wallet operations\n            // This ensures we maintain the wallet context for balance queries\n            const walletProviderRpc = provider.provider || this.rpcProvider;\n\n            this.connection = {\n                account,\n                provider: walletProviderRpc, // Use wallet's provider to maintain wallet context\n                walletProvider: provider, // Store raw wallet provider for WalletAccount creation\n                isConnected: true,\n                walletType,\n            };\n\n            // Cache globally for subsequent client instances\n            RealStarknetWalletClient.sharedConnection = this.connection;\n            console.log('âœ… New wallet connection established and cached', {\n                address: this.connection.account.address,\n                walletType: this.connection.walletType,\n                providerType: walletProvider === this.rpcProvider ? 'RPC' : 'Wallet'\n            });\n\n            return this.connection;\n        } catch (error) {\n            throw new Error(`Failed to connect to Starknet wallet: ${error}`);\n        }\n    }\n\n    async disconnect(): Promise<void> {\n        if (this.connection) {\n            await disconnect();\n            this.connection = null;\n            // Clear shared connection so next connect will prompt for wallet selection\n            RealStarknetWalletClient.sharedConnection = null;\n        }\n    }\n\n    isConnected(): boolean {\n        return this.connection?.isConnected || false;\n    }\n\n    getAccount(): StarknetAccount | null {\n        if (!this.connection) return null;\n\n        return {\n            address: this.connection.account.address,\n            publicKey: '', // Public key extraction varies by wallet\n            walletType: this.connection.walletType,\n            chainId: 'SN_MAIN' // Default to mainnet\n        };\n    }\n\n    async getBalance(tokenAddress?: string): Promise<TokenBalance> {\n        if (!this.connection) {\n            throw new Error('Wallet not connected');\n        }\n\n        // Handle native STRK vs ERC-20 tokens\n        if (!tokenAddress || tokenAddress.toLowerCase() === 'strk' || tokenAddress.toLowerCase() === 'native') {\n            // Get native STRK balance using the official STRK token contract\n            // Native STRK is actually an ERC-20 token on Starknet\n            const NATIVE_STRK_CONTRACT = '0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d'; // Sepolia STRK\n            try {\n                // Use the same approach as the E2E test - direct contract creation and balance_of call\n                const ERC20_ABI = [\n                    {\n                        name: 'balance_of',\n                        type: 'function',\n                        inputs: [{ name: 'account', type: 'core::starknet::contract_address::ContractAddress' }],\n                        outputs: [{ type: 'core::integer::u256' }],\n                        state_mutability: 'view'\n                    }\n                ];\n\n                // Use our configured RPC provider instead of wallet's provider for reliability\n                // This ensures we use the stable Alchemy endpoint instead of the wallet's default\n                const strkContract = new Contract(ERC20_ABI, NATIVE_STRK_CONTRACT, this.rpcProvider);\n                const balance = await strkContract.balance_of(this.connection.account.address);\n\n                console.log('ðŸ’° STRK balance check via contract:', {\n                    address: this.connection.account.address,\n                    contract: NATIVE_STRK_CONTRACT,\n                    balance: balance.toString()\n                });\n\n                return {\n                    symbol: 'STRK',\n                    address: NATIVE_STRK_CONTRACT,\n                    balance: BigInt(balance.toString()),\n                    decimals: 18 // STRK has 18 decimals\n                };\n            } catch (error) {\n                console.error('Failed to get STRK balance via contract:', error);\n                throw new Error(`Failed to get STRK balance: ${error}`);\n            }\n        } else {\n            // Handle ERC-20 tokens using same pattern as test\n            try {\n                const ERC20_ABI = [\n                    {\n                        name: 'balance_of',\n                        type: 'function',\n                        inputs: [{ name: 'account', type: 'core::starknet::contract_address::ContractAddress' }],\n                        outputs: [{ type: 'core::integer::u256' }],\n                        state_mutability: 'view'\n                    },\n                    {\n                        name: 'decimals',\n                        type: 'function',\n                        inputs: [],\n                        outputs: [{ type: 'core::integer::u8' }],\n                        state_mutability: 'view'\n                    },\n                    {\n                        name: 'symbol',\n                        type: 'function',\n                        inputs: [],\n                        outputs: [{ type: 'core::felt252' }],\n                        state_mutability: 'view'\n                    }\n                ];\n\n                // Use our configured RPC provider instead of wallet's provider for reliability\n                const tokenContract = new Contract(ERC20_ABI, tokenAddress, this.rpcProvider);\n\n                const balance = await tokenContract.balance_of(this.connection.account.address);\n                const decimals = await tokenContract.decimals();\n                const symbol = await tokenContract.symbol();\n\n                console.log('ðŸ’° Token balance check via contract:', {\n                    address: this.connection.account.address,\n                    contract: tokenAddress,\n                    balance: balance.toString(),\n                    decimals: decimals.toString(),\n                    symbol: symbol.toString()\n                });\n\n                return {\n                    symbol: num.toHex(symbol), // Convert felt to string\n                    address: tokenAddress,\n                    balance: BigInt(balance.toString()),\n                    decimals: Number(decimals.toString())\n                };\n            } catch (error) {\n                throw new Error(`Failed to get token balance: ${error}`);\n            }\n        }\n    }\n\n    async sendTransaction(calls: Array<{\n        contractAddress: string;\n        entrypoint: string;\n        calldata: any[];\n    }>): Promise<TransactionResult> {\n        if (!this.connection) {\n            throw new Error('Wallet not connected');\n        }\n\n        try {\n            const result = await this.connection.account.execute(calls);\n\n            return {\n                transactionHash: result.transaction_hash,\n                status: 'PENDING'\n            };\n        } catch (error) {\n            throw new Error(`Transaction failed: ${error}`);\n        }\n    }\n\n    async waitForTransaction(\n        txHash: string,\n        retryInterval: number = 5000\n    ): Promise<TransactionResult> {\n        if (!this.connection) {\n            throw new Error('Wallet not connected');\n        }\n\n        try {\n            const receipt = await this.rpcProvider.waitForTransaction(txHash);\n\n            return {\n                transactionHash: txHash,\n                status: receipt.isSuccess() ? 'ACCEPTED_ON_L2' : 'REJECTED',\n                blockNumber: (receipt as any).block_number || undefined,\n                actualFee: (receipt as any).actual_fee?.toString() || undefined\n            };\n        } catch (error) {\n            throw new Error(`Failed to wait for transaction: ${error}`);\n        }\n    }\n\n    async transfer(\n        tokenAddress: string,\n        recipient: string,\n        amount: bigint\n    ): Promise<TransactionResult> {\n        // Handle native STRK vs ERC-20 tokens\n        if (!tokenAddress || tokenAddress.toLowerCase() === 'strk' || tokenAddress.toLowerCase() === 'native') {\n            // Native STRK transfer - direct account execution\n            const calls = [{\n                contractAddress: recipient,\n                entrypoint: '__default__', // Native transfer entrypoint\n                calldata: CallData.compile([cairo.uint256(amount)])\n            }];\n\n            return this.sendTransaction(calls);\n        } else {\n            // ERC-20 token transfer\n            const calls = [{\n                contractAddress: tokenAddress,\n                entrypoint: 'transfer',\n                calldata: CallData.compile([recipient, cairo.uint256(amount)])\n            }];\n\n            return this.sendTransaction(calls);\n        }\n    }\n\n    async approve(\n        tokenAddress: string,\n        spender: string,\n        amount: bigint\n    ): Promise<TransactionResult> {\n        // Native STRK doesn't need approval - only ERC-20 tokens do\n        if (!tokenAddress || tokenAddress.toLowerCase() === 'strk' || tokenAddress.toLowerCase() === 'native') {\n            throw new Error('Native STRK does not require approval - use direct transfer');\n        }\n\n        // ERC-20 token approval\n        const calls = [{\n            contractAddress: tokenAddress,\n            entrypoint: 'approve',\n            calldata: CallData.compile([spender, cairo.uint256(amount)])\n        }];\n\n        return this.sendTransaction(calls);\n    }\n\n    async switchAccount(accountIndex: number): Promise<StarknetAccount> {\n        // This would depend on wallet's multi-account support\n        // For now, return current account\n        const account = this.getAccount();\n        if (!account) {\n            throw new Error('No account connected');\n        }\n        return account;\n    }\n\n    async listAccounts(): Promise<StarknetAccount[]> {\n        // This would query the wallet for all available accounts\n        // For now, return current account\n        const account = this.getAccount();\n        return account ? [account] : [];\n    }\n\n    async callContract(\n        contractAddress: string,\n        entrypoint: string,\n        calldata: any[]\n    ): Promise<any> {\n        if (!this.connection) {\n            throw new Error('Wallet not connected');\n        }\n\n        return this.rpcProvider.callContract({\n            contractAddress,\n            entrypoint,\n            calldata\n        });\n    }\n\n    // Privacy mixer contract integration\n    async initMixerContract(contractAddress: string): Promise<void> {\n        if (!this.connection) {\n            throw new Error('No wallet connected');\n        }\n\n        try {\n            // Create contract directly since we already have the connected account\n            this.mixerContract = new PrivacyMixerContract(\n                contractAddress,\n                this.connection.account,\n                this.rpcProvider\n            );\n        } catch (error) {\n            console.error('Failed to initialize mixer contract:', error);\n            throw error;\n        }\n    }\n\n    async depositToMixer(commitment: string, amount: bigint): Promise<string> {\n        if (!this.mixerContract) {\n            throw new Error('Mixer contract not initialized. Call initMixerContract first.');\n        }\n        if (!this.connection) {\n            throw new Error('No wallet connected');\n        }\n\n        try {\n            const result = await this.mixerContract.deposit(commitment, amount);\n            return result.transaction_hash;\n        } catch (error) {\n            console.error('Failed to deposit to mixer:', error);\n            throw error;\n        }\n    }\n\n    async withdrawFromMixer(\n        nullifier: string,\n        commitment: string,\n        recipient: string,\n        amount: bigint,\n        proof: string[]\n    ): Promise<string> {\n        if (!this.mixerContract) {\n            throw new Error('Mixer contract not initialized. Call initMixerContract first.');\n        }\n        if (!this.connection) {\n            throw new Error('No wallet connected');\n        }\n\n        try {\n            const result = await this.mixerContract.withdraw(\n                nullifier,\n                commitment,\n                recipient,\n                amount,\n                proof\n            );\n            return result.transaction_hash;\n        } catch (error) {\n            console.error('Failed to withdraw from mixer:', error);\n            throw error;\n        }\n    }\n\n    async getMixerStats(): Promise<any> {\n        if (!this.mixerContract) {\n            throw new Error('Mixer contract not initialized. Call initMixerContract first.');\n        }\n\n        return await this.mixerContract.get_mixing_stats();\n    }\n\n    async getPrivacyMetrics(): Promise<any> {\n        if (!this.mixerContract) {\n            throw new Error('Mixer contract not initialized. Call initMixerContract first.');\n        }\n\n        return await this.mixerContract.verify_privacy_guarantees();\n    }\n\n    private detectWalletType(starknet: any): WalletType {\n        // Detect wallet type based on provider details\n        if (starknet.id?.includes('argentX')) return 'argentX';\n        if (starknet.id?.includes('braavos')) return 'braavos';\n        if (starknet.id?.includes('bitkeep')) return 'bitkeep';\n        if (starknet.id?.includes('okx')) return 'okx';\n\n        // Default fallback\n        return 'argentX';\n    }\n}\n\n// Mock implementation for testing\nexport class MockStarknetWalletClient implements StarknetWalletClient {\n    private connected = false;\n    private mockAccount: StarknetAccount = {\n        address: '0x123...mock',\n        publicKey: '0xabc...mock',\n        walletType: 'argentX',\n        chainId: 'SN_MAIN'\n    };\n\n    async connect(preferredWallet?: WalletType): Promise<WalletConnection> {\n        this.connected = true;\n        return {\n            account: {} as Account,\n            provider: {} as Provider,\n            isConnected: true,\n            walletType: preferredWallet || 'argentX'\n        };\n    }\n\n    async disconnect(): Promise<void> {\n        this.connected = false;\n    }\n\n    isConnected(): boolean {\n        return this.connected;\n    }\n\n    getAccount(): StarknetAccount | null {\n        return this.connected ? this.mockAccount : null;\n    }\n\n    async getBalance(tokenAddress?: string): Promise<TokenBalance> {\n        return {\n            symbol: 'STRK',\n            address: tokenAddress || '0x123...strk',\n            balance: BigInt(1000000),\n            decimals: 18\n        };\n    }\n\n    async sendTransaction(calls: any): Promise<TransactionResult> {\n        return {\n            transactionHash: '0x' + Date.now().toString(16),\n            status: 'PENDING'\n        };\n    }\n\n    async waitForTransaction(txHash: string): Promise<TransactionResult> {\n        return {\n            transactionHash: txHash,\n            status: 'ACCEPTED_ON_L2',\n            blockNumber: 123456\n        };\n    }\n\n    async transfer(tokenAddress: string, recipient: string, amount: bigint): Promise<TransactionResult> {\n        return this.sendTransaction([]);\n    }\n\n    async approve(tokenAddress: string, spender: string, amount: bigint): Promise<TransactionResult> {\n        return this.sendTransaction([]);\n    }\n\n    async switchAccount(accountIndex: number): Promise<StarknetAccount> {\n        return this.mockAccount;\n    }\n\n    async listAccounts(): Promise<StarknetAccount[]> {\n        return [this.mockAccount];\n    }\n\n    async callContract(contractAddress: string, entrypoint: string, calldata: any[]): Promise<any> {\n        return { result: ['0x123'] };\n    }\n\n    async initMixerContract(_contractAddress: string): Promise<void> {\n        // Mock implementation - no-op\n    }\n\n    async depositToMixer(_commitment: string, _amount: bigint): Promise<string> {\n        return '0x' + Date.now().toString(16);\n    }\n\n    async withdrawFromMixer(\n        _nullifier: string,\n        _commitment: string,\n        _recipient: string,\n        _amount: bigint,\n        _proof: string[]\n    ): Promise<string> {\n        return '0x' + Date.now().toString(16);\n    }\n\n    async getMixerStats(): Promise<any> {\n        return {\n            total_deposits: 1000n,\n            total_withdrawals: 500n,\n            active_commitments: 500n,\n            anonymity_set_size: 100n,\n            mixing_efficiency: 95n,\n        };\n    }\n\n    async getPrivacyMetrics(): Promise<any> {\n        return {\n            min_anonymity_set: 10n,\n            avg_mixing_time: 3600n,\n            unlinkability_score: 95n,\n            temporal_privacy_score: 90n,\n        };\n    }\n}\n\n// Wallet connection manager\nexport class StarknetWalletManager {\n    private clients = new Map<WalletType, StarknetWalletClient>();\n    private activeClient: StarknetWalletClient | null = null;\n\n    constructor() {\n        // Initialize supported wallet clients\n        this.clients.set('argentX', new RealStarknetWalletClient());\n        this.clients.set('braavos', new RealStarknetWalletClient());\n        this.clients.set('okx', new RealStarknetWalletClient());\n    }\n\n    async connectWallet(preferredWallet?: WalletType): Promise<WalletConnection> {\n        const client = preferredWallet ?\n            this.clients.get(preferredWallet) :\n            this.clients.get('argentX');\n\n        if (!client) {\n            throw new Error(`Unsupported wallet: ${preferredWallet}`);\n        }\n\n        const connection = await client.connect(preferredWallet);\n        this.activeClient = client;\n        return connection;\n    }\n\n    getActiveClient(): StarknetWalletClient | null {\n        return this.activeClient;\n    }\n\n    async disconnectAll(): Promise<void> {\n        if (this.activeClient) {\n            await this.activeClient.disconnect();\n            this.activeClient = null;\n        }\n    }\n\n    getSupportedWallets(): WalletType[] {\n        return Array.from(this.clients.keys());\n    }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1014, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/src/context/WalletProvider.tsx"],"sourcesContent":["\"use client\";\n\nimport React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';\nimport { RealStarknetWalletClient, type WalletType, type WalletConnection } from '@/integrations/starknet/wallet';\nimport type { Account } from 'starknet';\n\ntype WalletCtx = {\n    isReady: boolean;\n    isConnected: boolean;\n    address?: string;\n    account?: Account; // Full Account object for signing\n    walletProvider?: any; // Raw wallet provider for WalletAccount creation\n    walletType?: WalletType;\n    connect: (preferred?: WalletType) => Promise<void>;\n    disconnect: () => Promise<void>;\n    client: RealStarknetWalletClient | null;\n};\n\nconst Ctx = createContext<WalletCtx | null>(null);\n\nexport function WalletProvider({ children }: { children: React.ReactNode }) {\n    const [client] = useState(() => new RealStarknetWalletClient());\n    const [isReady, setReady] = useState(false);\n    const [conn, setConn] = useState<WalletConnection | null>(null);\n\n    const connect = useCallback(async (preferred?: WalletType) => {\n        const c = await client.connect(preferred);\n        setConn(c);\n        try {\n            if (typeof window !== 'undefined' && preferred) {\n                window.localStorage.setItem('slpm:last-wallet', preferred);\n            }\n        } catch { }\n    }, [client]);\n\n    const disconnect = useCallback(async () => {\n        await client.disconnect();\n        setConn(null);\n        try { if (typeof window !== 'undefined') window.localStorage.removeItem('slpm:last-wallet'); } catch { }\n    }, [client]);\n\n    // Auto-connect on mount from localStorage\n    useEffect(() => {\n        (async () => {\n            try {\n                const last = typeof window !== 'undefined' ? (window.localStorage.getItem('slpm:last-wallet') as WalletType | null) : null;\n                if (last) {\n                    await connect(last);\n                }\n            } catch {/* ignore */ }\n            setReady(true);\n        })();\n    }, [connect]);\n\n    const value: WalletCtx = useMemo(() => ({\n        isReady,\n        isConnected: Boolean(conn?.isConnected),\n        address: conn?.account?.address,\n        account: conn?.account, // Expose full Account for signing\n        walletProvider: conn?.walletProvider, // Expose raw wallet provider for WalletAccount\n        walletType: conn?.walletType,\n        connect,\n        disconnect,\n        client\n    }), [isReady, conn, connect, disconnect, client]);\n\n    return <Ctx.Provider value={value}>{children}</Ctx.Provider>;\n}\n\nexport function useWallet() {\n    const ctx = useContext(Ctx);\n    if (!ctx) throw new Error('useWallet must be used within WalletProvider');\n    return ctx;\n}\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;;;AAHA;;;AAkBA,MAAM,oBAAM,IAAA,8KAAa,EAAmB;AAErC,SAAS,eAAe,KAA2C;QAA3C,EAAE,QAAQ,EAAiC,GAA3C;;IAC3B,MAAM,CAAC,OAAO,GAAG,IAAA,yKAAQ;mCAAC,IAAM,IAAI,wKAAwB;;IAC5D,MAAM,CAAC,SAAS,SAAS,GAAG,IAAA,yKAAQ,EAAC;IACrC,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,yKAAQ,EAA0B;IAE1D,MAAM,UAAU,IAAA,4KAAW;+CAAC,OAAO;YAC/B,MAAM,IAAI,MAAM,OAAO,OAAO,CAAC;YAC/B,QAAQ;YACR,IAAI;gBACA,IAAI,aAAkB,eAAe,WAAW;oBAC5C,OAAO,YAAY,CAAC,OAAO,CAAC,oBAAoB;gBACpD;YACJ,EAAE,UAAM,CAAE;QACd;8CAAG;QAAC;KAAO;IAEX,MAAM,aAAa,IAAA,4KAAW;kDAAC;YAC3B,MAAM,OAAO,UAAU;YACvB,QAAQ;YACR,IAAI;gBAAE,wCAAmC,OAAO,YAAY,CAAC,UAAU,CAAC;YAAqB,EAAE,UAAM,CAAE;QAC3G;iDAAG;QAAC;KAAO;IAEX,0CAA0C;IAC1C,IAAA,0KAAS;oCAAC;YACN;4CAAC;oBACG,IAAI;wBACA,MAAM,OAAO,uCAAiC,OAAO,YAAY,CAAC,OAAO,CAAC,sBAA4C;wBACtH,IAAI,MAAM;4BACN,MAAM,QAAQ;wBAClB;oBACJ,EAAE,UAAM,CAAc;oBACtB,SAAS;gBACb;;QACJ;mCAAG;QAAC;KAAQ;IAEZ,MAAM,QAAmB,IAAA,wKAAO;yCAAC;gBAGpB;mBAH2B;gBACpC;gBACA,aAAa,QAAQ,iBAAA,2BAAA,KAAM,WAAW;gBACtC,OAAO,EAAE,iBAAA,4BAAA,gBAAA,KAAM,OAAO,cAAb,oCAAA,cAAe,OAAO;gBAC/B,OAAO,EAAE,iBAAA,2BAAA,KAAM,OAAO;gBACtB,cAAc,EAAE,iBAAA,2BAAA,KAAM,cAAc;gBACpC,UAAU,EAAE,iBAAA,2BAAA,KAAM,UAAU;gBAC5B;gBACA;gBACA;YACJ;;wCAAI;QAAC;QAAS;QAAM;QAAS;QAAY;KAAO;IAEhD,qBAAO,6LAAC,IAAI,QAAQ;QAAC,OAAO;kBAAQ;;;;;;AACxC;GA/CgB;KAAA;AAiDT,SAAS;;IACZ,MAAM,MAAM,IAAA,2KAAU,EAAC;IACvB,IAAI,CAAC,KAAK,MAAM,IAAI,MAAM;IAC1B,OAAO;AACX;IAJgB","debugId":null}}]
}