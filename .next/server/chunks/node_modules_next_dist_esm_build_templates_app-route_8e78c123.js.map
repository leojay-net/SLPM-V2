{"version":3,"sources":["turbopack:///[project]/src/app/api/pipeline/transfer/route.ts","turbopack:///[project]/src/mixer/pipeline.ts","turbopack:///[project]/src/integrations/lightning/client.ts","turbopack:///[project]/node_modules/next/dist/esm/build/templates/app-route.js","turbopack:///[project]/src/utils/lightning.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { pipelineOrchestrator } from '@/mixer/pipeline';\nimport { z } from 'zod';\n\nconst schema = z.object({\n    from: z.string(),\n    to: z.string(),\n    amountStrk: z.string().transform(v => BigInt(v)),\n});\n\nexport async function POST(req: NextRequest) {\n    try {\n        const body = await req.json();\n        const parsed = schema.parse(body);\n        const transfer = await pipelineOrchestrator.initiate(parsed.from, parsed.to, parsed.amountStrk);\n        return NextResponse.json(transfer);\n    } catch (e) {\n        const msg = e instanceof Error ? e.message : 'error';\n        return NextResponse.json({ error: msg }, { status: 400 });\n    }\n}\n","import { randomHex } from '@/crypto/bdhke';\nimport { RealAtomiqSwapClient } from '@/integrations/swaps/atomiq';\nimport { RealLightningClient } from '@/integrations/lightning/client';\nimport { RealCashuClient } from '@/integrations/cashu/client';\nimport { ENV } from '@/config/env';\nimport { mixerEngine } from './engine';\nimport { globalEventBus } from '@/events/bus';\nimport { PipelineTransfer, EcashProof } from '@/domain/types';\nimport { generateMockInvoice } from '@/utils/lightning';\n\nconst atomiq = new RealAtomiqSwapClient(process.env.NEXT_PUBLIC_NETWORK === 'MAINNET' ? 'MAINNET' : 'TESTNET');\nconst _lnClient = new RealLightningClient(\n    process.env.LND_URL || '',\n    process.env.LND_MACAROON || '',\n    process.env.LND_TLS || ''\n);\nconst _cashuClient = new RealCashuClient(process.env.CASHU_MINT || ENV.CASHU_DEFAULT_MINT);\n\nconst transfers = new Map<string, PipelineTransfer>();\n\nexport class PipelineOrchestrator {\n    async initiate(from: string, to: string, amountStrk: bigint): Promise<PipelineTransfer> {\n        const id = randomHex(12);\n        const transfer: PipelineTransfer = {\n            id,\n            from,\n            // Do not persist recipient address for privacy\n            to: 'redacted',\n            amountStrk,\n            createdAt: Date.now(),\n            updatedAt: Date.now(),\n            state: 'PIPELINE_CREATED',\n        };\n        transfers.set(id, transfer);\n        globalEventBus.emit({ id: randomHex(8), type: 'pipeline.created', at: Date.now(), payload: { transfer } });\n        // fire and forget full pipeline (mocked)\n        void this.run(id);\n        return transfer;\n    }\n\n    get(id: string): PipelineTransfer | undefined { return transfers.get(id); }\n\n    private update(id: string, patch: Partial<PipelineTransfer>): PipelineTransfer {\n        const existing = transfers.get(id);\n        if (!existing) throw new Error('transfer not found');\n        const prevState = existing.state;\n        const updated: PipelineTransfer = { ...existing, ...patch, updatedAt: Date.now() };\n        transfers.set(id, updated);\n        globalEventBus.emit({ id: randomHex(8), type: 'pipeline.updated', at: Date.now(), payload: { transfer: updated } });\n        if (prevState !== updated.state) {\n            globalEventBus.emit({ id: randomHex(8), type: 'pipeline.state_changed', at: Date.now(), payload: { id, from: prevState, to: updated.state } });\n        }\n        return updated;\n    }\n\n    private async run(id: string) {\n        try {\n            // 1. STRK -> BTC swap (mock) then into LN\n            this.update(id, { state: 'SWAP_OUT_STRK_PENDING' });\n            const quote1 = await atomiq.getQuote('STRK', 'BTC_LN', this.get(id)!.amountStrk);\n            await atomiq.execute(quote1.id);\n            this.update(id, { state: 'SWAP_OUT_STRK_COMPLETED', intermediateBtcMsat: BigInt(quote1.amountOut) * 1000n });\n\n            // 2. Create LN invoice (mint side) & mark deposit\n            // Generate a proper bolt11-formatted mock invoice\n            const mockInvoice = generateMockInvoice(Number(quote1.amountOut), 'Privacy Mixer', id.slice(-6));\n            this.update(id, { state: 'LN_DEPOSIT_PENDING', lnInvoice: mockInvoice });\n            // simulate settlement\n            this.update(id, { state: 'LN_DEPOSIT_SETTLED' });\n\n            // 3. Mint ecash proofs (mock single proof)\n            const proofs: EcashProof[] = [{\n                secret: 'sec_' + id,\n                signature: 'sig_' + id,\n                amount: BigInt(quote1.amountOut),\n                currency: 'SAT',\n                keysetId: 'mock'\n            }];\n            this.update(id, { state: 'ECASH_MINTED', ecashProofs: proofs });\n\n            // 4. Create mixing session & deposit\n            const sessionRes = await mixerEngine.createSession({ currency: 'SAT', targetAmounts: [proofs[0].amount] });\n            await mixerEngine.deposit(sessionRes.session.id, proofs);\n            await mixerEngine.startMixing(sessionRes.session.id);\n            const mixed = (await mixerEngine.getSession(sessionRes.session.id))?.outputs ?? [];\n            this.update(id, { sessionId: sessionRes.session.id, state: 'REISSUED', mixedProofs: mixed });\n\n            // 5. Swap back to STRK (mock)\n            this.update(id, { state: 'SWAP_BACK_PENDING' });\n            const quote2 = await atomiq.getQuote('BTC_LN', 'STRK', BigInt(quote1.amountOut));\n            const exec2 = await atomiq.execute(quote2.id);\n            this.update(id, { state: 'SWAP_BACK_COMPLETED', swapBackTxId: exec2.txId });\n\n            // 6. Completed\n            this.update(id, { state: 'PIPELINE_COMPLETED' });\n            globalEventBus.emit({ id: randomHex(8), type: 'pipeline.completed', at: Date.now(), payload: { id } });\n        } catch (e) {\n            const msg = e instanceof Error ? e.message : 'error';\n            this.update(id, { state: 'PIPELINE_FAILED', error: msg });\n            globalEventBus.emit({ id: randomHex(8), type: 'pipeline.failed', at: Date.now(), payload: { id, error: msg } });\n        }\n    }\n}\n\nexport const pipelineOrchestrator = new PipelineOrchestrator();\n","// Real Lightning Network client implementation\nimport { decode } from 'bolt11';\nimport { generateMockInvoice } from '@/utils/lightning';\n\nexport interface LightningInvoiceInfo {\n    invoice: string;\n    amountMsat: number;\n    settled: boolean;\n    preimage?: string;\n    paymentHash?: string;\n    description?: string;\n    expiry?: number;\n    cltvExpiry?: number;\n}\n\nexport interface PaymentRoute {\n    totalTimeLock: number;\n    totalFeesMsat: number;\n    totalAmtMsat: number;\n    hops: Array<{\n        chanId: string;\n        chanCapacity: number;\n        amtToForwardMsat: number;\n        feeMsat: number;\n        expiry: number;\n        pubKey: string;\n    }>;\n}\n\nexport interface LightningPayment {\n    paymentHash: string;\n    paymentPreimage?: string;\n    paymentRoute?: PaymentRoute;\n    status: 'IN_FLIGHT' | 'SUCCEEDED' | 'FAILED';\n    failureReason?: string;\n    amountMsat: number;\n    creationTime: number;\n}\n\nexport interface LightningClient {\n    // Invoice operations\n    decodeInvoice(invoice: string): Promise<LightningInvoiceInfo>;\n    createInvoice(amountMsat: number, memo?: string, expiry?: number): Promise<LightningInvoiceInfo>;\n\n    // Payment operations\n    payInvoice(invoice: string, timeoutSeconds?: number): Promise<LightningPayment>;\n    payInvoiceSync(invoice: string): Promise<LightningPayment>;\n\n    // Multi-path payments\n    sendPaymentMultiPath(invoice: string, maxParts?: number): Promise<LightningPayment>;\n\n    // Payment tracking\n    trackPayment(paymentHash: string): Promise<LightningPayment>;\n    listPayments(includeIncomplete?: boolean): Promise<LightningPayment[]>;\n\n    // Channel and routing\n    getChannelBalance(): Promise<{ localBalance: number; remoteBalance: number }>;\n    estimateRoutingFee(destination: string, amountMsat: number): Promise<{ feeMsat: number }>;\n\n    // Advanced operations\n    sendKeysend(destination: string, amountMsat: number, customRecords?: Record<string, Uint8Array>): Promise<LightningPayment>;\n\n    // Node information\n    getNodeInfo(): Promise<{ pubkey: string; alias: string; version: string }>;\n}\n\nexport class RealLightningClient implements LightningClient {\n    private nodeEndpoint: string;\n    private macaroon?: string;\n    private tlsCert?: string;\n\n    constructor(nodeEndpoint: string, macaroon?: string, tlsCert?: string) {\n        this.nodeEndpoint = nodeEndpoint;\n        this.macaroon = macaroon;\n        this.tlsCert = tlsCert;\n    }\n\n    async decodeInvoice(invoice: string): Promise<LightningInvoiceInfo> {\n        // Handle mock invoices without actual bolt11 decoding\n        if (invoice.includes('mock')) {\n            const amountMatch = invoice.match(/lnbc(\\d+)u/);\n            const amountMsat = amountMatch ? parseInt(amountMatch[1]) * 1000 : 1000;\n\n            return {\n                invoice,\n                amountMsat,\n                settled: false,\n                paymentHash: 'hash_' + invoice.slice(-10),\n                description: 'Mock Lightning payment',\n                expiry: Math.floor(Date.now() / 1000) + 3600\n            };\n        }\n\n        try {\n            // Validate invoice format first\n            if (!invoice || !invoice.startsWith('ln')) {\n                throw new Error('Invalid invoice format: must start with \"ln\"');\n            }\n\n            const decoded = decode(invoice);\n\n            return {\n                invoice,\n                amountMsat: typeof decoded.millisatoshis === 'number' ? decoded.millisatoshis :\n                    typeof decoded.millisatoshis === 'string' ? parseInt(decoded.millisatoshis) : 0,\n                settled: false, // Would need to check with node\n                paymentHash: decoded.tagsObject.payment_hash,\n                description: decoded.tagsObject.description,\n                expiry: decoded.timeExpireDate ? Math.floor(decoded.timeExpireDate / 1000) : undefined,\n                cltvExpiry: decoded.tagsObject.min_final_cltv_expiry\n            };\n        } catch (error) {\n            console.error('Failed to decode Lightning invoice:', invoice, error);\n            throw new Error(`Failed to decode invoice: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n\n    async createInvoice(\n        amountMsat: number,\n        memo?: string,\n        expiry: number = 3600\n    ): Promise<LightningInvoiceInfo> {\n        if (this.nodeEndpoint && this.macaroon) {\n            try {\n                // Real LND REST API call\n                const response = await this.lndCall('POST', '/v1/invoices', {\n                    value_msat: amountMsat.toString(),\n                    memo: memo || '',\n                    expiry: expiry.toString()\n                });\n\n                return {\n                    invoice: response.payment_request,\n                    amountMsat,\n                    settled: false,\n                    paymentHash: response.r_hash,\n                    description: memo,\n                    expiry: Math.floor(Date.now() / 1000) + expiry\n                };\n            } catch (error) {\n                console.warn('LND API call failed, using fallback:', error);\n            }\n        }\n\n        // Fallback mock implementation\n        const paymentHash = this.generatePaymentHash();\n        const mockInvoice = this.generateMockInvoice(amountMsat, paymentHash, memo, expiry);\n\n        return {\n            invoice: mockInvoice,\n            amountMsat,\n            settled: false,\n            paymentHash,\n            description: memo,\n            expiry: Math.floor(Date.now() / 1000) + expiry\n        };\n    }\n\n    async payInvoice(invoice: string, timeoutSeconds: number = 60): Promise<LightningPayment> {\n        const decoded = await this.decodeInvoice(invoice);\n\n        if (this.nodeEndpoint && this.macaroon) {\n            try {\n                // Real LND payment\n                const response = await this.lndCall('POST', '/v1/channels/transactions', {\n                    payment_request: invoice,\n                    timeout_seconds: timeoutSeconds\n                });\n\n                return {\n                    paymentHash: response.payment_hash || decoded.paymentHash || '',\n                    paymentPreimage: response.payment_preimage,\n                    status: response.payment_error ? 'FAILED' : 'SUCCEEDED',\n                    failureReason: response.payment_error,\n                    amountMsat: decoded.amountMsat,\n                    creationTime: Date.now()\n                };\n            } catch (error) {\n                console.warn('LND payment failed, using fallback:', error);\n                return {\n                    paymentHash: decoded.paymentHash || '',\n                    status: 'FAILED',\n                    failureReason: error instanceof Error ? error.message : 'Unknown error',\n                    amountMsat: decoded.amountMsat,\n                    creationTime: Date.now()\n                };\n            }\n        }\n\n        // Fallback mock successful payment\n        return {\n            paymentHash: decoded.paymentHash || '',\n            paymentPreimage: this.generatePreimage(),\n            status: 'SUCCEEDED',\n            amountMsat: decoded.amountMsat,\n            creationTime: Date.now()\n        };\n    }\n\n    async payInvoiceSync(invoice: string): Promise<LightningPayment> {\n        return this.payInvoice(invoice, 30);\n    }\n\n    async sendPaymentMultiPath(\n        invoice: string,\n        maxParts: number = 16\n    ): Promise<LightningPayment> {\n        const decoded = await this.decodeInvoice(invoice);\n\n        // TODO: Implement real multi-path payment\n        // const response = await this.lndCall('POST', '/v2/router/send', {\n        //     payment_request: invoice,\n        //     max_parts: maxParts,\n        //     timeout_seconds: 60\n        // });\n\n        return {\n            paymentHash: decoded.paymentHash || '',\n            paymentPreimage: this.generatePreimage(),\n            status: 'SUCCEEDED',\n            amountMsat: decoded.amountMsat,\n            creationTime: Date.now()\n        };\n    }\n\n    async trackPayment(paymentHash: string): Promise<LightningPayment> {\n        // TODO: Implement real payment tracking\n        // const response = await this.lndCall('GET', `/v2/router/track/${paymentHash}`);\n\n        return {\n            paymentHash,\n            status: 'SUCCEEDED',\n            amountMsat: 1000,\n            creationTime: Date.now()\n        };\n    }\n\n    async listPayments(includeIncomplete: boolean = false): Promise<LightningPayment[]> {\n        // TODO: Implement real payment listing\n        // const response = await this.lndCall('GET', '/v1/payments', {\n        //     include_incomplete: includeIncomplete\n        // });\n\n        return [];\n    }\n\n    async getChannelBalance(): Promise<{ localBalance: number; remoteBalance: number }> {\n        // TODO: Implement real channel balance check\n        // const response = await this.lndCall('GET', '/v1/balance/channels');\n\n        return { localBalance: 1000000, remoteBalance: 500000 };\n    }\n\n    async estimateRoutingFee(\n        destination: string,\n        amountMsat: number\n    ): Promise<{ feeMsat: number }> {\n        // TODO: Implement real fee estimation\n        // const response = await this.lndCall('POST', '/v1/graph/routes', {\n        //     pub_key: destination,\n        //     amt_msat: amountMsat\n        // });\n\n        return { feeMsat: Math.floor(amountMsat * 0.001) }; // 0.1% fee estimate\n    }\n\n    async sendKeysend(\n        destination: string,\n        amountMsat: number,\n        customRecords?: Record<string, Uint8Array>\n    ): Promise<LightningPayment> {\n        // TODO: Implement real keysend\n        // const response = await this.lndCall('POST', '/v2/router/send', {\n        //     dest: destination,\n        //     amt_msat: amountMsat,\n        //     dest_custom_records: customRecords\n        // });\n\n        return {\n            paymentHash: this.generatePaymentHash(),\n            paymentPreimage: this.generatePreimage(),\n            status: 'SUCCEEDED',\n            amountMsat,\n            creationTime: Date.now()\n        };\n    }\n\n    async getNodeInfo(): Promise<{ pubkey: string; alias: string; version: string }> {\n        // TODO: Implement real node info\n        // const response = await this.lndCall('GET', '/v1/getinfo');\n\n        return {\n            pubkey: '02' + '0'.repeat(64), // Mock pubkey\n            alias: 'SLPM Lightning Node',\n            version: '0.17.0'\n        };\n    }\n\n    // Utility methods\n    private generatePaymentHash(): string {\n        return Array.from(crypto.getRandomValues(new Uint8Array(32)))\n            .map(b => b.toString(16).padStart(2, '0'))\n            .join('');\n    }\n\n    private generatePreimage(): string {\n        return Array.from(crypto.getRandomValues(new Uint8Array(32)))\n            .map(b => b.toString(16).padStart(2, '0'))\n            .join('');\n    }\n\n    private generateMockInvoice(\n        amountMsat: number,\n        paymentHash: string,\n        description?: string,\n        expiry: number = 3600\n    ): string {\n        // This would normally be generated by the Lightning node\n        // For now, return a mock invoice structure\n        return `lnbc${Math.floor(amountMsat / 1000)}u1p${paymentHash.slice(0, 8)}...mock`;\n    }\n\n    // HTTP client for LND REST API\n    private async lndCall(method: string, path: string, data?: any): Promise<any> {\n        // If running in the browser, route through Next.js API proxy endpoints to avoid exposing macaroon\n        const isBrowser = typeof window !== 'undefined';\n\n        if (isBrowser) {\n            // Map original LND path to our internal API routes\n            if (path === '/v1/invoices' && method === 'POST') {\n                const r = await fetch('/api/lightning/invoice', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                        amountMsat: Number(data?.value_msat ?? data?.valueMsat ?? 0),\n                        memo: data?.memo,\n                        expiry: Number(data?.expiry ?? 3600)\n                    })\n                });\n                if (!r.ok) throw new Error('Proxy invoice creation failed');\n                return r.json();\n            }\n            if (path === '/v1/channels/transactions' && method === 'POST') {\n                const r = await fetch('/api/lightning/pay', {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify({\n                        invoice: data?.payment_request,\n                        timeoutSeconds: data?.timeout_seconds || 60\n                    })\n                });\n                if (!r.ok) throw new Error('Proxy payment failed');\n                return r.json();\n            }\n            if (path === '/v1/getinfo' && method === 'GET') {\n                const r = await fetch('/api/lightning/info');\n                if (!r.ok) throw new Error('Proxy getinfo failed');\n                return r.json();\n            }\n            throw new Error(`Unsupported proxied LND call from browser: ${method} ${path}`);\n        }\n\n        // Server-side direct call\n        if (!this.nodeEndpoint) throw new Error('LND endpoint not configured');\n\n        const url = `${this.nodeEndpoint}${path}`;\n        const headers: Record<string, string> = { 'Content-Type': 'application/json' };\n        if (this.macaroon) headers['Grpc-Metadata-macaroon'] = this.macaroon;\n\n        const options: RequestInit = { method, headers };\n        if (data && method !== 'GET') options.body = JSON.stringify(data);\n\n        if (this.tlsCert && typeof process !== 'undefined' && process.env.NODE_ENV === 'development') {\n            (options as any).agent = new (await import('https')).Agent({ rejectUnauthorized: false });\n        }\n\n        const response = await fetch(url, options);\n        if (!response.ok) throw new Error(`LND API error: ${response.status} ${response.statusText}`);\n        return response.json();\n    }\n}\n\n// Enhanced mock client with realistic Lightning behavior\nexport class MockLightningClient implements LightningClient {\n    private payments = new Map<string, LightningPayment>();\n    private invoices = new Map<string, LightningInvoiceInfo>();\n\n    async decodeInvoice(invoice: string): Promise<LightningInvoiceInfo> {\n        // Handle mock invoices without actual bolt11 decoding\n        if (invoice.includes('mock')) {\n            const amountMatch = invoice.match(/lnbc(\\d+)u/);\n            const amountMsat = amountMatch ? parseInt(amountMatch[1]) * 1000 : 1000;\n\n            return {\n                invoice,\n                amountMsat,\n                settled: false,\n                paymentHash: 'hash_' + invoice.slice(-10),\n                description: 'Mock Lightning payment'\n            };\n        }\n\n        // For real bolt11 invoices, use the decode function\n        try {\n            const decoded = decode(invoice);\n            return {\n                invoice,\n                amountMsat: typeof decoded.millisatoshis === 'number' ? decoded.millisatoshis :\n                    typeof decoded.millisatoshis === 'string' ? parseInt(decoded.millisatoshis) : 0,\n                settled: false,\n                paymentHash: decoded.tagsObject.payment_hash,\n                description: decoded.tagsObject.description,\n                expiry: decoded.timeExpireDate ? Math.floor(decoded.timeExpireDate / 1000) : undefined,\n                cltvExpiry: decoded.tagsObject.min_final_cltv_expiry\n            };\n        } catch (error) {\n            throw new Error(`Failed to decode invoice: ${error}`);\n        }\n    }\n\n    async createInvoice(\n        amountMsat: number,\n        memo?: string,\n        expiry: number = 3600\n    ): Promise<LightningInvoiceInfo> {\n        const paymentHash = 'hash_' + Date.now();\n        // Generate a proper-looking mock bolt11 invoice\n        const sats = Math.max(1, Math.floor(amountMsat / 1000));\n        const invoice = generateMockInvoice(sats, memo, paymentHash);\n\n        const invoiceInfo: LightningInvoiceInfo = {\n            invoice,\n            amountMsat,\n            settled: false,\n            paymentHash,\n            description: memo,\n            expiry: Math.floor(Date.now() / 1000) + expiry\n        };\n\n        this.invoices.set(paymentHash, invoiceInfo);\n        return invoiceInfo;\n    }\n\n    async payInvoice(invoice: string, timeoutSeconds?: number): Promise<LightningPayment> {\n        const decoded = await this.decodeInvoice(invoice);\n        const preimage = 'preimage_' + Date.now();\n\n        const payment: LightningPayment = {\n            paymentHash: decoded.paymentHash || '',\n            paymentPreimage: preimage,\n            status: 'SUCCEEDED',\n            amountMsat: decoded.amountMsat,\n            creationTime: Date.now()\n        };\n\n        this.payments.set(payment.paymentHash, payment);\n        return payment;\n    }\n\n    async payInvoiceSync(invoice: string): Promise<LightningPayment> {\n        return this.payInvoice(invoice);\n    }\n\n    async sendPaymentMultiPath(invoice: string, maxParts?: number): Promise<LightningPayment> {\n        return this.payInvoice(invoice);\n    }\n\n    async trackPayment(paymentHash: string): Promise<LightningPayment> {\n        const existing = this.payments.get(paymentHash);\n        if (existing) {\n            return existing;\n        }\n\n        return {\n            paymentHash,\n            status: 'FAILED',\n            failureReason: 'Payment not found',\n            amountMsat: 0,\n            creationTime: Date.now()\n        };\n    }\n\n    async listPayments(includeIncomplete?: boolean): Promise<LightningPayment[]> {\n        return Array.from(this.payments.values());\n    }\n\n    async getChannelBalance(): Promise<{ localBalance: number; remoteBalance: number }> {\n        return { localBalance: 1000000, remoteBalance: 500000 };\n    }\n\n    async estimateRoutingFee(destination: string, amountMsat: number): Promise<{ feeMsat: number }> {\n        return { feeMsat: Math.floor(amountMsat * 0.001) };\n    }\n\n    async sendKeysend(\n        destination: string,\n        amountMsat: number,\n        customRecords?: Record<string, Uint8Array>\n    ): Promise<LightningPayment> {\n        const payment: LightningPayment = {\n            paymentHash: 'keysend_' + Date.now(),\n            paymentPreimage: 'preimage_' + Date.now(),\n            status: 'SUCCEEDED',\n            amountMsat,\n            creationTime: Date.now()\n        };\n\n        this.payments.set(payment.paymentHash, payment);\n        return payment;\n    }\n\n    async getNodeInfo(): Promise<{ pubkey: string; alias: string; version: string }> {\n        return {\n            pubkey: '02' + 'f'.repeat(64),\n            alias: 'Mock SLPM Node',\n            version: '0.1.0-mock'\n        };\n    }\n}\n","import { AppRouteRouteModule } from \"next/dist/esm/server/route-modules/app-route/module.compiled\";\nimport { RouteKind } from \"next/dist/esm/server/route-kind\";\nimport { patchFetch as _patchFetch } from \"next/dist/esm/server/lib/patch-fetch\";\nimport { getRequestMeta } from \"next/dist/esm/server/request-meta\";\nimport { getTracer, SpanKind } from \"next/dist/esm/server/lib/trace/tracer\";\nimport { normalizeAppPath } from \"next/dist/esm/shared/lib/router/utils/app-paths\";\nimport { NodeNextRequest, NodeNextResponse } from \"next/dist/esm/server/base-http/node\";\nimport { NextRequestAdapter, signalFromNodeResponse } from \"next/dist/esm/server/web/spec-extension/adapters/next-request\";\nimport { BaseServerSpan } from \"next/dist/esm/server/lib/trace/constants\";\nimport { getRevalidateReason } from \"next/dist/esm/server/instrumentation/utils\";\nimport { sendResponse } from \"next/dist/esm/server/send-response\";\nimport { fromNodeOutgoingHttpHeaders, toNodeOutgoingHttpHeaders } from \"next/dist/esm/server/web/utils\";\nimport { getCacheControlHeader } from \"next/dist/esm/server/lib/cache-control\";\nimport { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from \"next/dist/esm/lib/constants\";\nimport { NoFallbackError } from \"next/dist/esm/shared/lib/no-fallback-error.external\";\nimport { CachedRouteKind } from \"next/dist/esm/server/response-cache\";\nimport * as userland from \"INNER_APP_ROUTE\";\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new AppRouteRouteModule({\n    definition: {\n        kind: RouteKind.APP_ROUTE,\n        page: \"/api/pipeline/transfer/route\",\n        pathname: \"/api/pipeline/transfer\",\n        filename: \"route\",\n        bundlePath: \"\"\n    },\n    distDir: process.env.__NEXT_RELATIVE_DIST_DIR || '',\n    relativeProjectDir: process.env.__NEXT_RELATIVE_PROJECT_DIR || '',\n    resolvedPagePath: \"[project]/src/app/api/pipeline/transfer/route.ts\",\n    nextConfigOutput,\n    userland\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule;\nfunction patchFetch() {\n    return _patchFetch({\n        workAsyncStorage,\n        workUnitAsyncStorage\n    });\n}\nexport { routeModule, workAsyncStorage, workUnitAsyncStorage, serverHooks, patchFetch,  };\nexport async function handler(req, res, ctx) {\n    var _nextConfig_experimental;\n    let srcPage = \"/api/pipeline/transfer/route\";\n    // turbopack doesn't normalize `/index` in the page name\n    // so we need to to process dynamic routes properly\n    // TODO: fix turbopack providing differing value from webpack\n    if (process.env.TURBOPACK) {\n        srcPage = srcPage.replace(/\\/index$/, '') || '/';\n    } else if (srcPage === '/index') {\n        // we always normalize /index specifically\n        srcPage = '/';\n    }\n    const multiZoneDraftMode = process.env.__NEXT_MULTI_ZONE_DRAFT_MODE;\n    const prepareResult = await routeModule.prepare(req, res, {\n        srcPage,\n        multiZoneDraftMode\n    });\n    if (!prepareResult) {\n        res.statusCode = 400;\n        res.end('Bad Request');\n        ctx.waitUntil == null ? void 0 : ctx.waitUntil.call(ctx, Promise.resolve());\n        return null;\n    }\n    const { buildId, params, nextConfig, isDraftMode, prerenderManifest, routerServerContext, isOnDemandRevalidate, revalidateOnlyGenerated, resolvedPathname } = prepareResult;\n    const normalizedSrcPage = normalizeAppPath(srcPage);\n    let isIsr = Boolean(prerenderManifest.dynamicRoutes[normalizedSrcPage] || prerenderManifest.routes[resolvedPathname]);\n    if (isIsr && !isDraftMode) {\n        const isPrerendered = Boolean(prerenderManifest.routes[resolvedPathname]);\n        const prerenderInfo = prerenderManifest.dynamicRoutes[normalizedSrcPage];\n        if (prerenderInfo) {\n            if (prerenderInfo.fallback === false && !isPrerendered) {\n                throw new NoFallbackError();\n            }\n        }\n    }\n    let cacheKey = null;\n    if (isIsr && !routeModule.isDev && !isDraftMode) {\n        cacheKey = resolvedPathname;\n        // ensure /index and / is normalized to one key\n        cacheKey = cacheKey === '/index' ? '/' : cacheKey;\n    }\n    const supportsDynamicResponse = // If we're in development, we always support dynamic HTML\n    routeModule.isDev === true || // If this is not SSG or does not have static paths, then it supports\n    // dynamic HTML.\n    !isIsr;\n    // This is a revalidation request if the request is for a static\n    // page and it is not being resumed from a postponed render and\n    // it is not a dynamic RSC request then it is a revalidation\n    // request.\n    const isRevalidate = isIsr && !supportsDynamicResponse;\n    const method = req.method || 'GET';\n    const tracer = getTracer();\n    const activeSpan = tracer.getActiveScopeSpan();\n    const context = {\n        params,\n        prerenderManifest,\n        renderOpts: {\n            experimental: {\n                cacheComponents: Boolean(nextConfig.experimental.cacheComponents),\n                authInterrupts: Boolean(nextConfig.experimental.authInterrupts)\n            },\n            supportsDynamicResponse,\n            incrementalCache: getRequestMeta(req, 'incrementalCache'),\n            cacheLifeProfiles: (_nextConfig_experimental = nextConfig.experimental) == null ? void 0 : _nextConfig_experimental.cacheLife,\n            isRevalidate,\n            waitUntil: ctx.waitUntil,\n            onClose: (cb)=>{\n                res.on('close', cb);\n            },\n            onAfterTaskError: undefined,\n            onInstrumentationRequestError: (error, _request, errorContext)=>routeModule.onRequestError(req, error, errorContext, routerServerContext)\n        },\n        sharedContext: {\n            buildId\n        }\n    };\n    const nodeNextReq = new NodeNextRequest(req);\n    const nodeNextRes = new NodeNextResponse(res);\n    const nextReq = NextRequestAdapter.fromNodeNextRequest(nodeNextReq, signalFromNodeResponse(res));\n    try {\n        const invokeRouteModule = async (span)=>{\n            return routeModule.handle(nextReq, context).finally(()=>{\n                if (!span) return;\n                span.setAttributes({\n                    'http.status_code': res.statusCode,\n                    'next.rsc': false\n                });\n                const rootSpanAttributes = tracer.getRootSpanAttributes();\n                // We were unable to get attributes, probably OTEL is not enabled\n                if (!rootSpanAttributes) {\n                    return;\n                }\n                if (rootSpanAttributes.get('next.span_type') !== BaseServerSpan.handleRequest) {\n                    console.warn(`Unexpected root span type '${rootSpanAttributes.get('next.span_type')}'. Please report this Next.js issue https://github.com/vercel/next.js`);\n                    return;\n                }\n                const route = rootSpanAttributes.get('next.route');\n                if (route) {\n                    const name = `${method} ${route}`;\n                    span.setAttributes({\n                        'next.route': route,\n                        'http.route': route,\n                        'next.span_name': name\n                    });\n                    span.updateName(name);\n                } else {\n                    span.updateName(`${method} ${req.url}`);\n                }\n            });\n        };\n        const handleResponse = async (currentSpan)=>{\n            var _cacheEntry_value;\n            const responseGenerator = async ({ previousCacheEntry })=>{\n                try {\n                    if (!getRequestMeta(req, 'minimalMode') && isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry) {\n                        res.statusCode = 404;\n                        // on-demand revalidate always sets this header\n                        res.setHeader('x-nextjs-cache', 'REVALIDATED');\n                        res.end('This page could not be found');\n                        return null;\n                    }\n                    const response = await invokeRouteModule(currentSpan);\n                    req.fetchMetrics = context.renderOpts.fetchMetrics;\n                    let pendingWaitUntil = context.renderOpts.pendingWaitUntil;\n                    // Attempt using provided waitUntil if available\n                    // if it's not we fallback to sendResponse's handling\n                    if (pendingWaitUntil) {\n                        if (ctx.waitUntil) {\n                            ctx.waitUntil(pendingWaitUntil);\n                            pendingWaitUntil = undefined;\n                        }\n                    }\n                    const cacheTags = context.renderOpts.collectedTags;\n                    // If the request is for a static response, we can cache it so long\n                    // as it's not edge.\n                    if (isIsr) {\n                        const blob = await response.blob();\n                        // Copy the headers from the response.\n                        const headers = toNodeOutgoingHttpHeaders(response.headers);\n                        if (cacheTags) {\n                            headers[NEXT_CACHE_TAGS_HEADER] = cacheTags;\n                        }\n                        if (!headers['content-type'] && blob.type) {\n                            headers['content-type'] = blob.type;\n                        }\n                        const revalidate = typeof context.renderOpts.collectedRevalidate === 'undefined' || context.renderOpts.collectedRevalidate >= INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;\n                        const expire = typeof context.renderOpts.collectedExpire === 'undefined' || context.renderOpts.collectedExpire >= INFINITE_CACHE ? undefined : context.renderOpts.collectedExpire;\n                        // Create the cache entry for the response.\n                        const cacheEntry = {\n                            value: {\n                                kind: CachedRouteKind.APP_ROUTE,\n                                status: response.status,\n                                body: Buffer.from(await blob.arrayBuffer()),\n                                headers\n                            },\n                            cacheControl: {\n                                revalidate,\n                                expire\n                            }\n                        };\n                        return cacheEntry;\n                    } else {\n                        // send response without caching if not ISR\n                        await sendResponse(nodeNextReq, nodeNextRes, response, context.renderOpts.pendingWaitUntil);\n                        return null;\n                    }\n                } catch (err) {\n                    // if this is a background revalidate we need to report\n                    // the request error here as it won't be bubbled\n                    if (previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) {\n                        await routeModule.onRequestError(req, err, {\n                            routerKind: 'App Router',\n                            routePath: srcPage,\n                            routeType: 'route',\n                            revalidateReason: getRevalidateReason({\n                                isRevalidate,\n                                isOnDemandRevalidate\n                            })\n                        }, routerServerContext);\n                    }\n                    throw err;\n                }\n            };\n            const cacheEntry = await routeModule.handleResponse({\n                req,\n                nextConfig,\n                cacheKey,\n                routeKind: RouteKind.APP_ROUTE,\n                isFallback: false,\n                prerenderManifest,\n                isRoutePPREnabled: false,\n                isOnDemandRevalidate,\n                revalidateOnlyGenerated,\n                responseGenerator,\n                waitUntil: ctx.waitUntil\n            });\n            // we don't create a cacheEntry for ISR\n            if (!isIsr) {\n                return null;\n            }\n            if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== CachedRouteKind.APP_ROUTE) {\n                var _cacheEntry_value1;\n                throw Object.defineProperty(new Error(`Invariant: app-route received invalid cache entry ${cacheEntry == null ? void 0 : (_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind}`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E701\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            if (!getRequestMeta(req, 'minimalMode')) {\n                res.setHeader('x-nextjs-cache', isOnDemandRevalidate ? 'REVALIDATED' : cacheEntry.isMiss ? 'MISS' : cacheEntry.isStale ? 'STALE' : 'HIT');\n            }\n            // Draft mode should never be cached\n            if (isDraftMode) {\n                res.setHeader('Cache-Control', 'private, no-cache, no-store, max-age=0, must-revalidate');\n            }\n            const headers = fromNodeOutgoingHttpHeaders(cacheEntry.value.headers);\n            if (!(getRequestMeta(req, 'minimalMode') && isIsr)) {\n                headers.delete(NEXT_CACHE_TAGS_HEADER);\n            }\n            // If cache control is already set on the response we don't\n            // override it to allow users to customize it via next.config\n            if (cacheEntry.cacheControl && !res.getHeader('Cache-Control') && !headers.get('Cache-Control')) {\n                headers.set('Cache-Control', getCacheControlHeader(cacheEntry.cacheControl));\n            }\n            await sendResponse(nodeNextReq, nodeNextRes, new Response(cacheEntry.value.body, {\n                headers,\n                status: cacheEntry.value.status || 200\n            }));\n            return null;\n        };\n        // TODO: activeSpan code path is for when wrapped by\n        // next-server can be removed when this is no longer used\n        if (activeSpan) {\n            await handleResponse(activeSpan);\n        } else {\n            await tracer.withPropagatedContext(req.headers, ()=>tracer.trace(BaseServerSpan.handleRequest, {\n                    spanName: `${method} ${req.url}`,\n                    kind: SpanKind.SERVER,\n                    attributes: {\n                        'http.method': method,\n                        'http.target': req.url\n                    }\n                }, handleResponse));\n        }\n    } catch (err) {\n        // if we aren't wrapped by base-server handle here\n        if (!activeSpan && !(err instanceof NoFallbackError)) {\n            await routeModule.onRequestError(req, err, {\n                routerKind: 'App Router',\n                routePath: normalizedSrcPage,\n                routeType: 'route',\n                revalidateReason: getRevalidateReason({\n                    isRevalidate,\n                    isOnDemandRevalidate\n                })\n            });\n        }\n        // rethrow so that we can handle serving error page\n        // If this is during static generation, throw the error again.\n        if (isIsr) throw err;\n        // Otherwise, send a 500 response.\n        await sendResponse(nodeNextReq, nodeNextRes, new Response(null, {\n            status: 500\n        }));\n        return null;\n    }\n}\n\n//# sourceMappingURL=app-route.js.map\n","// Utility functions for Lightning Network operations\n\n/**\n * Generates a valid mock Lightning invoice (bolt11 format) for testing\n * @param amountSats Amount in satoshis\n * @param description Optional description for the invoice\n * @param suffix Optional suffix for unique identification\n * @returns A properly formatted mock bolt11 invoice\n */\nexport function generateMockInvoice(\n    amountSats: number,\n    description?: string,\n    suffix?: string\n): string {\n    // Convert sats to milli-satoshis for bolt11 format\n    const amountMsat = amountSats * 1000;\n\n    // Generate a mock invoice with proper bolt11 structure\n    // Format: lnbc[amount][multiplier]1[data]\n    // Where multiplier: p=pico (10^-12), n=nano (10^-9), u=micro (10^-6), m=milli (10^-3)\n\n    let amountStr = '';\n    if (amountMsat >= 1000) {\n        amountStr = Math.floor(amountMsat / 1000).toString() + 'm'; // milli-bitcoin\n    } else if (amountMsat >= 1) {\n        amountStr = amountMsat.toString() + 'p'; // pico-bitcoin (msat)\n    }\n\n    // Generate mock data section (normally contains payment hash, expiry, etc.)\n    const mockId = suffix || Math.random().toString(36).substring(2, 10);\n    const mockData = `pp5qqqsysgq9q5sqqqqqq5sqqqqq5qz8d5qhqqqqqeqq8z5sq9q5sqqqq8z5sq5qqqqqqqqqqqqqqq${mockId}`;\n\n    return `lnbc${amountStr}1${mockData}`;\n}\n\n/**\n * Validates if a string looks like a Lightning invoice\n * @param invoice The invoice string to validate\n * @returns true if it looks like a valid invoice format\n */\nexport function isValidInvoiceFormat(invoice: string): boolean {\n    // Basic format check: starts with ln, has minimum length\n    return invoice.startsWith('ln') && invoice.length > 50;\n}\n\n/**\n * Extracts amount from a mock invoice for testing\n * @param invoice Mock lightning invoice\n * @returns Amount in satoshis, or 0 if cannot parse\n */\nexport function extractMockInvoiceAmount(invoice: string): number {\n    try {\n        const match = invoice.match(/^lnbc(\\d+)([pmnu]?)1/);\n        if (!match) return 0;\n\n        const amount = parseInt(match[1]);\n        const multiplier = match[2];\n\n        switch (multiplier) {\n            case 'p': return Math.floor(amount / 1000); // pico to sats\n            case 'n': return amount * 1000; // nano to sats  \n            case 'u': return amount * 1000000; // micro to sats\n            case 'm': return amount * 100000000; // milli to sats\n            default: return amount; // assume sats\n        }\n    } catch {\n        return 0;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[3]}