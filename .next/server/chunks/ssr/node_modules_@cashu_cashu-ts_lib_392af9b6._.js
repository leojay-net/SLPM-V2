module.exports = [
"[project]/node_modules/@cashu/cashu-ts/lib/utils-CrQNeCaC.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "B",
    ()=>Yr,
    "b",
    ()=>Vr,
    "e",
    ()=>Xr,
    "h",
    ()=>Hr
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/abstract/utils.js [app-ssr] (ecmascript)");
;
var fr = {}, G = {};
G.byteLength = Dr;
G.toByteArray = Pr;
G.fromByteArray = Wr;
var S = [], R = [], br = typeof Uint8Array < "u" ? Uint8Array : Array, z = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var D = 0, kr = z.length; D < kr; ++D)S[D] = z[D], R[z.charCodeAt(D)] = D;
R[45] = 62;
R[95] = 63;
function pr(s) {
    var c = s.length;
    if (c % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var f = s.indexOf("=");
    f === -1 && (f = c);
    var w = f === c ? 0 : 4 - f % 4;
    return [
        f,
        w
    ];
}
function Dr(s) {
    var c = pr(s), f = c[0], w = c[1];
    return (f + w) * 3 / 4 - w;
}
function $r(s, c, f) {
    return (c + f) * 3 / 4 - f;
}
function Pr(s) {
    var c, f = pr(s), w = f[0], l = f[1], p = new br($r(s, w, l)), a = 0, m = l > 0 ? w - 4 : w, B;
    for(B = 0; B < m; B += 4)c = R[s.charCodeAt(B)] << 18 | R[s.charCodeAt(B + 1)] << 12 | R[s.charCodeAt(B + 2)] << 6 | R[s.charCodeAt(B + 3)], p[a++] = c >> 16 & 255, p[a++] = c >> 8 & 255, p[a++] = c & 255;
    return l === 2 && (c = R[s.charCodeAt(B)] << 2 | R[s.charCodeAt(B + 1)] >> 4, p[a++] = c & 255), l === 1 && (c = R[s.charCodeAt(B)] << 10 | R[s.charCodeAt(B + 1)] << 4 | R[s.charCodeAt(B + 2)] >> 2, p[a++] = c >> 8 & 255, p[a++] = c & 255), p;
}
function Or(s) {
    return S[s >> 18 & 63] + S[s >> 12 & 63] + S[s >> 6 & 63] + S[s & 63];
}
function Gr(s, c, f) {
    for(var w, l = [], p = c; p < f; p += 3)w = (s[p] << 16 & 16711680) + (s[p + 1] << 8 & 65280) + (s[p + 2] & 255), l.push(Or(w));
    return l.join("");
}
function Wr(s) {
    for(var c, f = s.length, w = f % 3, l = [], p = 16383, a = 0, m = f - w; a < m; a += p)l.push(Gr(s, a, a + p > m ? m : a + p));
    return w === 1 ? (c = s[f - 1], l.push(S[c >> 2] + S[c << 4 & 63] + "==")) : w === 2 && (c = (s[f - 2] << 8) + s[f - 1], l.push(S[c >> 10] + S[c >> 4 & 63] + S[c << 2 & 63] + "=")), l.join("");
}
var J = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ J.read = function(s, c, f, w, l) {
    var p, a, m = l * 8 - w - 1, B = (1 << m) - 1, F = B >> 1, o = -7, A = f ? l - 1 : 0, _ = f ? -1 : 1, T = s[c + A];
    for(A += _, p = T & (1 << -o) - 1, T >>= -o, o += m; o > 0; p = p * 256 + s[c + A], A += _, o -= 8);
    for(a = p & (1 << -o) - 1, p >>= -o, o += w; o > 0; a = a * 256 + s[c + A], A += _, o -= 8);
    if (p === 0) p = 1 - F;
    else {
        if (p === B) return a ? NaN : (T ? -1 : 1) * (1 / 0);
        a = a + Math.pow(2, w), p = p - F;
    }
    return (T ? -1 : 1) * a * Math.pow(2, p - w);
};
J.write = function(s, c, f, w, l, p) {
    var a, m, B, F = p * 8 - l - 1, o = (1 << F) - 1, A = o >> 1, _ = l === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, T = w ? 0 : p - 1, N = w ? 1 : -1, W = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
    for(c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (m = isNaN(c) ? 1 : 0, a = o) : (a = Math.floor(Math.log(c) / Math.LN2), c * (B = Math.pow(2, -a)) < 1 && (a--, B *= 2), a + A >= 1 ? c += _ / B : c += _ * Math.pow(2, 1 - A), c * B >= 2 && (a++, B /= 2), a + A >= o ? (m = 0, a = o) : a + A >= 1 ? (m = (c * B - 1) * Math.pow(2, l), a = a + A) : (m = c * Math.pow(2, A - 1) * Math.pow(2, l), a = 0)); l >= 8; s[f + T] = m & 255, T += N, m /= 256, l -= 8);
    for(a = a << l | m, F += l; F > 0; s[f + T] = a & 255, T += N, a /= 256, F -= 8);
    s[f + T - N] |= W * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ (function(s) {
    const c = G, f = J, w = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    s.Buffer = o, s.SlowBuffer = ar, s.INSPECT_MAX_BYTES = 50;
    const l = 2147483647;
    s.kMaxLength = l;
    const { Uint8Array: p, ArrayBuffer: a, SharedArrayBuffer: m } = globalThis;
    o.TYPED_ARRAY_SUPPORT = B(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function B() {
        try {
            const n = new p(1), r = {
                foo: function() {
                    return 42;
                }
            };
            return Object.setPrototypeOf(r, p.prototype), Object.setPrototypeOf(n, r), n.foo() === 42;
        } catch  {
            return !1;
        }
    }
    Object.defineProperty(o.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (o.isBuffer(this)) return this.buffer;
        }
    }), Object.defineProperty(o.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (o.isBuffer(this)) return this.byteOffset;
        }
    });
    function F(n) {
        if (n > l) throw new RangeError('The value "' + n + '" is invalid for option "size"');
        const r = new p(n);
        return Object.setPrototypeOf(r, o.prototype), r;
    }
    function o(n, r, t) {
        if (typeof n == "number") {
            if (typeof r == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return N(n);
        }
        return A(n, r, t);
    }
    o.poolSize = 8192;
    function A(n, r, t) {
        if (typeof n == "string") return W(n, r);
        if (a.isView(n)) return sr(n);
        if (n == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n);
        if (C(n, a) || n && C(n.buffer, a) || typeof m < "u" && (C(n, m) || n && C(n.buffer, m))) return H(n, r, t);
        if (typeof n == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
        const i = n.valueOf && n.valueOf();
        if (i != null && i !== n) return o.from(i, r, t);
        const e = lr(n);
        if (e) return e;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof n[Symbol.toPrimitive] == "function") return o.from(n[Symbol.toPrimitive]("string"), r, t);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof n);
    }
    o.from = function(n, r, t) {
        return A(n, r, t);
    }, Object.setPrototypeOf(o.prototype, p.prototype), Object.setPrototypeOf(o, p);
    function _(n) {
        if (typeof n != "number") throw new TypeError('"size" argument must be of type number');
        if (n < 0) throw new RangeError('The value "' + n + '" is invalid for option "size"');
    }
    function T(n, r, t) {
        return _(n), n <= 0 ? F(n) : r !== void 0 ? typeof t == "string" ? F(n).fill(r, t) : F(n).fill(r) : F(n);
    }
    o.alloc = function(n, r, t) {
        return T(n, r, t);
    };
    function N(n) {
        return _(n), F(n < 0 ? 0 : j(n) | 0);
    }
    o.allocUnsafe = function(n) {
        return N(n);
    }, o.allocUnsafeSlow = function(n) {
        return N(n);
    };
    function W(n, r) {
        if ((typeof r != "string" || r === "") && (r = "utf8"), !o.isEncoding(r)) throw new TypeError("Unknown encoding: " + r);
        const t = K(n, r) | 0;
        let i = F(t);
        const e = i.write(n, r);
        return e !== t && (i = i.slice(0, e)), i;
    }
    function Y(n) {
        const r = n.length < 0 ? 0 : j(n.length) | 0, t = F(r);
        for(let i = 0; i < r; i += 1)t[i] = n[i] & 255;
        return t;
    }
    function sr(n) {
        if (C(n, p)) {
            const r = new p(n);
            return H(r.buffer, r.byteOffset, r.byteLength);
        }
        return Y(n);
    }
    function H(n, r, t) {
        if (r < 0 || n.byteLength < r) throw new RangeError('"offset" is outside of buffer bounds');
        if (n.byteLength < r + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
        let i;
        return r === void 0 && t === void 0 ? i = new p(n) : t === void 0 ? i = new p(n, r) : i = new p(n, r, t), Object.setPrototypeOf(i, o.prototype), i;
    }
    function lr(n) {
        if (o.isBuffer(n)) {
            const r = j(n.length) | 0, t = F(r);
            return t.length === 0 || n.copy(t, 0, 0, r), t;
        }
        if (n.length !== void 0) return typeof n.length != "number" || X(n.length) ? F(0) : Y(n);
        if (n.type === "Buffer" && Array.isArray(n.data)) return Y(n.data);
    }
    function j(n) {
        if (n >= l) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + l.toString(16) + " bytes");
        return n | 0;
    }
    function ar(n) {
        return +n != n && (n = 0), o.alloc(+n);
    }
    o.isBuffer = function(r) {
        return r != null && r._isBuffer === !0 && r !== o.prototype;
    }, o.compare = function(r, t) {
        if (C(r, p) && (r = o.from(r, r.offset, r.byteLength)), C(t, p) && (t = o.from(t, t.offset, t.byteLength)), !o.isBuffer(r) || !o.isBuffer(t)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (r === t) return 0;
        let i = r.length, e = t.length;
        for(let u = 0, h = Math.min(i, e); u < h; ++u)if (r[u] !== t[u]) {
            i = r[u], e = t[u];
            break;
        }
        return i < e ? -1 : e < i ? 1 : 0;
    }, o.isEncoding = function(r) {
        switch(String(r).toLowerCase()){
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1;
        }
    }, o.concat = function(r, t) {
        if (!Array.isArray(r)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (r.length === 0) return o.alloc(0);
        let i;
        if (t === void 0) for(t = 0, i = 0; i < r.length; ++i)t += r[i].length;
        const e = o.allocUnsafe(t);
        let u = 0;
        for(i = 0; i < r.length; ++i){
            let h = r[i];
            if (C(h, p)) u + h.length > e.length ? (o.isBuffer(h) || (h = o.from(h)), h.copy(e, u)) : p.prototype.set.call(e, h, u);
            else if (o.isBuffer(h)) h.copy(e, u);
            else throw new TypeError('"list" argument must be an Array of Buffers');
            u += h.length;
        }
        return e;
    };
    function K(n, r) {
        if (o.isBuffer(n)) return n.length;
        if (a.isView(n) || C(n, a)) return n.byteLength;
        if (typeof n != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof n);
        const t = n.length, i = arguments.length > 2 && arguments[2] === !0;
        if (!i && t === 0) return 0;
        let e = !1;
        for(;;)switch(r){
            case "ascii":
            case "latin1":
            case "binary":
                return t;
            case "utf8":
            case "utf-8":
                return V(n).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return t * 2;
            case "hex":
                return t >>> 1;
            case "base64":
                return cr(n).length;
            default:
                if (e) return i ? -1 : V(n).length;
                r = ("" + r).toLowerCase(), e = !0;
        }
    }
    o.byteLength = K;
    function wr(n, r, t) {
        let i = !1;
        if ((r === void 0 || r < 0) && (r = 0), r > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r)) return "";
        for(n || (n = "utf8");;)switch(n){
            case "hex":
                return Ar(this, r, t);
            case "utf8":
            case "utf-8":
                return v(this, r, t);
            case "ascii":
                return Ir(this, r, t);
            case "latin1":
            case "binary":
                return Fr(this, r, t);
            case "base64":
                return dr(this, r, t);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Ur(this, r, t);
            default:
                if (i) throw new TypeError("Unknown encoding: " + n);
                n = (n + "").toLowerCase(), i = !0;
        }
    }
    o.prototype._isBuffer = !0;
    function M(n, r, t) {
        const i = n[r];
        n[r] = n[t], n[t] = i;
    }
    o.prototype.swap16 = function() {
        const r = this.length;
        if (r % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for(let t = 0; t < r; t += 2)M(this, t, t + 1);
        return this;
    }, o.prototype.swap32 = function() {
        const r = this.length;
        if (r % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for(let t = 0; t < r; t += 4)M(this, t, t + 3), M(this, t + 1, t + 2);
        return this;
    }, o.prototype.swap64 = function() {
        const r = this.length;
        if (r % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for(let t = 0; t < r; t += 8)M(this, t, t + 7), M(this, t + 1, t + 6), M(this, t + 2, t + 5), M(this, t + 3, t + 4);
        return this;
    }, o.prototype.toString = function() {
        const r = this.length;
        return r === 0 ? "" : arguments.length === 0 ? v(this, 0, r) : wr.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(r) {
        if (!o.isBuffer(r)) throw new TypeError("Argument must be a Buffer");
        return this === r ? !0 : o.compare(this, r) === 0;
    }, o.prototype.inspect = function() {
        let r = "";
        const t = s.INSPECT_MAX_BYTES;
        return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    }, w && (o.prototype[w] = o.prototype.inspect), o.prototype.compare = function(r, t, i, e, u) {
        if (C(r, p) && (r = o.from(r, r.offset, r.byteLength)), !o.isBuffer(r)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
        if (t === void 0 && (t = 0), i === void 0 && (i = r ? r.length : 0), e === void 0 && (e = 0), u === void 0 && (u = this.length), t < 0 || i > r.length || e < 0 || u > this.length) throw new RangeError("out of range index");
        if (e >= u && t >= i) return 0;
        if (e >= u) return -1;
        if (t >= i) return 1;
        if (t >>>= 0, i >>>= 0, e >>>= 0, u >>>= 0, this === r) return 0;
        let h = u - e, y = i - t;
        const E = Math.min(h, y), g = this.slice(e, u), d = r.slice(t, i);
        for(let x = 0; x < E; ++x)if (g[x] !== d[x]) {
            h = g[x], y = d[x];
            break;
        }
        return h < y ? -1 : y < h ? 1 : 0;
    };
    function Z(n, r, t, i, e) {
        if (n.length === 0) return -1;
        if (typeof t == "string" ? (i = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, X(t) && (t = e ? 0 : n.length - 1), t < 0 && (t = n.length + t), t >= n.length) {
            if (e) return -1;
            t = n.length - 1;
        } else if (t < 0) if (e) t = 0;
        else return -1;
        if (typeof r == "string" && (r = o.from(r, i)), o.isBuffer(r)) return r.length === 0 ? -1 : Q(n, r, t, i, e);
        if (typeof r == "number") return r = r & 255, typeof p.prototype.indexOf == "function" ? e ? p.prototype.indexOf.call(n, r, t) : p.prototype.lastIndexOf.call(n, r, t) : Q(n, [
            r
        ], t, i, e);
        throw new TypeError("val must be string, number or Buffer");
    }
    function Q(n, r, t, i, e) {
        let u = 1, h = n.length, y = r.length;
        if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) {
            if (n.length < 2 || r.length < 2) return -1;
            u = 2, h /= 2, y /= 2, t /= 2;
        }
        function E(d, x) {
            return u === 1 ? d[x] : d.readUInt16BE(x * u);
        }
        let g;
        if (e) {
            let d = -1;
            for(g = t; g < h; g++)if (E(n, g) === E(r, d === -1 ? 0 : g - d)) {
                if (d === -1 && (d = g), g - d + 1 === y) return d * u;
            } else d !== -1 && (g -= g - d), d = -1;
        } else for(t + y > h && (t = h - y), g = t; g >= 0; g--){
            let d = !0;
            for(let x = 0; x < y; x++)if (E(n, g + x) !== E(r, x)) {
                d = !1;
                break;
            }
            if (d) return g;
        }
        return -1;
    }
    o.prototype.includes = function(r, t, i) {
        return this.indexOf(r, t, i) !== -1;
    }, o.prototype.indexOf = function(r, t, i) {
        return Z(this, r, t, i, !0);
    }, o.prototype.lastIndexOf = function(r, t, i) {
        return Z(this, r, t, i, !1);
    };
    function yr(n, r, t, i) {
        t = Number(t) || 0;
        const e = n.length - t;
        i ? (i = Number(i), i > e && (i = e)) : i = e;
        const u = r.length;
        i > u / 2 && (i = u / 2);
        let h;
        for(h = 0; h < i; ++h){
            const y = parseInt(r.substr(h * 2, 2), 16);
            if (X(y)) return h;
            n[t + h] = y;
        }
        return h;
    }
    function xr(n, r, t, i) {
        return P(V(r, n.length - t), n, t, i);
    }
    function Br(n, r, t, i) {
        return P(Sr(r), n, t, i);
    }
    function gr(n, r, t, i) {
        return P(cr(r), n, t, i);
    }
    function Er(n, r, t, i) {
        return P(_r(r, n.length - t), n, t, i);
    }
    o.prototype.write = function(r, t, i, e) {
        if (t === void 0) e = "utf8", i = this.length, t = 0;
        else if (i === void 0 && typeof t == "string") e = t, i = this.length, t = 0;
        else if (isFinite(t)) t = t >>> 0, isFinite(i) ? (i = i >>> 0, e === void 0 && (e = "utf8")) : (e = i, i = void 0);
        else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const u = this.length - t;
        if ((i === void 0 || i > u) && (i = u), r.length > 0 && (i < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        e || (e = "utf8");
        let h = !1;
        for(;;)switch(e){
            case "hex":
                return yr(this, r, t, i);
            case "utf8":
            case "utf-8":
                return xr(this, r, t, i);
            case "ascii":
            case "latin1":
            case "binary":
                return Br(this, r, t, i);
            case "base64":
                return gr(this, r, t, i);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Er(this, r, t, i);
            default:
                if (h) throw new TypeError("Unknown encoding: " + e);
                e = ("" + e).toLowerCase(), h = !0;
        }
    }, o.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        };
    };
    function dr(n, r, t) {
        return r === 0 && t === n.length ? c.fromByteArray(n) : c.fromByteArray(n.slice(r, t));
    }
    function v(n, r, t) {
        t = Math.min(n.length, t);
        const i = [];
        let e = r;
        for(; e < t;){
            const u = n[e];
            let h = null, y = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
            if (e + y <= t) {
                let E, g, d, x;
                switch(y){
                    case 1:
                        u < 128 && (h = u);
                        break;
                    case 2:
                        E = n[e + 1], (E & 192) === 128 && (x = (u & 31) << 6 | E & 63, x > 127 && (h = x));
                        break;
                    case 3:
                        E = n[e + 1], g = n[e + 2], (E & 192) === 128 && (g & 192) === 128 && (x = (u & 15) << 12 | (E & 63) << 6 | g & 63, x > 2047 && (x < 55296 || x > 57343) && (h = x));
                        break;
                    case 4:
                        E = n[e + 1], g = n[e + 2], d = n[e + 3], (E & 192) === 128 && (g & 192) === 128 && (d & 192) === 128 && (x = (u & 15) << 18 | (E & 63) << 12 | (g & 63) << 6 | d & 63, x > 65535 && x < 1114112 && (h = x));
                }
            }
            h === null ? (h = 65533, y = 1) : h > 65535 && (h -= 65536, i.push(h >>> 10 & 1023 | 55296), h = 56320 | h & 1023), i.push(h), e += y;
        }
        return mr(i);
    }
    const rr = 4096;
    function mr(n) {
        const r = n.length;
        if (r <= rr) return String.fromCharCode.apply(String, n);
        let t = "", i = 0;
        for(; i < r;)t += String.fromCharCode.apply(String, n.slice(i, i += rr));
        return t;
    }
    function Ir(n, r, t) {
        let i = "";
        t = Math.min(n.length, t);
        for(let e = r; e < t; ++e)i += String.fromCharCode(n[e] & 127);
        return i;
    }
    function Fr(n, r, t) {
        let i = "";
        t = Math.min(n.length, t);
        for(let e = r; e < t; ++e)i += String.fromCharCode(n[e]);
        return i;
    }
    function Ar(n, r, t) {
        const i = n.length;
        (!r || r < 0) && (r = 0), (!t || t < 0 || t > i) && (t = i);
        let e = "";
        for(let u = r; u < t; ++u)e += Lr[n[u]];
        return e;
    }
    function Ur(n, r, t) {
        const i = n.slice(r, t);
        let e = "";
        for(let u = 0; u < i.length - 1; u += 2)e += String.fromCharCode(i[u] + i[u + 1] * 256);
        return e;
    }
    o.prototype.slice = function(r, t) {
        const i = this.length;
        r = ~~r, t = t === void 0 ? i : ~~t, r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), t < 0 ? (t += i, t < 0 && (t = 0)) : t > i && (t = i), t < r && (t = r);
        const e = this.subarray(r, t);
        return Object.setPrototypeOf(e, o.prototype), e;
    };
    function I(n, r, t) {
        if (n % 1 !== 0 || n < 0) throw new RangeError("offset is not uint");
        if (n + r > t) throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(r, t, i) {
        r = r >>> 0, t = t >>> 0, i || I(r, t, this.length);
        let e = this[r], u = 1, h = 0;
        for(; ++h < t && (u *= 256);)e += this[r + h] * u;
        return e;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(r, t, i) {
        r = r >>> 0, t = t >>> 0, i || I(r, t, this.length);
        let e = this[r + --t], u = 1;
        for(; t > 0 && (u *= 256);)e += this[r + --t] * u;
        return e;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(r, t) {
        return r = r >>> 0, t || I(r, 1, this.length), this[r];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(r, t) {
        return r = r >>> 0, t || I(r, 2, this.length), this[r] | this[r + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(r, t) {
        return r = r >>> 0, t || I(r, 2, this.length), this[r] << 8 | this[r + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(r, t) {
        return r = r >>> 0, t || I(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(r, t) {
        return r = r >>> 0, t || I(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    }, o.prototype.readBigUInt64LE = L(function(r) {
        r = r >>> 0, k(r, "offset");
        const t = this[r], i = this[r + 7];
        (t === void 0 || i === void 0) && $(r, this.length - 8);
        const e = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, u = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + i * 2 ** 24;
        return BigInt(e) + (BigInt(u) << BigInt(32));
    }), o.prototype.readBigUInt64BE = L(function(r) {
        r = r >>> 0, k(r, "offset");
        const t = this[r], i = this[r + 7];
        (t === void 0 || i === void 0) && $(r, this.length - 8);
        const e = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], u = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + i;
        return (BigInt(e) << BigInt(32)) + BigInt(u);
    }), o.prototype.readIntLE = function(r, t, i) {
        r = r >>> 0, t = t >>> 0, i || I(r, t, this.length);
        let e = this[r], u = 1, h = 0;
        for(; ++h < t && (u *= 256);)e += this[r + h] * u;
        return u *= 128, e >= u && (e -= Math.pow(2, 8 * t)), e;
    }, o.prototype.readIntBE = function(r, t, i) {
        r = r >>> 0, t = t >>> 0, i || I(r, t, this.length);
        let e = t, u = 1, h = this[r + --e];
        for(; e > 0 && (u *= 256);)h += this[r + --e] * u;
        return u *= 128, h >= u && (h -= Math.pow(2, 8 * t)), h;
    }, o.prototype.readInt8 = function(r, t) {
        return r = r >>> 0, t || I(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    }, o.prototype.readInt16LE = function(r, t) {
        r = r >>> 0, t || I(r, 2, this.length);
        const i = this[r] | this[r + 1] << 8;
        return i & 32768 ? i | 4294901760 : i;
    }, o.prototype.readInt16BE = function(r, t) {
        r = r >>> 0, t || I(r, 2, this.length);
        const i = this[r + 1] | this[r] << 8;
        return i & 32768 ? i | 4294901760 : i;
    }, o.prototype.readInt32LE = function(r, t) {
        return r = r >>> 0, t || I(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    }, o.prototype.readInt32BE = function(r, t) {
        return r = r >>> 0, t || I(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    }, o.prototype.readBigInt64LE = L(function(r) {
        r = r >>> 0, k(r, "offset");
        const t = this[r], i = this[r + 7];
        (t === void 0 || i === void 0) && $(r, this.length - 8);
        const e = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (i << 24);
        return (BigInt(e) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    }), o.prototype.readBigInt64BE = L(function(r) {
        r = r >>> 0, k(r, "offset");
        const t = this[r], i = this[r + 7];
        (t === void 0 || i === void 0) && $(r, this.length - 8);
        const e = (t << 24) + // Overflow
        this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
        return (BigInt(e) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + i);
    }), o.prototype.readFloatLE = function(r, t) {
        return r = r >>> 0, t || I(r, 4, this.length), f.read(this, r, !0, 23, 4);
    }, o.prototype.readFloatBE = function(r, t) {
        return r = r >>> 0, t || I(r, 4, this.length), f.read(this, r, !1, 23, 4);
    }, o.prototype.readDoubleLE = function(r, t) {
        return r = r >>> 0, t || I(r, 8, this.length), f.read(this, r, !0, 52, 8);
    }, o.prototype.readDoubleBE = function(r, t) {
        return r = r >>> 0, t || I(r, 8, this.length), f.read(this, r, !1, 52, 8);
    };
    function U(n, r, t, i, e, u) {
        if (!o.isBuffer(n)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (r > e || r < u) throw new RangeError('"value" argument is out of bounds');
        if (t + i > n.length) throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(r, t, i, e) {
        if (r = +r, t = t >>> 0, i = i >>> 0, !e) {
            const y = Math.pow(2, 8 * i) - 1;
            U(this, r, t, i, y, 0);
        }
        let u = 1, h = 0;
        for(this[t] = r & 255; ++h < i && (u *= 256);)this[t + h] = r / u & 255;
        return t + i;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(r, t, i, e) {
        if (r = +r, t = t >>> 0, i = i >>> 0, !e) {
            const y = Math.pow(2, 8 * i) - 1;
            U(this, r, t, i, y, 0);
        }
        let u = i - 1, h = 1;
        for(this[t + u] = r & 255; --u >= 0 && (h *= 256);)this[t + u] = r / h & 255;
        return t + i;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function tr(n, r, t, i, e) {
        hr(r, i, e, n, t, 7);
        let u = Number(r & BigInt(4294967295));
        n[t++] = u, u = u >> 8, n[t++] = u, u = u >> 8, n[t++] = u, u = u >> 8, n[t++] = u;
        let h = Number(r >> BigInt(32) & BigInt(4294967295));
        return n[t++] = h, h = h >> 8, n[t++] = h, h = h >> 8, n[t++] = h, h = h >> 8, n[t++] = h, t;
    }
    function nr(n, r, t, i, e) {
        hr(r, i, e, n, t, 7);
        let u = Number(r & BigInt(4294967295));
        n[t + 7] = u, u = u >> 8, n[t + 6] = u, u = u >> 8, n[t + 5] = u, u = u >> 8, n[t + 4] = u;
        let h = Number(r >> BigInt(32) & BigInt(4294967295));
        return n[t + 3] = h, h = h >> 8, n[t + 2] = h, h = h >> 8, n[t + 1] = h, h = h >> 8, n[t] = h, t + 8;
    }
    o.prototype.writeBigUInt64LE = L(function(r, t = 0) {
        return tr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeBigUInt64BE = L(function(r, t = 0) {
        return nr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeIntLE = function(r, t, i, e) {
        if (r = +r, t = t >>> 0, !e) {
            const E = Math.pow(2, 8 * i - 1);
            U(this, r, t, i, E - 1, -E);
        }
        let u = 0, h = 1, y = 0;
        for(this[t] = r & 255; ++u < i && (h *= 256);)r < 0 && y === 0 && this[t + u - 1] !== 0 && (y = 1), this[t + u] = (r / h >> 0) - y & 255;
        return t + i;
    }, o.prototype.writeIntBE = function(r, t, i, e) {
        if (r = +r, t = t >>> 0, !e) {
            const E = Math.pow(2, 8 * i - 1);
            U(this, r, t, i, E - 1, -E);
        }
        let u = i - 1, h = 1, y = 0;
        for(this[t + u] = r & 255; --u >= 0 && (h *= 256);)r < 0 && y === 0 && this[t + u + 1] !== 0 && (y = 1), this[t + u] = (r / h >> 0) - y & 255;
        return t + i;
    }, o.prototype.writeInt8 = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    }, o.prototype.writeInt16LE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    }, o.prototype.writeInt16BE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    }, o.prototype.writeInt32LE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    }, o.prototype.writeInt32BE = function(r, t, i) {
        return r = +r, t = t >>> 0, i || U(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    }, o.prototype.writeBigInt64LE = L(function(r, t = 0) {
        return tr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), o.prototype.writeBigInt64BE = L(function(r, t = 0) {
        return nr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function ir(n, r, t, i, e, u) {
        if (t + i > n.length) throw new RangeError("Index out of range");
        if (t < 0) throw new RangeError("Index out of range");
    }
    function er(n, r, t, i, e) {
        return r = +r, t = t >>> 0, e || ir(n, r, t, 4), f.write(n, r, t, i, 23, 4), t + 4;
    }
    o.prototype.writeFloatLE = function(r, t, i) {
        return er(this, r, t, !0, i);
    }, o.prototype.writeFloatBE = function(r, t, i) {
        return er(this, r, t, !1, i);
    };
    function or(n, r, t, i, e) {
        return r = +r, t = t >>> 0, e || ir(n, r, t, 8), f.write(n, r, t, i, 52, 8), t + 8;
    }
    o.prototype.writeDoubleLE = function(r, t, i) {
        return or(this, r, t, !0, i);
    }, o.prototype.writeDoubleBE = function(r, t, i) {
        return or(this, r, t, !1, i);
    }, o.prototype.copy = function(r, t, i, e) {
        if (!o.isBuffer(r)) throw new TypeError("argument should be a Buffer");
        if (i || (i = 0), !e && e !== 0 && (e = this.length), t >= r.length && (t = r.length), t || (t = 0), e > 0 && e < i && (e = i), e === i || r.length === 0 || this.length === 0) return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (i < 0 || i >= this.length) throw new RangeError("Index out of range");
        if (e < 0) throw new RangeError("sourceEnd out of bounds");
        e > this.length && (e = this.length), r.length - t < e - i && (e = r.length - t + i);
        const u = e - i;
        return this === r && typeof p.prototype.copyWithin == "function" ? this.copyWithin(t, i, e) : p.prototype.set.call(r, this.subarray(i, e), t), u;
    }, o.prototype.fill = function(r, t, i, e) {
        if (typeof r == "string") {
            if (typeof t == "string" ? (e = t, t = 0, i = this.length) : typeof i == "string" && (e = i, i = this.length), e !== void 0 && typeof e != "string") throw new TypeError("encoding must be a string");
            if (typeof e == "string" && !o.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            if (r.length === 1) {
                const h = r.charCodeAt(0);
                (e === "utf8" && h < 128 || e === "latin1") && (r = h);
            }
        } else typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
        if (t < 0 || this.length < t || this.length < i) throw new RangeError("Out of range index");
        if (i <= t) return this;
        t = t >>> 0, i = i === void 0 ? this.length : i >>> 0, r || (r = 0);
        let u;
        if (typeof r == "number") for(u = t; u < i; ++u)this[u] = r;
        else {
            const h = o.isBuffer(r) ? r : o.from(r, e), y = h.length;
            if (y === 0) throw new TypeError('The value "' + r + '" is invalid for argument "value"');
            for(u = 0; u < i - t; ++u)this[u + t] = h[u % y];
        }
        return this;
    };
    const b = {};
    function q(n, r, t) {
        b[n] = class extends t {
            constructor(){
                super(), Object.defineProperty(this, "message", {
                    value: r.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }), this.name = `${this.name} [${n}]`, this.stack, delete this.name;
            }
            get code() {
                return n;
            }
            set code(e) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: e,
                    writable: !0
                });
            }
            toString() {
                return `${this.name} [${n}]: ${this.message}`;
            }
        };
    }
    q("ERR_BUFFER_OUT_OF_BOUNDS", function(n) {
        return n ? `${n} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError), q("ERR_INVALID_ARG_TYPE", function(n, r) {
        return `The "${n}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError), q("ERR_OUT_OF_RANGE", function(n, r, t) {
        let i = `The value of "${n}" is out of range.`, e = t;
        return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? e = ur(String(t)) : typeof t == "bigint" && (e = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (e = ur(e)), e += "n"), i += ` It must be ${r}. Received ${e}`, i;
    }, RangeError);
    function ur(n) {
        let r = "", t = n.length;
        const i = n[0] === "-" ? 1 : 0;
        for(; t >= i + 4; t -= 3)r = `_${n.slice(t - 3, t)}${r}`;
        return `${n.slice(0, t)}${r}`;
    }
    function Tr(n, r, t) {
        k(r, "offset"), (n[r] === void 0 || n[r + t] === void 0) && $(r, n.length - (t + 1));
    }
    function hr(n, r, t, i, e, u) {
        if (n > t || n < r) {
            const h = typeof r == "bigint" ? "n" : "";
            let y;
            throw r === 0 || r === BigInt(0) ? y = `>= 0${h} and < 2${h} ** ${(u + 1) * 8}${h}` : y = `>= -(2${h} ** ${(u + 1) * 8 - 1}${h}) and < 2 ** ${(u + 1) * 8 - 1}${h}`, new b.ERR_OUT_OF_RANGE("value", y, n);
        }
        Tr(i, e, u);
    }
    function k(n, r) {
        if (typeof n != "number") throw new b.ERR_INVALID_ARG_TYPE(r, "number", n);
    }
    function $(n, r, t) {
        throw Math.floor(n) !== n ? (k(n, t), new b.ERR_OUT_OF_RANGE("offset", "an integer", n)) : r < 0 ? new b.ERR_BUFFER_OUT_OF_BOUNDS() : new b.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${r}`, n);
    }
    const Rr = /[^+/0-9A-Za-z-_]/g;
    function Cr(n) {
        if (n = n.split("=")[0], n = n.trim().replace(Rr, ""), n.length < 2) return "";
        for(; n.length % 4 !== 0;)n = n + "=";
        return n;
    }
    function V(n, r) {
        r = r || 1 / 0;
        let t;
        const i = n.length;
        let e = null;
        const u = [];
        for(let h = 0; h < i; ++h){
            if (t = n.charCodeAt(h), t > 55295 && t < 57344) {
                if (!e) {
                    if (t > 56319) {
                        (r -= 3) > -1 && u.push(239, 191, 189);
                        continue;
                    } else if (h + 1 === i) {
                        (r -= 3) > -1 && u.push(239, 191, 189);
                        continue;
                    }
                    e = t;
                    continue;
                }
                if (t < 56320) {
                    (r -= 3) > -1 && u.push(239, 191, 189), e = t;
                    continue;
                }
                t = (e - 55296 << 10 | t - 56320) + 65536;
            } else e && (r -= 3) > -1 && u.push(239, 191, 189);
            if (e = null, t < 128) {
                if ((r -= 1) < 0) break;
                u.push(t);
            } else if (t < 2048) {
                if ((r -= 2) < 0) break;
                u.push(t >> 6 | 192, t & 63 | 128);
            } else if (t < 65536) {
                if ((r -= 3) < 0) break;
                u.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
            } else if (t < 1114112) {
                if ((r -= 4) < 0) break;
                u.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
            } else throw new Error("Invalid code point");
        }
        return u;
    }
    function Sr(n) {
        const r = [];
        for(let t = 0; t < n.length; ++t)r.push(n.charCodeAt(t) & 255);
        return r;
    }
    function _r(n, r) {
        let t, i, e;
        const u = [];
        for(let h = 0; h < n.length && !((r -= 2) < 0); ++h)t = n.charCodeAt(h), i = t >> 8, e = t % 256, u.push(e), u.push(i);
        return u;
    }
    function cr(n) {
        return c.toByteArray(Cr(n));
    }
    function P(n, r, t, i) {
        let e;
        for(e = 0; e < i && !(e + t >= r.length || e >= n.length); ++e)r[e + t] = n[e];
        return e;
    }
    function C(n, r) {
        return n instanceof r || n != null && n.constructor != null && n.constructor.name != null && n.constructor.name === r.name;
    }
    function X(n) {
        return n !== n;
    }
    const Lr = function() {
        const n = "0123456789abcdef", r = new Array(256);
        for(let t = 0; t < 16; ++t){
            const i = t * 16;
            for(let e = 0; e < 16; ++e)r[i + e] = n[t] + n[e];
        }
        return r;
    }();
    function L(n) {
        return typeof BigInt > "u" ? Nr : n;
    }
    function Nr() {
        throw new Error("BigInt not supported");
    }
})(fr);
const O = fr.Buffer;
class Yr {
    static fromHex(c) {
        if (c = c.trim(), c.length === 0) return new Uint8Array(0);
        if (c.length < 2 || c.length & 1) throw new Error("Invalid hex string: odd length.");
        if ((c.startsWith("0x") || c.startsWith("0X")) && (c = c.slice(2)), !c.match(/^[0-9a-fA-F]*$/)) throw new Error("Invalid hex string: contains non-hex characters");
        const w = c.match(/.{1,2}/g);
        if (!w) throw new Error("Invalid hex string");
        return new Uint8Array(w.map((l)=>parseInt(l, 16)));
    }
    static toHex(c) {
        return Array.from(c, (f)=>f.toString(16).padStart(2, "0")).join("");
    }
    static fromString(c) {
        return c = c.trim(), new TextEncoder().encode(c);
    }
    static toString(c) {
        return new TextDecoder("utf-8").decode(c);
    }
    static concat(...c) {
        const f = c.reduce((p, a)=>p + a.length, 0), w = new Uint8Array(f);
        let l = 0;
        for (const p of c)w.set(p, l), l += p.length;
        return w;
    }
    static alloc(c) {
        return new Uint8Array(c);
    }
    static writeBigUint64BE(c) {
        const f = new ArrayBuffer(8);
        return new DataView(f).setBigUint64(0, c, !1), new Uint8Array(f);
    }
    static toBase64(c) {
        if (typeof O < "u") return O.from(c).toString("base64");
        if (c.length > 32768) {
            let f = "";
            for(let w = 0; w < c.length; w += 32768){
                const l = c.slice(w, w + 32768);
                f += btoa(String.fromCharCode(...l));
            }
            return f;
        }
        return btoa(String.fromCharCode(...c));
    }
    static fromBase64(c) {
        if (c = c.trim(), typeof O < "u") return new Uint8Array(O.from(c, "base64"));
        let f = c.replace(/-/g, "+").replace(/_/g, "/");
        for(; f.length % 4;)f += "=";
        return new Uint8Array([
            ...atob(f)
        ].map((w)=>w.charCodeAt(0)));
    }
    static equals(c, f) {
        if (c.length !== f.length) return !1;
        let w = 0;
        for(let l = 0; l < c.length; l++)w |= c[l] ^ f[l];
        return w === 0;
    }
    static compare(c, f) {
        const w = Math.min(c.length, f.length);
        for(let l = 0; l < w; l++){
            if (c[l] < f[l]) return -1;
            if (c[l] > f[l]) return 1;
        }
        return c.length - f.length;
    }
}
function Vr(s) {
    return Hr((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(s));
}
function Hr(s) {
    return BigInt(`0x${s}`);
}
function Xr(s) {
    return Yr.fromBase64(s);
}
;
 //# sourceMappingURL=utils-CrQNeCaC.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/crypto/common.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createRandomPrivateKey",
    ()=>v,
    "deriveKeysetId",
    ()=>P,
    "deserializeMintKeys",
    ()=>O,
    "getKeysetIdInt",
    ()=>K,
    "hashToCurve",
    ()=>T,
    "hash_e",
    ()=>H,
    "pointFromBytes",
    ()=>w,
    "pointFromHex",
    ()=>l,
    "serializeMintKeys",
    ()=>p
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/secp256k1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/abstract/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/utils-CrQNeCaC.js [app-ssr] (ecmascript)");
;
;
;
;
const d = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])("536563703235366b315f48617368546f43757276655f43617368755f");
function T(t) {
    const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].concat(d, t)), n = new Uint32Array(1), o = 2 ** 16;
    for(let s = 0; s < o; s++){
        const m = new Uint8Array(n.buffer), r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].concat(e, m));
        try {
            return l((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].concat(new Uint8Array([
                2
            ]), r)));
        } catch  {
            n[0]++;
        }
    }
    throw new Error("No valid point found");
}
function H(t) {
    const n = t.map((o)=>o.toHex(!1)).join("");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(new TextEncoder().encode(n));
}
function w(t) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].ProjectivePoint.fromHex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(t));
}
function l(t) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].ProjectivePoint.fromHex(t);
}
const K = (t)=>{
    let e;
    return /^[a-fA-F0-9]+$/.test(t) ? e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["h"])(t) % BigInt(2 ** 31 - 1) : e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(t)) % BigInt(2 ** 31 - 1), e;
};
function v() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].utils.randomPrivateKey();
}
function p(t) {
    const e = {};
    return Object.keys(t).forEach((n)=>{
        e[n] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(t[n]);
    }), e;
}
function O(t) {
    const e = {};
    return Object.keys(t).forEach((n)=>{
        e[n] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(t[n]);
    }), e;
}
function P(t) {
    const n = (r)=>[
            BigInt(r[0]),
            r[1]
        ], o = Object.entries(p(t)).map(n).sort((r, c)=>r[0] < c[0] ? -1 : r[0] > c[0] ? 1 : 0).map(([, r])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(r)).reduce((r, c)=>I(r, c), new Uint8Array()), s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(o);
    return "00" + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toHex(s).slice(0, 14);
}
function I(t, e) {
    const n = new Uint8Array(t.length + e.length);
    return n.set(t), n.set(e, t.length), n;
}
;
 //# sourceMappingURL=common.es.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT12.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "verifyDLEQProof",
    ()=>v,
    "verifyDLEQProof_reblind",
    ()=>d
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/common.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/abstract/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/secp256k1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/utils-CrQNeCaC.js [app-ssr] (ecmascript)");
;
;
;
;
function p(t, o) {
    if (t.length !== o.length) return !1;
    for(let r = 0; r < t.length; r++)if (t[r] !== o[r]) return !1;
    return !0;
}
const v = (t, o, r, e)=>{
    const n = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].ProjectivePoint.fromPrivateKey((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(t.s)), s = e.multiply((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(t.e)), i = o.multiply((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(t.s)), f = r.multiply((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(t.e)), m = n.subtract(s), a = i.subtract(f), y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hash_e"])([
        m,
        a,
        e,
        r
    ]);
    return p(y, t.e);
}, d = (t, o, r, e)=>{
    if (o.r === void 0) throw new Error("verifyDLEQProof_reblind: Undefined blinding factor");
    const n = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashToCurve"])(t), s = r.add(e.multiply(o.r)), i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].ProjectivePoint.fromPrivateKey(o.r), f = n.add(i);
    return v(o, f, s, e);
};
;
 //# sourceMappingURL=NUT12.es.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/NUT09-BsylB_jy.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "a",
    ()=>D,
    "b",
    ()=>x,
    "c",
    ()=>j,
    "d",
    ()=>T,
    "e",
    ()=>U,
    "f",
    ()=>z,
    "i",
    ()=>u
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$hmac$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/hmac.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/common.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip32$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip32/lib/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/utils-CrQNeCaC.js [app-ssr] (ecmascript)");
;
;
;
;
;
function D(r) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toBase64(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
function U(r) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromBase64(r);
}
function j(r) {
    const e = JSON.stringify(r);
    return v(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toBase64(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromString(e)));
}
function x(r) {
    const e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toString(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromBase64($(r)));
    return JSON.parse(e);
}
function $(r) {
    return r.replace(/-/g, "+").replace(/_/g, "/").split("=")[0];
}
function v(r) {
    return r.replace(/\+/g, "-").replace(/\//g, "_").split("=")[0];
}
function u(r) {
    if (typeof r != "string" || r.length === 0) return !1;
    const e = /^[A-Za-z0-9\-_]+={0,2}$/, o = /^[A-Za-z0-9+/]+={0,2}$/;
    if (!e.test(r) && !o.test(r)) return !1;
    const n = r.replace(/-/g, "+").replace(/_/g, "/"), a = (4 - n.length % 4) % 4;
    if (a > 2) return !1;
    const c = n + "=".repeat(a);
    try {
        const f = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromBase64(c), s = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toBase64(f), g = s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, ""), l = n.replace(/=+$/, "");
        return s.replace(/=+$/, "") === l || g === l;
    } catch  {
        return !1;
    }
}
const S = "m/129372'/0'", T = (r, e, o)=>{
    const n = /^[a-fA-F0-9]+$/.test(e);
    if (!n && u(e) || n && e.startsWith("00")) return i(r, e, o, 0);
    if (n && e.startsWith("01")) return p(r, e, o, 0);
    throw new Error(`Unrecognized keyset ID version ${e.slice(0, 2)}`);
}, z = (r, e, o)=>{
    const n = /^[a-fA-F0-9]+$/.test(e);
    if (!n && u(e) || n && e.startsWith("00")) return i(r, e, o, 1);
    if (n && e.startsWith("01")) return p(r, e, o, 1);
    throw new Error(`Unrecognized keyset ID version ${e.slice(0, 2)}`);
}, p = (r, e, o, n)=>{
    let a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].concat(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromString("Cashu_KDF_HMAC_SHA256"), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromHex(e), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].writeBigUint64BE(BigInt(o)));
    switch(n){
        case 0:
            a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].concat(a, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromHex("00"));
            break;
        case 1:
            a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].concat(a, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromHex("01"));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$hmac$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hmac"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"], r, a);
}, i = (r, e, o, n)=>{
    const a = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip32$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HDKey"].fromMasterSeed(r), c = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getKeysetIdInt"])(e), f = `${S}/${c}'/${o}'/${n}`, s = a.derive(f);
    if (s.privateKey === null) throw new Error("Could not derive private key");
    return s.privateKey;
};
;
 //# sourceMappingURL=NUT09-BsylB_jy.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/crypto/common/NUT11.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parseP2PKSecret",
    ()=>e
]);
const e = (r)=>{
    try {
        return r instanceof Uint8Array && (r = new TextDecoder().decode(r)), JSON.parse(r);
    } catch  {
        throw new Error("can't parse secret");
    }
};
;
 //# sourceMappingURL=NUT11.es.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT11.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createP2PKsecret",
    ()=>x,
    "getP2PKExpectedKWitnessPubkeys",
    ()=>d,
    "getP2PKLocktime",
    ()=>w,
    "getP2PKNSigs",
    ()=>N,
    "getP2PKSigFlag",
    ()=>O,
    "getP2PKWitnessPubkeys",
    ()=>E,
    "getP2PKWitnessRefundkeys",
    ()=>I,
    "getP2PKWitnessSignatures",
    ()=>K,
    "getSignedOutput",
    ()=>_,
    "getSignedOutputs",
    ()=>H,
    "hasP2PKSignedProof",
    ()=>F,
    "signBlindedMessage",
    ()=>k,
    "signP2PKProof",
    ()=>T,
    "signP2PKProofs",
    ()=>W,
    "signP2PKSecret",
    ()=>p,
    "verifyP2PKSecretSignature",
    ()=>h
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/abstract/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/secp256k1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/common/NUT11.es.js [app-ssr] (ecmascript)");
;
;
;
;
;
const x = (t)=>{
    const n = [
        "P2PK",
        {
            nonce: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomBytes"])(32)),
            data: t
        }
    ];
    return JSON.stringify(n);
}, p = (t, n)=>{
    const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(t), e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["schnorr"].sign(r, n);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(e);
}, k = (t, n)=>{
    const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(t), e = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["schnorr"].sign(r, n);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(e);
}, h = (t, n, r)=>{
    try {
        const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(n), s = r.length === 66 ? r.slice(2) : r;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["schnorr"].verify(t, e, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(s))) return !0;
    } catch (e) {
        console.error("verifyP2PKsecret error:", e);
    }
    return !1;
}, F = (t, n)=>n.witness ? K(n.witness).some((e)=>{
        try {
            return h(e, n.secret, t);
        } catch  {
            return !1;
        }
    }) : !1;
function d(t) {
    try {
        const n = typeof t == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseP2PKSecret"])(t) : t;
        if (n[0] !== "P2PK") throw new Error('Invalid P2PK secret: must start with "P2PK"');
        const r = Math.floor(Date.now() / 1e3);
        return w(n) > r ? E(n) : I(n);
    } catch  {}
    return [];
}
function E(t) {
    const n = typeof t == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseP2PKSecret"])(t) : t;
    if (n[0] !== "P2PK") throw new Error('Invalid P2PK secret: must start with "P2PK"');
    const { data: r, tags: e } = n[1], s = e && e.find((o)=>o[0] === "pubkeys"), i = s && s.length > 1 ? s.slice(1) : [];
    return [
        r,
        ...i
    ].filter(Boolean);
}
function I(t) {
    const n = typeof t == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseP2PKSecret"])(t) : t;
    if (n[0] !== "P2PK") throw new Error('Invalid P2PK secret: must start with "P2PK"');
    const { tags: r } = n[1], e = r && r.find((s)=>s[0] === "refund");
    return e && e.length > 1 ? e.slice(1).filter(Boolean) : [];
}
function w(t) {
    const n = typeof t == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseP2PKSecret"])(t) : t;
    if (n[0] !== "P2PK") throw new Error('Invalid P2PK secret: must start with "P2PK"');
    const { tags: r } = n[1], e = r && r.find((s)=>s[0] === "locktime");
    return e && e.length > 1 ? parseInt(e[1], 10) : 1 / 0;
}
function N(t) {
    const n = typeof t == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseP2PKSecret"])(t) : t;
    if (n[0] !== "P2PK") throw new Error('Invalid P2PK secret: must start with "P2PK"');
    if (!d(n).length) return 0;
    const { tags: e } = n[1], s = Math.floor(Date.now() / 1e3);
    if (w(n) > s) {
        const c = e && e.find((a)=>a[0] === "n_sigs");
        return c && c.length > 1 ? parseInt(c[1], 10) : 1;
    }
    const o = e && e.find((c)=>c[0] === "n_sigs_refund");
    return o && o.length > 1 ? parseInt(o[1], 10) : 1;
}
function O(t) {
    const n = typeof t == "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseP2PKSecret"])(t) : t;
    if (n[0] !== "P2PK") throw new Error('Invalid P2PK secret: must start with "P2PK"');
    const { tags: r } = n[1], e = r && r.find((s)=>s[0] === "sigflag");
    return e && e.length > 1 ? e[1] : "SIG_INPUTS";
}
const K = (t)=>{
    if (!t) return [];
    if (typeof t == "string") try {
        return JSON.parse(t).signatures || [];
    } catch (n) {
        return console.error("Failed to parse witness string:", n), [];
    }
    return t.signatures || [];
}, W = (t, n, r = !1)=>{
    const e = Array.isArray(n) ? n : [
        n
    ];
    return t.map((s, i)=>{
        let o = s;
        for (const c of e)try {
            o = T(o, c);
        } catch (a) {
            const l = a instanceof Error ? a.message : "Unknown error";
            if (r) throw new Error(`Failed signing proof #${i + 1}: ${l}`);
            console.warn(`Proof #${i + 1}: ${l}`);
        }
        return o;
    });
}, T = (t, n)=>{
    const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parseP2PKSecret"])(t.secret);
    if (r[0] !== "P2PK") throw new Error("not a P2PK secret");
    const e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["schnorr"].getPublicKey(n)), s = d(r);
    if (!s.length || !s.some((a)=>a.includes(e))) throw new Error(`Signature not required from [02|03]${e}`);
    const i = K(t.witness);
    if (i.some((a)=>{
        try {
            return h(a, t.secret, e);
        } catch  {
            return !1;
        }
    })) throw new Error(`Proof already signed by [02|03]${e}`);
    const c = p(t.secret, n);
    return i.push(c), {
        ...t,
        witness: {
            signatures: i
        }
    };
}, _ = (t, n)=>{
    const r = t.B_.toHex(!0), e = k(r, n);
    return t.witness = {
        signatures: [
            e
        ]
    }, t;
}, H = (t, n)=>t.map((r)=>_(r, n));
;
 //# sourceMappingURL=NUT11.es.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT20.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "signMintQuote",
    ()=>p,
    "verifyMintQuoteSignature",
    ()=>b
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/secp256k1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-ssr] (ecmascript)");
;
;
;
function u(s, n) {
    let e = s;
    for (const r of n)e += r.B_;
    const o = new TextEncoder().encode(e);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(o);
}
function p(s, n, e) {
    const o = u(n, e), r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(s), t = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["schnorr"].sign(o, r);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(t);
}
function b(s, n, e, o) {
    const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(o);
    let t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(s);
    if (t.length !== 33) return !1;
    t = t.slice(1);
    const f = u(n, e);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["schnorr"].verify(r, f, t);
}
;
 //# sourceMappingURL=NUT20.es.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/crypto/client.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "blindMessage",
    ()=>l,
    "constructProofFromPromise",
    ()=>y,
    "createRandomBlindedMessage",
    ()=>x,
    "deserializeProof",
    ()=>S,
    "serializeBlindedMessage",
    ()=>T,
    "serializeProof",
    ()=>v,
    "unblindSignature",
    ()=>C
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/secp256k1.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/utils-CrQNeCaC.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/common.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT11.es.js [app-ssr] (ecmascript)");
;
;
;
;
;
function x(t) {
    return l((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomBytes"])(32), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].utils.randomPrivateKey()), t);
}
function l(t, e, n) {
    const i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashToCurve"])(t);
    e || (e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].utils.randomPrivateKey()));
    const o = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$secp256k1$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["secp256k1"].ProjectivePoint.BASE.multiply(e), r = i.add(o);
    return n !== void 0 ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSignedOutput"])({
        B_: r,
        r: e,
        secret: t
    }, n) : {
        B_: r,
        r: e,
        secret: t
    };
}
function C(t, e, n) {
    return t.subtract(n.multiply(e));
}
function y(t, e, n, i) {
    const o = i, r = C(t.C_, e, o);
    return {
        id: t.id,
        amount: t.amount,
        secret: n,
        C: r
    };
}
const v = (t)=>({
        amount: t.amount,
        C: t.C.toHex(!0),
        id: t.id,
        secret: new TextDecoder().decode(t.secret),
        witness: JSON.stringify(t.witness)
    }), S = (t)=>({
        amount: t.amount,
        C: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointFromHex"])(t.C),
        id: t.id,
        secret: new TextEncoder().encode(t.secret),
        witness: t.witness ? JSON.parse(t.witness) : void 0
    }), T = (t, e)=>({
        B_: t.B_.toHex(!0),
        amount: e
    });
;
 //# sourceMappingURL=client.es.js.map
}),
"[project]/node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CashuAuthMint",
    ()=>Z,
    "CashuAuthWallet",
    ()=>We,
    "CashuMint",
    ()=>q,
    "CashuWallet",
    ()=>us,
    "CheckStateEnum",
    ()=>as,
    "ConsoleLogger",
    ()=>Ut,
    "HttpResponseError",
    ()=>st,
    "LogLevel",
    ()=>v,
    "MeltQuoteState",
    ()=>et,
    "MintOperationError",
    ()=>St,
    "MintQuoteState",
    ()=>gt,
    "NetworkError",
    ()=>Pt,
    "OutputData",
    ()=>Q,
    "PaymentRequest",
    ()=>Et,
    "PaymentRequestTransportType",
    ()=>xe,
    "decodePaymentRequest",
    ()=>ns,
    "deriveKeysetId",
    ()=>qe,
    "getBlindedAuthToken",
    ()=>hs,
    "getDecodedToken",
    ()=>Me,
    "getDecodedTokenBinary",
    ()=>rs,
    "getEncodedAuthToken",
    ()=>$e,
    "getEncodedToken",
    ()=>es,
    "getEncodedTokenBinary",
    ()=>os,
    "getEncodedTokenV4",
    ()=>Ie,
    "getTokenMetadata",
    ()=>ss,
    "hasValidDleq",
    ()=>Vt,
    "injectWebSocketImpl",
    ()=>is,
    "setGlobalRequestOptions",
    ()=>cs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT12$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT12.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/common.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/curves/esm/abstract/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/NUT09-BsylB_jy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/utils-CrQNeCaC.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT11.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT20$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT20.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@cashu/cashu-ts/lib/crypto/client.es.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
function ue(n) {
    return typeof n == "number" || typeof n == "string";
}
function kt(n) {
    const t = [];
    return bt(n, t), new Uint8Array(t);
}
function bt(n, t) {
    if (n === null) t.push(246);
    else if (n === void 0) t.push(247);
    else if (typeof n == "boolean") t.push(n ? 245 : 244);
    else if (typeof n == "number") Nt(n, t);
    else if (typeof n == "string") Qt(n, t);
    else if (Array.isArray(n)) le(n, t);
    else if (n instanceof Uint8Array) he(n, t);
    else if (// Defensive: POJO only (null/array handled above)
    typeof n == "object" && n !== null && !Array.isArray(n)) de(n, t);
    else throw new Error("Unsupported type");
}
function Nt(n, t) {
    if (n < 24) t.push(n);
    else if (n < 256) t.push(24, n);
    else if (n < 65536) t.push(25, n >> 8, n & 255);
    else if (n < 4294967296) t.push(26, n >> 24, n >> 16 & 255, n >> 8 & 255, n & 255);
    else throw new Error("Unsupported integer size");
}
function he(n, t) {
    const e = n.length;
    if (e < 24) t.push(64 + e);
    else if (e < 256) t.push(88, e);
    else if (e < 65536) t.push(89, e >> 8 & 255, e & 255);
    else if (e < 4294967296) t.push(90, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255);
    else throw new Error("Byte string too long to encode");
    for(let s = 0; s < n.length; s++)t.push(n[s]);
}
function Qt(n, t) {
    const e = new TextEncoder().encode(n), s = e.length;
    if (s < 24) t.push(96 + s);
    else if (s < 256) t.push(120, s);
    else if (s < 65536) t.push(121, s >> 8 & 255, s & 255);
    else if (s < 4294967296) t.push(122, s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, s & 255);
    else throw new Error("String too long to encode");
    for(let o = 0; o < e.length; o++)t.push(e[o]);
}
function le(n, t) {
    const e = n.length;
    if (e < 24) t.push(128 | e);
    else if (e < 256) t.push(152, e);
    else if (e < 65536) t.push(153, e >> 8, e & 255);
    else throw new Error("Unsupported array length");
    for (const s of n)bt(s, t);
}
function de(n, t) {
    const e = Object.keys(n);
    Nt(e.length, t), t[t.length - 1] |= 160;
    for (const s of e)Qt(s, t), bt(n[s], t);
}
function _t(n) {
    const t = new DataView(n.buffer, n.byteOffset, n.byteLength);
    return it(t, 0).value;
}
function it(n, t) {
    if (t >= n.byteLength) throw new Error("Unexpected end of data");
    const e = n.getUint8(t++), s = e >> 5, o = e & 31;
    switch(s){
        case 0:
            return fe(n, t, o);
        case 1:
            return me(n, t, o);
        case 2:
            return pe(n, t, o);
        case 3:
            return ye(n, t, o);
        case 4:
            return ge(n, t, o);
        case 5:
            return we(n, t, o);
        case 7:
            return be(n, t, o);
        default:
            throw new Error(`Unsupported major type: ${s}`);
    }
}
function X(n, t, e) {
    if (e < 24) return {
        value: e,
        offset: t
    };
    if (e === 24) return {
        value: n.getUint8(t++),
        offset: t
    };
    if (e === 25) {
        const s = n.getUint16(t, !1);
        return t += 2, {
            value: s,
            offset: t
        };
    }
    if (e === 26) {
        const s = n.getUint32(t, !1);
        return t += 4, {
            value: s,
            offset: t
        };
    }
    if (e === 27) {
        const s = n.getUint32(t, !1), o = n.getUint32(t + 4, !1);
        return t += 8, {
            value: s * 2 ** 32 + o,
            offset: t
        };
    }
    throw new Error(`Unsupported length: ${e}`);
}
function fe(n, t, e) {
    const { value: s, offset: o } = X(n, t, e);
    return {
        value: s,
        offset: o
    };
}
function me(n, t, e) {
    const { value: s, offset: o } = X(n, t, e);
    return {
        value: -1 - s,
        offset: o
    };
}
function pe(n, t, e) {
    const { value: s, offset: o } = X(n, t, e);
    if (o + s > n.byteLength) throw new Error("Byte string length exceeds data length");
    return {
        value: new Uint8Array(n.buffer, n.byteOffset + o, s),
        offset: o + s
    };
}
function ye(n, t, e) {
    const { value: s, offset: o } = X(n, t, e);
    if (o + s > n.byteLength) throw new Error("String length exceeds data length");
    const r = new Uint8Array(n.buffer, n.byteOffset + o, s);
    return {
        value: new TextDecoder().decode(r),
        offset: o + s
    };
}
function ge(n, t, e) {
    const { value: s, offset: o } = X(n, t, e), r = [];
    let a = o;
    for(let i = 0; i < s; i++){
        const c = it(n, a);
        r.push(c.value), a = c.offset;
    }
    return {
        value: r,
        offset: a
    };
}
function we(n, t, e) {
    const { value: s, offset: o } = X(n, t, e), r = {};
    let a = o;
    for(let i = 0; i < s; i++){
        const c = it(n, a);
        if (!ue(c.value)) throw new Error("Invalid key type");
        const u = it(n, c.offset);
        r[c.value] = u.value, a = u.offset;
    }
    return {
        value: r,
        offset: a
    };
}
function ke(n) {
    const t = (n & 31744) >> 10, e = n & 1023, s = n & 32768 ? -1 : 1;
    return t === 0 ? s * 2 ** -14 * (e / 1024) : t === 31 ? e ? NaN : s * (1 / 0) : s * 2 ** (t - 15) * (1 + e / 1024);
}
function be(n, t, e) {
    if (e < 24) switch(e){
        case 20:
            return {
                value: !1,
                offset: t
            };
        case 21:
            return {
                value: !0,
                offset: t
            };
        case 22:
            return {
                value: null,
                offset: t
            };
        case 23:
            return {
                value: void 0,
                offset: t
            };
        default:
            throw new Error(`Unknown simple value: ${e}`);
    }
    if (e === 24) return {
        value: n.getUint8(t++),
        offset: t
    };
    if (e === 25) {
        const s = ke(n.getUint16(t, !1));
        return t += 2, {
            value: s,
            offset: t
        };
    }
    if (e === 26) {
        const s = n.getFloat32(t, !1);
        return t += 4, {
            value: s,
            offset: t
        };
    }
    if (e === 27) {
        const s = n.getFloat64(t, !1);
        return t += 8, {
            value: s,
            offset: t
        };
    }
    throw new Error(`Unknown simple or float value: ${e}`);
}
class Et {
    constructor(t, e, s, o, r, a, i = !1, c){
        this.transport = t, this.id = e, this.amount = s, this.unit = o, this.mints = r, this.description = a, this.singleUse = i, this.nut10 = c;
    }
    toRawRequest() {
        const t = {};
        return this.transport && (t.t = this.transport.map((e)=>({
                t: e.type,
                a: e.target,
                g: e.tags
            }))), this.id && (t.i = this.id), this.amount && (t.a = this.amount), this.unit && (t.u = this.unit), this.mints && (t.m = this.mints), this.description && (t.d = this.description), this.singleUse && (t.s = this.singleUse), this.nut10 && (t.nut10 = {
            k: this.nut10.kind,
            d: this.nut10.data,
            t: this.nut10.tags
        }), t;
    }
    toEncodedRequest() {
        const t = this.toRawRequest(), e = kt(t);
        return "creqA" + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toBase64(e);
    }
    getTransport(t) {
        return this.transport?.find((e)=>e.type === t);
    }
    static fromRawRequest(t) {
        const e = t.t ? t.t.map((o)=>({
                type: o.t,
                target: o.a,
                tags: o.g
            })) : void 0, s = t.nut10 ? {
            kind: t.nut10.k,
            data: t.nut10.d,
            tags: t.nut10.t
        } : void 0;
        return new Et(e, t.i, t.a, t.u, t.m, t.d, t.s, s);
    }
    static fromEncodedRequest(t) {
        if (!t.startsWith("creq")) throw new Error("unsupported pr: invalid prefix");
        if (t[4] !== "A") throw new Error("unsupported pr version");
        const s = t.slice(5), o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(s), r = _t(o);
        return this.fromRawRequest(r);
    }
}
const _e = "A", Ee = "cashu";
function D(n, t, e, s) {
    if (e) {
        const r = Dt(e);
        if (n === 0 && r === 0) return e;
        const a = e.filter((c)=>c > 0), i = Dt(a);
        if (i > n) throw new Error(`Split is greater than total amount: ${i} > ${n}`);
        if (a.some((c)=>!Ct(c, t))) throw new Error("Provided amount preferences do not match the amounts of the mint keyset.");
        if (i === n) return a;
        e = a, n -= i;
    } else e = [];
    const o = Lt(t, "desc");
    if (!o || o.length === 0) throw new Error("Cannot split amount, keyset is inactive or contains no keys");
    if (o.forEach((r)=>{
        if (n <= 0 || r <= 0) return;
        const a = Math.floor(n / r);
        for(let i = 0; i < a; ++i)e.push(r);
        n %= r;
    }), n !== 0) throw new Error(`Unable to split remaining amount: ${n}`);
    return e.sort((r, a)=>r - a);
}
function Tt(n, t, e, s) {
    const o = [], r = n.map((c)=>c.amount);
    Lt(e, "asc").forEach((c)=>{
        const u = r.filter((l)=>l === c).length, h = Math.max(s - u, 0);
        for(let l = 0; l < h && !(o.reduce((f, d)=>f + d, 0) + c > t); ++l)o.push(c);
    });
    const i = t - o.reduce((c, u)=>c + u, 0);
    return i && D(i, e).forEach((u)=>{
        o.push(u);
    }), o.sort((c, u)=>c - u);
}
function Lt(n, t = "desc") {
    return t == "desc" ? Object.keys(n).map((e)=>parseInt(e)).sort((e, s)=>s - e) : Object.keys(n).map((e)=>parseInt(e)).sort((e, s)=>e - s);
}
function Ct(n, t) {
    return n in t;
}
function Ae(n) {
    return Wt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(n));
}
function Wt(n) {
    return BigInt(`0x${n}`);
}
function Pe(n) {
    return n.toString(16).padStart(64, "0");
}
function yt(n) {
    return /^[a-f0-9]*$/i.test(n);
}
function At(n) {
    return Array.isArray(n) ? n.some((t)=>!yt(t.id)) : !yt(n.id);
}
function Se(n, t) {
    At(n.proofs) || (n.proofs = $t(n.proofs)), t && (n.proofs = at(n.proofs));
    const e = {
        token: [
            {
                mint: n.mint,
                proofs: n.proofs
            }
        ]
    };
    return n.unit && (e.unit = n.unit), n.memo && (e.memo = n.memo), Ee + _e + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(e);
}
function $t(n) {
    return n.map((t)=>{
        const e = {
            ...t
        };
        return e.id = e.id.slice(0, 16), e;
    });
}
function es(n, t) {
    if (At(n.proofs) || t?.version === 3) {
        if (t?.version === 4) throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
        return Se(n, t?.removeDleq);
    }
    return Ie(n, t?.removeDleq);
}
function Ie(n, t) {
    if (t && (n.proofs = at(n.proofs)), n.proofs.forEach((c)=>{
        if (c.dleq && c.dleq.r == null) throw new Error("Missing blinding factor in included DLEQ proof");
    }), At(n.proofs)) throw new Error("can not encode to v4 token if proofs contain non-hex keyset id");
    n.proofs = $t(n.proofs);
    const s = jt(n), o = kt(s), r = "cashu", a = "B", i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["a"])(o);
    return r + a + i;
}
function jt(n) {
    const t = {}, e = n.mint;
    for(let o = 0; o < n.proofs.length; o++){
        const r = n.proofs[o];
        t[r.id] ? t[r.id].push(r) : t[r.id] = [
            r
        ];
    }
    const s = {
        m: e,
        u: n.unit || "sat",
        t: Object.keys(t).map((o)=>({
                i: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(o),
                p: t[o].map((r)=>({
                        a: r.amount,
                        s: r.secret,
                        c: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(r.C),
                        ...r.dleq && {
                            d: {
                                e: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(r.dleq.e),
                                s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(r.dleq.s),
                                r: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(r.dleq.r ?? "00")
                            }
                        },
                        ...r.witness && {
                            w: JSON.stringify(r.witness)
                        }
                    }))
            }))
    };
    return n.memo && (s.d = n.memo), s;
}
function zt(n) {
    const t = [];
    n.t.forEach((s)=>s.p.forEach((o)=>{
            t.push({
                secret: o.s,
                C: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(o.c),
                amount: o.a,
                id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(s.i),
                ...o.d && {
                    dleq: {
                        r: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(o.d.r),
                        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(o.d.s),
                        e: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(o.d.e)
                    }
                },
                ...o.w && {
                    witness: o.w
                }
            });
        }));
    const e = {
        mint: n.m,
        proofs: t,
        unit: n.u || "sat"
    };
    return n.d && (e.memo = n.d), e;
}
function Me(n, t) {
    n = Xt(n);
    const e = Ht(n);
    return e.proofs = Te(e.proofs, t), e;
}
function ss(n) {
    n = Xt(n);
    const t = Ht(n);
    return {
        unit: t.unit || "sat",
        mint: t.mint,
        amount: W(t.proofs),
        incompleteProofs: t.proofs.map((e)=>({
                secret: e.secret,
                C: e.C,
                amount: e.amount,
                ...e.dleq && {
                    dleq: e.dleq
                }
            })),
        ...t.memo && {
            memo: t.memo
        }
    };
}
function Ht(n) {
    const t = n.slice(0, 1), e = n.slice(1);
    if (t === "A") {
        const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["b"])(e);
        if (s.token.length > 1) throw new Error("Multi entry token are not supported");
        const o = s.token[0], r = {
            mint: o.mint,
            proofs: o.proofs,
            unit: s.unit || "sat"
        };
        return s.memo && (r.memo = s.memo), r;
    } else if (t === "B") {
        const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["e"])(e), o = _t(s);
        return zt(o);
    }
    throw new Error("Token version is not supported");
}
function qe(n, t, e, s = 0, o = !1) {
    if (o) {
        const c = Object.entries(n).sort((l, f)=>+l[0] - +f[0]).map(([, l])=>l).reduce((l, f)=>l + f, ""), u = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(c);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toBase64(u).slice(0, 12);
    }
    let r = Object.entries(n).sort((c, u)=>+c[0] - +u[0]).map(([, c])=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(c)).reduce((c, u)=>dt(c, u), new Uint8Array()), a, i;
    switch(s){
        case 0:
            return a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(r), i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toHex(a).slice(0, 14), "00" + i;
        case 1:
            if (!t) throw new Error("Cannot compute keyset ID version 01: unit is required.");
            return r = dt(r, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromString("unit:" + t)), e && (r = dt(r, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].fromString("final_expiry:" + e.toString()))), a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"])(r), i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$utils$2d$CrQNeCaC$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["B"].toHex(a), "01" + i;
        default:
            throw new Error(`Unrecognized keyset ID version: ${s}`);
    }
}
function dt(n, t) {
    const e = new Uint8Array(n.length + t.length);
    return e.set(n), e.set(t, n.length), e;
}
function O(n) {
    return typeof n == "object";
}
function S(...n) {
    return n.map((t)=>t.replace(/(^\/+|\/+$)/g, "")).join("/");
}
function Gt(n) {
    return n.replace(/\/$/, "");
}
function W(n) {
    return n.reduce((t, e)=>t + e.amount, 0);
}
function ns(n) {
    return Et.fromEncodedRequest(n);
}
class Be {
    get value() {
        return this._value;
    }
    set value(t) {
        this._value = t;
    }
    get next() {
        return this._next;
    }
    set next(t) {
        this._next = t;
    }
    constructor(t){
        this._value = t, this._next = null;
    }
}
class ve {
    get first() {
        return this._first;
    }
    set first(t) {
        this._first = t;
    }
    get last() {
        return this._last;
    }
    set last(t) {
        this._last = t;
    }
    get size() {
        return this._size;
    }
    set size(t) {
        this._size = t;
    }
    constructor(){
        this._first = null, this._last = null, this._size = 0;
    }
    enqueue(t) {
        const e = new Be(t);
        return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;
    }
    dequeue() {
        if (this._size === 0 || !this._first) return null;
        const t = this._first;
        return this._first = t.next, t.next = null, this._size--, t.value;
    }
}
function at(n) {
    return n.map((t)=>{
        const e = {
            ...t
        };
        return delete e.dleq, e;
    });
}
function Rt(n) {
    const t = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["i"])(n.id), e = /^[a-fA-F0-9]+$/.test(n.id), s = e ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(n.id)[0] : 0;
    return qe(n.keys, n.unit, n.final_expiry, s, t && !e) === n.id;
}
function Te(n, t) {
    const e = [];
    for (const s of n){
        let o;
        try {
            o = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(s.id);
        } catch  {
            e.push(s);
            continue;
        }
        if (o[0] === 0) e.push(s);
        else if (o[0] === 1) {
            if (!t) throw new Error("A short keyset ID v2 was encountered, but got no keysets to map it to.");
            let r = !1;
            for (const a of t)if (s.id === a.id.slice(0, s.id.length)) {
                s.id = a.id, e.push(s), r = !0;
                break;
            }
            if (!r) throw new Error(`Couldn't map short keyset ID ${s.id} to any known keysets of the current Mint`);
        } else throw new Error(`Unknown keyset ID version: ${o[0]}`);
    }
    return e;
}
function Vt(n, t) {
    if (n.dleq == null) return !1;
    const e = {
        e: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(n.dleq.e),
        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$abstract$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(n.dleq.s),
        r: Wt(n.dleq.r ?? "00")
    };
    if (!Ct(n.amount, t.keys)) throw new Error(`undefined key for amount ${n.amount}`);
    const s = t.keys[n.amount];
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT12$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["verifyDLEQProof_reblind"])(new TextEncoder().encode(n.secret), e, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointFromHex"])(n.C), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointFromHex"])(s));
}
function Re(...n) {
    const t = n.reduce((o, r)=>o + r.length, 0), e = new Uint8Array(t);
    let s = 0;
    for(let o = 0; o < n.length; o++)e.set(n[o], s), s = s + n[o].length;
    return e;
}
function os(n) {
    const t = new TextEncoder(), e = jt(n), s = kt(e), o = t.encode("craw"), r = t.encode("B");
    return Re(o, r, s);
}
function rs(n) {
    const t = new TextDecoder(), e = t.decode(n.slice(0, 4)), s = t.decode(new Uint8Array([
        n[4]
    ]));
    if (e !== "craw" || s !== "B") throw new Error("not a valid binary token");
    const o = n.slice(5), r = _t(o);
    return zt(r);
}
function Dt(n) {
    return n.reduce((t, e)=>t + e, 0);
}
function Xt(n) {
    return [
        "web+cashu://",
        "cashu://",
        "cashu:",
        "cashu"
    ].forEach((e)=>{
        n.startsWith(e) && (n = n.slice(e.length));
    }), n;
}
let ct;
typeof WebSocket < "u" && (ct = WebSocket);
function is(n) {
    ct = n;
}
function De() {
    if (ct === void 0) throw new Error("WebSocket implementation not initialized");
    return ct;
}
const v = {
    FATAL: "FATAL",
    ERROR: "ERROR",
    WARN: "WARN",
    INFO: "INFO",
    DEBUG: "DEBUG",
    TRACE: "TRACE"
}, F = {
    fatal () {},
    error () {},
    warn () {},
    info () {},
    debug () {},
    trace () {},
    log () {}
}, tt = class tt {
    constructor(t = v.INFO){
        this.minLevel = t;
    }
    logToConsole(t, e, s) {
        if (tt.SEVERITY[t] > tt.SEVERITY[this.minLevel]) return;
        const o = `[${t}] `;
        let r = e;
        const a = /* @__PURE__ */ new Set();
        if (s) {
            const i = Object.fromEntries(Object.entries(s).map(([h, l])=>[
                    h,
                    l instanceof Error ? {
                        message: l.message,
                        stack: l.stack
                    } : l
                ]));
            r = e.replace(/\{(\w+)\}/g, (h, l)=>{
                if (l in i && i[l] !== void 0) {
                    a.add(l);
                    const f = i[l];
                    return typeof f == "string" ? f : typeof f == "number" || typeof f == "boolean" ? f.toString() : f == null ? "" : JSON.stringify(f);
                }
                return h;
            });
            const c = Object.fromEntries(Object.entries(i).filter(([h])=>!a.has(h))), u = this.getConsoleMethod(t);
            Object.keys(c).length > 0 ? u(o + r, c) : u(o + r);
        } else this.getConsoleMethod(t)(o + r);
    }
    // Note: NOT static as test suite needs to spy on the output
    getConsoleMethod(t) {
        switch(t){
            case v.FATAL:
            case v.ERROR:
                return console.error;
            case v.WARN:
                return console.warn;
            case v.INFO:
                return console.info;
            case v.DEBUG:
                return console.debug;
            case v.TRACE:
                return console.trace;
            default:
                return console.log;
        }
    }
    // Interface methods
    fatal(t, e) {
        this.logToConsole(v.FATAL, t, e);
    }
    error(t, e) {
        this.logToConsole(v.ERROR, t, e);
    }
    warn(t, e) {
        this.logToConsole(v.WARN, t, e);
    }
    info(t, e) {
        this.logToConsole(v.INFO, t, e);
    }
    debug(t, e) {
        this.logToConsole(v.DEBUG, t, e);
    }
    trace(t, e) {
        this.logToConsole(v.TRACE, t, e);
    }
    log(t, e, s) {
        this.logToConsole(t, e, s);
    }
};
tt.SEVERITY = {
    [v.FATAL]: 0,
    [v.ERROR]: 1,
    [v.WARN]: 2,
    [v.INFO]: 3,
    [v.DEBUG]: 4,
    [v.TRACE]: 5
};
let Ut = tt;
function Ue() {
    const n = Date.now();
    return {
        elapsed: ()=>Date.now() - n
    };
}
class V {
    constructor(){
        this.connectionMap = /* @__PURE__ */ new Map();
    }
    static getInstance() {
        return V.instance || (V.instance = new V()), V.instance;
    }
    getConnection(t, e) {
        if (this.connectionMap.has(t)) return this.connectionMap.get(t);
        const s = new Ke(t, e);
        return this.connectionMap.set(t, s), s;
    }
}
class Ke {
    constructor(t, e){
        this.subListeners = {}, this.rpcListeners = {}, this.rpcId = 0, this.onCloseCallbacks = [], this._WS = De(), this.url = new URL(t), this.messageQueue = new ve(), this._logger = e ?? F;
    }
    connect() {
        return this.connectionPromise || (this.connectionPromise = new Promise((t, e)=>{
            try {
                this.ws = new this._WS(this.url.toString()), this.onCloseCallbacks = [];
            } catch (s) {
                e(s instanceof Error ? s : new Error(String(s)));
                return;
            }
            this.ws.onopen = ()=>{
                t();
            }, this.ws.onerror = ()=>{
                e(new Error("Failed to open WebSocket"));
            }, this.ws.onmessage = (s)=>{
                this.messageQueue.enqueue(s.data), this.handlingInterval || (this.handlingInterval = setInterval(this.handleNextMessage.bind(this), 0));
            }, this.ws.onclose = (s)=>{
                this.connectionPromise = void 0, this.onCloseCallbacks.forEach((o)=>o(s));
            };
        })), this.connectionPromise;
    }
    sendRequest(t, e) {
        if (this.ws?.readyState !== 1) {
            if (t === "unsubscribe") return;
            throw this._logger.error("Attempted sendRequest, but socket was not open"), new Error("Socket not open");
        }
        const s = this.rpcId;
        this.rpcId++;
        const o = JSON.stringify({
            jsonrpc: "2.0",
            method: t,
            params: e,
            id: s
        });
        this.ws?.send(o);
    }
    /**
   * @deprecated Use cancelSubscription for JSONRPC compliance.
   */ closeSubscription(t) {
        this.ws?.send(JSON.stringify([
            "CLOSE",
            t
        ]));
    }
    addSubListener(t, e) {
        (this.subListeners[t] = this.subListeners[t] || []).push(e);
    }
    addRpcListener(t, e, s) {
        this.rpcListeners[s] = {
            callback: t,
            errorCallback: e
        };
    }
    removeRpcListener(t) {
        delete this.rpcListeners[t];
    }
    removeListener(t, e) {
        if (this.subListeners[t]) {
            if (this.subListeners[t].length === 1) {
                delete this.subListeners[t];
                return;
            }
            this.subListeners[t] = this.subListeners[t].filter((s)=>s !== e);
        }
    }
    async ensureConnection() {
        this.ws?.readyState !== 1 && await this.connect();
    }
    handleNextMessage() {
        if (this.messageQueue.size === 0) {
            clearInterval(this.handlingInterval), this.handlingInterval = void 0;
            return;
        }
        const t = this.messageQueue.dequeue();
        let e;
        try {
            if (e = JSON.parse(t), "result" in e && e.id != null) this.rpcListeners[e.id] && (this.rpcListeners[e.id].callback(), this.removeRpcListener(e.id));
            else if ("error" in e && e.id != null) this.rpcListeners[e.id] && (this.rpcListeners[e.id].errorCallback(new Error(e.error.message)), this.removeRpcListener(e.id));
            else if ("method" in e && !("id" in e)) {
                const s = e.params?.subId;
                if (!s) return;
                if (this.subListeners[s]?.length > 0) {
                    const o = e;
                    this.subListeners[s].forEach((r)=>r(o.params?.payload));
                }
            }
        } catch (s) {
            this._logger.error("Error doing handleNextMessage", {
                e: s
            });
            return;
        }
    }
    createSubscription(t, e, s) {
        if (this.ws?.readyState !== 1) throw this._logger.error("Attempted createSubscription, but socket was not open"), new Error("Socket is not open");
        const o = (Math.random() + 1).toString(36).substring(7);
        return this.addRpcListener(()=>{
            this.addSubListener(o, e);
        }, s, this.rpcId), this.sendRequest("subscribe", {
            ...t,
            subId: o
        }), this.rpcId++, o;
    }
    /**
   * Cancels a subscription, sending an unsubscribe request and handling responses.
   *
   * @param subId The subscription ID to cancel.
   * @param callback The original payload callback to remove.
   * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).
   */ cancelSubscription(t, e, s) {
        this.removeListener(t, e), this.addRpcListener(()=>{
            this._logger.info("Unsubscribed {subId}", {
                subId: t
            });
        }, s || ((o)=>this._logger.error("Unsubscribe failed", {
                e: o
            })), this.rpcId), this.sendRequest("unsubscribe", {
            subId: t
        });
    }
    get activeSubscriptions() {
        return Object.keys(this.subListeners);
    }
    close() {
        this.ws && this.ws?.close();
    }
    onClose(t) {
        this.onCloseCallbacks.push(t);
    }
}
const as = {
    UNSPENT: "UNSPENT",
    PENDING: "PENDING",
    SPENT: "SPENT"
}, et = {
    UNPAID: "UNPAID",
    PENDING: "PENDING",
    PAID: "PAID"
}, gt = {
    UNPAID: "UNPAID",
    PAID: "PAID",
    ISSUED: "ISSUED"
};
var xe = /* @__PURE__ */ ((n)=>(n.POST = "post", n.NOSTR = "nostr", n))(xe || {});
class st extends Error {
    constructor(t, e){
        super(t), this.status = e, this.name = "HttpResponseError", Object.setPrototypeOf(this, st.prototype);
    }
}
class Pt extends Error {
    constructor(t){
        super(t), this.name = "NetworkError", Object.setPrototypeOf(this, Pt.prototype);
    }
}
class St extends st {
    constructor(t, e){
        super(e || "Unknown mint operation error", 400), this.code = t, this.name = "MintOperationError", Object.setPrototypeOf(this, St.prototype);
    }
}
let Jt = {}, Yt = F;
function cs(n) {
    Jt = n;
}
function Oe(n) {
    Yt = n;
}
async function Fe({ endpoint: n, requestBody: t, headers: e, ...s }) {
    const o = t ? JSON.stringify(t) : void 0, r = {
        Accept: "application/json, text/plain, */*",
        ...o ? {
            "Content-Type": "application/json"
        } : void 0,
        ...e
    };
    let a;
    try {
        a = await fetch(n, {
            body: o,
            headers: r,
            ...s
        });
    } catch (i) {
        throw new Pt(i instanceof Error ? i.message : "Network request failed");
    }
    if (!a.ok) {
        let i;
        try {
            i = await a.json();
        } catch  {
            i = {
                error: "bad response"
            };
        }
        if (a.status === 400 && "code" in i && typeof i.code == "number" && "detail" in i && typeof i.detail == "string") throw new St(i.code, i.detail);
        let c = "HTTP request failed";
        throw "error" in i && typeof i.error == "string" ? c = i.error : "detail" in i && typeof i.detail == "string" && (c = i.detail), new st(c, a.status);
    }
    try {
        return await a.json();
    } catch (i) {
        throw Yt.error("Failed to parse HTTP response", {
            err: i
        }), new st("bad response", a.status);
    }
}
async function M(n) {
    return await Fe({
        ...n,
        ...Jt
    });
}
function ft(n, t) {
    return n.state || (t.warn("Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)"), typeof n.paid == "boolean" && (n.state = n.paid ? et.PAID : et.UNPAID)), n;
}
function Kt(n, t) {
    return n.state || (t.warn("Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)"), typeof n.paid == "boolean" && (n.state = n.paid ? gt.PAID : gt.UNPAID)), n;
}
function Ne(n, t) {
    return Array.isArray(n?.contact) && n?.contact.length > 0 && (n.contact = n.contact.map((e)=>Array.isArray(e) && e.length === 2 && typeof e[0] == "string" && typeof e[1] == "string" ? (t.warn("Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117"), {
            method: e[0],
            info: e[1]
        }) : e)), n;
}
class wt {
    constructor(t){
        this._mintInfo = t, t.nuts[22] && (this._protectedEnpoints = {
            cache: {},
            apiReturn: t.nuts[22].protected_endpoints.map((e)=>({
                    method: e.method,
                    regex: new RegExp(e.path)
                }))
        });
    }
    isSupported(t) {
        switch(t){
            case 4:
            case 5:
                return this.checkMintMelt(t);
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 14:
            case 20:
                return this.checkGenericNut(t);
            case 17:
                return this.checkNut17();
            case 15:
                return this.checkNut15();
            default:
                throw new Error("nut is not supported by cashu-ts");
        }
    }
    requiresBlindAuthToken(t) {
        if (!this._protectedEnpoints) return !1;
        if (typeof this._protectedEnpoints.cache[t] == "boolean") return this._protectedEnpoints.cache[t];
        const e = this._protectedEnpoints.apiReturn.some((s)=>s.regex.test(t));
        return this._protectedEnpoints.cache[t] = e, e;
    }
    checkGenericNut(t) {
        return this._mintInfo.nuts[t]?.supported ? {
            supported: !0
        } : {
            supported: !1
        };
    }
    checkMintMelt(t) {
        const e = this._mintInfo.nuts[t];
        return e && e.methods.length > 0 && !e.disabled ? {
            disabled: !1,
            params: e.methods
        } : {
            disabled: !0,
            params: e.methods
        };
    }
    checkNut17() {
        return this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0 ? {
            supported: !0,
            params: this._mintInfo.nuts[17].supported
        } : {
            supported: !1
        };
    }
    checkNut15() {
        return this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0 ? {
            supported: !0,
            params: this._mintInfo.nuts[15].methods
        } : {
            supported: !1
        };
    }
    get contact() {
        return this._mintInfo.contact;
    }
    get description() {
        return this._mintInfo.description;
    }
    get description_long() {
        return this._mintInfo.description_long;
    }
    get name() {
        return this._mintInfo.name;
    }
    get pubkey() {
        return this._mintInfo.pubkey;
    }
    get nuts() {
        return this._mintInfo.nuts;
    }
    get version() {
        return this._mintInfo.version;
    }
    get motd() {
        return this._mintInfo.motd;
    }
    /**
   * Checks if the mint supports creating BOLT12 offers with a description.
   *
   * @returns True if the mint supports offers with a description, false otherwise.
   */ get supportsBolt12Description() {
        return this._mintInfo.nuts[4]?.methods.some((t)=>t.method === "bolt12" && t.options?.description === !0);
    }
}
class q {
    /**
   * @param _mintUrl Requires mint URL to create this object.
   * @param _customRequest If passed, use custom request implementation for network communication
   *   with the mint.
   * @param [authTokenGetter] A function that is called by the CashuMint instance to obtain a NUT-22
   *   BlindedAuthToken (e.g. from a database or localstorage)
   */ constructor(t, e, s, o){
        this._mintUrl = t, this._customRequest = e, this._checkNut22 = !1, this._mintUrl = Gt(t), this._customRequest = e, s && (this._checkNut22 = !0, this._authTokenGetter = s), this._logger = o?.logger ?? F, Oe(this._logger);
    }
    //TODO: v3 - refactor CashuMint to take two or less args.
    get mintUrl() {
        return this._mintUrl;
    }
    /**
   * Fetches mints info at the /info endpoint.
   *
   * @param mintUrl
   * @param customRequest
   */ static async getInfo(t, e, s) {
        const o = s ?? F, a = await (e || M)({
            endpoint: S(t, "/v1/info")
        });
        return Ne(a, o);
    }
    /**
   * Fetches mints info at the /info endpoint.
   */ async getInfo() {
        return q.getInfo(this._mintUrl, this._customRequest, this._logger);
    }
    async getLazyMintInfo() {
        if (this._mintInfo) return this._mintInfo;
        const t = await q.getInfo(this._mintUrl, this._customRequest);
        return this._mintInfo = new wt(t), this._mintInfo;
    }
    /**
   * Performs a swap operation with ecash inputs and outputs.
   *
   * @param mintUrl
   * @param swapPayload Payload containing inputs and outputs.
   * @param customRequest
   * @returns Signed outputs.
   */ static async swap(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {}, i = await r({
            endpoint: S(t, "/v1/swap"),
            method: "POST",
            requestBody: e,
            headers: a
        });
        if (!O(i) || !Array.isArray(i?.signatures)) throw new Error(i.detail ?? "bad response");
        return i;
    }
    /**
   * Performs a swap operation with ecash inputs and outputs.
   *
   * @param swapPayload Payload containing inputs and outputs.
   * @returns Signed outputs.
   */ async swap(t) {
        const e = await this.handleBlindAuth("/v1/swap");
        return q.swap(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Requests a new mint quote from the mint.
   *
   * @param mintUrl
   * @param mintQuotePayload Payload for creating a new mint quote.
   * @param customRequest
   * @returns The mint will create and return a new mint quote containing a payment request for the
   *   specified amount and unit.
   */ static async createMintQuote(t, e, s, o, r) {
        const a = r ?? F, i = s || M, c = o ? {
            "Blind-auth": o
        } : {}, u = await i({
            endpoint: S(t, "/v1/mint/quote/bolt11"),
            method: "POST",
            requestBody: e,
            headers: c
        });
        return Kt(u, a);
    }
    /**
   * Requests a new mint quote from the mint.
   *
   * @param mintQuotePayload Payload for creating a new mint quote.
   * @returns The mint will create and return a new mint quote containing a payment request for the
   *   specified amount and unit.
   */ async createMintQuote(t) {
        const e = await this.handleBlindAuth("/v1/mint/quote/bolt11");
        return q.createMintQuote(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.
   *
   * @param mintUrl The mint's base URL.
   * @param mintQuotePayload Payload containing amount, unit, optional description, and required
   *   pubkey.
   * @param customRequest Optional custom request implementation.
   * @param blindAuthToken Optional authentication token for NUT-22.
   * @returns A mint quote containing a BOLT12 offer.
   */ static async createMintQuoteBolt12(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {};
        return await r({
            endpoint: S(t, "/v1/mint/quote/bolt12"),
            method: "POST",
            requestBody: e,
            headers: a
        });
    }
    /**
   * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.
   *
   * @param mintQuotePayload Payload containing amount, unit, optional description, and required
   *   pubkey.
   * @returns A mint quote containing a BOLT12 offer.
   */ async createMintQuoteBolt12(t) {
        const e = await this.handleBlindAuth("/v1/mint/quote/bolt12");
        return q.createMintQuoteBolt12(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Gets an existing mint quote from the mint.
   *
   * @param mintUrl
   * @param quote Quote ID.
   * @param customRequest
   * @returns The mint will create and return a Lightning invoice for the specified amount.
   */ static async checkMintQuote(t, e, s, o, r) {
        const a = r ?? F, i = s || M, c = o ? {
            "Blind-auth": o
        } : {}, u = await i({
            endpoint: S(t, "/v1/mint/quote/bolt11", e),
            method: "GET",
            headers: c
        });
        return Kt(u, a);
    }
    /**
   * Gets an existing mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The mint will create and return a Lightning invoice for the specified amount.
   */ async checkMintQuote(t) {
        const e = await this.handleBlindAuth(`/v1/mint/quote/bolt11/${t}`);
        return q.checkMintQuote(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param mintUrl The mint's base URL.
   * @param quote Quote ID to check.
   * @param customRequest Optional custom request implementation.
   * @param blindAuthToken Optional authentication token for NUT-22.
   * @returns Updated quote with current payment and issuance amounts.
   */ static async checkMintQuoteBolt12(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {};
        return await r({
            endpoint: S(t, "/v1/mint/quote/bolt12", e),
            method: "GET",
            headers: a
        });
    }
    /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID to check.
   * @returns Updated quote with current payment and issuance amounts.
   */ async checkMintQuoteBolt12(t) {
        const e = await this.handleBlindAuth(`/v1/mint/quote/bolt12/${t}`);
        return q.checkMintQuoteBolt12(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Mints new tokens by requesting blind signatures on the provided outputs.
   *
   * @param mintUrl
   * @param mintPayload Payload containing the outputs to get blind signatures on.
   * @param customRequest
   * @returns Serialized blinded signatures.
   */ static async mint(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {}, i = await r({
            endpoint: S(t, "/v1/mint/bolt11"),
            method: "POST",
            requestBody: e,
            headers: a
        });
        if (!O(i) || !Array.isArray(i?.signatures)) throw new Error("bad response");
        return i;
    }
    /**
   * Mints new tokens by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the outputs to get blind signatures on.
   * @returns Serialized blinded signatures.
   */ async mint(t) {
        const e = await this.handleBlindAuth("/v1/mint/bolt11");
        return q.mint(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.
   *
   * @param mintUrl The mint's base URL.
   * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.
   * @param customRequest Optional custom request implementation.
   * @param blindAuthToken Optional authentication token for NUT-22.
   * @returns Serialized blinded signatures for the requested outputs.
   */ static async mintBolt12(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {}, i = await r({
            endpoint: S(t, "/v1/mint/bolt12"),
            method: "POST",
            requestBody: e,
            headers: a
        });
        if (!O(i) || !Array.isArray(i?.signatures)) throw new Error("bad response");
        return i;
    }
    /**
   * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.
   * @returns Serialized blinded signatures for the requested outputs.
   */ async mintBolt12(t) {
        const e = await this.handleBlindAuth("/v1/mint/bolt12");
        return q.mintBolt12(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Requests a new melt quote from the mint.
   *
   * @param mintUrl
   * @param MeltQuotePayload
   * @returns
   */ static async createMeltQuote(t, e, s, o, r) {
        const a = r ?? F, i = s || M, c = o ? {
            "Blind-auth": o
        } : {}, u = await i({
            endpoint: S(t, "/v1/melt/quote/bolt11"),
            method: "POST",
            requestBody: e,
            headers: c
        }), h = ft(u, a);
        if (!O(h) || typeof h?.amount != "number" || typeof h?.fee_reserve != "number" || typeof h?.quote != "string") throw new Error("bad response");
        return h;
    }
    /**
   * Requests a new melt quote from the mint.
   *
   * @param MeltQuotePayload
   * @returns
   */ async createMeltQuote(t) {
        const e = await this.handleBlindAuth("/v1/melt/quote/bolt11");
        return q.createMeltQuote(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For
   * amount-less offers, specify the amount in options.amountless.amount_msat.
   *
   * @param mintUrl The mint's base URL.
   * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.
   * @param customRequest Optional custom request implementation.
   * @param blindAuthToken Optional authentication token for NUT-22.
   * @returns Melt quote with amount, fee reserve, and payment state.
   */ static async createMeltQuoteBolt12(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {};
        return await r({
            endpoint: S(t, "/v1/melt/quote/bolt12"),
            method: "POST",
            requestBody: e,
            headers: a
        });
    }
    /**
   * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For
   * amount-less offers, specify the amount in options.amountless.amount_msat.
   *
   * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.
   * @returns Melt quote with amount, fee reserve, and payment state.
   */ async createMeltQuoteBolt12(t) {
        const e = await this.handleBlindAuth("/v1/melt/quote/bolt12");
        return q.createMeltQuoteBolt12(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Gets an existing melt quote.
   *
   * @param mintUrl
   * @param quote Quote ID.
   * @returns
   */ static async checkMeltQuote(t, e, s, o, r) {
        const a = r ?? F, i = s || M, c = o ? {
            "Blind-auth": o
        } : {}, u = await i({
            endpoint: S(t, "/v1/melt/quote/bolt11", e),
            method: "GET",
            headers: c
        }), h = ft(u, a);
        if (!O(h) || typeof h?.amount != "number" || typeof h?.fee_reserve != "number" || typeof h?.quote != "string" || typeof h?.state != "string" || !Object.values(et).includes(h.state)) throw new Error("bad response");
        return h;
    }
    /**
   * Gets an existing melt quote.
   *
   * @param quote Quote ID.
   * @returns
   */ async checkMeltQuote(t) {
        const e = await this.handleBlindAuth(`/v1/melt/quote/bolt11/${t}`);
        return q.checkMeltQuote(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,
   * PENDING, or PAID) and payment preimage if paid.
   *
   * @param mintUrl The mint's base URL.
   * @param quote Quote ID to check.
   * @param customRequest Optional custom request implementation.
   * @param blindAuthToken Optional authentication token for NUT-22.
   * @returns Updated quote with current payment state and preimage if available.
   */ static async checkMeltQuoteBolt12(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {};
        return await r({
            endpoint: S(t, "/v1/melt/quote/bolt12", e),
            method: "GET",
            headers: a
        });
    }
    /**
   * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,
   * PENDING, or PAID) and payment preimage if paid.
   *
   * @param quote Quote ID to check.
   * @returns Updated quote with current payment state and preimage if available.
   */ async checkMeltQuoteBolt12(t) {
        const e = await this.handleBlindAuth(`/v1/melt/quote/bolt12/${t}`);
        return q.checkMeltQuoteBolt12(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.
   * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can
   * also contain blank outputs in order to receive back overpaid Lightning fees.
   *
   * @param mintUrl
   * @param meltPayload
   * @param customRequest
   * @returns
   */ static async melt(t, e, s, o, r) {
        const a = r ?? F, i = s || M, c = o ? {
            "Blind-auth": o
        } : {}, u = await i({
            endpoint: S(t, "/v1/melt/bolt11"),
            method: "POST",
            requestBody: e,
            headers: c
        }), h = ft(u, a);
        if (!O(h) || typeof h?.state != "string" || !Object.values(et).includes(h.state)) throw new Error("bad response");
        return h;
    }
    /**
   * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens
   * matching its amount + fees.
   *
   * @param meltPayload
   * @returns
   */ async melt(t) {
        const e = await this.handleBlindAuth("/v1/melt/bolt11");
        return q.melt(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must
   * cover the amount plus fee reserves. Optional outputs can be included to receive change for
   * overpaid Lightning fees.
   *
   * @param mintUrl The mint's base URL.
   * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.
   * @param customRequest Optional custom request implementation.
   * @param blindAuthToken Optional authentication token for NUT-22.
   * @returns Payment result with state and optional change signatures.
   */ static async meltBolt12(t, e, s, o) {
        const r = s || M, a = o ? {
            "Blind-auth": o
        } : {};
        return await r({
            endpoint: S(t, "/v1/melt/bolt12"),
            method: "POST",
            requestBody: e,
            headers: a
        });
    }
    /**
   * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must
   * cover the amount plus fee reserves. Optional outputs can be included to receive change for
   * overpaid Lightning fees.
   *
   * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.
   * @returns Payment result with state and optional change signatures.
   */ async meltBolt12(t) {
        const e = await this.handleBlindAuth("/v1/melt/bolt12");
        return q.meltBolt12(this._mintUrl, t, this._customRequest, e);
    }
    /**
   * Checks if specific proofs have already been redeemed.
   *
   * @param mintUrl
   * @param checkPayload
   * @param customRequest
   * @returns Redeemed and unredeemed ordered list of booleans.
   */ static async check(t, e, s) {
        const r = await (s || M)({
            endpoint: S(t, "/v1/checkstate"),
            method: "POST",
            requestBody: e
        });
        if (!O(r) || !Array.isArray(r?.states)) throw new Error("bad response");
        return r;
    }
    /**
   * Get the mints public keys.
   *
   * @param mintUrl
   * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
   *   keys from all active keysets are fetched.
   * @param customRequest
   * @returns
   */ static async getKeys(t, e, s) {
        e && (e = e.replace(/\//g, "_").replace(/\+/g, "-"));
        const r = await (s || M)({
            endpoint: e ? S(t, "/v1/keys", e) : S(t, "/v1/keys")
        });
        if (!O(r) || !Array.isArray(r.keysets)) throw new Error("bad response");
        return r;
    }
    /**
   * Get the mints public keys.
   *
   * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
   *   keys from all active keysets are fetched.
   * @returns The mints public keys.
   */ async getKeys(t, e) {
        return await q.getKeys(e || this._mintUrl, t, this._customRequest);
    }
    /**
   * Get the mints keysets in no specific order.
   *
   * @param mintUrl
   * @param customRequest
   * @returns All the mints past and current keysets.
   */ static async getKeySets(t, e) {
        return (e || M)({
            endpoint: S(t, "/v1/keysets")
        });
    }
    /**
   * Get the mints keysets in no specific order.
   *
   * @returns All the mints past and current keysets.
   */ async getKeySets() {
        return q.getKeySets(this._mintUrl, this._customRequest);
    }
    /**
   * Checks if specific proofs have already been redeemed.
   *
   * @param checkPayload
   * @returns Redeemed and unredeemed ordered list of booleans.
   */ async check(t) {
        return q.check(this._mintUrl, t, this._customRequest);
    }
    static async restore(t, e, s) {
        const r = await (s || M)({
            endpoint: S(t, "/v1/restore"),
            method: "POST",
            requestBody: e
        });
        if (!O(r) || !Array.isArray(r?.outputs) || !Array.isArray(r?.signatures)) throw new Error("bad response");
        return r;
    }
    async restore(t) {
        return q.restore(this._mintUrl, t, this._customRequest);
    }
    /**
   * Tries to establish a websocket connection with the websocket mint url according to NUT-17.
   */ async connectWebSocket() {
        if (this.ws) await this.ws.ensureConnection();
        else {
            const t = new URL(this._mintUrl), e = "v1/ws";
            t.pathname && (t.pathname.endsWith("/") ? t.pathname += e : t.pathname += "/" + e), this.ws = V.getInstance().getConnection(`${t.protocol === "https:" ? "wss" : "ws"}://${t.host}${t.pathname}`);
            try {
                await this.ws.connect();
            } catch (s) {
                throw this._logger.error("Failed to connect to WebSocket...", {
                    e: s
                }), new Error("Failed to connect to WebSocket...");
            }
        }
    }
    /**
   * Closes a websocket connection.
   */ disconnectWebSocket() {
        this.ws && this.ws.close();
    }
    get webSocketConnection() {
        return this.ws;
    }
    async handleBlindAuth(t) {
        if (!this._checkNut22) return;
        if ((await this.getLazyMintInfo()).requiresBlindAuthToken(t)) {
            if (!this._authTokenGetter) throw new Error("Can not call a protected endpoint without authProofGetter");
            return this._authTokenGetter();
        }
    }
}
class mt {
    constructor(t, e, s){
        this.amount = t, this.B_ = e, this.id = s;
    }
    getSerializedBlindedMessage() {
        return {
            amount: this.amount,
            B_: this.B_.toHex(!0),
            id: this.id
        };
    }
}
function pt(n) {
    return typeof n == "function";
}
const Qe = /* @__PURE__ */ new Set([
    "locktime",
    "pubkeys",
    "n_sigs",
    "refund",
    "n_sigs_refund"
]), xt = 1024;
class Q {
    constructor(t, e, s){
        this.secret = s, this.blindingFactor = e, this.blindedMessage = t;
    }
    toProof(t, e) {
        let s;
        t.dleq && (s = {
            s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(t.dleq.s),
            e: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hexToBytes"])(t.dleq.e),
            r: this.blindingFactor
        });
        const o = {
            id: t.id,
            amount: t.amount,
            C_: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointFromHex"])(t.C_)
        }, r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["pointFromHex"])(e.keys[t.amount]), a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["constructProofFromPromise"])(o, this.blindingFactor, this.secret, r);
        return {
            ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["serializeProof"])(a),
            ...s && {
                dleq: {
                    s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(s.s),
                    e: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(s.e),
                    r: Pe(s.r ?? BigInt(0))
                }
            }
        };
    }
    static createP2PKData(t, e, s, o) {
        return D(e, s.keys, o).map((a)=>this.createSingleP2PKData(t, a, s.id));
    }
    static createSingleP2PKData(t, e, s) {
        const o = Array.isArray(t.pubkey) ? t.pubkey : [
            t.pubkey
        ], r = t.refundKeys ?? [], a = Math.max(1, Math.min(t.requiredSignatures ?? 1, o.length)), i = Math.max(1, Math.min(t.requiredRefundSignatures ?? 1, r.length || 1)), c = o[0], u = o.slice(1), h = r, l = [], f = t.locktime ?? NaN;
        if (Number.isSafeInteger(f) && f >= 0 && l.push([
            "locktime",
            String(f)
        ]), u.length > 0 && (l.push([
            "pubkeys",
            ...u
        ]), a > 1 && l.push([
            "n_sigs",
            String(a)
        ])), h.length > 0 && (l.push([
            "refund",
            ...h
        ]), i > 1 && l.push([
            "n_sigs_refund",
            String(i)
        ])), t.additionalTags?.length) {
            const m = t.additionalTags.map(([E, ...x], $)=>{
                if (typeof E != "string" || !E) throw new Error(`additionalTags[${$}][0] must be a non empty string`);
                if (Qe.has(E)) throw new Error(`additionalTags must not use reserved key "${E}"`);
                return [
                    E,
                    ...x.map(String)
                ];
            });
            l.push(...m);
        }
        const d = [
            "P2PK",
            {
                nonce: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomBytes"])(32)),
                data: c,
                tags: l
            }
        ], y = JSON.stringify(d), _ = [
            ...y
        ].length;
        if (_ > xt) throw new Error(`Secret too long (${_} characters), maximum is ${xt}`);
        const I = new TextEncoder().encode(y), { r: T, B_: b } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blindMessage"])(I);
        return new Q(new mt(e, b, s).getSerializedBlindedMessage(), T, I);
    }
    static createRandomData(t, e, s) {
        return D(t, e.keys, s).map((r)=>this.createSingleRandomData(r, e.id));
    }
    static createSingleRandomData(t, e) {
        const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["randomBytes"])(32)), o = new TextEncoder().encode(s), { r, B_: a } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blindMessage"])(o);
        return new Q(new mt(t, a, e).getSerializedBlindedMessage(), r, o);
    }
    static createDeterministicData(t, e, s, o, r) {
        return D(t, o.keys, r).map((i, c)=>this.createSingleDeterministicData(i, e, s + c, o.id));
    }
    static createSingleDeterministicData(t, e, s, o) {
        const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["d"])(e, o, s), a = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesToHex"])(r), i = new TextEncoder().encode(a), c = Ae((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["f"])(e, o, s)), { r: u, B_: h } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blindMessage"])(i, c);
        return new Q(new mt(t, h, o).getSerializedBlindedMessage(), u, i);
    }
}
const Le = 3, Ce = "sat";
class us {
    /**
   * @param mint Cashu mint instance is used to make api calls.
   * @param options.unit Optionally set unit (default is 'sat')
   * @param options.keys Public keys from the mint (will be fetched from mint if not provided)
   * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)
   * @param options.mintInfo Mint info from the mint (will be fetched from mint if not provided)
   * @param options.denominationTarget Target number proofs per denomination (default: see @constant
   *   DEFAULT_DENOMINATION_TARGET)
   * @param options.bip39seed BIP39 seed for deterministic secrets.
   * @param options.keepFactory A function that will be used by all parts of the library that
   *   produce proofs to be kept (change, etc.). This can lead to poor performance, in which case
   *   the seed should be directly provided.
   */ constructor(t, e){
        this._keys = /* @__PURE__ */ new Map(), this._keysets = [], this._seed = void 0, this._unit = Ce, this._mintInfo = void 0, this._denominationTarget = Le, this.mint = t, this._logger = e?.logger ?? F, this._logger.warn("cashu-ts v3 has been released. Please upgrade to access the latest features. v2 is now in minimal maintenance mode.");
        let s = [];
        if (e?.keys && !Array.isArray(e.keys) ? s = [
            e.keys
        ] : e?.keys && Array.isArray(e?.keys) && (s = e?.keys), s && s.forEach((o)=>this._keys.set(o.id, o)), e?.unit && (this._unit = e?.unit), e?.keysets && (this._keysets = e.keysets), e?.mintInfo && (this._mintInfo = new wt(e.mintInfo)), e?.denominationTarget && (this._denominationTarget = e.denominationTarget), e?.bip39seed) {
            if (e.bip39seed instanceof Uint8Array) {
                this._seed = e.bip39seed;
                return;
            }
            throw new Error("bip39seed must be a valid UInt8Array");
        }
        e?.keepFactory && (this._keepFactory = e.keepFactory);
    }
    get unit() {
        return this._unit;
    }
    get keys() {
        return this._keys;
    }
    get keysetId() {
        if (!this._keysetId) throw new Error("No keysetId set");
        return this._keysetId;
    }
    set keysetId(t) {
        this._keysetId = t;
    }
    get keysets() {
        return this._keysets;
    }
    get mintInfo() {
        if (!this._mintInfo) throw new Error("Mint info not loaded");
        return this._mintInfo;
    }
    /**
   * Get information about the mint.
   *
   * @returns Mint info.
   */ async getMintInfo() {
        const t = await this.mint.getInfo();
        return this._mintInfo = new wt(t), this._mintInfo;
    }
    /**
   * Get stored information about the mint or request it if not loaded.
   *
   * @returns Mint info.
   */ async lazyGetMintInfo() {
        return this._mintInfo ? this._mintInfo : await this.getMintInfo();
    }
    /**
   * Load mint information, keysets and keys. This function can be called if no keysets are passed
   * in the constructor.
   */ async loadMint() {
        await Promise.all([
            this.getMintInfo(),
            this.getKeys()
        ]);
    }
    /**
   * Choose a keyset to activate based on the lowest input fee.
   *
   * Note: this function will filter out deprecated base64 keysets.
   *
   * @param keysets Keysets to choose from.
   * @returns Active keyset.
   */ getActiveKeyset(t) {
        let e = t.filter((o)=>o.active && o.unit === this._unit);
        e = e.filter((o)=>yt(o.id));
        const s = e.sort((o, r)=>(o.input_fee_ppk ?? 0) - (r.input_fee_ppk ?? 0))[0];
        if (!s) throw new Error("No active keyset found");
        return s;
    }
    /**
   * Get keysets from the mint with the unit of the wallet.
   *
   * @returns Keysets with wallet's unit.
   */ async getKeySets() {
        const e = (await this.mint.getKeySets()).keysets.filter((s)=>s.unit === this._unit);
        return this._keysets = e, this._keysets;
    }
    /**
   * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet
   * keyset.
   *
   * @returns Keyset.
   */ async getAllKeys() {
        const t = await this.mint.getKeys();
        return t.keysets.forEach((e)=>{
            if (!Rt(e)) throw new Error(`Couldn't verify keyset ID ${e.id}`);
        }), this._keys = new Map(t.keysets.map((e)=>[
                e.id,
                e
            ])), this.keysetId = this.getActiveKeyset(this._keysets).id, t.keysets;
    }
    /**
   * Get public keys from the mint. If keys were already fetched, it will return those.
   *
   * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an
   * active keyset with the unit of the wallet.
   *
   * @param keysetId Optional keysetId to get keys for.
   * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.
   * @returns Keyset.
   */ async getKeys(t, e) {
        if ((!(this._keysets.length > 0) || e) && await this.getKeySets(), t || (t = this.getActiveKeyset(this._keysets).id), !this._keysets.find((s)=>s.id === t) && (await this.getKeySets(), !this._keysets.find((s)=>s.id === t))) throw new Error(`could not initialize keys. No keyset with id '${t}' found`);
        if (!this._keys.get(t)) {
            const s = await this.mint.getKeys(t);
            if (!Rt(s.keysets[0])) throw new Error(`Couldn't verify keyset ID ${s.keysets[0].id}`);
            this._keys.set(t, s.keysets[0]);
        }
        return this.keysetId = t, this._keys.get(t);
    }
    /**
   * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the
   * first token in the token array)
   *
   * @param {string | Token} token - Cashu token, either as string or decoded.
   * @param {ReceiveOptions} [options] - Optional configuration for token processing.
   * @returns New token with newly created proofs, token entries that had errors.
   */ async receive(t, e) {
        const { requireDleq: s, keysetId: o, outputAmounts: r, counter: a, pubkey: i, privkey: c, outputData: u, p2pk: h } = e || {};
        this._keysets.length === 0 && await this.getKeySets(), typeof t == "string" && (t = Me(t, this._keysets));
        const l = await this.getKeys(o);
        if (s && t.proofs.some((b)=>!Vt(b, l))) throw new Error("Token contains proofs with invalid DLEQ");
        const f = W(t.proofs) - this.getFeesForProofs(t.proofs);
        let d;
        u ? d = {
            send: u
        } : this._keepFactory && (d = {
            send: this._keepFactory
        });
        const y = this.createSwapPayload(f, t.proofs, l, r, a, i, c, d, h), { signatures: _ } = await this.mint.swap(y.payload), I = y.outputData.map((b, m)=>b.toProof(_[m], l)), T = [];
        return y.sortedIndices.forEach((b, m)=>{
            T[b] = I[m];
        }), T;
    }
    /**
   * Send proofs of a given amount, by providing at least the required amount of proofs.
   *
   * @param amount Amount to send.
   * @param proofs Array of proofs (accumulated amount of proofs must be >= than amount)
   * @param {SendOptions} [options] - Optional parameters for configuring the send operation.
   * @returns {SendResponse}
   */ async send(t, e, s) {
        const { offline: o, includeFees: r, includeDleq: a, keysetId: i, outputAmounts: c, pubkey: u, privkey: h, outputData: l } = s || {};
        if (a && (e = e.filter((_)=>_.dleq != null)), W(e) < t) throw new Error("Not enough funds available to send");
        const { keep: f, send: d } = this.selectProofsToSend(e, t, s?.includeFees), y = r ? this.getFeesForProofs(d) : 0;
        if (!o && (W(d) != t + y || // if the exact amount cannot be selected
        c || u || h || i || l)) {
            const _ = await this.swap(t, e, s), { keep: I, send: T } = _, b = _.serialized;
            return {
                keep: I,
                send: T,
                serialized: b
            };
        }
        if (W(d) < t + y) throw new Error("Not enough funds available to send");
        return {
            keep: f,
            send: d
        };
    }
    /**
   * Selects proofs to send based on amount and fee inclusion.
   *
   * @remarks
   * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time
   * complexity O(n log n) and space complexity O(n).
   * @param proofs Array of Proof objects available to select from.
   * @param amountToSend The target amount to send.
   * @param includeFees Optional boolean to include fees; Default: false.
   * @returns SendResponse containing proofs to keep and proofs to send.
   * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf
   */ selectProofsToSend(t, e, s = !1) {
        const h = Ue();
        let l = null, f = 1 / 0, d = 0, y = 0;
        const _ = (g, p)=>g - (s ? Math.ceil(p / 1e3) : 0), I = (g)=>{
            const p = [
                ...g
            ];
            for(let k = p.length - 1; k > 0; k--){
                const w = Math.floor(Math.random() * (k + 1));
                [p[k], p[w]] = [
                    p[w],
                    p[k]
                ];
            }
            return p;
        }, T = (g, p, k)=>{
            let w = 0, A = g.length - 1, P = null;
            for(; w <= A;){
                const L = Math.floor((w + A) / 2), j = g[L].exFee;
                (k ? j <= p : j >= p) ? (P = L, k ? w = L + 1 : A = L - 1) : k ? A = L - 1 : w = L + 1;
            }
            return k ? P : w < g.length ? w : null;
        }, b = (g, p)=>{
            const k = p.exFee;
            let w = 0, A = g.length;
            for(; w < A;){
                const P = Math.floor((w + A) / 2);
                g[P].exFee < k ? w = P + 1 : A = P;
            }
            g.splice(w, 0, p);
        }, m = (g, p)=>_(g, p) < e ? 1 / 0 : g + p / 1e3 - e;
        let E = 0, x = 0;
        const $ = t.map((g)=>{
            const p = this.getProofFeePPK(g), k = s ? g.amount - p / 1e3 : g.amount, w = {
                proof: g,
                exFee: k,
                ppkfee: p
            };
            return (!s || k > 0) && (E += g.amount, x += p), w;
        });
        let B = s ? $.filter((g)=>g.exFee > 0) : $;
        if (B.sort((g, p)=>g.exFee - p.exFee), B.length > 0) {
            let g;
            {
                const p = T(B, e, !1);
                if (p !== null) {
                    const k = B[p].exFee, w = T(B, k, !0);
                    if (w === null) throw new Error("Unexpected null rightIndex in binary search");
                    g = w + 1;
                } else g = B.length;
            }
            for(let p = g; p < B.length; p++)E -= B[p].proof.amount, x -= B[p].ppkfee;
            B = B.slice(0, g);
        }
        const nt = _(E, x);
        if (e <= 0 || e > nt) return {
            keep: t,
            send: []
        };
        const J = Math.min(Math.ceil(e * (1 + 0 / 100)), e + 0, nt);
        for(let g = 0; g < 60; g++){
            const p = [];
            let k = 0, w = 0;
            for (const R of I(B)){
                const U = k + R.proof.amount, K = w + R.ppkfee, C = _(U, K);
                if (p.push(R), k = U, w = K, C >= e) break;
            }
            const A = new Set(p), P = B.filter((R)=>!A.has(R)), L = I(Array.from({
                length: p.length
            }, (R, U)=>U)).slice(0, 5e3);
            for (const R of L){
                const U = _(k, w);
                if (U === e || U >= e && U <= J) break;
                const K = p[R], C = k - K.proof.amount, z = w - K.ppkfee, Zt = _(C, z), It = e - Zt, ut = T(P, It, !1);
                if (ut !== null) {
                    const ot = P[ut];
                    (It >= 0 || ot.exFee <= K.exFee) && (p[R] = ot, k = C + ot.proof.amount, w = z + ot.ppkfee, P.splice(ut, 1), b(P, K));
                }
            }
            const j = m(k, w);
            if (j < f) {
                this._logger.debug("selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}", {
                    trial: g,
                    amount: k,
                    delta: j
                }), l = [
                    ...p
                ].sort((U, K)=>K.exFee - U.exFee), f = j, d = k, y = w;
                const R = [
                    ...l
                ];
                for(; R.length > 1 && f > 0;){
                    const U = R.pop(), K = k - U.proof.amount, C = w - U.ppkfee, z = m(K, C);
                    if (z == 1 / 0) break;
                    z < f && (l = [
                        ...R
                    ], f = z, d = K, y = C, k = K, w = C);
                }
            }
            if (l && f < 1 / 0) {
                const R = _(d, y);
                if (R === e || R >= e && R <= J) break;
            }
            if (h.elapsed() > 1e3) {
                this._logger.warn("Proof selection took too long. Returning best selection so far.");
                break;
            }
        }
        if (l && f < 1 / 0) {
            const g = l.map((w)=>w.proof), p = new Set(g), k = t.filter((w)=>!p.has(w));
            return this._logger.info("Proof selection took {time}ms", {
                time: h.elapsed()
            }), {
                keep: k,
                send: g
            };
        }
        return {
            keep: t,
            send: []
        };
    }
    /**
   * Calculates the fees based on inputs (proofs)
   *
   * @param proofs Input proofs to calculate fees for.
   * @returns Fee amount.
   * @throws Throws an error if the proofs keyset is unknown.
   */ getFeesForProofs(t) {
        const e = t.reduce((s, o)=>s + this.getProofFeePPK(o), 0);
        return Math.ceil(e / 1e3);
    }
    /**
   * Returns the current fee PPK for a proof according to the cached keyset.
   *
   * @param proof {Proof} A single proof.
   * @returns FeePPK {number} The feePPK for the selected proof.
   * @throws Throws an error if the proofs keyset is unknown.
   */ getProofFeePPK(t) {
        const e = this._keysets.find((s)=>s.id === t.id);
        if (!e) throw new Error(`Could not get fee. No keyset found for keyset id: ${t.id}`);
        return e?.input_fee_ppk || 0;
    }
    /**
   * Calculates the fees based on inputs for a given keyset.
   *
   * @param nInputs Number of inputs.
   * @param keysetId KeysetId used to lookup `input_fee_ppk`
   * @returns Fee amount.
   */ getFeesForKeyset(t, e) {
        return Math.floor(Math.max((t * (this._keysets.find((o)=>o.id === e)?.input_fee_ppk || 0) + 999) / 1e3, 0));
    }
    /**
   * Splits and creates sendable tokens if no amount is specified, the amount is implied by the
   * cumulative amount of all proofs if both amount and preference are set, but the preference
   * cannot fulfill the amount, then we use the default split.
   *
   * @param {SwapOptions} [options] - Optional parameters for configuring the swap operation.
   * @returns Promise of the change- and send-proofs.
   */ async swap(t, e, s) {
        let { outputAmounts: o } = s || {};
        const { includeFees: r, keysetId: a, counter: i, pubkey: c, privkey: u, proofsWeHave: h, outputData: l, p2pk: f } = s || {}, d = await this.getKeys(a);
        let y = t;
        const _ = W(e);
        let I = o?.sendAmounts || D(y, d.keys);
        if (r) {
            let A = this.getFeesForKeyset(I.length, d.id), P = D(A, d.keys);
            for(; this.getFeesForKeyset(I.concat(P).length, d.id) > A;)A++, P = D(A, d.keys);
            I = I.concat(P), y += A;
        }
        const { keep: T, send: b } = this.selectProofsToSend(e, y, !0), m = W(b) - this.getFeesForProofs(b) - y;
        if (m < 0) throw new Error("Not enough balance to send");
        let E;
        if (!o?.keepAmounts && !h) E = D(m, d.keys);
        else if (!o?.keepAmounts && h) E = Tt(h, m, d.keys, this._denominationTarget);
        else if (o) {
            if (o.keepAmounts?.reduce((A, P)=>A + P, 0) != m) throw new Error("Keep amounts do not match amount to keep");
            E = o.keepAmounts;
        }
        if (y + this.getFeesForProofs(b) > _) throw this._logger.error(`Not enough funds available (${_}) for swap amountToSend: ${y} + fee: ${this.getFeesForProofs(b)} | length: ${b.length}`), new Error("Not enough funds available for swap");
        o = {
            keepAmounts: E,
            sendAmounts: I
        };
        const x = l?.keep || this._keepFactory, $ = l?.send, B = this.createSwapPayload(y, b, d, o, i, c, u, {
            keep: x,
            send: $
        }, f), { signatures: nt } = await this.mint.swap(B.payload), J = B.outputData.map((A, P)=>A.toProof(nt[P], d)), g = [], p = [], k = Array(B.keepVector.length), w = Array(J.length);
        return B.sortedIndices.forEach((A, P)=>{
            k[A] = B.keepVector[P], w[A] = J[P];
        }), w.forEach((A, P)=>{
            k[P] ? g.push(A) : p.push(A);
        }), {
            keep: [
                ...g,
                ...T
            ],
            send: p
        };
    }
    /**
   * Restores batches of deterministic proofs until no more signatures are returned from the mint.
   *
   * @param [gapLimit=300] The amount of empty counters that should be returned before restoring
   *   ends (defaults to 300). Default is `300`
   * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to
   *   100). Default is `100`
   * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default
   *   is `0`
   * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's
   *   default one will be used.
   */ async batchRestore(t = 300, e = 100, s = 0, o) {
        const r = Math.ceil(t / e), a = [];
        let i, c = 0;
        for(; c < r;){
            const u = await this.restore(s, e, {
                keysetId: o
            });
            u.proofs.length > 0 ? (c = 0, a.push(...u.proofs), i = u.lastCounterWithSignature) : c++, s += e;
        }
        return {
            proofs: a,
            lastCounterWithSignature: i
        };
    }
    /**
   * Regenerates.
   *
   * @param start Set starting point for count (first cycle for each keyset should usually be 0)
   * @param count Set number of blinded messages that should be generated.
   * @param options.keysetId Set a custom keysetId to restore from. keysetIds can be loaded with
   *   `CashuMint.getKeySets()`
   */ async restore(t, e, s) {
        const { keysetId: o } = s || {}, r = await this.getKeys(o);
        if (!this._seed) throw new Error("CashuWallet must be initialized with a seed to use restore");
        const a = Array(e).fill(0), i = Q.createDeterministicData(0, this._seed, t, r, a), { outputs: c, signatures: u } = await this.mint.restore({
            outputs: i.map((d)=>d.blindedMessage)
        }), h = {};
        c.forEach((d, y)=>h[d.B_] = u[y]);
        const l = [];
        let f;
        for(let d = 0; d < i.length; d++){
            const y = h[i[d].blindedMessage.B_];
            y && (f = t + d, i[d].blindedMessage.amount = y.amount, l.push(i[d].toProof(y, r)));
        }
        return {
            proofs: l,
            lastCounterWithSignature: f
        };
    }
    /**
   * Requests a mint quote from the mint. Response returns a Lightning payment request for the
   * requested given amount and unit.
   *
   * @param amount Amount requesting for mint.
   * @param description Optional description for the mint quote.
   * @param pubkey Optional public key to lock the quote to.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit.
   */ async createMintQuote(t, e) {
        const s = {
            unit: this._unit,
            amount: t,
            description: e
        }, o = await this.mint.createMintQuote(s);
        return {
            ...o,
            amount: o.amount || t,
            unit: o.unit || this.unit
        };
    }
    /**
   * Requests a mint quote from the mint that is locked to a public key.
   *
   * @param amount Amount requesting for mint.
   * @param pubkey Public key to lock the quote to.
   * @param description Optional description for the mint quote.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit. The quote will be locked to the specified `pubkey`.
   */ async createLockedMintQuote(t, e, s) {
        const { supported: o } = (await this.lazyGetMintInfo()).isSupported(20);
        if (!o) throw new Error("Mint does not support NUT-20");
        const r = {
            unit: this._unit,
            amount: t,
            description: s,
            pubkey: e
        }, a = await this.mint.createMintQuote(r);
        if (typeof a.pubkey != "string") throw new Error("Mint returned unlocked mint quote");
        {
            const i = a.pubkey;
            return {
                ...a,
                pubkey: i,
                amount: a.amount || t,
                unit: a.unit || this.unit
            };
        }
    }
    /**
   * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the
   * requested given amount and unit.
   *
   * @param pubkey Public key to lock the quote to.
   * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will
   *   be amountless.
   * @param options.description Description for the mint quote.
   * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the
   *   specified amount and unit.
   */ async createMintQuoteBolt12(t, e) {
        const s = await this.lazyGetMintInfo();
        if (e?.description && !s.supportsBolt12Description) throw new Error("Mint does not support description for bolt12");
        const o = {
            pubkey: t,
            unit: this._unit,
            amount: e?.amount,
            description: e?.description
        };
        return this.mint.createMintQuoteBolt12(o);
    }
    async checkMintQuote(t) {
        const e = typeof t == "string" ? t : t.quote, s = await this.mint.checkMintQuote(e);
        return typeof t == "string" ? s : {
            ...s,
            amount: s.amount || t.amount,
            unit: s.unit || t.unit
        };
    }
    /**
   * Gets an existing BOLT12 mint quote from the mint.
   *
   * @param quote Quote ID.
   * @returns The latest mint quote for the given quote ID.
   */ async checkMintQuoteBolt12(t) {
        return this.mint.checkMintQuoteBolt12(t);
    }
    async mintProofs(t, e, s) {
        return this._mintProofs("bolt11", t, e, s);
    }
    /**
   * Mint proofs for a given mint quote.
   *
   * @param amount Amount to request. This must be less than or equal to the `quote.amountPaid -
   *   quote.amountIssued`
   * @param {string} quote - ID of mint quote.
   * @param {string} privateKey - Private key to unlock the quote.
   * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof
   *   operation.
   * @returns Proofs.
   */ async mintProofsBolt12(t, e, s, o) {
        return this._mintProofs("bolt12", t, e, {
            ...o,
            privateKey: s
        });
    }
    /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a Lightning invoice.
   *
   * @param invoice LN invoice that needs to get a fee estimate.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   */ async createMeltQuote(t) {
        const e = {
            unit: this._unit,
            request: t
        }, s = await this.mint.createMeltQuote(e);
        return {
            ...s,
            unit: s.unit || this.unit,
            request: s.request || t
        };
    }
    /**
   * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order
   * to pay a BOLT12 offer.
   *
   * @param offer BOLT12 offer that needs to get a fee estimate.
   * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the
   *   offer has an amount, they **MUST** be equal.
   * @returns The mint will create and return a melt quote for the offer with an amount and fee
   *   reserve.
   */ async createMeltQuoteBolt12(t, e) {
        return this.mint.createMeltQuoteBolt12({
            unit: this._unit,
            request: t,
            options: e ? {
                amountless: {
                    amount_msat: e
                }
            } : void 0
        });
    }
    /**
   * Requests a multi path melt quote from the mint.
   *
   * @param invoice LN invoice that needs to get a fee estimate.
   * @param partialAmount The partial amount of the invoice's total to be paid by this instance.
   * @returns The mint will create and return a melt quote for the invoice with an amount and fee
   *   reserve.
   */ async createMultiPathMeltQuote(t, e) {
        const { supported: s, params: o } = (await this.lazyGetMintInfo()).isSupported(15);
        if (!s) throw new Error("Mint does not support NUT-15");
        if (!o?.some((u)=>u.method === "bolt11" && u.unit === this.unit)) throw new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);
        const a = {
            mpp: {
                amount: e
            }
        }, i = {
            unit: this._unit,
            request: t,
            options: a
        };
        return {
            ...await this.mint.createMeltQuote(i),
            request: t,
            unit: this._unit
        };
    }
    async checkMeltQuote(t) {
        const e = typeof t == "string" ? t : t.quote, s = await this.mint.checkMeltQuote(e);
        return typeof t == "string" ? s : {
            ...s,
            request: t.request,
            unit: t.unit
        };
    }
    async checkMeltQuoteBolt12(t) {
        return this.mint.checkMeltQuoteBolt12(t);
    }
    /**
   * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt
   * quote. This function does not perform coin selection!. Returns melt quote and change proofs.
   *
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof
   *   operation.
   * @returns
   */ async meltProofs(t, e, s) {
        return this._meltProofs("bolt11", t, e, s);
    }
    /**
   * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt
   * quote. This function does not perform coin selection!. Returns melt quote and change proofs.
   *
   * @param meltQuote ID of the melt quote.
   * @param proofsToSend Proofs to melt.
   * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof
   *   operation.
   * @returns
   */ async meltProofsBolt12(t, e, s) {
        return this._meltProofs("bolt12", t, e, s);
    }
    /**
   * Creates a split payload.
   *
   * @param amount Amount to send.
   * @param proofsToSend Proofs to split*
   * @param outputAmounts? Optionally specify the output's amounts to keep and to send.
   * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class
   *   must be initialized with seed phrase to take effect.
   * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is
   *   set!
   * @param privkey? Will create a signature on the @param proofsToSend secrets if set.
   * @param customOutputData? Optionally specify your own OutputData (blinded messages)
   * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.
   * @returns
   */ createSwapPayload(t, e, s, o, r, a, i, c, u) {
        const h = e.reduce((m, E)=>m + E.amount, 0);
        o && o.sendAmounts && !o.keepAmounts && (o.keepAmounts = D(h - t - this.getFeesForProofs(e), s.keys));
        const l = h - t - this.getFeesForProofs(e);
        let f = [], d = [];
        if (c?.keep) if (pt(c.keep)) {
            const m = c.keep;
            D(l, s.keys).forEach((x)=>{
                f.push(m(x, s));
            });
        } else f = c.keep;
        else f = this.createOutputData(l, s, r, void 0, o?.keepAmounts, void 0, this._keepFactory);
        if (c?.send) if (pt(c.send)) {
            const m = c.send;
            D(t, s.keys).forEach((x)=>{
                d.push(m(x, s));
            });
        } else d = c.send;
        else d = this.createOutputData(t, s, r ? r + f.length : void 0, a, o?.sendAmounts, u);
        i && (e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["signP2PKProofs"])(e, i)), e = at(e), e = e.map((m)=>{
            const E = m.witness && typeof m.witness != "string" ? JSON.stringify(m.witness) : m.witness;
            return {
                ...m,
                witness: E
            };
        });
        const y = [
            ...f,
            ...d
        ], _ = y.map((m, E)=>E).sort((m, E)=>y[m].blindedMessage.amount - y[E].blindedMessage.amount), I = [
            ...Array.from({
                length: f.length
            }, ()=>!0),
            ...Array.from({
                length: d.length
            }, ()=>!1)
        ], T = _.map((m)=>y[m]), b = _.map((m)=>I[m]);
        return {
            payload: {
                inputs: e,
                outputs: T.map((m)=>m.blindedMessage)
            },
            outputData: T,
            keepVector: b,
            sortedIndices: _
        };
    }
    /**
   * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
   *
   * @param proofs (only the `secret` field is required)
   * @returns
   */ async checkProofsStates(t) {
        const e = new TextEncoder(), s = t.map((a)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashToCurve"])(e.encode(a.secret)).toHex(!0)), o = 100, r = [];
        for(let a = 0; a < s.length; a += o){
            const i = s.slice(a, a + o), { states: c } = await this.mint.check({
                Ys: i
            }), u = {};
            c.forEach((h)=>{
                u[h.Y] = h;
            });
            for(let h = 0; h < i.length; h++){
                const l = u[i[h]];
                if (!l) throw new Error("Could not find state for proof with Y: " + i[h]);
                r.push(l);
            }
        }
        return r;
    }
    /**
   * Register a callback to be called whenever a mint quote's state changes.
   *
   * @param quoteIds List of mint quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a mint quote state changes.
   * @param errorCallback
   * @returns
   */ async onMintQuoteUpdates(t, e, s) {
        if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection) throw new Error("failed to establish WebSocket connection.");
        const o = this.mint.webSocketConnection.createSubscription({
            kind: "bolt11_mint_quote",
            filters: t
        }, e, s);
        return ()=>{
            this.mint.webSocketConnection?.cancelSubscription(o, e);
        };
    }
    /**
   * Register a callback to be called whenever a melt quote's state changes.
   *
   * @param quoteIds List of melt quote IDs that should be subscribed to.
   * @param callback Callback function that will be called whenever a melt quote state changes.
   * @param errorCallback
   * @returns
   */ async onMeltQuotePaid(t, e, s) {
        return this.onMeltQuoteUpdates([
            t
        ], (o)=>{
            o.state === et.PAID && e(o);
        }, s);
    }
    /**
   * Register a callback to be called when a single mint quote gets paid.
   *
   * @param quoteId Mint quote id that should be subscribed to.
   * @param callback Callback function that will be called when this mint quote gets paid.
   * @param errorCallback
   * @returns
   */ async onMintQuotePaid(t, e, s) {
        return this.onMintQuoteUpdates([
            t
        ], (o)=>{
            o.state === gt.PAID && e(o);
        }, s);
    }
    /**
   * Register a callback to be called when a single melt quote gets paid.
   *
   * @param quoteId Melt quote id that should be subscribed to.
   * @param callback Callback function that will be called when this melt quote gets paid.
   * @param errorCallback
   * @returns
   */ async onMeltQuoteUpdates(t, e, s) {
        if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection) throw new Error("failed to establish WebSocket connection.");
        const o = this.mint.webSocketConnection.createSubscription({
            kind: "bolt11_melt_quote",
            filters: t
        }, e, s);
        return ()=>{
            this.mint.webSocketConnection?.cancelSubscription(o, e);
        };
    }
    /**
   * Register a callback to be called whenever a subscribed proof state changes.
   *
   * @param proofs List of proofs that should be subscribed to.
   * @param callback Callback function that will be called whenever a proof's state changes.
   * @param errorCallback
   * @returns
   */ async onProofStateUpdates(t, e, s) {
        if (await this.mint.connectWebSocket(), !this.mint.webSocketConnection) throw new Error("failed to establish WebSocket connection.");
        const o = new TextEncoder(), r = {};
        for(let c = 0; c < t.length; c++){
            const u = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$common$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hashToCurve"])(o.encode(t[c].secret)).toHex(!0);
            r[u] = t[c];
        }
        const a = Object.keys(r), i = this.mint.webSocketConnection.createSubscription({
            kind: "proof_state",
            filters: a
        }, (c)=>{
            e({
                ...c,
                proof: r[c.Y]
            });
        }, s);
        return ()=>{
            this.mint.webSocketConnection?.cancelSubscription(i, e);
        };
    }
    /**
   * Creates blinded messages for a according to @param amounts.
   *
   * @param amount Array of amounts to create blinded messages for.
   * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class
   *   must be initialized with seed phrase to take effect.
   * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is
   *   set!
   * @param outputAmounts? Optionally specify the output's amounts to keep and to send.
   * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.
   * @param factory? Optionally specify a custom function that produces OutputData (blinded
   *   messages)
   * @returns Blinded messages, secrets, rs, and amounts.
   */ createOutputData(t, e, s, o, r, a, i) {
        let c;
        if (o) c = Q.createP2PKData({
            pubkey: o,
            additionalTags: a?.additionalTags
        }, t, e, r);
        else if (s || s === 0) {
            if (!this._seed) throw new Error("cannot create deterministic messages without seed");
            c = Q.createDeterministicData(t, this._seed, s, e, r);
        } else a ? c = Q.createP2PKData(a, t, e, r) : i ? c = D(t, e.keys).map((h)=>i(h, e)) : c = Q.createRandomData(t, e, r);
        return c;
    }
    /**
   * Creates NUT-08 blank outputs (fee returns) for a given fee reserve See:
   * https://github.com/cashubtc/nuts/blob/main/08.md.
   *
   * @param amount Amount to cover with blank outputs.
   * @param keysetId Mint keysetId.
   * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class
   *   must be initialized with seed phrase to take effect.
   * @returns Blinded messages, secrets, and rs.
   */ createBlankOutputs(t, e, s, o) {
        let r = Math.ceil(Math.log2(t)) || 1;
        r < 0 && (r = 0);
        const a = r ? Array(r).fill(0) : [];
        return this.createOutputData(0, e, s, void 0, a, void 0, o);
    }
    /**
   * Mints proofs for a given mint quote created with the bolt11 or bolt12 method.
   *
   * @param method Payment method of the quote.
   * @param amount Amount to mint.
   * @param quote The bolt11 or bolt12 mint quote.
   * @param options Optional parameters for configuring the Mint Proof operation.
   * @returns Proofs.
   */ async _mintProofs(t, e, s, o) {
        let { outputAmounts: r } = o || {};
        const { counter: a, pubkey: i, p2pk: c, keysetId: u, proofsWeHave: h, outputData: l, privateKey: f } = o || {}, d = await this.getKeys(u);
        !r && h && (r = {
            keepAmounts: Tt(h, e, d.keys, this._denominationTarget),
            sendAmounts: []
        });
        let y = [];
        if (l) if (pt(l)) {
            const b = D(e, d.keys, r?.keepAmounts);
            for(let m = 0; m < b.length; m++)y.push(l(b[m], d));
        } else y = l;
        else if (this._keepFactory) {
            const b = D(e, d.keys, r?.keepAmounts);
            for(let m = 0; m < b.length; m++)y.push(this._keepFactory(b[m], d));
        } else y = this.createOutputData(e, d, a, i, r?.keepAmounts, c);
        const _ = y.map((b)=>b.blindedMessage), I = {
            outputs: _,
            quote: typeof s == "string" ? s : s.quote
        };
        if (typeof s != "string" && s.pubkey) {
            if (!f) throw new Error("Can not sign locked quote without private key");
            I.signature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT20$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["signMintQuote"])(f, s.quote, _);
        }
        if (t === "bolt12") {
            const { signatures: b } = await this.mint.mintBolt12(I);
            return y.map((m, E)=>m.toProof(b[E], d));
        }
        const { signatures: T } = await this.mint.mint(I);
        return y.map((b, m)=>b.toProof(T[m], d));
    }
    /**
   * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.
   *
   * @param method Payment method of the quote.
   * @param meltQuote The bolt11 or bolt12 melt quote.
   * @param proofsToSend Proofs to melt.
   * @param options Optional parameters for configuring the Melting Proof operation.
   * @returns Melt quote and change proofs.
   */ async _meltProofs(t, e, s, o) {
        const { keysetId: r, counter: a, privkey: i } = o || {}, c = await this.getKeys(r), u = this.createBlankOutputs(W(s) - e.amount, c, a, this._keepFactory);
        i != null && (s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$crypto$2f$client$2f$NUT11$2e$es$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["signP2PKProofs"])(s, i)), s = at(s), s = s.map((f)=>{
            const d = f.witness && typeof f.witness != "string" ? JSON.stringify(f.witness) : f.witness;
            return {
                ...f,
                witness: d
            };
        });
        const h = {
            quote: e.quote,
            inputs: s,
            outputs: u.map((f)=>f.blindedMessage)
        };
        if (t === "bolt12") {
            const f = await this.mint.meltBolt12(h);
            return {
                quote: {
                    ...f,
                    unit: e.unit,
                    request: e.request
                },
                change: f.change?.map((d, y)=>u[y].toProof(d, c)) ?? []
            };
        }
        const l = await this.mint.melt(h);
        return {
            quote: {
                ...l,
                unit: e.unit,
                request: e.request
            },
            change: l.change?.map((f, d)=>u[d].toProof(f, c)) ?? []
        };
    }
}
class Z {
    /**
   * @param _mintUrl Requires mint URL to create this object.
   * @param _customRequest If passed, use custom request implementation for network communication
   *   with the mint.
   */ constructor(t, e){
        this._mintUrl = t, this._customRequest = e, this._mintUrl = Gt(t), this._customRequest = e;
    }
    get mintUrl() {
        return this._mintUrl;
    }
    /**
   * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.
   *
   * @param mintUrl
   * @param mintPayload Payload containing the outputs to get blind signatures on.
   * @param clearAuthToken A NUT-21 clear auth token.
   * @param customRequest
   * @returns Serialized blinded signatures.
   */ static async mint(t, e, s, o) {
        const r = o || M, a = {
            "Clear-auth": `${s}`
        }, i = await r({
            endpoint: S(t, "/v1/auth/blind/mint"),
            method: "POST",
            requestBody: e,
            headers: a
        });
        if (!O(i) || !Array.isArray(i?.signatures)) throw new Error("bad response");
        return i;
    }
    /**
   * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.
   *
   * @param mintPayload Payload containing the outputs to get blind signatures on.
   * @param clearAuthToken A NUT-21 clear auth token.
   * @returns Serialized blinded signatures.
   */ async mint(t, e) {
        return Z.mint(this._mintUrl, t, e, this._customRequest);
    }
    /**
   * Get the mints public NUT-22 keys.
   *
   * @param mintUrl
   * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
   *   keys from all active keysets are fetched.
   * @param customRequest
   * @returns
   */ static async getKeys(t, e, s) {
        const r = await (s || M)({
            endpoint: e ? S(t, "/v1/auth/blind/keys", e) : S(t, "/v1/auth/blind/keys")
        });
        if (!O(r) || !Array.isArray(r.keysets)) throw new Error("bad response");
        return r;
    }
    /**
   * Get the mints public NUT-22 keys.
   *
   * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the
   *   keys from all active keysets are fetched.
   * @returns The mints public keys.
   */ async getKeys(t, e) {
        return await Z.getKeys(e || this._mintUrl, t, this._customRequest);
    }
    /**
   * Get the mints NUT-22 keysets in no specific order.
   *
   * @param mintUrl
   * @param customRequest
   * @returns All the mints past and current keysets.
   */ static async getKeySets(t, e) {
        return (e || M)({
            endpoint: S(t, "/v1/auth/blind/keysets")
        });
    }
    /**
   * Get the mints NUT-22 keysets in no specific order.
   *
   * @returns All the mints past and current keysets.
   */ async getKeySets() {
        return Z.getKeySets(this._mintUrl, this._customRequest);
    }
}
class We {
    /**
   * @param mint NUT-22 auth mint instance.
   * @param options.keys Public keys from the mint (will be fetched from mint if not provided)
   * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)
   */ constructor(t, e){
        this._keys = /* @__PURE__ */ new Map(), this._keysets = [], this._unit = "auth", this.mint = t;
        let s = [];
        e?.keys && !Array.isArray(e.keys) ? s = [
            e.keys
        ] : e?.keys && Array.isArray(e?.keys) && (s = e?.keys), s && s.forEach((o)=>this._keys.set(o.id, o)), e?.keysets && (this._keysets = e.keysets);
    }
    get keys() {
        return this._keys;
    }
    get keysetId() {
        if (!this._keysetId) throw new Error("No keysetId set");
        return this._keysetId;
    }
    set keysetId(t) {
        this._keysetId = t;
    }
    get keysets() {
        return this._keysets;
    }
    /**
   * Load mint information, keysets and keys. This function can be called if no keysets are passed
   * in the constructor.
   */ async loadMint() {
        await this.getKeySets(), await this.getKeys();
    }
    /**
   * Choose a keyset to activate based on the lowest input fee.
   *
   * Note: this function will filter out deprecated base64 keysets.
   *
   * @param keysets Keysets to choose from.
   * @returns Active keyset.
   */ getActiveKeyset(t) {
        let e = t.filter((o)=>o.active);
        e = e.filter((o)=>o.id.startsWith("00"));
        const s = e.sort((o, r)=>(o.input_fee_ppk ?? 0) - (r.input_fee_ppk ?? 0))[0];
        if (!s) throw new Error("No active keyset found");
        return s;
    }
    /**
   * Get keysets from the mint with the unit of the wallet.
   *
   * @returns Keysets with wallet's unit.
   */ async getKeySets() {
        const e = (await this.mint.getKeySets()).keysets.filter((s)=>s.unit === this._unit);
        return this._keysets = e, this._keysets;
    }
    /**
   * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet
   * keyset.
   *
   * @returns Keyset.
   */ async getAllKeys() {
        const t = await this.mint.getKeys();
        return this._keys = new Map(t.keysets.map((e)=>[
                e.id,
                e
            ])), this.keysetId = this.getActiveKeyset(this._keysets).id, t.keysets;
    }
    /**
   * Get public keys from the mint. If keys were already fetched, it will return those.
   *
   * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an
   * active keyset with the unit of the wallet.
   *
   * @param keysetId Optional keysetId to get keys for.
   * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.
   * @returns Keyset.
   */ async getKeys(t, e) {
        if ((!(this._keysets.length > 0) || e) && await this.getKeySets(), t || (t = this.getActiveKeyset(this._keysets).id), !this._keysets.find((s)=>s.id === t) && (await this.getKeySets(), !this._keysets.find((s)=>s.id === t))) throw new Error(`could not initialize keys. No keyset with id '${t}' found`);
        if (!this._keys.get(t)) {
            const s = await this.mint.getKeys(t);
            this._keys.set(t, s.keysets[0]);
        }
        return this.keysetId = t, this._keys.get(t);
    }
    /**
   * Mint proofs for a given mint quote.
   *
   * @param amount Amount to request.
   * @param clearAuthToken ClearAuthToken to mint.
   * @param options.keysetId? Optionally set keysetId for blank outputs for returned change.
   * @returns Proofs.
   */ async mintProofs(t, e, s) {
        const o = await this.getKeys(s?.keysetId), r = Q.createRandomData(t, o), a = {
            outputs: r.map((u)=>u.blindedMessage)
        }, { signatures: i } = await this.mint.mint(a, e), c = r.map((u, h)=>u.toProof(i[h], o));
        if (c.some((u)=>!Vt(u, o))) throw new Error("Mint returned auth proofs with invalid DLEQ");
        return c;
    }
}
function $e(n) {
    const t = {
        id: n.id,
        secret: n.secret,
        C: n.C
    }, e = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$cashu$2f$cashu$2d$ts$2f$lib$2f$NUT09$2d$BsylB_jy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["c"])(t);
    return "auth" + "A" + e;
}
async function hs(n, t, e) {
    const s = new Z(t);
    return (await new We(s).mintProofs(n, e)).map((a)=>$e(a));
}
;
 //# sourceMappingURL=cashu-ts.es.js.map
}),
];

//# sourceMappingURL=node_modules_%40cashu_cashu-ts_lib_392af9b6._.js.map