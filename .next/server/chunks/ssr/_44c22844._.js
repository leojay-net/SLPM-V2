module.exports=[570536,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.OutOfBoundsError=c.RequestError=void 0;class d extends Error{constructor(a,b){try{let b=JSON.parse(a);null!=b.msg&&(a=b.msg)}catch(a){}super(a),Object.setPrototypeOf(this,d.prototype),this.httpCode=b}static parse(a,b){try{let c=JSON.parse(a);if(a=c.msg,20003===c.code||20004===c.code)return new e(c.msg,b,BigInt(c.data.min),BigInt(c.data.max))}catch(a){}return new d(a,b)}}c.RequestError=d;class e extends d{constructor(a,b,c,d){super(a,b),this.max=d,this.min=c,Object.setPrototypeOf(this,e.prototype)}}c.OutOfBoundsError=e},213144,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.randomBytes=c.toCoinselectAddressType=c.toOutputScript=c.bigIntCompare=c.bigIntMax=c.bigIntMin=c.timeoutSignal=c.timeoutPromise=c.httpPost=c.httpGet=c.fetchWithTimeout=c.tryWithRetries=c.extendAbortController=c.mapToArray=c.objectMap=c.promiseAny=c.getLogger=void 0;let d=a.r(570536),e=a.r(500874),f=a.r(680302),g=a.r(571420);function h(a){return"function"==typeof a&&null!=a.prototype&&a.prototype.constructor===a}function i(b){return{debug:(c,...d)=>a.g.atomiqLogLevel>=3&&console.debug(b+c,...d),info:(c,...d)=>a.g.atomiqLogLevel>=2&&console.info(b+c,...d),warn:(c,...d)=>(null==a.g.atomiqLogLevel||a.g.atomiqLogLevel>=1)&&console.warn(b+c,...d),error:(c,...d)=>(null==a.g.atomiqLogLevel||a.g.atomiqLogLevel>=0)&&console.error(b+c,...d)}}c.getLogger=i;let j=i("Utils: ");function k(a,b){return null==b&&(b={}),null!=b.timeout&&(b.signal=m(b.timeout,Error("Network request timed out"),b.signal)),fetch(a,b).catch(a=>{if("AbortError"===a.name)throw b.signal.reason;throw a})}function l(a,b){return new Promise((c,d)=>{let e;if(null!=b&&b.aborted)return void d(b.reason);let f=setTimeout(()=>{null!=e&&b.removeEventListener("abort",e),c()},a);null!=b&&b.addEventListener("abort",e=()=>{null!=f&&clearTimeout(f),f=null,d(b.reason)})})}function m(a,b,c){if(null==a)return c;let d=new AbortController,e=setTimeout(()=>d.abort(b||Error("Timed out")),a);return null!=c&&c.addEventListener("abort",()=>{clearTimeout(e),d.abort(c.reason)}),d.signal}c.promiseAny=function(a){return new Promise((b,c)=>{let d=0,e=Array(a.length);a.forEach((f,g)=>{f.then(a=>{null!=b&&b(a),b=null}).catch(b=>{e[g]=b,++d===a.length&&c(e)})})})},c.objectMap=function(a,b){let c={};for(let d in a)c[d]=b(a[d],d);return c},c.mapToArray=function(a,b){let c=Array(a.size),d=0;for(let e of a.entries())c[d++]=b(e[0],e[1]);return c},c.extendAbortController=function(a){let b=new AbortController;return null!=a&&(a.throwIfAborted(),a.onabort=()=>b.abort(a.reason)),b},c.tryWithRetries=async function(a,b,c,d){(b=b||{}).maxRetries=b.maxRetries||5,b.delay=b.delay||500,b.exponential=null==b.exponential||b.exponential;let e=null;for(let f=0;f<b.maxRetries;f++){try{return await a(f)}catch(a){if(null!=c&&function(a,b){return Array.isArray(b)&&b.every(h)?null!=b.find(b=>a instanceof b):h(b)?a instanceof b:b(a)}(a,c))throw a;e=a,j.warn("tryWithRetries(): Error on try number: "+f,a)}if(null!=d&&d.aborted)throw d.reason||Error("Aborted");f!==b.maxRetries-1&&await l(b.exponential?b.delay*Math.pow(2,f):b.delay,d)}throw e},c.fetchWithTimeout=k,c.httpGet=async function(a,b,c,e=!1){let f=await k(a,{method:"GET",timeout:b,signal:c});if(200!==f.status){let a;try{a=await f.text()}catch(a){throw new d.RequestError(f.statusText,f.status)}if(e)try{return JSON.parse(a)}catch(a){}throw d.RequestError.parse(a,f.status)}return await f.json()},c.httpPost=async function(a,b,c,e){let f={method:"POST",timeout:c,body:JSON.stringify(b),headers:{"Content-Type":"application/json"},signal:e},g=null==c?await fetch(a,f):await k(a,f);if(200!==g.status){let a;try{a=await g.text()}catch(a){throw new d.RequestError(g.statusText,g.status)}throw d.RequestError.parse(a,g.status)}return await g.json()},c.timeoutPromise=l,c.timeoutSignal=m,c.bigIntMin=function(a,b){return a>b?b:a},c.bigIntMax=function(a,b){return b>a?b:a},c.bigIntCompare=function(a,b){return a>b?1:a===b?0:-1},c.toOutputScript=function(a,b){let c=(0,f.Address)(a).decode(b);switch(c.type){case"pkh":case"sh":case"wpkh":case"wsh":return e.Buffer.from(f.OutScript.encode({type:c.type,hash:c.hash}));case"tr":return e.Buffer.from(f.OutScript.encode({type:"tr",pubkey:c.pubkey}))}},c.toCoinselectAddressType=function(a){switch(f.OutScript.decode(a).type){case"pkh":return"p2pkh";case"sh":return"p2sh-p2wpkh";case"wpkh":return"p2wpkh";case"wsh":return"p2wsh";case"tr":return"p2tr"}throw Error("Unrecognized address type!")},c.randomBytes=function(a){return e.Buffer.from((0,g.randomBytes)(a))}},255707,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.MempoolBtcRelaySynchronizer=void 0;let d=a.r(213144),e=(0,d.getLogger)("MempoolBtcRelaySynchronizer: ");c.MempoolBtcRelaySynchronizer=class{constructor(a,b){this.btcRelay=a,this.bitcoinRpc=b}async syncToLatestTxs(a,b){let c=await this.btcRelay.getTipData(),f={forkId:0,lastStoredHeader:null,tx:null,computedCommitedHeaders:null},{resultStoredHeader:g,resultBitcoinHeader:h}=await this.btcRelay.retrieveLatestKnownBlockLog();f.lastStoredHeader=g,g.getBlockheight()<c.blockheight&&(f.forkId=-1),h.getHash(),e.debug("Retrieved stored header with commitment: ",f.lastStoredHeader),e.debug("SPV tip bitcoin RPC block header: ",h);let i=h.height,j=[],k={[h.getHeight()]:h},l={[g.getBlockheight()]:g},m=null,n=b,o=b,p=async b=>{for(let d of(-1===f.forkId?(null==o&&(o=await this.btcRelay.getMainFeeRate(a)),f=await this.btcRelay.saveNewForkHeaders(a,b,f.lastStoredHeader,c.chainWork,o)):0===f.forkId?(null==o&&(o=await this.btcRelay.getMainFeeRate(a)),f=await this.btcRelay.saveMainHeaders(a,b,f.lastStoredHeader,o)):(null==n&&(n=await this.btcRelay.getForkFeeRate(a,f.forkId)),f=await this.btcRelay.saveForkHeaders(a,b,f.lastStoredHeader,f.forkId,c.chainWork,n)),-1!==f.forkId&&0!==f.forkId&&(m=f.forkId),j.push(f.tx),f.computedCommitedHeaders))l[d.getBlockheight()]=d},q=null,r=[];for(;null==q||q.length>0;){let a=(q=await this.bitcoinRpc.getPast15Blocks(i+15)).findIndex(a=>a.height===i);-1===a&&(a=q.length);for(let b=a-1;b>=0;b--){let a=q[b];k[a.height]=a,r.push(a),(0===f.forkId?r.length>=this.btcRelay.maxHeadersPerTx:r.length>=this.btcRelay.maxForkHeadersPerTx)&&(await p(r),r=[])}if(q.length>0){if(i===q[0].height)break;i=q[0].height,await (0,d.timeoutPromise)(1e3)}}if(r.length>0&&await p(r),0!==f.forkId)throw Error("Unable to synchronize on-chain bitcoin light client! Not enough chainwork at connected RPC.");return{txs:j,targetCommitedHeader:f.lastStoredHeader,blockHeaderMap:k,computedHeaderMap:l,btcRelayTipCommitedHeader:g,btcRelayTipBlockHeader:h,latestBlockHeader:h,startForkId:m}}}},102635,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.MempoolApi=void 0;let d=a.r(500874),e=a.r(213144),f=a.r(570536);c.MempoolApi=class{getOperationalApi(){return this.backends.find(a=>!0===a.operational)}getMaybeOperationalApis(){let a=this.backends.filter(a=>!0===a.operational||null===a.operational);return 0===a.length&&(this.backends.forEach(a=>a.operational=null),a=this.backends),a}async _request(a,b,c,d="GET",g){let h=await (0,e.fetchWithTimeout)(a+b,{method:d,timeout:this.timeout,body:"string"==typeof g?g:JSON.stringify(g)});if(200!==h.status){let a;try{a=await h.text()}catch(a){throw new f.RequestError(h.statusText,h.status)}throw f.RequestError.parse(a,h.status)}return"str"===c?await h.text():await h.json()}async requestFromMaybeOperationalUrls(a,b,c="GET",d){try{return await (0,e.promiseAny)(this.getMaybeOperationalApis().map(e=>(async()=>{try{let f=await this._request(e.url,a,b,c,d);return e.operational=!0,f}catch(a){if(a instanceof f.RequestError&&5!==Math.floor(a.httpCode/100))throw e.operational=!0,a;throw e.operational=!1,a}})()))}catch(a){throw a.find(a=>a instanceof f.RequestError&&5!==Math.floor(a.httpCode/100))||a[0]}}async request(a,b,c="GET",d){return(0,e.tryWithRetries)(()=>{let e=this.getOperationalApi();return null!=e?this._request(e.url,a,b,c,d).catch(g=>{if(g instanceof f.RequestError&&5!==Math.floor(g.httpCode/100))throw g;return e.operational=!1,this.requestFromMaybeOperationalUrls(a,b,c,d)}):this.requestFromMaybeOperationalUrls(a,b,c,d)},null,a=>a instanceof f.RequestError&&5!==Math.floor(a.httpCode/100))}constructor(a,b){Array.isArray(a=a??"https://mempool.space/testnet/api/")?this.backends=a.map(a=>({url:a,operational:null})):this.backends=[{url:a,operational:null}],this.timeout=b}getLNNodeInfo(a){return this.request("v1/lightning/nodes/"+a,"obj").catch(a=>{if("This node does not exist, or our node is not seeing it yet"===a.message)return null;throw a})}getTransaction(a){return this.request("tx/"+a,"obj").catch(a=>{if("Transaction not found"===a.message)return null;throw a})}async getRawTransaction(a){let b=await this.request("tx/"+a+"/hex","str").catch(a=>{if("Transaction not found"===a.message)return null;throw a});return null==b?null:d.Buffer.from(b,"hex")}async getAddressBalances(a){let b=await this.request("address/"+a,"obj"),c=BigInt(b.chain_stats.funded_txo_sum),d=BigInt(b.chain_stats.spent_txo_sum);return{confirmedBalance:c-d,unconfirmedBalance:BigInt(b.mempool_stats.funded_txo_sum)-BigInt(b.mempool_stats.spent_txo_sum)}}getCPFPData(a){return this.request("v1/cpfp/"+a,"obj")}async getAddressUTXOs(a){let b=await this.request("address/"+a+"/utxo","obj");return b.forEach(a=>a.value=BigInt(a.value)),b}getFees(){return this.request("v1/fees/recommended","obj")}getAddressTransactions(a){return this.request("address/"+a+"/txs","obj")}getPendingBlocks(){return this.request("v1/fees/mempool-blocks","obj")}async getTipBlockHeight(){return parseInt(await this.request("blocks/tip/height","str"))}getBlockHeader(a){return this.request("block/"+a,"obj")}getBlockStatus(a){return this.request("block/"+a+"/status","obj")}getTransactionProof(a){return this.request("tx/"+a+"/merkle-proof","obj")}getOutspends(a){return this.request("tx/"+a+"/outspends","obj")}getBlockHash(a){return this.request("block-height/"+a,"str")}getPast15BlockHeaders(a){return this.request("v1/blocks/"+a,"obj")}sendTransaction(a){return this.request("tx","str","POST",a)}}},822364,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.MempoolBitcoinBlock=void 0,c.MempoolBitcoinBlock=class{constructor(a){this.id=a.id,this.height=a.height,this.version=a.version,this.timestamp=a.timestamp,this.tx_count=a.tx_count,this.size=a.size,this.weight=a.weight,this.merkle_root=a.merkle_root,this.previousblockhash=a.previousblockhash,this.mediantime=a.mediantime,this.nonce=a.nonce,this.bits=a.bits,this.difficulty=a.difficulty}getHeight(){return this.height}getHash(){return this.id}getMerkleRoot(){return this.merkle_root}getNbits(){return this.bits}getNonce(){return this.nonce}getPrevBlockhash(){return this.previousblockhash}getTimestamp(){return this.timestamp}getVersion(){return this.version}getChainWork(){throw Error("Unsupported")}}},205646,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.MempoolBitcoinRpc=void 0;let d=a.r(163846),e=a.r(822364),f=a.r(102635),g=a.r(500874),h=a.r(213144),i=a.r(680302),j=a.r(404322);class k{constructor(a){this.api=a instanceof f.MempoolApi?a:new f.MempoolApi(a)}static getTxoHash(a){return g.Buffer.from((0,j.sha256)(g.Buffer.concat([d.BigIntBufferUtils.toBuffer(BigInt(a.value),"le",8),g.Buffer.from(a.scriptpubkey,"hex")])))}async getTimeTillConfirmation(a){let b=await this.api.getPendingBlocks(),c=b.findIndex(b=>b.feeRange[0]<=a);return -1===c||c+1===b.length&&b[b.length-1].blockVSize>1048576?-1:(c+1)*6e5}async getConfirmationDelay(a,b){if(a.confirmations>b)return 0;if(0===a.confirmations){let c=await this.api.getCPFPData(a.txid);if(null==c.effectiveFeePerVsize)return null;let d=await this.getTimeTillConfirmation(c.effectiveFeePerVsize);return -1!==d&&(d+=(b-1)*6e5),d}return(b-a.confirmations)*6e5}async toBtcTx(a,b=!0){let c,d=b?await this.api.getRawTransaction(a.txid):null,e=0;if(null!=a.status&&a.status.confirmed&&(e=await this.api.getTipBlockHeight()-a.status.block_height+1),null!=d){let a=i.Transaction.fromRaw(d,{allowLegacyWitnessUtxo:!0,allowUnknownInputs:!0,allowUnknownOutputs:!0,disableScriptCheck:!0});c=g.Buffer.from(a.toBytes(!0,!1)).toString("hex")}return{locktime:a.locktime,version:a.version,blockheight:a.status?.block_height,blockhash:a.status?.block_hash,confirmations:e,txid:a.txid,vsize:a.weight/4,hex:c,raw:null==d?null:d.toString("hex"),outs:a.vout.map((a,b)=>({value:a.value,n:b,scriptPubKey:{hex:a.scriptpubkey,asm:a.scriptpubkey_asm}})),ins:a.vin.map(a=>({txid:a.txid,vout:a.vout,scriptSig:{hex:a.scriptsig,asm:a.scriptsig_asm},sequence:a.sequence,txinwitness:a.witness}))}}getTipHeight(){return this.api.getTipBlockHeight()}async getBlockHeader(a){return new e.MempoolBitcoinBlock(await this.api.getBlockHeader(a))}async getMerkleProof(a,b){let c=await this.api.getTransactionProof(a);return{reversedTxId:g.Buffer.from(a,"hex").reverse(),pos:c.pos,merkle:c.merkle.map(a=>g.Buffer.from(a,"hex").reverse()),blockheight:c.block_height}}async getTransaction(a){let b=await this.api.getTransaction(a);return null==b?null:await this.toBtcTx(b)}async isInMainChain(a){return(await this.api.getBlockStatus(a)).in_best_chain}getBlockhash(a){return this.api.getBlockHash(a)}getBlockWithTransactions(a){throw Error("Unsupported.")}async getSyncInfo(){let a=await this.api.getTipBlockHeight();return{verificationProgress:1,blocks:a,headers:a,ibd:!1}}async getPast15Blocks(a){return(await this.api.getPast15BlockHeaders(a)).map(a=>new e.MempoolBitcoinBlock(a))}async checkAddressTxos(a,b){let c=(await this.api.getAddressTransactions(a)).map(a=>({tx:a,vout:a.vout.findIndex(a=>k.getTxoHash(a).equals(b))})).filter(a=>a.vout>=0).sort((a,b)=>a.tx.status.confirmed&&!b.tx.status.confirmed?-1:!a.tx.status.confirmed&&b.tx.status.confirmed?1:a.tx.status.confirmed&&b.tx.status.confirmed?a.tx.status.block_height-b.tx.status.block_height:0);return 0===c.length?null:{tx:await this.toBtcTx(c[0].tx,!1),vout:c[0].vout}}async waitForAddressTxo(a,b,c,d,e,f){for(null!=e&&e.throwIfAborted();null==e||!e.aborted;){await (0,h.timeoutPromise)(1e3*(f||5),e);let g=await this.checkAddressTxos(a,b);if(null==g){d(null,null,null,null);continue}let i=await this.getConfirmationDelay(g.tx,c);if(null!=i&&(null!=d&&d(g.tx.confirmations,g.tx.txid,g.vout,i),0===i))return g}e.throwIfAborted()}async waitForTransaction(a,b,c,d,e){for(null!=d&&d.throwIfAborted();null==d||!d.aborted;){await (0,h.timeoutPromise)(1e3*(e||5),d);let f=await this.getTransaction(a);if(null==f){c(null,null,null);continue}let g=await this.getConfirmationDelay(f,b);if(null!=g&&(null!=c&&c(f.confirmations,f.txid,g),0===g))return f}d.throwIfAborted()}async getLNNodeLiquidity(a){let b=await this.api.getLNNodeInfo(a);return{publicKey:b.public_key,capacity:BigInt(b.capacity),numChannels:b.active_channel_count}}sendRawTransaction(a){return this.api.sendTransaction(a)}sendRawPackage(a){throw Error("Unsupported")}async isSpent(a,b){let[c,d]=a.split(":"),e=parseInt(d),f=await this.api.getOutspends(c);return null==f[e]||(b?f[e].spent&&f[e].status.confirmed:f[e].spent)}parseTransaction(a){var b;return Promise.resolve({locktime:(b=i.Transaction.fromRaw(g.Buffer.from(a,"hex"),{allowLegacyWitnessUtxo:!0,allowUnknownInputs:!0,allowUnknownOutputs:!0,disableScriptCheck:!0})).lockTime,version:b.version,blockhash:null,confirmations:0,txid:g.Buffer.from((0,j.sha256)((0,j.sha256)(b.toBytes(!0,!1)))).reverse().toString("hex"),hex:g.Buffer.from(b.toBytes(!0,!1)).toString("hex"),raw:g.Buffer.from(b.toBytes(!0,!0)).toString("hex"),vsize:b.isFinal?b.vsize:null,outs:Array.from({length:b.outputsLength},(a,b)=>b).map(a=>{let c=b.getOutput(a);return{value:Number(c.amount),n:a,scriptPubKey:{asm:i.Script.decode(c.script).map(a=>"object"==typeof a?g.Buffer.from(a).toString("hex"):a.toString()).join(" "),hex:g.Buffer.from(c.script).toString("hex")}}}),ins:Array.from({length:b.inputsLength},(a,b)=>b).map(a=>{let c=b.getInput(a);return{txid:g.Buffer.from(c.txid).toString("hex"),vout:c.index,scriptSig:{asm:i.Script.decode(c.finalScriptSig).map(a=>"object"==typeof a?g.Buffer.from(a).toString("hex"):a.toString()).join(" "),hex:g.Buffer.from(c.finalScriptSig).toString("hex")},sequence:c.sequence,txinwitness:null==c.finalScriptWitness?[]:c.finalScriptWitness.map(a=>g.Buffer.from(a).toString("hex"))}})})}getEffectiveFeeRate(a){throw Error("Unsupported.")}async getFeeRate(){return(await this.api.getFees()).fastestFee}getAddressBalances(a){return this.api.getAddressBalances(a)}async getAddressUTXOs(a){return(await this.api.getAddressUTXOs(a)).map(a=>({txid:a.txid,vout:a.vout,confirmed:a.status.confirmed,block_height:a.status.block_height,block_hash:a.status.block_hash,block_time:a.status.block_time,value:a.value}))}getCPFPData(a){return this.api.getCPFPData(a)}}c.MempoolBitcoinRpc=k},963151,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0})},620427,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0})},963002,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.isIBitcoinWallet=void 0,c.isIBitcoinWallet=function(a){return null!==a&&"function"==typeof a.sendTransaction&&"function"==typeof a.fundPsbt&&"function"==typeof a.signPsbt&&"function"==typeof a.getFeeRate&&"function"==typeof a.getTransactionFee&&"function"==typeof a.getFundedPsbtFee&&"function"==typeof a.getReceiveAddress&&"function"==typeof a.getBalance&&"function"==typeof a.getSpendableBalance}},336756,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.utils=c.DUST_THRESHOLDS=void 0;let d=(0,a.r(213144).getLogger)("CoinSelect: "),e={"p2sh-p2wpkh":51,p2wpkh:27,p2tr:16.75,p2pkh:107,p2wsh:16.5};function f(a){return 41+(a.script?a.script.length:e[a.type])}let g={"p2sh-p2wpkh":23,p2wpkh:22,p2tr:34,p2pkh:25,p2wsh:34};function h(a){return 9+(a.script?a.script.length:g[a.type])}function i(a){return c.DUST_THRESHOLDS[a.type]}function j(a,b,c){let d=10,e=!1;for(let b of("p2pkh"!==c&&(d+=.5),a))e||"p2pkh"===b.type||(e=!0,d+=.5),d+=f(b);for(let a of b)d+=h(a);return Math.ceil(d)}function k(a){return"number"!=typeof a||!isFinite(a)||Math.floor(a)!==a||a<0?NaN:a}function l(a){return a.reduce((a,b)=>a+k(b.value),0)}c.DUST_THRESHOLDS={"p2sh-p2wpkh":540,p2wpkh:294,p2tr:330,p2pkh:546,p2wsh:330},c.utils={dustThreshold:i,finalize:function(a,b,c,e,f=0){let g=j(a,b,e);d.debug("finalize(): Transaction bytes: ",g);let k=c*(g+h({type:e}))+f;d.debug("finalize(): TX fee after adding change output: ",k);let m=Math.floor(l(a)-(l(b)+k));d.debug("finalize(): Leaves change (changeType="+e+") value: ",m),m>=i({type:e})&&(b=b.concat({value:m,type:e}));let n=l(a)-l(b);return(d.debug("finalize(): Re-calculated total fee: ",n),isFinite(n))?{inputs:a,outputs:b,fee:n}:{fee:c*g+f}},inputBytes:f,outputBytes:h,sumOrNaN:l,sumForgiving:function(a){return a.reduce((a,b)=>a+(isFinite(b.value)?b.value:0),0)},transactionBytes:j,uintOrNaN:k}},53026,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.accumulative=void 0;let d=a.r(336756),e=(0,a.r(213144).getLogger)("CoinSelect: ");c.accumulative=function(a,b,c,f,g){if(!isFinite(d.utils.uintOrNaN(c)))return null;let h=null==g?[]:[...g],i=d.utils.transactionBytes(h,b,f),j=c*i,k=0,l=d.utils.sumOrNaN(h),m=d.utils.sumOrNaN(b);e.debug("accumulative(): total output: ",m);for(let g=0;g<a.length;++g){let n=a[g],o=d.utils.inputBytes(n),p=c*o,q=d.utils.uintOrNaN(n.value),r=0;if(null!=n.cpfp&&n.cpfp.txEffectiveFeeRate<c&&(r=Math.ceil(n.cpfp.txVsize*(c-n.cpfp.txEffectiveFeeRate))),p+r>n.value){if(e.debug("accumulative("+g+"): Skipping detrimental output, cpfpFee: "+r+" utxoFee: "+p+" value: "+n.value),g===a.length-1)return{fee:c*(i+o)+k+r};continue}if(i+=o,l+=q,k+=r,h.push(n),j=Math.ceil(c*i+k),e.debug("accumulative("+g+"): total fee: ",j),e.debug("accumulative("+g+"): input value: ",l),e.debug("accumulative("+g+"): cpfpAddFee: ",k),!(l<m+j))return e.debug("accumulative("+g+"): Finalizing transaction, inputs: ",h),e.debug("accumulative("+g+"): Finalizing transaction, outputs: ",b),e.debug("accumulative("+g+"): Finalizing transaction, feeRate: ",c),d.utils.finalize(h,b,c,f,k)}return{fee:j}}},561577,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.blackjack=void 0;let d=a.r(336756);c.blackjack=function(a,b,c,e,f){if(!isFinite(d.utils.uintOrNaN(c)))return null;let g=null==f?[]:[...f],h=d.utils.transactionBytes(g,b,e),i=d.utils.sumOrNaN(g),j=0,k=d.utils.sumOrNaN(b),l=d.utils.dustThreshold({type:e});for(let f=0;f<a.length;++f){let m=a[f],n=d.utils.inputBytes(m),o=0;null!=m.cpfp&&m.cpfp.txEffectiveFeeRate<c&&(o=Math.ceil(m.cpfp.txVsize*(c-m.cpfp.txEffectiveFeeRate)));let p=Math.ceil(c*(h+n)+j+o),q=d.utils.uintOrNaN(m.value);if(!(i+q>k+p+l)&&(h+=n,i+=q,j+=o,g.push(m),!(i<k+p)))return d.utils.finalize(g,b,c,e,j)}return{fee:c*h+j}}},815577,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.maxSendable=c.coinSelect=c.DUST_THRESHOLDS=void 0;let d=a.r(53026),e=a.r(561577),f=a.r(336756);function g(a,b){let c=a.value-b*f.utils.inputBytes(a);return null!=a.cpfp&&a.cpfp.txEffectiveFeeRate<b&&(c-=a.cpfp.txVsize*(b-a.cpfp.txEffectiveFeeRate)),c}Object.defineProperty(c,"DUST_THRESHOLDS",{enumerable:!0,get:function(){return f.DUST_THRESHOLDS}}),c.coinSelect=function(a,b,c,f,h){a=a.sort((a,b)=>g(b,c)-g(a,c));let i=(0,e.blackjack)(a,b,c,f,h);return i.inputs?i:(0,d.accumulative)(a,b,c,f,h)},c.maxSendable=function(a,b,c,d,e){if(!isFinite(f.utils.uintOrNaN(c)))return null;let g=e??[],h=d??[],i=f.utils.transactionBytes(h,g.concat([b]),null),j=0,k=f.utils.sumOrNaN(h),l=f.utils.sumOrNaN(g);for(let b=0;b<a.length;++b){let d=a[b],e=f.utils.inputBytes(d),g=c*e,l=0;null!=d.cpfp&&d.cpfp.txEffectiveFeeRate<c&&(l=d.cpfp.txVsize*(c-d.cpfp.txEffectiveFeeRate));let m=f.utils.uintOrNaN(d.value);g+l>d.value||(i+=e,k+=m,j+=l,h.push(d))}let m=c*i+j,n=k-m-l;return n<f.DUST_THRESHOLDS[b.type]?{fee:m,value:0}:{fee:m,value:n}}},421427,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.BitcoinWallet=c.identifyAddressType=void 0;let d=a.r(815577),e=a.r(680302),f=a.r(500874),g=a.r(213144);c.identifyAddressType=function(a,b){switch((0,e.Address)(b).decode(a).type){case"pkh":return"p2pkh";case"wpkh":return"p2wpkh";case"tr":return"p2tr";case"sh":return"p2sh-p2wpkh";case"wsh":return"p2wsh";default:return null}};let h=(0,g.getLogger)("BitcoinWallet: ");c.BitcoinWallet=class{constructor(a,b,c=1.25,d){this.rpc=a,this.network=b,this.feeMultiplier=c,this.feeOverride=d}async getFeeRate(){return null!=this.feeOverride?this.feeOverride:Math.floor(await this.rpc.getFeeRate()*this.feeMultiplier)}_sendTransaction(a){return this.rpc.sendRawTransaction(a)}_getBalance(a){return this.rpc.getAddressBalances(a)}async _getUtxoPool(a,b){let c=await this.rpc.getAddressUTXOs(a),d=0,e=(0,g.toOutputScript)(this.network,a),f=[];for(let g of c){let c=Number(g.value);d+=c,f.push({vout:g.vout,txId:g.txid,value:c,type:b,outputScript:e,address:a,cpfp:g.confirmed?null:await this.rpc.getCPFPData(g.txid).then(a=>null==a.effectiveFeePerVsize?null:{txVsize:a.adjustedVsize,txEffectiveFeeRate:a.effectiveFeePerVsize}),confirmed:g.confirmed})}return h.debug("_getUtxoPool(): Total spendable value: "+d+" num utxos: "+f.length),f}async _getPsbt(a,b,c,d){let f=new e.Transaction({PSBTVersion:0});return f.addOutput({amount:BigInt(c),script:(0,g.toOutputScript)(this.network,b)}),this._fundPsbt(a,f,d)}async _fundPsbt(a,b,c){null==c&&(c=await this.getFeeRate());let i=(await Promise.all(a.map(a=>this._getUtxoPool(a.address,a.addressType)))).flat();h.debug("_fundPsbt(): fee rate: "+c+" utxo pool: ",i);let j={};a.forEach(a=>j[a.address]=a.pubkey);let k=[];for(let a=0;a<b.inputsLength;a++){let c=b.getInput(a),d=null!=c.witnessUtxo?c.witnessUtxo.amount:c.nonWitnessUtxo.outputs[c.index].amount,e=null!=c.witnessUtxo?c.witnessUtxo.script:c.nonWitnessUtxo.outputs[c.index].script;k.push({txId:f.Buffer.from(c.txid).toString("hex"),vout:c.index,value:Number(d),type:(0,g.toCoinselectAddressType)(e)})}let l=[];for(let a=0;a<b.outputsLength;a++){let c=b.getOutput(a);l.push({value:Number(c.amount),script:f.Buffer.from(c.script)})}h.debug("_fundPsbt(): Coinselect targets: ",l);let m=(0,d.coinSelect)(i,l,c,a[0].addressType,k);if(h.debug("_fundPsbt(): Coinselect result: ",m),null==m.inputs||null==m.outputs)return{psbt:null,fee:m.fee,inputAddressIndexes:null};m.inputs.splice(0,b.inputsLength),m.outputs.splice(0,b.outputsLength);let n={};return m.inputs.forEach((a,b)=>{n[a.address]??=[],n[a.address].push(b)}),(await Promise.all(m.inputs.map(async a=>{switch(a.type){case"p2tr":let b=(0,e.p2tr)(f.Buffer.from(j[a.address],"hex"));return{txid:a.txId,index:a.vout,witnessUtxo:{script:a.outputScript,amount:BigInt(a.value)},tapInternalKey:b.tapInternalKey,tapMerkleRoot:b.tapMerkleRoot,tapLeafScript:b.tapLeafScript};case"p2wpkh":return{txid:a.txId,index:a.vout,witnessUtxo:{script:a.outputScript,amount:BigInt(a.value)},sighashType:1};case"p2sh-p2wpkh":return{txid:a.txId,index:a.vout,witnessUtxo:{script:a.outputScript,amount:BigInt(a.value)},redeemScript:(0,e.p2wpkh)(f.Buffer.from(j[a.address],"hex"),this.network).script,sighashType:1};case"p2pkh":return{txid:a.txId,index:a.vout,nonWitnessUtxo:(await this.rpc.getTransaction(a.txId)).raw,sighashType:1}}}))).forEach(a=>b.addInput(a)),m.outputs.forEach(c=>{null==c.script&&null==c.address?b.addOutput({script:(0,g.toOutputScript)(this.network,a[0].address),amount:BigInt(Math.floor(c.value))}):b.addOutput({script:c.script??(0,g.toOutputScript)(this.network,c.address),amount:BigInt(c.value)})}),{psbt:b,fee:m.fee,inputAddressIndexes:n}}async _getSpendableBalance(a,b,c){c??=await this.getFeeRate();let i=(await Promise.all(a.map(a=>this._getUtxoPool(a.address,a.addressType)))).flat(),j=[];if(null!=b)for(let a=0;a<b.inputsLength;a++){let c=b.getInput(a),d=null!=c.witnessUtxo?c.witnessUtxo.amount:c.nonWitnessUtxo.outputs[c.index].amount,e=null!=c.witnessUtxo?c.witnessUtxo.script:c.nonWitnessUtxo.outputs[c.index].script;j.push({txId:f.Buffer.from(c.txid).toString("hex"),vout:c.index,value:Number(d),type:(0,g.toCoinselectAddressType)(e)})}let k=[];if(null!=b)for(let a=0;a<b.outputsLength;a++){let c=b.getOutput(a);k.push({value:Number(c.amount),script:f.Buffer.from(c.script)})}let l=e.OutScript.encode({type:"wsh",hash:(0,g.randomBytes)(32)}),m=(0,d.maxSendable)(i,{script:f.Buffer.from(l),type:"p2wsh"},c,j,k);return h.debug("_getSpendableBalance(): Max spendable result: ",m),{feeRate:c,balance:BigInt(Math.floor(m.value)),totalFee:m.fee}}}},823212,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SingleAddressBitcoinWallet=void 0;let d=a.r(411320),e=a.r(680302),f=a.r(500874),g=a.r(421427);class h extends g.BitcoinWallet{constructor(a,b,c,h=1.25,i){if(super(a,b,h,i),"string"==typeof c){try{this.privKey=(0,e.WIF)(b).decode(c)}catch(a){this.privKey=(0,e.WIF)().decode(c)}this.pubkey=(0,d.pubECDSA)(this.privKey),this.address=(0,e.getAddress)("wpkh",this.privKey,b)}else this.address=c.address,this.pubkey=f.Buffer.from(c.publicKey,"hex");this.addressType=(0,g.identifyAddressType)(this.address,b)}toBitcoinWalletAccounts(){return[{pubkey:f.Buffer.from(this.pubkey).toString("hex"),address:this.address,addressType:this.addressType}]}async sendTransaction(a,b,c){if(!this.privKey)throw Error("Not supported.");let{psbt:d}=await super._getPsbt(this.toBitcoinWalletAccounts(),a,Number(b),c);d.sign(this.privKey),d.finalize();let e=f.Buffer.from(d.extract()).toString("hex");return await super._sendTransaction(e)}async fundPsbt(a,b){let{psbt:c}=await super._fundPsbt(this.toBitcoinWalletAccounts(),a,b);if(null==c)throw Error("Not enough balance!");return c}async signPsbt(a,b){if(!this.privKey)throw Error("Not supported.");for(let c of b)a.signIdx(this.privKey,c);return a}async getTransactionFee(a,b,c){let{psbt:d,fee:e}=await super._getPsbt(this.toBitcoinWalletAccounts(),a,Number(b),c);return null==d?null:e}async getFundedPsbtFee(a,b){let{psbt:c,fee:d}=await super._fundPsbt(this.toBitcoinWalletAccounts(),a,b);return null==c?null:d}getReceiveAddress(){return this.address}getBalance(){return this._getBalance(this.address)}getSpendableBalance(a,b){return this._getSpendableBalance([{address:this.address,addressType:this.addressType}],a,b)}static generateRandomPrivateKey(a){return(0,e.WIF)(a).encode((0,d.randomPrivateKeyBytes)())}}c.SingleAddressBitcoinWallet=h},974727,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IntermediaryError=void 0;class d extends Error{constructor(a){super(a),Object.setPrototypeOf(this,d.prototype)}}c.IntermediaryError=d},725291,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.PaymentAuthError=void 0;class d extends Error{constructor(a,b,c){super(a),this.data=c,this.code=b,Object.setPrototypeOf(this,d.prototype)}getCode(){return this.code}getData(){return this.data}}c.PaymentAuthError=d},339834,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.UserError=void 0;class d extends Error{constructor(a){super(a),Object.setPrototypeOf(this,d.prototype)}}c.UserError=d},813954,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SwapType=void 0,function(a){a[a.FROM_BTC=0]="FROM_BTC",a[a.FROM_BTCLN=1]="FROM_BTCLN",a[a.TO_BTC=2]="TO_BTC",a[a.TO_BTCLN=3]="TO_BTCLN",a[a.TRUSTED_FROM_BTC=4]="TRUSTED_FROM_BTC",a[a.TRUSTED_FROM_BTCLN=5]="TRUSTED_FROM_BTCLN",a[a.SPV_VAULT_FROM_BTC=6]="SPV_VAULT_FROM_BTC"}(c.SwapType||(c.SwapType={}))},596795,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Intermediary=void 0;let d=a.r(813954),e=a.r(213144);c.Intermediary=class{constructor(a,b,c,e={}){for(let f in this.reputation={},this.liquidity={},this.url=a,this.addresses=b,this.services=c,this.reputation=e,this.swapBounds={},this.services){let a=parseInt(f),b=this.services[f],c={min:BigInt(b.min),max:BigInt(b.max)},e=a===d.SwapType.TO_BTC||a===d.SwapType.TO_BTCLN;for(let d in this.swapBounds[a]={},b.chainTokens)for(let f of(this.swapBounds[a][d]={},b.chainTokens[d]))this.swapBounds[a][d][f]={input:e?{min:null,max:null}:c,output:e?c:{min:null,max:null}}}}getSwapLimits(a,b,c){return this.swapBounds[a]?.[b]?.[c]}getSupportedTokens(a,b=[d.SwapType.TO_BTC,d.SwapType.TO_BTCLN,d.SwapType.FROM_BTC,d.SwapType.FROM_BTCLN,d.SwapType.SPV_VAULT_FROM_BTC]){let c=new Set(b),e=new Set;return c.forEach(b=>{null!=this.services[b]&&null!=this.services[b].chainTokens&&null!=this.services[b].chainTokens[a]&&this.services[b].chainTokens[a].forEach(a=>e.add(a))}),e}async getReputation(a,b,c,f){let g=null==c?this.getSupportedTokens(a,[d.SwapType.TO_BTC,d.SwapType.TO_BTCLN]):new Set(c),h=[],i={};for(let c of g)h.push((0,e.tryWithRetries)(()=>b.getIntermediaryReputation(this.getAddress(a),c),null,null,f).then(a=>{i[c]=a}));for(let b in await Promise.all(h),this.reputation??={},this.reputation[a]??={},i)this.reputation[a][b]=i[b];return i}async getLiquidity(a,b,c,d){let f=await (0,e.tryWithRetries)(()=>b.getBalance(this.getAddress(a),c,!0),null,null,d);return this.liquidity??={},this.liquidity[a]??={},this.liquidity[a][c]=f,f}supportsChain(a){return null!=this.addresses[a]&&0!==this.getSupportedTokens(a).size}getAddress(a){return this.addresses[a]}}},266022,(a,b,c)=>{"use strict";var d;function e(a){if(null==a||"string"!=typeof a&&"number"!=typeof a)return null;try{return BigInt(a)}catch(a){return null}}function f(a){if("function"==typeof a)return null!=a(void 0);if("object"==typeof a){for(let b in a)if(!f(a[b]))return!1;return!0}return a>=100}function g(a,b){if(null==a)return null;let c={};for(let h in b){let i=a[h],j=b[h];if("function"==typeof j){let a=j(i);if(null==a)return null;c[h]=a;continue}if(null==i&&f(j)){c[h]=null;continue}if(j===d.Any||j===d.AnyOptional)c[h]=i;else if(j===d.Boolean||j===d.BooleanOptional){if("boolean"!=typeof i)return null;c[h]=i}else if(j===d.Number||j===d.NumberOptional){if("number"!=typeof i||isNaN(i))return null;c[h]=i}else if(j===d.BigInt||j===d.BigIntOptional){let a=e(i);if(null==a)return null;c[h]=a}else if(j===d.String||j===d.StringOptional){if("string"!=typeof i)return null;c[h]=i}else{let a=g(i,j);if(null==a)return null;c[h]=a}}return c}Object.defineProperty(c,"__esModule",{value:!0}),c.verifySchema=c.verifyField=c.isOptionalField=c.FieldTypeEnum=c.parseBigInt=void 0,c.parseBigInt=e,function(a){a[a.String=0]="String",a[a.Boolean=1]="Boolean",a[a.Number=2]="Number",a[a.BigInt=3]="BigInt",a[a.Any=4]="Any",a[a.StringOptional=100]="StringOptional",a[a.BooleanOptional=101]="BooleanOptional",a[a.NumberOptional=102]="NumberOptional",a[a.BigIntOptional=103]="BigIntOptional",a[a.AnyOptional=104]="AnyOptional"}(d=c.FieldTypeEnum||(c.FieldTypeEnum={})),c.isOptionalField=f,c.verifyField=function(a,b){if("function"==typeof a){let c=a(b);if(null==c)return;return c}if(null==b&&f(a))return null;if(a===d.Any||a===d.AnyOptional)return b;if(a===d.Boolean||a===d.BooleanOptional){if("boolean"!=typeof b)return;return b}if(a===d.Number||a===d.NumberOptional){if("number"!=typeof b||isNaN(b))return;return b}if(a===d.BigInt||a===d.BigIntOptional){let a=e(b);if(null==a)return;return a}if(a===d.String||a===d.StringOptional){if("string"!=typeof b)return;return b}else{let c=g(b,a);if(null==c)return;return c}},c.verifySchema=g},768947,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ParamEncoder=void 0;let d=a.r(500874);c.ParamEncoder=class{constructor(a,b){this.writeFN=a,this.endFN=b}writeParams(a){let b=d.Buffer.from(JSON.stringify(a)),c=d.Buffer.alloc(4);return c.writeUint32LE(b.length),this.writeFN(d.Buffer.concat([c,b]))}end(){return this.endFN()}}},306025,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.StreamParamEncoder=void 0;let d=a.r(768947);class e extends d.ParamEncoder{constructor(){let a=new TransformStream,b=a.writable.getWriter();b.closed.then(()=>this.closed=!0),super(b.write.bind(b),()=>this.closed?Promise.resolve():(this.closed=!0,b.close())),this.closed=!1,this.stream=a}getReadableStream(){return this.stream.readable}}c.StreamParamEncoder=e},866198,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ParamDecoder=void 0;let d=a.r(500874);c.ParamDecoder=class{constructor(){this.frameHeader=null,this.frameData=[],this.frameDataLength=0,this.closed=!1,this.params={}}onFrameRead(a){let b=JSON.parse(a.toString());for(let a in b)null==this.params[a]?this.params[a]={promise:Promise.resolve(b[a]),resolve:null,reject:null}:null!=this.params[a].resolve&&(this.params[a].resolve(b[a]),this.params[a].resolve=null,this.params[a].reject=null)}onData(a){let b=a;for(;null!=b&&b.length>0;){if(null==this.frameHeader)b.length<=4?(this.frameHeader=b,b=null):(this.frameHeader=b.subarray(0,4),b=b.subarray(4));else if(this.frameHeader.length<4){let a=4-this.frameHeader.length;b.length<=a?(this.frameHeader=d.Buffer.concat([this.frameHeader,b]),b=null):(this.frameHeader=d.Buffer.concat([this.frameHeader,b.subarray(0,a)]),b=b.subarray(a))}if(null==b||null==this.frameHeader||this.frameHeader.length<4)continue;let a=this.frameHeader.readUint32LE(),c=a-this.frameDataLength;b.length<=c?(this.frameData.push(b),this.frameDataLength+=b.length,b=null):(this.frameData.push(b.subarray(0,c)),this.frameDataLength+=c,b=b.subarray(c)),a===this.frameDataLength&&(this.onFrameRead(d.Buffer.concat(this.frameData)),this.frameHeader=null,this.frameData=[],this.frameDataLength=0)}}onEnd(){for(let a in this.params)null!=this.params[a].reject&&this.params[a].reject(Error("EOF before field seen!"));this.closed=!0}onError(a){for(let b in this.params)null!=this.params[b].reject&&this.params[b].reject(a);this.closed=!0}getParam(a){if(null==this.params[a]){let b,c;if(this.closed)return Promise.reject(Error("Stream already closed without param received!"));let d=new Promise((a,d)=>{b=a,c=d});this.params[a]={resolve:b,reject:c,promise:d}}return this.params[a].promise}}},315151,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ResponseParamDecoder=void 0;let d=a.r(866198),e=a.r(500874),f=(0,a.r(213144).getLogger)("ResponseParamDecoder: ");class g extends d.ParamDecoder{constructor(a,b){super(),this.abortSignal=b;try{this.reader=a.body.getReader(),this.readResponse()}catch(b){a.arrayBuffer().then(a=>{super.onData(e.Buffer.from(a)),super.onEnd()}).catch(a=>{super.onError(a)})}null!=b&&b.addEventListener("abort",()=>{super.onError(b.reason),this.reader.closed||this.reader.cancel(b.reason)})}async readResponse(){for(;;){let a=await this.reader.read().catch(a=>(f.error("readResponse(): Error reading response: ",a),null));if(null!=this.abortSignal&&this.abortSignal.aborted)return;if(null==a||a.done)return void super.onEnd();super.onData(e.Buffer.from(a.value))}}}c.ResponseParamDecoder=g},356498,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.streamingFetchPromise=void 0;let d=a.r(266022),e=a.r(570536),f=a.r(213144),g=a.r(306025),h=a.r(315151),i=(0,f.getLogger)("StreamingFetch: "),j=(()=>{try{let a=!1,b=new Request("https://example.com/",{body:new ReadableStream,method:"POST",get duplex(){return a=!0,"half"}}).headers.has("Content-Type");return a&&!b}catch(a){return i.error("supportsRequestStreams: Error checking environment support for HTTP request stream",a),!1}})();i.info("Environment supports request stream: "+j),c.streamingFetchPromise=async function(a,b,c,k,l,m){null==m&&(m=j),null!=k&&(l=(0,f.timeoutSignal)(k,Error("Network request timed out"),l));let n={method:"POST",headers:{}},o=Date.now(),p={},q=[];if(m){let c=new g.StreamParamEncoder,d=!1;for(let e in b)b[e]instanceof Promise?(q.push(b[e].then(b=>(i.debug(a+": Send param ("+(Date.now()-o)+"ms) (streaming): ",{[e]:b}),c.writeParams({[e]:b})))),d=!0):p[e]=b[e];if(d){n.body=c.getReadableStream(),n.headers["content-type"]="application/x-multiple-json",n.duplex="half",i.debug(a+": Sending request ("+(Date.now()-o)+"ms) (streaming): ",p),q.push(c.writeParams(p));let b=(0,f.extendAbortController)(l);l=b.signal,Promise.all(q).then(()=>c.end()).catch(a=>{a._inputPromiseError=!0,b.abort(a)}),l.addEventListener("abort",()=>c.end())}else i.debug(a+": Sending request ("+(Date.now()-o)+"ms) (non-streaming): ",p),n.body=JSON.stringify(p),n.headers["content-type"]="application/json"}else{for(let a in b)b[a]instanceof Promise?q.push(b[a].then(b=>{p[a]=b})):p[a]=b[a];try{await Promise.all(q)}catch(a){throw a._inputPromiseError=!0,a}null!=l&&l.throwIfAborted(),i.debug(a+": Sending request ("+(Date.now()-o)+"ms) (non-streaming): ",p),n.body=JSON.stringify(p),n.headers["content-type"]="application/json"}null!=l&&(n.signal=l),n.headers.accept="application/x-multiple-json";let r=await fetch(a,n).catch(a=>{if(null!=n.signal&&"AbortError"===a.name)throw n.signal.reason;throw null!=a.message&&(a.message+=m?" (streaming req)":" (non streaming req)"),a});if(i.debug(a+": Response status ("+(Date.now()-o)+"ms) "+(m?"(streaming req)":"(non streaming req)")+": ",r.status),200!==r.status){let a;try{a=await r.text()}catch(a){throw new e.RequestError(r.statusText,r.status)}throw new e.RequestError(a,r.status)}if("application/x-multiple-json"!==r.headers.get("content-type")){let b=await r.json();return i.debug(a+": Response read ("+(Date.now()-o)+"ms) (non streaming resp): ",b),(0,f.objectMap)(c,(a,c)=>{let e=b[c],f=(0,d.verifyField)(a,e);return void 0===f?Promise.reject(Error("Invalid field value")):Promise.resolve(f)})}{let b=new h.ResponseParamDecoder(r,n.signal);return(0,f.objectMap)(c,(c,e)=>b.getParam(e).catch(a=>{if(!(0,d.isOptionalField)(c))throw a}).then(b=>{i.debug(a+": Response frame read ("+(Date.now()-o)+"ms) (streaming resp): ",{[e]:b});let f=(0,d.verifyField)(c,b);return void 0===f?Promise.reject(Error("Invalid field value")):f}))}}},774702,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IntermediaryAPI=c.PaymentAuthorizationResponseCodes=c.RefundAuthorizationResponseCodes=void 0;let d=a.r(570536),e=a.r(266022),f=a.r(356498),g=a.r(213144);!function(a){a[a.EXPIRED=20010]="EXPIRED",a[a.REFUND_DATA=2e4]="REFUND_DATA",a[a.NOT_FOUND=20007]="NOT_FOUND",a[a.PENDING=20008]="PENDING",a[a.PAID=20006]="PAID"}(c.RefundAuthorizationResponseCodes||(c.RefundAuthorizationResponseCodes={})),function(a){a[a.AUTH_DATA=1e4]="AUTH_DATA",a[a.EXPIRED=10001]="EXPIRED",a[a.PAID=10002]="PAID",a[a.PENDING=10003]="PENDING",a[a.ALREADY_COMMITTED=10004]="ALREADY_COMMITTED"}(c.PaymentAuthorizationResponseCodes||(c.PaymentAuthorizationResponseCodes={}));let h={data:e.FieldTypeEnum.Any,prefix:e.FieldTypeEnum.String,timeout:e.FieldTypeEnum.String,signature:e.FieldTypeEnum.String},i={amount:e.FieldTypeEnum.BigInt,address:e.FieldTypeEnum.String,satsPervByte:e.FieldTypeEnum.BigInt,networkFee:e.FieldTypeEnum.BigInt,swapFee:e.FieldTypeEnum.BigInt,totalFee:e.FieldTypeEnum.BigInt,total:e.FieldTypeEnum.BigInt,minRequiredExpiry:e.FieldTypeEnum.BigInt,...h},j={maxFee:e.FieldTypeEnum.BigInt,swapFee:e.FieldTypeEnum.BigInt,total:e.FieldTypeEnum.BigInt,confidence:e.FieldTypeEnum.Number,address:e.FieldTypeEnum.String,routingFeeSats:e.FieldTypeEnum.BigInt,...h},k={amount:e.FieldTypeEnum.BigInt,reqId:e.FieldTypeEnum.String},l={amount:e.FieldTypeEnum.BigInt,btcAddress:e.FieldTypeEnum.String,address:e.FieldTypeEnum.String,swapFee:e.FieldTypeEnum.BigInt,total:e.FieldTypeEnum.BigInt,confirmations:e.FieldTypeEnum.NumberOptional,...h},m={pr:e.FieldTypeEnum.String,swapFee:e.FieldTypeEnum.BigInt,total:e.FieldTypeEnum.BigInt,intermediaryKey:e.FieldTypeEnum.String,securityDeposit:e.FieldTypeEnum.BigInt},n={quoteId:e.FieldTypeEnum.String,expiry:e.FieldTypeEnum.Number,address:e.FieldTypeEnum.String,vaultId:e.FieldTypeEnum.BigInt,vaultBtcAddress:e.FieldTypeEnum.String,btcAddress:e.FieldTypeEnum.String,btcUtxo:e.FieldTypeEnum.String,btcFeeRate:e.FieldTypeEnum.Number,btcAmount:e.FieldTypeEnum.BigInt,btcAmountSwap:e.FieldTypeEnum.BigInt,btcAmountGas:e.FieldTypeEnum.BigInt,total:e.FieldTypeEnum.BigInt,totalGas:e.FieldTypeEnum.BigInt,totalFeeBtc:e.FieldTypeEnum.BigInt,swapFeeBtc:e.FieldTypeEnum.BigInt,swapFee:e.FieldTypeEnum.BigInt,gasSwapFeeBtc:e.FieldTypeEnum.BigInt,gasSwapFee:e.FieldTypeEnum.BigInt,callerFeeShare:e.FieldTypeEnum.BigInt,frontingFeeShare:e.FieldTypeEnum.BigInt,executionFeeShare:e.FieldTypeEnum.BigInt},o={txId:e.FieldTypeEnum.String};c.IntermediaryAPI=class{static async getIntermediaryInfo(a,b,c){let d=(0,g.randomBytes)(32).toString("hex"),e=await (0,g.httpPost)(a+"/info",{nonce:d},b,c);if(d!==JSON.parse(e.envelope).nonce)throw Error("Invalid response - nonce");return e}static async getRefundAuthorization(a,b,c,e,f){return(0,g.tryWithRetries)(()=>(0,g.httpGet)(a+"/getRefundAuthorization?paymentHash="+encodeURIComponent(b)+"&sequence="+encodeURIComponent(c.toString(10)),e,f),null,d.RequestError,f)}static async getPaymentAuthorization(a,b,c,e){return(0,g.tryWithRetries)(()=>(0,g.httpGet)(a+"/getInvoicePaymentAuth?paymentHash="+encodeURIComponent(b),c,e),null,d.RequestError,e)}static initToBTC(a,b,c,g,h,j){let k=(0,f.streamingFetchPromise)(b+"/tobtc/payInvoice?chain="+encodeURIComponent(a),{...c.additionalParams,address:c.btcAddress,amount:c.amount.toString(10),exactIn:c.exactIn,confirmationTarget:c.confirmationTarget,confirmations:c.confirmations,nonce:c.nonce.toString(10),token:c.token,offerer:c.offerer,feeRate:c.feeRate},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional,signDataPrefetch:e.FieldTypeEnum.AnyOptional},g,h,j);return{signDataPrefetch:k.then(a=>a.signDataPrefetch),response:k.then(a=>Promise.all([a.code,a.msg,a.data])).then(([a,b,c])=>{if(2e4!==a)throw d.RequestError.parse(JSON.stringify({code:a,msg:b,data:c}),400);return(0,e.verifySchema)(c,i)})}}static initFromBTC(a,b,c,g,h,i,j){let k=(0,f.streamingFetchPromise)(b+"/frombtc/getAddress?chain="+encodeURIComponent(a)+"&depositToken="+encodeURIComponent(c),{...g.additionalParams,address:g.claimer,amount:g.amount.toString(10),token:g.token,exactOut:g.exactOut,sequence:g.sequence.toString(10),claimerBounty:g.claimerBounty.then(a=>({feePerBlock:a.feePerBlock.toString(10),safetyFactor:a.safetyFactor,startTimestamp:a.startTimestamp.toString(10),addBlock:a.addBlock,addFee:a.addFee.toString(10)})),feeRate:g.feeRate},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional,signDataPrefetch:e.FieldTypeEnum.AnyOptional},h,i,j);return{signDataPrefetch:k.then(a=>a.signDataPrefetch),response:k.then(a=>Promise.all([a.code,a.msg,a.data])).then(([a,b,c])=>{if(2e4!==a)throw d.RequestError.parse(JSON.stringify({code:a,msg:b,data:c}),400);return(0,e.verifySchema)(c,l)})}}static initFromBTCLN(a,b,c,g,h,i,j){let k=(0,f.streamingFetchPromise)(b+"/frombtcln/createInvoice?chain="+encodeURIComponent(a)+"&depositToken="+encodeURIComponent(c),{...g.additionalParams,paymentHash:g.paymentHash.toString("hex"),amount:g.amount.toString(),address:g.claimer,token:g.token,descriptionHash:null==g.descriptionHash?null:g.descriptionHash.toString("hex"),exactOut:g.exactOut,feeRate:g.feeRate},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional,lnPublicKey:e.FieldTypeEnum.StringOptional},h,i,j);return{lnPublicKey:k.then(a=>a.lnPublicKey),response:k.then(a=>Promise.all([a.code,a.msg,a.data])).then(([a,b,c])=>{if(2e4!==a)throw d.RequestError.parse(JSON.stringify({code:a,msg:b,data:c}),400);return(0,e.verifySchema)(c,m)})}}static initToBTCLN(a,b,c,g,h,i){let k=(0,f.streamingFetchPromise)(b+"/tobtcln/payInvoice?chain="+encodeURIComponent(a),{exactIn:!1,...c.additionalParams,pr:c.pr,maxFee:c.maxFee.toString(10),expiryTimestamp:c.expiryTimestamp.toString(10),token:c.token,offerer:c.offerer,feeRate:c.feeRate,amount:null},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional,signDataPrefetch:e.FieldTypeEnum.AnyOptional},g,h,i);return{signDataPrefetch:k.then(a=>a.signDataPrefetch),response:k.then(a=>Promise.all([a.code,a.msg,a.data])).then(([a,b,c])=>{if(2e4!==a)throw d.RequestError.parse(JSON.stringify({code:a,msg:b,data:c}),400);return(0,e.verifySchema)(c,j)})}}static async initToBTCLNExactIn(a,b,c,g,h){let i=await (0,f.streamingFetchPromise)(a+"/tobtcln/payInvoiceExactIn",{...b.additionalParams,pr:b.pr,reqId:b.reqId,feeRate:b.feeRate},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional},c,g,h),[k,l,m]=await Promise.all([i.code,i.msg,i.data]);if(2e4!==k)throw d.RequestError.parse(JSON.stringify({code:k,msg:l,data:m}),400);return(0,e.verifySchema)(m,j)}static prepareToBTCLNExactIn(a,b,c,g,h,i){let j=(0,f.streamingFetchPromise)(b+"/tobtcln/payInvoice?chain="+encodeURIComponent(a),{exactIn:!0,...c.additionalParams,pr:c.pr,maxFee:c.maxFee.toString(10),expiryTimestamp:c.expiryTimestamp.toString(10),token:c.token,offerer:c.offerer,amount:c.amount.toString(10)},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional,signDataPrefetch:e.FieldTypeEnum.AnyOptional},g,h,i);return{signDataPrefetch:j.then(a=>a.signDataPrefetch),response:j.then(a=>Promise.all([a.code,a.msg,a.data])).then(([a,b,c])=>{if(2e4!==a)throw d.RequestError.parse(JSON.stringify({code:a,msg:b,data:c}),400);return(0,e.verifySchema)(c,k)})}}static prepareSpvFromBTC(a,b,c,g,h,i){return(0,f.streamingFetchPromise)(b+"/frombtc_spv/getQuote?chain="+encodeURIComponent(a),{exactOut:c.exactOut,...c.additionalParams,address:c.address,amount:c.amount.toString(10),token:c.token,gasAmount:c.gasAmount.toString(10),gasToken:c.gasToken,frontingFeeRate:c.frontingFeeRate.toString(10),callerFeeRate:c.callerFeeRate.then(a=>a.toString(10))},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional},g,h,i).then(a=>Promise.all([a.code,a.msg,a.data])).then(([a,b,c])=>{if(2e4!==a)throw d.RequestError.parse(JSON.stringify({code:a,msg:b,data:c}),400);return(0,e.verifySchema)(c,n)})}static initSpvFromBTC(a,b,c,g,h,i){return(0,f.streamingFetchPromise)(b+"/postQuote?chain="+encodeURIComponent(a),{quoteId:c.quoteId,psbtHex:c.psbtHex},{code:e.FieldTypeEnum.Number,msg:e.FieldTypeEnum.String,data:e.FieldTypeEnum.AnyOptional},g,h,i).then(a=>Promise.all([a.code,a.msg,a.data])).then(([a,b,c])=>{if(2e4!==a)throw d.RequestError.parse(JSON.stringify({code:a,msg:b,data:c}),400);return(0,e.verifySchema)(c,o)})}}},947317,(a,b,c)=>{"use strict";var d;Object.defineProperty(c,"__esModule",{value:!0}),c.IntermediaryDiscovery=c.SwapHandlerType=void 0;let e=a.r(596795),f=a.r(813954),g=a.r(163846),h=a.r(427699),i=a.r(500874),j=a.r(213144),k=a.r(774702);!function(a){a.TO_BTC="TO_BTC",a.FROM_BTC="FROM_BTC",a.TO_BTCLN="TO_BTCLN",a.FROM_BTCLN="FROM_BTCLN",a.FROM_BTC_TRUSTED="FROM_BTC_TRUSTED",a.FROM_BTCLN_TRUSTED="FROM_BTCLN_TRUSTED",a.FROM_BTC_SPV="FROM_BTC_SPV"}(d=c.SwapHandlerType||(c.SwapHandlerType={}));let l=(0,j.getLogger)("IntermediaryDiscovery: ");class m extends h.EventEmitter{constructor(a,b="https://api.github.com/repos/adambor/SolLightning-registry/contents/registry.json?ref=main",c,d){super(),this.intermediaries=[],this.swapContracts=a,this.registryUrl=b,this.overrideNodeUrls=c,this.httpRequestTimeout=d}async getIntermediaryUrls(a){if(null!=this.overrideNodeUrls&&this.overrideNodeUrls.length>0)return this.overrideNodeUrls;let b=(await (0,j.httpGet)(this.registryUrl,this.httpRequestTimeout,a)).content.replace(RegExp("\\n","g"),"");return JSON.parse(i.Buffer.from(b,"base64").toString())}async getNodeInfo(a,b){let c=await (0,j.tryWithRetries)(()=>k.IntermediaryAPI.getIntermediaryInfo(a,this.httpRequestTimeout,b),{maxRetries:3,delay:100,exponential:!0},void 0,b),d={};for(let e in c.chains)if(null!=this.swapContracts[e]){let{signature:f,address:h}=c.chains[e];try{await (0,j.tryWithRetries)(()=>this.swapContracts[e].isValidDataSignature(i.Buffer.from(c.envelope),f,h),{maxRetries:3,delay:100,exponential:!0},g.SignatureVerificationError,b),d[e]=h}catch(b){l.warn("Failed to verify "+e+" signature for intermediary: "+a)}}null!=b&&b.throwIfAborted();let e=JSON.parse(c.envelope);for(let a in e.services){let b=e.services[a];for(let a in null==b.chainTokens&&(b.chainTokens={SOLANA:b.tokens}),b.chainTokens)null==d[a]&&delete b.chainTokens[a]}return{addresses:d,info:e}}async loadIntermediary(a,b){try{let c=await this.getNodeInfo(a,b),g={};for(let a in c.info.services)g[function(a){switch(a){case d.FROM_BTC:return f.SwapType.FROM_BTC;case d.TO_BTC:return f.SwapType.TO_BTC;case d.FROM_BTCLN:return f.SwapType.FROM_BTCLN;case d.TO_BTCLN:return f.SwapType.TO_BTCLN;case d.FROM_BTC_TRUSTED:return f.SwapType.TRUSTED_FROM_BTC;case d.FROM_BTCLN_TRUSTED:return f.SwapType.TRUSTED_FROM_BTCLN;case d.FROM_BTC_SPV:return f.SwapType.SPV_VAULT_FROM_BTC}}(a)]=c.info.services[a];return new e.Intermediary(a,c.addresses,g)}catch(b){return l.warn("fetchIntermediaries(): Error contacting intermediary "+a+": ",b),null}}async fetchIntermediaries(a){let b=await this.getIntermediaryUrls(a);l.debug("fetchIntermediaries(): Pinging intermediaries: ",b.join());let c=b.map(b=>this.loadIntermediary(b,a)),d=(await Promise.all(c)).filter(a=>null!=a);if(0===d.length)throw Error("No online intermediary found!");return d}getIntermediary(a){let b=this.intermediaries.find(b=>b.url===a);return null!=b?Promise.resolve(b):this.loadIntermediary(a)}async reloadIntermediaries(a){let b=await (0,j.tryWithRetries)(()=>this.fetchIntermediaries(a),null,null,a);this.intermediaries=b,this.emit("added",b),l.info("reloadIntermediaries(): Using active intermediaries: ",b.map(a=>a.url).join())}init(a){return l.info("init(): Initializing with registryUrl: "+this.registryUrl+" intermediary array: "+(this.overrideNodeUrls||[]).join()),this.reloadIntermediaries(a)}getMultichainSwapBounds(){let a={};return this.intermediaries.forEach(b=>{for(let c in b.services){let d=b.services[c];a[c]??={};let e=a[c];for(let a in d.chainTokens){e[a]??={};let b=e[a];for(let c of d.chainTokens[a]){let a=b[c];null==a?b[c]={min:BigInt(d.min),max:BigInt(d.max)}:(a.min=(0,j.bigIntMin)(a.min,BigInt(d.min)),a.max=(0,j.bigIntMax)(a.max,BigInt(d.max)))}}}}),a}getSwapBounds(a){let b={};return this.intermediaries.forEach(c=>{for(let d in c.services){let e=c.services[d];null==b[d]&&(b[d]={});let f=b[d];if(null!=e.chainTokens&&null!=e.chainTokens[a])for(let b of e.chainTokens[a]){let a=f[b];null==a?f[b]={min:BigInt(e.min),max:BigInt(e.max)}:(a.min=(0,j.bigIntMin)(a.min,BigInt(e.min)),a.max=(0,j.bigIntMax)(a.max,BigInt(e.max)))}}}),b}getSwapMinimum(a,b,c){let d=c.toString();return this.intermediaries.reduce((c,e)=>{let f=e.services[b];return null!=f&&null!=f.chainTokens&&null!=f.chainTokens[a]&&f.chainTokens[a].includes(d)?null==c?f.min:Math.min(c,f.min):c},null)}getSwapMaximum(a,b,c){let d=c.toString();return this.intermediaries.reduce((c,e)=>{let f=e.services[b];return null!=f&&null!=f.chainTokens&&null!=f.chainTokens[a]&&f.chainTokens[a].includes(d)?null==c?f.max:Math.max(c,f.max):c},null)}getSwapCandidates(a,b,c,d,e){let g=this.intermediaries.filter(e=>{let f=e.services[b];return!(null==f||null!=d&&d<BigInt(f.min)||null!=d&&d>BigInt(f.max))&&null!=f.chainTokens&&null!=f.chainTokens[a]&&!!f.chainTokens[a].includes(c.toString())});return(g.sort((f.SwapType.TO_BTC,(a,c)=>{if(null==d)return a.services[b].swapFeePPM-c.services[b].swapFeePPM;{let e=BigInt(a.services[b].swapBaseFee)+d*BigInt(a.services[b].swapFeePPM)/1000000n,f=BigInt(c.services[b].swapBaseFee)+d*BigInt(c.services[b].swapFeePPM)/1000000n;return e-f>0n?1:e===f?0:-1}})),null==e)?g:g.slice(0,e)}removeIntermediary(a){let b=this.intermediaries.indexOf(a);return b>=0&&(l.info("removeIntermediary(): Removing intermediary: "+a.url),this.intermediaries.splice(b,1),this.emit("removed",[a]),!0)}}c.IntermediaryDiscovery=m},488717,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ISwapPrice=c.isPriceInfoType=void 0,c.isPriceInfoType=function(a){return null!=a&&"boolean"==typeof a.isValid&&"bigint"==typeof a.differencePPM&&"bigint"==typeof a.satsBaseFee&&"bigint"==typeof a.feePPM&&"bigint"==typeof a.realPriceUSatPerToken&&"bigint"==typeof a.swapPriceUSatPerToken},c.ISwapPrice=class{constructor(a){this.maxAllowedFeeDifferencePPM=a}recomputePriceInfoSend(a,b,c,d,e,f){let g=1000000n*(b*(1000000n+d)/1000000n+c)*10n**BigInt(this.getDecimals(a,f))/e;return{isValid:!0,differencePPM:0n,satsBaseFee:c,feePPM:d,realPriceUSatPerToken:this.shouldIgnore(a,f)?null:g,swapPriceUSatPerToken:g}}async isValidAmountSend(a,b,c,d,e,f,g,h){let i=b*(1000000n+d)/1000000n+c,j=1000000n*i,k=j*10n**BigInt(this.getDecimals(a,f))/e;if(this.shouldIgnore(a,f))return{isValid:!0,differencePPM:0n,satsBaseFee:c,feePPM:d,realPriceUSatPerToken:null,swapPriceUSatPerToken:k};let l=await this.getFromBtcSwapAmount(a,i,f,g,h),m=j*10n**BigInt(this.getDecimals(a,f))/l,n=1000000n*(e-l)/l;return{isValid:n<=this.maxAllowedFeeDifferencePPM,differencePPM:n,satsBaseFee:c,feePPM:d,realPriceUSatPerToken:m,swapPriceUSatPerToken:k}}recomputePriceInfoReceive(a,b,c,d,e,f){let g=1000000n*(b*(1000000n-d)/1000000n-c)*10n**BigInt(this.getDecimals(a,f))/e;return{isValid:!0,differencePPM:0n,satsBaseFee:c,feePPM:d,realPriceUSatPerToken:this.shouldIgnore(a,f)?null:g,swapPriceUSatPerToken:g}}async isValidAmountReceive(a,b,c,d,e,f,g,h){let i=b*(1000000n-d)/1000000n-c,j=1000000n*i,k=j*10n**BigInt(this.getDecimals(a,f))/e;if(this.shouldIgnore(a,f))return{isValid:!0,differencePPM:0n,satsBaseFee:c,feePPM:d,realPriceUSatPerToken:null,swapPriceUSatPerToken:k};let l=await this.getFromBtcSwapAmount(a,i,f,g,h),m=j*10n**BigInt(this.getDecimals(a,f))/l,n=100000n*(l-e)/l;return{isValid:n<=this.maxAllowedFeeDifferencePPM,differencePPM:n,satsBaseFee:c,feePPM:d,realPriceUSatPerToken:m,swapPriceUSatPerToken:k}}preFetchPrice(a,b,c){return this.getPrice(a,b,c)}preFetchUsdPrice(a){return this.getUsdPrice(a)}async getFromBtcSwapAmount(a,b,c,d,e){if(null==this.getDecimals(a,c.toString()))throw Error("Token not found!");let f=e||await this.getPrice(a,c,d);return b*10n**BigInt(this.getDecimals(a,c.toString()))*1000000n/f}async getToBtcSwapAmount(a,b,c,d,e){if(null==this.getDecimals(a,c.toString()))throw Error("Token not found");return b*(e||await this.getPrice(a,c,d))/1000000n/10n**BigInt(this.getDecimals(a,c.toString()))}shouldIgnore(a,b){let c=this.getDecimals(a,b.toString());if(null==c)throw Error("Token not found");return -1===c}async getBtcUsdValue(a,b,c){return Number(a)*(c||await this.getUsdPrice(b))}async getTokenUsdValue(a,b,c,d,e){let[f,g]=await Promise.all([this.getToBtcSwapAmount(a,b,c,d),null==e?this.preFetchUsdPrice(d):Promise.resolve(e)]);return Number(f)*g}getUsdValue(a,b,c,d){return"BTC"===b.chain?this.getBtcUsdValue(a,c,d):this.getTokenUsdValue(b.chainId,a,b.address,c,d)}}},661064,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ICachedSwapPrice=void 0;let d=a.r(488717);class e extends d.ISwapPrice{constructor(a,b){super(a),this.cache={},this.cacheTimeout=b||1e4}getPrice(a,b,c){let d=b.toString(),e=this.cache[a];if(null!=e){let b=e[d];if(null!=b&&b.expiry>Date.now())return b.price.catch(b=>this.fetchPrice(a,d,c))}let f=this.fetchPrice(a,d);return this.cache[a]??={},this.cache[a][d]={price:f,expiry:Date.now()+this.cacheTimeout},f.catch(b=>{throw null!=this.cache[a]&&null!=this.cache[a][d]&&this.cache[a][d].price===f&&delete this.cache[d],b}),f}getUsdPrice(a){if(null!=this.usdCache&&this.usdCache.expiry>Date.now())return this.usdCache.price.catch(b=>this.fetchUsdPrice(a));let b=this.fetchUsdPrice();return this.usdCache={price:b,expiry:Date.now()+this.cacheTimeout},b.catch(a=>{throw null!=this.usdCache&&this.usdCache.price===b&&delete this.usdCache,a}),b}}c.ICachedSwapPrice=e},156628,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IPriceProvider=void 0,c.IPriceProvider=class{constructor(a){for(let b of(this.coinsMap={},a))if(null!=b.coinId)for(let a in b.chains){let{address:c,decimals:d}=b.chains[a];this.coinsMap[a]??={},this.coinsMap[a][c.toString()]={coinId:b.coinId,decimals:d}}}getPrice(a,b,c){let d=b.toString(),e=this.coinsMap[a];if(null==e)throw Error("Chain not found");let f=e[d];if(null==f)throw Error("Token not found");return f.coinId.startsWith("$fixed-")?Promise.resolve(BigInt(Math.floor(1e6*parseFloat(f.coinId.substring(7))).toString(10))):this.fetchPrice(f,c)}getUsdPrice(a){return this.fetchUsdPrice(a)}getDecimals(a,b){let c=this.coinsMap[a];if(null==c)throw Error("Chain not found");let d=c[b.toString()];if(null==d)throw Error("Token not found");return"$ignore"===d.coinId?-1:d.decimals}}},213944,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.HttpPriceProvider=void 0;let d=a.r(156628);class e extends d.IPriceProvider{constructor(a,b,c){super(a),this.url=b,this.httpRequestTimeout=c}}c.HttpPriceProvider=e},325656,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ExchangePriceProvider=void 0;let d=a.r(213944);class e extends d.HttpPriceProvider{async fetchPrice(a,b){let c=a.coinId.split(";");return BigInt(Math.floor(1e14*(await Promise.all(c.map(a=>{let c=a.startsWith("!");return c&&(a=a.substring(1)),this.fetchPair(a,b).then(a=>c?1/a:a)}))).reduce((a,b)=>a*b,1)))}}c.ExchangePriceProvider=e},443354,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.BinancePriceProvider=void 0;let d=a.r(325656),e=a.r(213144);class f extends d.ExchangePriceProvider{constructor(a,b="https://api.binance.com/api/v3",c){super(a,b,c)}async fetchPair(a,b){return parseFloat((await (0,e.httpGet)(this.url+"/ticker/price?symbol="+a,this.httpRequestTimeout,b)).price)}async fetchUsdPrice(a){return parseFloat((await (0,e.httpGet)(this.url+"/ticker/price?symbol=BTCUSDC",this.httpRequestTimeout,a)).price)/1e8}}c.BinancePriceProvider=f},96360,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.CoinGeckoPriceProvider=void 0;let d=a.r(213944),e=a.r(213144);class f extends d.HttpPriceProvider{constructor(a,b="https://api.coingecko.com/api/v3",c){super(a,b,c)}async fetchPrice(a,b){return BigInt(1e6*(await (0,e.httpGet)(this.url+"/simple/price?ids="+a.coinId+"&vs_currencies=sats&precision=6",this.httpRequestTimeout,b))[a.coinId].sats)}async fetchUsdPrice(a){return(await (0,e.httpGet)(this.url+"/simple/price?ids=bitcoin&vs_currencies=usd&precision=9",this.httpRequestTimeout,a)).bitcoin.usd/1e8}}c.CoinGeckoPriceProvider=f},573547,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.CoinPaprikaPriceProvider=void 0;let d=a.r(213944),e=a.r(213144);class f extends d.HttpPriceProvider{constructor(a,b="https://api.coinpaprika.com/v1",c){super(a,b,c)}async fetchPrice(a,b){return BigInt(Math.floor(1e14*(await (0,e.httpGet)(this.url+"/tickers/"+a.coinId+"?quotes=BTC",this.httpRequestTimeout,b)).quotes.BTC.price))}async fetchUsdPrice(a){return(await (0,e.httpGet)(this.url+"/tickers/btc-bitcoin?quotes=USD",this.httpRequestTimeout,a)).quotes.USD.price/1e8}}c.CoinPaprikaPriceProvider=f},145001,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.OKXPriceProvider=void 0;let d=a.r(325656),e=a.r(213144);class f extends d.ExchangePriceProvider{constructor(a,b="https://www.okx.com/api/v5",c){super(a,b,c)}async fetchPair(a,b){return parseFloat((await (0,e.httpGet)(this.url+"/market/index-tickers?instId="+a,this.httpRequestTimeout,b)).data[0].idxPx)}async fetchUsdPrice(a){return parseFloat((await (0,e.httpGet)(this.url+"/market/index-tickers?instId=BTC-USD",this.httpRequestTimeout,a)).data[0].idxPx)/1e8}}c.OKXPriceProvider=f},641955,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.CustomPriceProvider=void 0;let d=a.r(156628);class e extends d.IPriceProvider{constructor(a,b){super(a),this.getUsdPriceFn=b}async fetchPrice(a,b){let[c,d]=await this.getUsdPriceFn(["BTC",a.coinId],b);return BigInt(Math.floor(d/c*1e14))}async fetchUsdPrice(a){let[b]=await this.getUsdPriceFn(["BTC"],a);return b/1e8}}c.CustomPriceProvider=e},547621,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.KrakenPriceProvider=void 0;let d=a.r(325656),e=a.r(213144);class f extends d.ExchangePriceProvider{constructor(a,b="https://api.kraken.com/0",c){super(a,b,c)}async fetchPair(a,b){return parseFloat((await (0,e.httpGet)(this.url+"/public/Ticker?pair="+a,this.httpRequestTimeout,b)).result[a].c[0])}async fetchUsdPrice(a){return parseFloat((await (0,e.httpGet)(this.url+"/public/Ticker?pair=XBTUSDC",this.httpRequestTimeout,a)).result.XBTUSDC.c[0])/1e8}async fetchPrice(a,b){let c=a.coinId.split(";"),d=await (0,e.httpGet)(this.url+"/public/Ticker?pair="+c.map(a=>a.startsWith("!")?a.substring(1):a).join(","),this.httpRequestTimeout,b);return BigInt(Math.floor(1e14*c.map(a=>{let b=a.startsWith("!");b&&(a=a.substring(1));let c=parseFloat(d.result[a].c[0]);return b?1/c:c}).reduce((a,b)=>a*b,1)))}}c.KrakenPriceProvider=f},194941,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.RedundantSwapPrice=void 0;let d=a.r(443354),e=a.r(145001),f=a.r(96360),g=a.r(573547),h=a.r(213144),i=a.r(661064),j=a.r(570536),k=a.r(547621),l=(0,h.getLogger)("RedundantSwapPrice: ");class m extends i.ICachedSwapPrice{static createFromTokenMap(a,b,c){let h=[new d.BinancePriceProvider(b.map(a=>({coinId:a.binancePair,chains:a.chains}))),new e.OKXPriceProvider(b.map(a=>({coinId:a.okxPair,chains:a.chains}))),new f.CoinGeckoPriceProvider(b.map(a=>({coinId:a.coinGeckoCoinId,chains:a.chains}))),new g.CoinPaprikaPriceProvider(b.map(a=>({coinId:a.coinPaprikaCoinId,chains:a.chains}))),new k.KrakenPriceProvider(b.map(a=>({coinId:a.krakenPair,chains:a.chains})))];return new m(a,b,h,c)}constructor(a,b,c,d){for(let c of(super(a,d),this.coinsDecimals={},b))for(let a in c.chains){let{address:b,decimals:d}=c.chains[a];this.coinsDecimals[a]??={},this.coinsDecimals[a][b.toString()]=d}this.priceApis=c.map(a=>({priceApi:a,operational:null}))}getOperationalPriceApi(){return this.priceApis.find(a=>!0===a.operational)}getMaybeOperationalPriceApis(){let a=this.priceApis.filter(a=>!0===a.operational||null===a.operational);return 0===a.length&&(this.priceApis.forEach(a=>a.operational=null),a=this.priceApis),a}async fetchPriceFromMaybeOperationalPriceApis(a,b,c){try{return await (0,h.promiseAny)(this.getMaybeOperationalPriceApis().map(d=>(async()=>{try{let e=await d.priceApi.getPrice(a,b,c);return l.debug("fetchPrice(): Price from "+d.priceApi.constructor.name+": ",e.toString(10)),d.operational=!0,e}catch(a){throw null!=c&&c.throwIfAborted(),d.operational=!1,a}})()))}catch(a){throw null!=c&&c.throwIfAborted(),a.find(a=>!(a instanceof j.RequestError))||a[0]}}fetchPrice(a,b,c){return(0,h.tryWithRetries)(async()=>{let d=this.getOperationalPriceApi();if(null!=d)try{return await d.priceApi.getPrice(a,b,c)}catch(a){null!=c&&c.throwIfAborted(),d.operational=!1}return await this.fetchPriceFromMaybeOperationalPriceApis(a,b,c)},null,j.RequestError,c)}getDecimals(a,b){return null==this.coinsDecimals[a]?null:this.coinsDecimals[a][b.toString()]}async fetchUsdPriceFromMaybeOperationalPriceApis(a){try{return await (0,h.promiseAny)(this.getMaybeOperationalPriceApis().map(b=>(async()=>{try{let c=await b.priceApi.getUsdPrice(a);return l.debug("fetchPrice(): USD price from "+b.priceApi.constructor.name+": ",c.toString(10)),b.operational=!0,c}catch(c){throw null!=a&&a.throwIfAborted(),b.operational=!1,c}})()))}catch(b){throw null!=a&&a.throwIfAborted(),b.find(a=>!(a instanceof j.RequestError))||b[0]}}fetchUsdPrice(a){return(0,h.tryWithRetries)(()=>{let b=this.getOperationalPriceApi();return null!=b?b.priceApi.getUsdPrice(a).catch(c=>(null!=a&&a.throwIfAborted(),b.operational=!1,this.fetchUsdPriceFromMaybeOperationalPriceApis(a))):this.fetchUsdPriceFromMaybeOperationalPriceApis(a)},null,j.RequestError,a)}}c.RedundantSwapPrice=m},689056,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SingleSwapPrice=void 0;let d=a.r(661064);class e extends d.ICachedSwapPrice{constructor(a,b,c){super(a,c),this.priceProvider=b}fetchPrice(a,b,c){return this.priceProvider.getPrice(a,b,c)}getDecimals(a,b){return this.priceProvider.getDecimals(a,b.toString())}fetchUsdPrice(a){return this.priceProvider.getUsdPrice(a)}}c.SingleSwapPrice=e},356603,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SwapPriceWithChain=void 0,c.SwapPriceWithChain=class{constructor(a,b){this.swapPrice=a,this.chainIdentifier=b}async isValidAmountSend(a,b,c,d,e,f,g){return this.swapPrice.isValidAmountSend(this.chainIdentifier,a,b,c,d,e,f,g)}async isValidAmountReceive(a,b,c,d,e,f,g){return this.swapPrice.isValidAmountReceive(this.chainIdentifier,a,b,c,d,e,f,g)}preFetchPrice(a,b){return this.swapPrice.preFetchPrice(this.chainIdentifier,a,b)}preFetchUsdPrice(a){return this.swapPrice.preFetchUsdPrice(a)}async getFromBtcSwapAmount(a,b,c,d){return this.swapPrice.getFromBtcSwapAmount(this.chainIdentifier,a,b,c,d)}async getToBtcSwapAmount(a,b,c,d){return this.swapPrice.getToBtcSwapAmount(this.chainIdentifier,a,b,c,d)}shouldIgnore(a){return this.swapPrice.shouldIgnore(this.chainIdentifier,a)}async getBtcUsdValue(a,b,c){return this.swapPrice.getBtcUsdValue(a,b,c)}async getTokenUsdValue(a,b,c,d){return this.swapPrice.getTokenUsdValue(this.chainIdentifier,a,b,c,d)}getUsdValue(a,b,c,d){return this.swapPrice.getUsdValue(a,b,c,d)}}},294982,(a,b,c)=>{"use strict";function d(a){return"object"==typeof a&&"BTC"===a.chain&&"boolean"==typeof a.lightning&&"string"==typeof a.ticker&&"number"==typeof a.decimals&&"string"==typeof a.name}function e(a){return"object"==typeof a&&"SC"===a.chain&&"string"==typeof a.chainId&&"string"==typeof a.address&&"string"==typeof a.ticker&&"number"==typeof a.decimals&&"string"==typeof a.name}function f(a,b,c,d){if(b<=0)return a.toString(10)+"0".repeat(-b);let e=a.toString(10).padStart(b+1,"0"),f=e.length-b,g=e.substring(f,e.length),h=g.length;if(c&&h>0){for(let a=g.length-1;a--;)if("0"===g.charAt(a))h=a;else break;0===h&&(h=1)}return 0===d?e.substring(0,f):(null!=d&&h>d&&(h=d),e.substring(0,f)+"."+g.substring(0,h))}Object.defineProperty(c,"__esModule",{value:!0}),c.toTokenAmount=c.toDecimal=c.fromDecimal=c.isToken=c.isSCToken=c.BitcoinTokens=c.isBtcToken=void 0,c.isBtcToken=d,c.BitcoinTokens={BTC:{chain:"BTC",lightning:!1,ticker:"BTC",decimals:8,name:"Bitcoin (on-chain L1)"},BTCLN:{chain:"BTC",lightning:!0,ticker:"BTC",decimals:8,name:"Bitcoin (lightning L2)"}},c.isSCToken=e,c.isToken=function(a){return d(a)||e(a)},c.fromDecimal=function(a,b){if(a.includes(".")){let[c,d]=a.split(".");return b<0?BigInt(c.substring(0,c.length+b)):d.length>b?BigInt(("0"===c?"":c)+d.substring(0,b)):BigInt(("0"===c?"":c)+d.padEnd(b,"0"))}return b<0?BigInt(a.substring(0,a.length+b)):BigInt(a+"0".repeat(b))},c.toDecimal=f,c.toTokenAmount=function(a,b,c){if(null==a)return null;let d=f(a,b.decimals,void 0,b.displayDecimals);return{rawAmount:a,amount:d,_amount:parseFloat(d),token:b,usdValue:(d,e)=>c.getUsdValue(a,b,d,e),toString:()=>d+" "+b.ticker}}},890703,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SwapDirection=void 0,function(a){a[a.FROM_BTC=0]="FROM_BTC",a[a.TO_BTC=1]="TO_BTC"}(c.SwapDirection||(c.SwapDirection={}))},19763,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ISwap=c.ppmToPercentage=c.isISwapInit=void 0;let d=a.r(813954),e=a.r(427699),f=a.r(488717),g=a.r(213144),h=a.r(890703);function i(a){return"object"==typeof a&&null!=a&&(0,f.isPriceInfoType)(a.pricingInfo)&&"string"==typeof a.url&&"number"==typeof a.expiry&&"bigint"==typeof a.swapFee&&(null==a.swapFeeBtc||"bigint"==typeof a.swapFeeBtc)&&"boolean"==typeof a.exactIn}function j(a){if(null==a)return null;let b=Number(a)/1e4;return{ppm:a,decimal:Number(a)/1e6,percentage:b,toString:a=>(null!=a?b.toFixed(a):b)+"%"}}c.isISwapInit=i,c.ppmToPercentage=j,c.ISwap=class{constructor(a,b){this.currentVersion=1,this.initiated=!1,this.events=new e.EventEmitter,this.chainIdentifier=a.chainIdentifier,this.wrapper=a,i(b)?(Object.assign(this,b),this.version=this.currentVersion,this.createdAt=Date.now(),this.randomNonce=(0,g.randomBytes)(16).toString("hex")):(this.expiry=b.expiry,this.url=b.url,this.state=b.state,this.pricingInfo={isValid:b._isValid,differencePPM:null==b._differencePPM?null:BigInt(b._differencePPM),satsBaseFee:null==b._satsBaseFee?null:BigInt(b._satsBaseFee),feePPM:null==b._feePPM?null:BigInt(b._feePPM),realPriceUSatPerToken:null==b._realPriceUSatPerToken?null:BigInt(b._realPriceUSatPerToken),swapPriceUSatPerToken:null==b._swapPriceUSatPerToken?null:BigInt(b._swapPriceUSatPerToken)},this.swapFee=null==b.swapFee?null:BigInt(b.swapFee),this.swapFeeBtc=null==b.swapFeeBtc?null:BigInt(b.swapFeeBtc),this.version=b.version,this.initiated=b.initiated,this.exactIn=b.exactIn,this.createdAt=b.createdAt??b.expiry,this.randomNonce=b.randomNonce),this.version!==this.currentVersion&&this.upgradeVersion(),null==this.initiated&&(this.initiated=!0)}waitTillState(a,b="eq",c){return new Promise((d,e)=>{let f;f=c=>{("eq"===b?c.state===a:"gte"===b?c.state>=a:c.state!=a)&&(d(),this.events.removeListener("swapState",f))},this.events.on("swapState",f),null!=c&&c.addEventListener("abort",()=>{this.events.removeListener("swapState",f),e(c.reason)})})}tryRecomputeSwapPrice(){if(null==this.pricingInfo.swapPriceUSatPerToken)if(this.getDirection()===h.SwapDirection.TO_BTC){let a=this.getInput();this.pricingInfo=this.wrapper.prices.recomputePriceInfoSend(this.chainIdentifier,this.getOutput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,a.rawAmount,a.token.address)}else{let a=this.getOutput();this.pricingInfo=this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier,this.getInput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,a.rawAmount,a.token.address)}}async refreshPriceData(){if(null==this.pricingInfo)return null;if(this.getDirection()===h.SwapDirection.TO_BTC){let a=this.getInput();this.pricingInfo=await this.wrapper.prices.isValidAmountSend(this.chainIdentifier,this.getOutput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,a.rawAmount,a.token.address)}else{let a=this.getOutput();this.pricingInfo=await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier,this.getInput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,a.rawAmount,a.token.address)}}hasValidPrice(){return null==this.pricingInfo?null:this.pricingInfo.isValid}getPriceInfo(){let a=this.getDirection()===h.SwapDirection.TO_BTC?1e14/Number(this.pricingInfo.swapPriceUSatPerToken):Number(this.pricingInfo.swapPriceUSatPerToken)/1e14;return{marketPrice:this.getDirection()===h.SwapDirection.TO_BTC?1e14/Number(this.pricingInfo.realPriceUSatPerToken):Number(this.pricingInfo.swapPriceUSatPerToken)/1e14,swapPrice:a,difference:j(this.pricingInfo.differencePPM)}}checkSigner(a){if(("string"==typeof a?a:a.getAddress())!==this._getInitiator())throw Error("Invalid signer provided!")}isInitiated(){return this.initiated}_setInitiated(){this.initiated=!0}getQuoteExpiry(){return this.expiry}getType(){return this.TYPE}getDirection(){return this.TYPE===d.SwapType.TO_BTC||this.TYPE===d.SwapType.TO_BTCLN?h.SwapDirection.TO_BTC:h.SwapDirection.FROM_BTC}getState(){return this.state}serialize(){return null==this.pricingInfo?{}:{id:this.getId(),type:this.getType(),escrowHash:this._getEscrowHash(),initiator:this._getInitiator(),_isValid:this.pricingInfo.isValid,_differencePPM:null==this.pricingInfo.differencePPM?null:this.pricingInfo.differencePPM.toString(10),_satsBaseFee:null==this.pricingInfo.satsBaseFee?null:this.pricingInfo.satsBaseFee.toString(10),_feePPM:null==this.pricingInfo.feePPM?null:this.pricingInfo.feePPM.toString(10),_realPriceUSatPerToken:null==this.pricingInfo.realPriceUSatPerToken?null:this.pricingInfo.realPriceUSatPerToken.toString(10),_swapPriceUSatPerToken:null==this.pricingInfo.swapPriceUSatPerToken?null:this.pricingInfo.swapPriceUSatPerToken.toString(10),state:this.state,url:this.url,swapFee:null==this.swapFee?null:this.swapFee.toString(10),swapFeeBtc:null==this.swapFeeBtc?null:this.swapFeeBtc.toString(10),expiry:this.expiry,version:this.version,initiated:this.initiated,exactIn:this.exactIn,createdAt:this.createdAt,randomNonce:this.randomNonce}}_save(){return this.isQuoteExpired()?this.wrapper.removeSwapData(this):this.wrapper.saveSwapData(this)}async _saveAndEmit(a){null!=a&&(this.state=a),await this._save(),this._emitEvent()}_emitEvent(){this.wrapper.events.emit("swapState",this),this.events.emit("swapState",this)}}},224458,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0})},366927,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ISwapWrapper=void 0;let d=a.r(427699),e=a.r(974727),f=a.r(213144);c.ISwapWrapper=class{constructor(a,b,c,e,g,h,i,j){for(let k of(this.logger=(0,f.getLogger)(this.constructor.name+": "),this.pendingSwaps=new Map,this.isInitialized=!1,this.tickInterval=null,this.unifiedStorage=b,this.unifiedChainEvents=c,this.chainIdentifier=a,this.chain=e,this.prices=g,this.events=j||new d.EventEmitter,this.options=i,this.tokens={},h)){let b=k.chains[a];null!=b&&(this.tokens[b.address]={chain:"SC",chainId:this.chainIdentifier,address:b.address,decimals:b.decimals,ticker:k.ticker,name:k.name,displayDecimals:b.displayDecimals})}}preFetchPrice(a,b){return this.prices.preFetchPrice(this.chainIdentifier,a.token,b).catch(a=>(this.logger.error("preFetchPrice(): Error: ",a),null))}async verifyReturnedPrice(a,b,c,d,f,g,h=Promise.resolve(null),i){let j=BigInt(a.swapBaseFee),k=BigInt(a.swapFeePPM);b&&(d-=g.networkFee);let l=await (b?this.prices.isValidAmountSend(this.chainIdentifier,c,j,k,d,f,i,await h):this.prices.isValidAmountReceive(this.chainIdentifier,c,j,k,d,f,i,await h));if(!l.isValid)throw new e.IntermediaryError("Fee too high");return l}async init(a=!1,b=!1){if(this.isInitialized)return;let c=null!=this.processEvent,d=[];if(c&&this.unifiedChainEvents.registerListener(this.TYPE,(a,b)=>(d.push({event:a,swap:b}),Promise.resolve()),this.swapDeserializer.bind(null,this)),b||await this.checkPastSwaps(),c){for(let a of d)await this.processEvent(a.event,a.swap);this.unifiedChainEvents.unregisterListener(this.TYPE),this.unifiedChainEvents.registerListener(this.TYPE,this.processEvent.bind(this),this.swapDeserializer.bind(null,this))}a||this.startTickInterval(),this.isInitialized=!0}startTickInterval(){null!=this.tickSwapState&&0!==this.tickSwapState.length&&(this.tickInterval=setInterval(()=>{this.tick()},1e3))}async checkPastSwaps(a){null==a&&(a=await this.unifiedStorage.query([[{key:"type",value:this.TYPE},{key:"state",value:this.pendingSwapStates}]],a=>new this.swapDeserializer(this,a)));let b=[],c=[];await Promise.all(a.map(a=>a._sync(!1).then(d=>{a.isQuoteExpired()?(c.push(a),this.logger.debug("init(): Removing expired swap: "+a.getId())):d&&b.push(a)}).catch(b=>this.logger.error("init(): Error when checking swap "+a.getId()+": ",b)))),await this.unifiedStorage.removeAll(c),await this.unifiedStorage.saveAll(b)}async tick(a){for(let b of(null==a&&(a=await this.unifiedStorage.query([[{key:"type",value:this.TYPE},{key:"state",value:this.tickSwapState}]],a=>new this.swapDeserializer(this,a))),this.pendingSwaps.values())){let a=b.deref();null!=a&&a._tick(!0)}a.forEach(a=>{a._tick(!0)})}saveSwapData(a){return a.isInitiated()?(this.pendingSwaps.delete(a.getId()),this.unifiedStorage.save(a)):(this.logger.debug("saveSwapData(): Swap "+a.getId()+" not initiated, saving to pending swaps"),this.pendingSwaps.set(a.getId(),new WeakRef(a)),Promise.resolve())}removeSwapData(a){return(this.pendingSwaps.delete(a.getId()),a.isInitiated())?this.unifiedStorage.remove(a):Promise.resolve()}async stop(){this.isInitialized=!1,this.unifiedChainEvents.unregisterListener(this.TYPE),this.logger.info("stop(): Swap wrapper stopped"),null!=this.tickInterval&&clearInterval(this.tickInterval)}getNativeToken(){return this.tokens[this.chain.getNativeCurrencyAddress()]}}},659437,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.hmac=c.HMAC=void 0;let d=a.r(571420);class e extends d.Hash{constructor(a,b){super(),this.finished=!1,this.destroyed=!1,(0,d.ahash)(a);let c=(0,d.toBytes)(b);if(this.iHash=a.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let e=this.blockLen,f=new Uint8Array(e);f.set(c.length>e?a.create().update(c).digest():c);for(let a=0;a<f.length;a++)f[a]^=54;this.iHash.update(f),this.oHash=a.create();for(let a=0;a<f.length;a++)f[a]^=106;this.oHash.update(f),(0,d.clean)(f)}update(a){return(0,d.aexists)(this),this.iHash.update(a),this}digestInto(a){(0,d.aexists)(this),(0,d.abytes)(a,this.outputLen),this.finished=!0,this.iHash.digestInto(a),this.oHash.update(a),this.oHash.digestInto(a),this.destroy()}digest(){let a=new Uint8Array(this.oHash.outputLen);return this.digestInto(a),a}_cloneInto(a){a||(a=Object.create(Object.getPrototypeOf(this),{}));let{oHash:b,iHash:c,finished:d,destroyed:e,blockLen:f,outputLen:g}=this;return a.finished=d,a.destroyed=e,a.blockLen=f,a.outputLen=g,a.oHash=b._cloneInto(a.oHash),a.iHash=c._cloneInto(a.iHash),a}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}c.HMAC=e,c.hmac=(a,b,c)=>new e(a,b).update(c).digest(),c.hmac.create=(a,b)=>new e(a,b)},999619,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.notImplemented=c.bitMask=c.utf8ToBytes=c.randomBytes=c.isBytes=c.hexToBytes=c.concatBytes=c.bytesToUtf8=c.bytesToHex=c.anumber=c.abytes=void 0,c.abool=function(a,b){if("boolean"!=typeof b)throw Error(a+" boolean expected, got "+b)},c._abool2=function(a,b=""){if("boolean"!=typeof a)throw Error((b&&`"${b}"`)+"expected boolean, got type="+typeof a);return a},c._abytes2=function(a,b,c=""){let e=(0,d.isBytes)(a),f=a?.length,g=void 0!==b;if(!e||g&&f!==b)throw Error((c&&`"${c}" `)+"expected Uint8Array"+(g?` of length ${b}`:"")+", got "+(e?`length=${f}`:`type=${typeof a}`));return a},c.numberToHexUnpadded=h,c.hexToNumber=i,c.bytesToNumberBE=function(a){return i((0,d.bytesToHex)(a))},c.bytesToNumberLE=function(a){return(0,d.abytes)(a),i((0,d.bytesToHex)(Uint8Array.from(a).reverse()))},c.numberToBytesBE=j,c.numberToBytesLE=function(a,b){return j(a,b).reverse()},c.numberToVarBytesBE=function(a){return(0,d.hexToBytes)(h(a))},c.ensureBytes=function(a,b,c){let e;if("string"==typeof b)try{e=(0,d.hexToBytes)(b)}catch(b){throw Error(a+" must be hex string or Uint8Array, cause: "+b)}else if((0,d.isBytes)(b))e=Uint8Array.from(b);else throw Error(a+" must be hex string or Uint8Array");let f=e.length;if("number"==typeof c&&f!==c)throw Error(a+" of length "+c+" expected, got "+f);return e},c.equalBytes=function(a,b){if(a.length!==b.length)return!1;let c=0;for(let d=0;d<a.length;d++)c|=a[d]^b[d];return 0===c},c.copyBytes=function(a){return Uint8Array.from(a)},c.asciiToBytes=function(a){return Uint8Array.from(a,(b,c)=>{let d=b.charCodeAt(0);if(1!==b.length||d>127)throw Error(`string contains non-ASCII character "${a[c]}" with code ${d} at position ${c}`);return d})},c.inRange=l,c.aInRange=function(a,b,c,d){if(!l(b,c,d))throw Error("expected valid "+a+": "+c+" <= n < "+d+", got "+b)},c.bitLen=function(a){let b;for(b=0;a>f;a>>=g,b+=1);return b},c.bitGet=function(a,b){return a>>BigInt(b)&g},c.bitSet=function(a,b,c){return a|(c?g:f)<<BigInt(b)},c.createHmacDrbg=function(a,b,c){if("number"!=typeof a||a<2)throw Error("hashLen must be a number");if("number"!=typeof b||b<2)throw Error("qByteLen must be a number");if("function"!=typeof c)throw Error("hmacFn must be a function");let e=a=>new Uint8Array(a),f=a=>Uint8Array.of(a),g=e(a),h=e(a),i=0,j=()=>{g.fill(1),h.fill(0),i=0},k=(...a)=>c(h,g,...a),l=(a=e(0))=>{h=k(f(0),a),g=k(),0!==a.length&&(h=k(f(1),a),g=k())},m=()=>{if(i++>=1e3)throw Error("drbg: tried 1000 values");let a=0,c=[];for(;a<b;){let b=(g=k()).slice();c.push(b),a+=g.length}return(0,d.concatBytes)(...c)};return(a,b)=>{let c;for(j(),l(a);!(c=b(m()));)l();return j(),c}},c.validateObject=function(a,b,c={}){let d=(b,c,d)=>{let e=m[c];if("function"!=typeof e)throw Error("invalid validator function");let f=a[b];if((!d||void 0!==f)&&!e(f,a))throw Error("param "+String(b)+" is invalid. Expected "+c+", got "+f)};for(let[a,c]of Object.entries(b))d(a,c,!1);for(let[a,b]of Object.entries(c))d(a,b,!0);return a},c.isHash=function(a){return"function"==typeof a&&Number.isSafeInteger(a.outputLen)},c._validateObject=function(a,b,c={}){if(!a||"object"!=typeof a)throw Error("expected valid options object");function d(b,c,d){let e=a[b];if(d&&void 0===e)return;let f=typeof e;if(f!==c||null===e)throw Error(`param "${b}" is invalid: expected ${c}, got ${f}`)}Object.entries(b).forEach(([a,b])=>d(a,b,!1)),Object.entries(c).forEach(([a,b])=>d(a,b,!0))},c.memoized=function(a){let b=new WeakMap;return(c,...d)=>{let e=b.get(c);if(void 0!==e)return e;let f=a(c,...d);return b.set(c,f),f}};let d=a.r(571420);var e=a.r(571420);Object.defineProperty(c,"abytes",{enumerable:!0,get:function(){return e.abytes}}),Object.defineProperty(c,"anumber",{enumerable:!0,get:function(){return e.anumber}}),Object.defineProperty(c,"bytesToHex",{enumerable:!0,get:function(){return e.bytesToHex}}),Object.defineProperty(c,"bytesToUtf8",{enumerable:!0,get:function(){return e.bytesToUtf8}}),Object.defineProperty(c,"concatBytes",{enumerable:!0,get:function(){return e.concatBytes}}),Object.defineProperty(c,"hexToBytes",{enumerable:!0,get:function(){return e.hexToBytes}}),Object.defineProperty(c,"isBytes",{enumerable:!0,get:function(){return e.isBytes}}),Object.defineProperty(c,"randomBytes",{enumerable:!0,get:function(){return e.randomBytes}}),Object.defineProperty(c,"utf8ToBytes",{enumerable:!0,get:function(){return e.utf8ToBytes}});let f=BigInt(0),g=BigInt(1);function h(a){let b=a.toString(16);return 1&b.length?"0"+b:b}function i(a){if("string"!=typeof a)throw Error("hex string expected, got "+typeof a);return""===a?f:BigInt("0x"+a)}function j(a,b){return(0,d.hexToBytes)(a.toString(16).padStart(2*b,"0"))}let k=a=>"bigint"==typeof a&&f<=a;function l(a,b,c){return k(a)&&k(b)&&k(c)&&b<=a&&a<c}c.bitMask=a=>(g<<BigInt(a))-g;let m={bigint:a=>"bigint"==typeof a,function:a=>"function"==typeof a,boolean:a=>"boolean"==typeof a,string:a=>"string"==typeof a,stringOrUint8Array:a=>"string"==typeof a||(0,d.isBytes)(a),isSafeInteger:a=>Number.isSafeInteger(a),array:a=>Array.isArray(a),field:(a,b)=>b.Fp.isValid(a),hash:a=>"function"==typeof a&&Number.isSafeInteger(a.outputLen)};c.notImplemented=()=>{throw Error("not implemented")}},311351,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.isNegativeLE=void 0,c.mod=o,c.pow=function(a,b,c){return w(A(c),a,b)},c.pow2=function(a,b,c){let d=a;for(;b-- >e;)d*=d,d%=c;return d},c.invert=p,c.tonelliShanks=t,c.FpSqrt=u,c.validateField=function(a){let b=v.reduce((a,b)=>(a[b]="function",a),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,d._validateObject)(a,b),a},c.FpPow=w,c.FpInvertBatch=x,c.FpDiv=function(a,b,c){return a.mul(b,"bigint"==typeof c?p(c,a.ORDER):a.inv(c))},c.FpLegendre=y,c.FpIsSquare=function(a,b){return 1===y(a,b)},c.nLength=z,c.Field=A,c.FpSqrtOdd=function(a,b){if(!a.isOdd)throw Error("Field doesn't have isOdd");let c=a.sqrt(b);return a.isOdd(c)?c:a.neg(c)},c.FpSqrtEven=function(a,b){if(!a.isOdd)throw Error("Field doesn't have isOdd");let c=a.sqrt(b);return a.isOdd(c)?a.neg(c):c},c.hashToPrivateScalar=function(a,b,c=!1){let e=(a=(0,d.ensureBytes)("privateHash",a)).length,g=z(b).nByteLength+8;if(g<24||e<g||e>1024)throw Error("hashToPrivateScalar: expected "+g+"-1024 bytes of input, got "+e);return o(c?(0,d.bytesToNumberLE)(a):(0,d.bytesToNumberBE)(a),b-f)+f},c.getFieldBytesLength=B,c.getMinHashLength=C,c.mapHashToField=function(a,b,c=!1){let e=a.length,g=B(b),h=C(b);if(e<16||e<h||e>1024)throw Error("expected "+h+"-1024 bytes of input, got "+e);let i=o(c?(0,d.bytesToNumberLE)(a):(0,d.bytesToNumberBE)(a),b-f)+f;return c?(0,d.numberToBytesLE)(i,g):(0,d.numberToBytesBE)(i,g)};let d=a.r(999619),e=BigInt(0),f=BigInt(1),g=BigInt(2),h=BigInt(3),i=BigInt(4),j=BigInt(5),k=BigInt(7),l=BigInt(8),m=BigInt(9),n=BigInt(16);function o(a,b){let c=a%b;return c>=e?c:b+c}function p(a,b){if(a===e)throw Error("invert: expected non-zero number");if(b<=e)throw Error("invert: expected positive modulus, got "+b);let c=o(a,b),d=b,g=e,h=f,i=f,j=e;for(;c!==e;){let a=d/c,b=d%c,e=g-i*a,f=h-j*a;d=c,c=b,g=i,h=j,i=e,j=f}if(d!==f)throw Error("invert: does not exist");return o(g,b)}function q(a,b,c){if(!a.eql(a.sqr(b),c))throw Error("Cannot find square root")}function r(a,b){let c=(a.ORDER+f)/i,d=a.pow(b,c);return q(a,d,b),d}function s(a,b){let c=(a.ORDER-j)/l,d=a.mul(b,g),e=a.pow(d,c),f=a.mul(b,e),h=a.mul(a.mul(f,g),e),i=a.mul(f,a.sub(h,a.ONE));return q(a,i,b),i}function t(a){if(a<h)throw Error("sqrt is not defined for small field");let b=a-f,c=0;for(;b%g===e;)b/=g,c++;let d=g,i=A(a);for(;1===y(i,d);)if(d++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===c)return r;let j=i.pow(d,b),k=(b+f)/g;return function(a,d){if(a.is0(d))return d;if(1!==y(a,d))throw Error("Cannot find square root");let e=c,g=a.mul(a.ONE,j),h=a.pow(d,b),i=a.pow(d,k);for(;!a.eql(h,a.ONE);){if(a.is0(h))return a.ZERO;let b=1,c=a.sqr(h);for(;!a.eql(c,a.ONE);)if(b++,c=a.sqr(c),b===e)throw Error("Cannot find square root");let d=f<<BigInt(e-b-1),j=a.pow(g,d);e=b,g=a.sqr(j),h=a.mul(h,g),i=a.mul(i,j)}return i}}function u(a){return a%i===h?r:a%l===j?s:a%n===m?function(a){let b=A(a),c=t(a),d=c(b,b.neg(b.ONE)),e=c(b,d),f=c(b,b.neg(d)),g=(a+k)/n;return(a,b)=>{let c=a.pow(b,g),h=a.mul(c,d),i=a.mul(c,e),j=a.mul(c,f),k=a.eql(a.sqr(h),b),l=a.eql(a.sqr(i),b);c=a.cmov(c,h,k),h=a.cmov(j,i,l);let m=a.eql(a.sqr(h),b),n=a.cmov(c,h,m);return q(a,n,b),n}}(a):t(a)}c.isNegativeLE=(a,b)=>(o(a,b)&f)===f;let v=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function w(a,b,c){if(c<e)throw Error("invalid exponent, negatives unsupported");if(c===e)return a.ONE;if(c===f)return b;let d=a.ONE,g=b;for(;c>e;)c&f&&(d=a.mul(d,g)),g=a.sqr(g),c>>=f;return d}function x(a,b,c=!1){let d=Array(b.length).fill(c?a.ZERO:void 0),e=b.reduce((b,c,e)=>a.is0(c)?b:(d[e]=b,a.mul(b,c)),a.ONE),f=a.inv(e);return b.reduceRight((b,c,e)=>a.is0(c)?b:(d[e]=a.mul(b,d[e]),a.mul(b,c)),f),d}function y(a,b){let c=(a.ORDER-f)/g,d=a.pow(b,c),e=a.eql(d,a.ONE),h=a.eql(d,a.ZERO),i=a.eql(d,a.neg(a.ONE));if(!e&&!h&&!i)throw Error("invalid Legendre symbol result");return e?1:h?0:-1}function z(a,b){void 0!==b&&(0,d.anumber)(b);let c=void 0!==b?b:a.toString(2).length,e=Math.ceil(c/8);return{nBitLength:c,nByteLength:e}}function A(a,b,c=!1,g={}){let h,i,j,k;if(a<=e)throw Error("invalid field: expected ORDER > 0, got "+a);let l=!1;if("object"==typeof b&&null!=b){if(g.sqrt||c)throw Error("cannot specify opts in two arguments");b.BITS&&(i=b.BITS),b.sqrt&&(j=b.sqrt),"boolean"==typeof b.isLE&&(c=b.isLE),"boolean"==typeof b.modFromBytes&&(l=b.modFromBytes),k=b.allowedLengths}else"number"==typeof b&&(i=b),g.sqrt&&(j=g.sqrt);let{nBitLength:m,nByteLength:n}=z(a,i);if(n>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let q=Object.freeze({ORDER:a,isLE:c,BITS:m,BYTES:n,MASK:(0,d.bitMask)(m),ZERO:e,ONE:f,allowedLengths:k,create:b=>o(b,a),isValid:b=>{if("bigint"!=typeof b)throw Error("invalid field element: expected bigint, got "+typeof b);return e<=b&&b<a},is0:a=>a===e,isValidNot0:a=>!q.is0(a)&&q.isValid(a),isOdd:a=>(a&f)===f,neg:b=>o(-b,a),eql:(a,b)=>a===b,sqr:b=>o(b*b,a),add:(b,c)=>o(b+c,a),sub:(b,c)=>o(b-c,a),mul:(b,c)=>o(b*c,a),pow:(a,b)=>w(q,a,b),div:(b,c)=>o(b*p(c,a),a),sqrN:a=>a*a,addN:(a,b)=>a+b,subN:(a,b)=>a-b,mulN:(a,b)=>a*b,inv:b=>p(b,a),sqrt:j||(b=>(h||(h=u(a)),h(q,b))),toBytes:a=>c?(0,d.numberToBytesLE)(a,n):(0,d.numberToBytesBE)(a,n),fromBytes:(b,e=!0)=>{if(k){if(!k.includes(b.length)||b.length>n)throw Error("Field.fromBytes: expected "+k+" bytes, got "+b.length);let a=new Uint8Array(n);a.set(b,c?0:a.length-b.length),b=a}if(b.length!==n)throw Error("Field.fromBytes: expected "+n+" bytes, got "+b.length);let f=c?(0,d.bytesToNumberLE)(b):(0,d.bytesToNumberBE)(b);if(l&&(f=o(f,a)),!e&&!q.isValid(f))throw Error("invalid field element: outside of range 0..ORDER");return f},invertBatch:a=>x(q,a),cmov:(a,b,c)=>c?b:a});return Object.freeze(q)}function B(a){if("bigint"!=typeof a)throw Error("field order must be bigint");return Math.ceil(a.toString(2).length/8)}function C(a){let b=B(a);return b+Math.ceil(b/2)}},915670,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.wNAF=void 0,c.negateCt=h,c.normalizeZ=function(a,b){let c=(0,e.FpInvertBatch)(a.Fp,b.map(a=>a.Z));return b.map((b,d)=>a.fromAffine(b.toAffine(c[d])))},c.mulEndoUnsafe=function(a,b,c,d){let e=b,h=a.ZERO,i=a.ZERO;for(;c>f||d>f;)c&g&&(h=h.add(e)),d&g&&(i=i.add(e)),e=e.double(),c>>=g,d>>=g;return{p1:h,p2:i}},c.pippenger=function(a,b,c,e){l(c,a),m(e,b);let f=c.length,g=e.length;if(f!==g)throw Error("arrays of points and scalars must have equal length");let h=a.ZERO,i=(0,d.bitLen)(BigInt(f)),j=1;i>12?j=i-3:i>4?j=i-2:i>0&&(j=2);let k=(0,d.bitMask)(j),n=Array(Number(k)+1).fill(h),o=Math.floor((b.BITS-1)/j)*j,p=h;for(let a=o;a>=0;a-=j){n.fill(h);for(let b=0;b<g;b++){let d=Number(e[b]>>BigInt(a)&k);n[d]=n[d].add(c[b])}let b=h;for(let a=n.length-1,c=h;a>0;a--)c=c.add(n[a]),b=b.add(c);if(p=p.add(b),0!==a)for(let a=0;a<j;a++)p=p.double()}return p},c.precomputeMSMUnsafe=function(a,b,c,e){i(e,b.BITS),l(c,a);let f=a.ZERO,g=2**e-1,h=Math.ceil(b.BITS/e),j=(0,d.bitMask)(e),k=c.map(a=>{let b=[];for(let c=0,d=a;c<g;c++)b.push(d),d=d.add(a);return b});return a=>{if(m(a,b),a.length>c.length)throw Error("array of scalars must be smaller than array of points");let d=f;for(let b=0;b<h;b++){if(d!==f)for(let a=0;a<e;a++)d=d.double();let c=BigInt(h*e-(b+1)*e);for(let b=0;b<a.length;b++){let e=Number(a[b]>>c&j);e&&(d=d.add(k[b][e-1]))}}return d}},c.validateBasic=function(a){return(0,e.validateField)(a.Fp),(0,d.validateObject)(a,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,e.nLength)(a.n,a.nBitLength),...a,...{p:a.Fp.ORDER}})},c._createCurveFields=function(a,b,c={},d){if(void 0===d&&(d="edwards"===a),!b||"object"!=typeof b)throw Error(`expected valid ${a} CURVE object`);for(let a of["p","n","h"]){let c=b[a];if(!("bigint"==typeof c&&c>f))throw Error(`CURVE.${a} must be positive bigint`)}let e=r(b.p,c.Fp,d),g=r(b.n,c.Fn,d);for(let c of["Gx","Gy","a","weierstrass"===a?"b":"d"])if(!e.isValid(b[c]))throw Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return{CURVE:b=Object.freeze(Object.assign({},b)),Fp:e,Fn:g}};let d=a.r(999619),e=a.r(311351),f=BigInt(0),g=BigInt(1);function h(a,b){let c=b.negate();return a?c:b}function i(a,b){if(!Number.isSafeInteger(a)||a<=0||a>b)throw Error("invalid window size, expected [1.."+b+"], got W="+a)}function j(a,b){i(a,b);let c=Math.ceil(b/a)+1,e=2**(a-1),f=2**a;return{windows:c,windowSize:e,mask:(0,d.bitMask)(a),maxNumber:f,shiftBy:BigInt(a)}}function k(a,b,c){let{windowSize:d,mask:e,maxNumber:f,shiftBy:h}=c,i=Number(a&e),j=a>>h;i>d&&(i-=f,j+=g);let k=b*d,l=k+Math.abs(i)-1,m=0===i;return{nextN:j,offset:l,isZero:m,isNeg:i<0,isNegF:b%2!=0,offsetF:k}}function l(a,b){if(!Array.isArray(a))throw Error("array expected");a.forEach((a,c)=>{if(!(a instanceof b))throw Error("invalid point at index "+c)})}function m(a,b){if(!Array.isArray(a))throw Error("array of scalars expected");a.forEach((a,c)=>{if(!b.isValid(a))throw Error("invalid scalar at index "+c)})}let n=new WeakMap,o=new WeakMap;function p(a){return o.get(a)||1}function q(a){if(a!==f)throw Error("invalid wNAF")}function r(a,b,c){if(!b)return(0,e.Field)(a,{isLE:c});if(b.ORDER!==a)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,e.validateField)(b),b}c.wNAF=class{constructor(a,b){this.BASE=a.BASE,this.ZERO=a.ZERO,this.Fn=a.Fn,this.bits=b}_unsafeLadder(a,b,c=this.ZERO){let d=a;for(;b>f;)b&g&&(c=c.add(d)),d=d.double(),b>>=g;return c}precomputeWindow(a,b){let{windows:c,windowSize:d}=j(b,this.bits),e=[],f=a,g=f;for(let a=0;a<c;a++){g=f,e.push(g);for(let a=1;a<d;a++)g=g.add(f),e.push(g);f=g.double()}return e}wNAF(a,b,c){if(!this.Fn.isValid(c))throw Error("invalid scalar");let d=this.ZERO,e=this.BASE,f=j(a,this.bits);for(let a=0;a<f.windows;a++){let{nextN:g,offset:i,isZero:j,isNeg:l,isNegF:m,offsetF:n}=k(c,a,f);c=g,j?e=e.add(h(m,b[n])):d=d.add(h(l,b[i]))}return q(c),{p:d,f:e}}wNAFUnsafe(a,b,c,d=this.ZERO){let e=j(a,this.bits);for(let a=0;a<e.windows&&c!==f;a++){let{nextN:f,offset:g,isZero:h,isNeg:i}=k(c,a,e);if(c=f,!h){let a=b[g];d=d.add(i?a.negate():a)}}return q(c),d}getPrecomputes(a,b,c){let d=n.get(b);return d||(d=this.precomputeWindow(b,a),1!==a&&("function"==typeof c&&(d=c(d)),n.set(b,d))),d}cached(a,b,c){let d=p(a);return this.wNAF(d,this.getPrecomputes(d,a,c),b)}unsafe(a,b,c,d){let e=p(a);return 1===e?this._unsafeLadder(a,b,d):this.wNAFUnsafe(e,this.getPrecomputes(e,a,c),b,d)}createCache(a,b){i(b,this.bits),o.set(a,b),n.delete(a)}hasCache(a){return 1!==p(a)}}},55686,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.DER=c.DERErr=void 0,c._splitEndoScalar=j,c._normFnElement=s,c.weierstrassN=t,c.SWUFpSqrtRatio=v,c.mapToCurveSimpleSWU=function(a,b){(0,h.validateField)(a);let{A:c,B:d,Z:e}=b;if(!a.isValid(c)||!a.isValid(d)||!a.isValid(e))throw Error("mapToCurveSimpleSWU: invalid opts");let f=v(a,e);if(!a.isOdd)throw Error("Field does not have .isOdd()");return b=>{let g,i,j,k,l,m,n,o;g=a.sqr(b),g=a.mul(g,e),i=a.sqr(g),i=a.add(i,g),j=a.add(i,a.ONE),j=a.mul(j,d),k=a.cmov(e,a.neg(i),!a.eql(i,a.ZERO)),k=a.mul(k,c),i=a.sqr(j),m=a.sqr(k),l=a.mul(m,c),i=a.add(i,l),i=a.mul(i,j),m=a.mul(m,k),l=a.mul(m,d),i=a.add(i,l),n=a.mul(g,j);let{isValid:p,value:q}=f(i,m);o=a.mul(g,b),o=a.mul(o,q),n=a.cmov(n,j,p),o=a.cmov(o,q,p);let r=a.isOdd(b)===a.isOdd(o);o=a.cmov(a.neg(o),o,r);let s=(0,h.FpInvertBatch)(a,[k],!0)[0];return{x:n=a.mul(n,s),y:o}}},c.ecdh=x,c.ecdsa=y,c.weierstrassPoints=function(a){let{CURVE:b,curveOpts:c}=z(a);var d=a,e=t(b,c);let{Fp:g,Fn:h}=e,i=A(g,d.a,d.b);return Object.assign({},{CURVE:d,Point:e,ProjectivePoint:e,normPrivateKeyToScalar:a=>s(h,a),weierstrassEquation:i,isWithinCurveOrder:function(a){return(0,f.inRange)(a,o,h.ORDER)}})},c._legacyHelperEquat=A,c.weierstrass=function(a){let{CURVE:b,curveOpts:c,hash:d,ecdsaOpts:e}=function(a){let{CURVE:b,curveOpts:c}=z(a),d={hmac:a.hmac,randomBytes:a.randomBytes,lowS:a.lowS,bits2int:a.bits2int,bits2int_modN:a.bits2int_modN};return{CURVE:b,curveOpts:c,hash:a.hash,ecdsaOpts:d}}(a),f=y(t(b,c),d,e),g=f.Point;return Object.assign({},f,{ProjectivePoint:g,CURVE:Object.assign({},a,(0,h.nLength)(g.Fn.ORDER,g.Fn.BITS))})};let d=a.r(659437),e=a.r(571420),f=a.r(999619),g=a.r(915670),h=a.r(311351),i=(a,b)=>(a+(a>=0?b:-b)/p)/b;function j(a,b,c){let[[d,e],[g,h]]=b,j=i(h*a,c),k=i(-e*a,c),l=a-j*d-k*g,m=-j*e-k*h,p=l<n,q=m<n;p&&(l=-l),q&&(m=-m);let r=(0,f.bitMask)(Math.ceil((0,f.bitLen)(c)/2))+o;if(l<n||l>=r||m<n||m>=r)throw Error("splitScalar (endomorphism): failed, k="+a);return{k1neg:p,k1:l,k2neg:q,k2:m}}function k(a){if(!["compact","recovered","der"].includes(a))throw Error('Signature format must be "compact", "recovered", or "der"');return a}function l(a,b){let c={};for(let d of Object.keys(b))c[d]=void 0===a[d]?b[d]:a[d];return(0,f._abool2)(c.lowS,"lowS"),(0,f._abool2)(c.prehash,"prehash"),void 0!==c.format&&k(c.format),c}class m extends Error{constructor(a=""){super(a)}}c.DERErr=m,c.DER={Err:m,_tlv:{encode:(a,b)=>{let{Err:d}=c.DER;if(a<0||a>256)throw new d("tlv.encode: wrong tag");if(1&b.length)throw new d("tlv.encode: unpadded data");let e=b.length/2,g=(0,f.numberToHexUnpadded)(e);if(g.length/2&128)throw new d("tlv.encode: long form length too big");let h=e>127?(0,f.numberToHexUnpadded)(g.length/2|128):"";return(0,f.numberToHexUnpadded)(a)+h+g+b},decode(a,b){let{Err:d}=c.DER,e=0;if(a<0||a>256)throw new d("tlv.encode: wrong tag");if(b.length<2||b[e++]!==a)throw new d("tlv.decode: wrong tlv");let f=b[e++],g=0;if(128&f){let a=127&f;if(!a)throw new d("tlv.decode(long): indefinite length not supported");if(a>4)throw new d("tlv.decode(long): byte length is too big");let c=b.subarray(e,e+a);if(c.length!==a)throw new d("tlv.decode: length bytes not complete");if(0===c[0])throw new d("tlv.decode(long): zero leftmost byte");for(let a of c)g=g<<8|a;if(e+=a,g<128)throw new d("tlv.decode(long): not minimal encoding")}else g=f;let h=b.subarray(e,e+g);if(h.length!==g)throw new d("tlv.decode: wrong value length");return{v:h,l:b.subarray(e+g)}}},_int:{encode(a){let{Err:b}=c.DER;if(a<n)throw new b("integer: negative integers are not allowed");let d=(0,f.numberToHexUnpadded)(a);if(8&Number.parseInt(d[0],16)&&(d="00"+d),1&d.length)throw new b("unexpected DER parsing assertion: unpadded hex");return d},decode(a){let{Err:b}=c.DER;if(128&a[0])throw new b("invalid signature integer: negative");if(0===a[0]&&!(128&a[1]))throw new b("invalid signature integer: unnecessary leading zero");return(0,f.bytesToNumberBE)(a)}},toSig(a){let{Err:b,_int:d,_tlv:e}=c.DER,g=(0,f.ensureBytes)("signature",a),{v:h,l:i}=e.decode(48,g);if(i.length)throw new b("invalid signature: left bytes after parsing");let{v:j,l:k}=e.decode(2,h),{v:l,l:m}=e.decode(2,k);if(m.length)throw new b("invalid signature: left bytes after parsing");return{r:d.decode(j),s:d.decode(l)}},hexFromSig(a){let{_tlv:b,_int:d}=c.DER,e=b.encode(2,d.encode(a.r)),f=b.encode(2,d.encode(a.s));return b.encode(48,e+f)}};let n=BigInt(0),o=BigInt(1),p=BigInt(2),q=BigInt(3),r=BigInt(4);function s(a,b){let c,{BYTES:d}=a;if("bigint"==typeof b)c=b;else{let e=(0,f.ensureBytes)("private key",b);try{c=a.fromBytes(e)}catch(a){throw Error(`invalid private key: expected ui8a of size ${d}, got ${typeof b}`)}}if(!a.isValidNot0(c))throw Error("invalid private key: out of range [1..N-1]");return c}function t(a,b={}){let c=(0,g._createCurveFields)("weierstrass",a,b),{Fp:d,Fn:e}=c,h=c.CURVE,{h:i,n:k}=h;(0,f._validateObject)(b,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});let{endo:l}=b;if(l&&(!d.is0(h.a)||"bigint"!=typeof l.beta||!Array.isArray(l.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');let m=w(d,e);function p(){if(!d.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}let v=b.toBytes||function(a,b,c){let{x:e,y:g}=b.toAffine(),h=d.toBytes(e);if((0,f._abool2)(c,"isCompressed"),!c)return(0,f.concatBytes)(Uint8Array.of(4),h,d.toBytes(g));{p();let a=!d.isOdd(g);return(0,f.concatBytes)(u(a),h)}},x=b.fromBytes||function(a){(0,f._abytes2)(a,void 0,"Point");let{publicKey:b,publicKeyUncompressed:c}=m,e=a.length,g=a[0],h=a.subarray(1);if(e===b&&(2===g||3===g)){let a,b=d.fromBytes(h);if(!d.isValid(b))throw Error("bad point: is not on curve, wrong x");let c=y(b);try{a=d.sqrt(c)}catch(a){throw Error("bad point: is not on curve, sqrt error"+(a instanceof Error?": "+a.message:""))}return p(),(1&g)==1!==d.isOdd(a)&&(a=d.neg(a)),{x:b,y:a}}if(e===c&&4===g){let a=d.BYTES,b=d.fromBytes(h.subarray(0,a)),c=d.fromBytes(h.subarray(a,2*a));if(!z(b,c))throw Error("bad point: is not on curve");return{x:b,y:c}}throw Error(`bad point: got length ${e}, expected compressed=${b} or uncompressed=${c}`)};function y(a){let b=d.sqr(a),c=d.mul(b,a);return d.add(d.add(c,d.mul(a,h.a)),h.b)}function z(a,b){let c=d.sqr(b),e=y(a);return d.eql(c,e)}if(!z(h.Gx,h.Gy))throw Error("bad curve params: generator point");let A=d.mul(d.pow(h.a,q),r),B=d.mul(d.sqr(h.b),BigInt(27));if(d.is0(d.add(A,B)))throw Error("bad curve params: a or b");function C(a,b,c=!1){if(!d.isValid(b)||c&&d.is0(b))throw Error(`bad point coordinate ${a}`);return b}function D(a){if(!(a instanceof I))throw Error("ProjectivePoint expected")}function E(a){if(!l||!l.basises)throw Error("no endo");return j(a,l.basises,e.ORDER)}let F=(0,f.memoized)((a,b)=>{let{X:c,Y:e,Z:f}=a;if(d.eql(f,d.ONE))return{x:c,y:e};let g=a.is0();null==b&&(b=g?d.ONE:d.inv(f));let h=d.mul(c,b),i=d.mul(e,b),j=d.mul(f,b);if(g)return{x:d.ZERO,y:d.ZERO};if(!d.eql(j,d.ONE))throw Error("invZ was invalid");return{x:h,y:i}}),G=(0,f.memoized)(a=>{if(a.is0()){if(b.allowInfinityPoint&&!d.is0(a.Y))return;throw Error("bad point: ZERO")}let{x:c,y:e}=a.toAffine();if(!d.isValid(c)||!d.isValid(e))throw Error("bad point: x or y not field elements");if(!z(c,e))throw Error("bad point: equation left != right");if(!a.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function H(a,b,c,e,f){return c=new I(d.mul(c.X,a),c.Y,c.Z),b=(0,g.negateCt)(e,b),c=(0,g.negateCt)(f,c),b.add(c)}class I{constructor(a,b,c){this.X=C("x",a),this.Y=C("y",b,!0),this.Z=C("z",c),Object.freeze(this)}static CURVE(){return h}static fromAffine(a){let{x:b,y:c}=a||{};if(!a||!d.isValid(b)||!d.isValid(c))throw Error("invalid affine point");if(a instanceof I)throw Error("projective point not allowed");return d.is0(b)&&d.is0(c)?I.ZERO:new I(b,c,d.ONE)}static fromBytes(a){let b=I.fromAffine(x((0,f._abytes2)(a,void 0,"point")));return b.assertValidity(),b}static fromHex(a){return I.fromBytes((0,f.ensureBytes)("pointHex",a))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(a=8,b=!0){return K.createCache(this,a),b||this.multiply(q),this}assertValidity(){G(this)}hasEvenY(){let{y:a}=this.toAffine();if(!d.isOdd)throw Error("Field doesn't support isOdd");return!d.isOdd(a)}equals(a){D(a);let{X:b,Y:c,Z:e}=this,{X:f,Y:g,Z:h}=a,i=d.eql(d.mul(b,h),d.mul(f,e)),j=d.eql(d.mul(c,h),d.mul(g,e));return i&&j}negate(){return new I(this.X,d.neg(this.Y),this.Z)}double(){let{a,b}=h,c=d.mul(b,q),{X:e,Y:f,Z:g}=this,i=d.ZERO,j=d.ZERO,k=d.ZERO,l=d.mul(e,e),m=d.mul(f,f),n=d.mul(g,g),o=d.mul(e,f);return o=d.add(o,o),k=d.mul(e,g),k=d.add(k,k),i=d.mul(a,k),j=d.mul(c,n),j=d.add(i,j),i=d.sub(m,j),j=d.add(m,j),j=d.mul(i,j),i=d.mul(o,i),k=d.mul(c,k),n=d.mul(a,n),o=d.sub(l,n),o=d.mul(a,o),o=d.add(o,k),k=d.add(l,l),l=d.add(k,l),l=d.add(l,n),l=d.mul(l,o),j=d.add(j,l),n=d.mul(f,g),n=d.add(n,n),l=d.mul(n,o),i=d.sub(i,l),k=d.mul(n,m),k=d.add(k,k),new I(i,j,k=d.add(k,k))}add(a){D(a);let{X:b,Y:c,Z:e}=this,{X:f,Y:g,Z:i}=a,j=d.ZERO,k=d.ZERO,l=d.ZERO,m=h.a,n=d.mul(h.b,q),o=d.mul(b,f),p=d.mul(c,g),r=d.mul(e,i),s=d.add(b,c),t=d.add(f,g);s=d.mul(s,t),t=d.add(o,p),s=d.sub(s,t),t=d.add(b,e);let u=d.add(f,i);return t=d.mul(t,u),u=d.add(o,r),t=d.sub(t,u),u=d.add(c,e),j=d.add(g,i),u=d.mul(u,j),j=d.add(p,r),u=d.sub(u,j),l=d.mul(m,t),j=d.mul(n,r),l=d.add(j,l),j=d.sub(p,l),l=d.add(p,l),k=d.mul(j,l),p=d.add(o,o),p=d.add(p,o),r=d.mul(m,r),t=d.mul(n,t),p=d.add(p,r),r=d.sub(o,r),r=d.mul(m,r),t=d.add(t,r),o=d.mul(p,t),k=d.add(k,o),o=d.mul(u,t),j=d.mul(s,j),j=d.sub(j,o),o=d.mul(s,p),l=d.mul(u,l),new I(j,k,l=d.add(l,o))}subtract(a){return this.add(a.negate())}is0(){return this.equals(I.ZERO)}multiply(a){let c,d,{endo:f}=b;if(!e.isValidNot0(a))throw Error("invalid scalar: out of range");let h=a=>K.cached(this,a,a=>(0,g.normalizeZ)(I,a));if(f){let{k1neg:b,k1:e,k2neg:g,k2:i}=E(a),{p:j,f:k}=h(e),{p:l,f:m}=h(i);d=k.add(m),c=H(f.beta,j,l,b,g)}else{let{p:b,f:e}=h(a);c=b,d=e}return(0,g.normalizeZ)(I,[c,d])[0]}multiplyUnsafe(a){let{endo:c}=b;if(!e.isValid(a))throw Error("invalid scalar: out of range");if(a===n||this.is0())return I.ZERO;if(a===o)return this;if(K.hasCache(this))return this.multiply(a);if(!c)return K.unsafe(this,a);{let{k1neg:b,k1:d,k2neg:e,k2:f}=E(a),{p1:h,p2:i}=(0,g.mulEndoUnsafe)(I,this,d,f);return H(c.beta,h,i,b,e)}}multiplyAndAddUnsafe(a,b,c){let d=this.multiplyUnsafe(b).add(a.multiplyUnsafe(c));return d.is0()?void 0:d}toAffine(a){return F(this,a)}isTorsionFree(){let{isTorsionFree:a}=b;return i===o||(a?a(I,this):K.unsafe(this,k).is0())}clearCofactor(){let{clearCofactor:a}=b;return i===o?this:a?a(I,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(a=!0){return(0,f._abool2)(a,"isCompressed"),this.assertValidity(),v(I,this,a)}toHex(a=!0){return(0,f.bytesToHex)(this.toBytes(a))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(a=!0){return this.toBytes(a)}_setWindowSize(a){this.precompute(a)}static normalizeZ(a){return(0,g.normalizeZ)(I,a)}static msm(a,b){return(0,g.pippenger)(I,e,a,b)}static fromPrivateKey(a){return I.BASE.multiply(s(e,a))}}I.BASE=new I(h.Gx,h.Gy,d.ONE),I.ZERO=new I(d.ZERO,d.ONE,d.ZERO),I.Fp=d,I.Fn=e;let J=e.BITS,K=new g.wNAF(I,b.endo?Math.ceil(J/2):J);return I.BASE.precompute(8),I}function u(a){return Uint8Array.of(a?2:3)}function v(a,b){let c=a.ORDER,d=n;for(let a=c-o;a%p===n;a/=p)d+=o;let e=d,f=p<<e-o-o,g=f*p,h=(c-o)/g,i=(h-o)/p,j=g-o,k=a.pow(b,h),l=a.pow(b,(h+o)/p),m=(b,c)=>{let d=k,g=a.pow(c,j),h=a.sqr(g);h=a.mul(h,c);let m=a.mul(b,h);m=a.pow(m,i),m=a.mul(m,g),g=a.mul(m,c),h=a.mul(m,b);let n=a.mul(h,g);m=a.pow(n,f);let q=a.eql(m,a.ONE);g=a.mul(h,l),m=a.mul(n,d),h=a.cmov(g,h,q),n=a.cmov(m,n,q);for(let b=e;b>o;b--){let c=b-p;c=p<<c-o;let e=a.pow(n,c),f=a.eql(e,a.ONE);g=a.mul(h,d),d=a.mul(d,d),e=a.mul(n,d),h=a.cmov(g,h,f),n=a.cmov(e,n,f)}return{isValid:q,value:h}};if(a.ORDER%r===q){let c=(a.ORDER-q)/r,d=a.sqrt(a.neg(b));m=(b,e)=>{let f=a.sqr(e),g=a.mul(b,e);f=a.mul(f,g);let h=a.pow(f,c);h=a.mul(h,g);let i=a.mul(h,d),j=a.mul(a.sqr(h),e),k=a.eql(j,b),l=a.cmov(i,h,k);return{isValid:k,value:l}}}return m}function w(a,b){return{secretKey:b.BYTES,publicKey:1+a.BYTES,publicKeyUncompressed:1+2*a.BYTES,publicKeyHasPrefix:!0,signature:2*b.BYTES}}function x(a,b={}){let{Fn:c}=a,d=b.randomBytes||f.randomBytes,e=Object.assign(w(a.Fp,c),{seed:(0,h.getMinHashLength)(c.ORDER)});function g(a){try{return!!s(c,a)}catch(a){return!1}}function i(a=d(e.seed)){return(0,h.mapHashToField)((0,f._abytes2)(a,e.seed,"seed"),c.ORDER)}function j(b,d=!0){return a.BASE.multiply(s(c,b)).toBytes(d)}function k(b){if("bigint"==typeof b)return!1;if(b instanceof a)return!0;let{secretKey:d,publicKey:g,publicKeyUncompressed:h}=e;if(c.allowedLengths||d===g)return;let i=(0,f.ensureBytes)("key",b).length;return i===g||i===h}return Object.freeze({getPublicKey:j,getSharedSecret:function(b,d,e=!0){if(!0===k(b))throw Error("first arg must be private key");if(!1===k(d))throw Error("second arg must be public key");let f=s(c,b);return a.fromHex(d).multiply(f).toBytes(e)},keygen:function(a){let b=i(a);return{secretKey:b,publicKey:j(b)}},Point:a,utils:{isValidSecretKey:g,isValidPublicKey:function(b,c){let{publicKey:d,publicKeyUncompressed:f}=e;try{let e=b.length;if(!0===c&&e!==d||!1===c&&e!==f)return!1;return!!a.fromBytes(b)}catch(a){return!1}},randomSecretKey:i,isValidPrivateKey:g,randomPrivateKey:i,normPrivateKeyToScalar:a=>s(c,a),precompute:(b=8,c=a.BASE)=>c.precompute(b,!1)},lengths:e})}function y(a,b,g={}){(0,e.ahash)(b),(0,f._validateObject)(g,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let h=g.randomBytes||f.randomBytes,i=g.hmac||((a,...c)=>(0,d.hmac)(b,a,(0,f.concatBytes)(...c))),{Fp:j,Fn:m}=a,{ORDER:q,BITS:r}=m,{keygen:t,getPublicKey:v,getSharedSecret:w,utils:z,lengths:A}=x(a,g),B={prehash:!1,lowS:"boolean"==typeof g.lowS&&g.lowS,format:void 0,extraEntropy:!1},C="compact";function D(a,b){if(!m.isValidNot0(b))throw Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);return b}class E{constructor(a,b,c){this.r=D("r",a),this.s=D("s",b),null!=c&&(this.recovery=c),Object.freeze(this)}static fromBytes(a,b=C){let d;if(!function(a,b){k(b);let c=A.signature;(0,f._abytes2)(a,"compact"===b?c:"recovered"===b?c+1:void 0,`${b} signature`)}(a,b),"der"===b){let{r:b,s:d}=c.DER.toSig((0,f._abytes2)(a));return new E(b,d)}"recovered"===b&&(d=a[0],b="compact",a=a.subarray(1));let e=m.BYTES,g=a.subarray(0,e),h=a.subarray(e,2*e);return new E(m.fromBytes(g),m.fromBytes(h),d)}static fromHex(a,b){return this.fromBytes((0,f.hexToBytes)(a),b)}addRecoveryBit(a){return new E(this.r,this.s,a)}recoverPublicKey(b){let c=j.ORDER,{r:d,s:e,recovery:g}=this;if(null==g||![0,1,2,3].includes(g))throw Error("recovery id invalid");if(q*p<c&&g>1)throw Error("recovery id is ambiguous for h>1 curve");let h=2===g||3===g?d+q:d;if(!j.isValid(h))throw Error("recovery id 2 or 3 invalid");let i=j.toBytes(h),k=a.fromBytes((0,f.concatBytes)(u((1&g)==0),i)),l=m.inv(h),n=G((0,f.ensureBytes)("msgHash",b)),o=m.create(-n*l),r=m.create(e*l),s=a.BASE.multiplyUnsafe(o).add(k.multiplyUnsafe(r));if(s.is0())throw Error("point at infinify");return s.assertValidity(),s}hasHighS(){return this.s>q>>o}toBytes(a=C){if(k(a),"der"===a)return(0,f.hexToBytes)(c.DER.hexFromSig(this));let b=m.toBytes(this.r),d=m.toBytes(this.s);if("recovered"===a){if(null==this.recovery)throw Error("recovery bit must be present");return(0,f.concatBytes)(Uint8Array.of(this.recovery),b,d)}return(0,f.concatBytes)(b,d)}toHex(a){return(0,f.bytesToHex)(this.toBytes(a))}assertValidity(){}static fromCompact(a){return E.fromBytes((0,f.ensureBytes)("sig",a),"compact")}static fromDER(a){return E.fromBytes((0,f.ensureBytes)("sig",a),"der")}normalizeS(){return this.hasHighS()?new E(this.r,m.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,f.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,f.bytesToHex)(this.toBytes("compact"))}}let F=g.bits2int||function(a){if(a.length>8192)throw Error("input is too large");let b=(0,f.bytesToNumberBE)(a),c=8*a.length-r;return c>0?b>>BigInt(c):b},G=g.bits2int_modN||function(a){return m.create(F(a))},H=(0,f.bitMask)(r);function I(a){return(0,f.aInRange)("num < 2^"+r,a,n,H),m.toBytes(a)}function J(a,c){return(0,f._abytes2)(a,void 0,"message"),c?(0,f._abytes2)(b(a),void 0,"prehashed message"):a}return Object.freeze({keygen:t,getPublicKey:v,getSharedSecret:w,utils:z,lengths:A,Point:a,sign:function(c,d,e={}){let{seed:g,k2sig:j}=function(b,c,d){if(["recovered","canonical"].some(a=>a in d))throw Error("sign() legacy options not supported");let{lowS:e,prehash:g,extraEntropy:i}=l(d,B),j=G(b=J(b,g)),k=s(m,c),p=[I(k),I(j)];if(null!=i&&!1!==i){let a=!0===i?h(A.secretKey):i;p.push((0,f.ensureBytes)("extraEntropy",a))}return{seed:(0,f.concatBytes)(...p),k2sig:function(b){let c=F(b);if(!m.isValidNot0(c))return;let d=m.inv(c),f=a.BASE.multiply(c).toAffine(),g=m.create(f.x);if(g===n)return;let h=m.create(d*m.create(j+g*k));if(h===n)return;let i=2*(f.x!==g)|Number(f.y&o),l=h;return e&&h>q>>o&&(l=m.neg(h),i^=1),new E(g,l,i)}}}(c=(0,f.ensureBytes)("message",c),d,e);return(0,f.createHmacDrbg)(b.outputLen,m.BYTES,i)(g,j)},verify:function(b,d,e,g={}){let{lowS:h,prehash:i,format:j}=l(g,B);if(e=(0,f.ensureBytes)("publicKey",e),d=J((0,f.ensureBytes)("message",d),i),"strict"in g)throw Error("options.strict was renamed to lowS");let k=void 0===j?function(a){let b,d="string"==typeof a||(0,f.isBytes)(a),e=!d&&null!==a&&"object"==typeof a&&"bigint"==typeof a.r&&"bigint"==typeof a.s;if(!d&&!e)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(e)b=new E(a.r,a.s);else if(d){try{b=E.fromBytes((0,f.ensureBytes)("sig",a),"der")}catch(a){if(!(a instanceof c.DER.Err))throw a}if(!b)try{b=E.fromBytes((0,f.ensureBytes)("sig",a),"compact")}catch(a){return!1}}return!!b&&b}(b):E.fromBytes((0,f.ensureBytes)("sig",b),j);if(!1===k)return!1;try{let b=a.fromBytes(e);if(h&&k.hasHighS())return!1;let{r:c,s:f}=k,g=G(d),i=m.inv(f),j=m.create(g*i),l=m.create(c*i),n=a.BASE.multiplyUnsafe(j).add(b.multiplyUnsafe(l));if(n.is0())return!1;return m.create(n.x)===c}catch(a){return!1}},recoverPublicKey:function(a,b,c={}){let{prehash:d}=l(c,B);return b=J(b,d),E.fromBytes(a,"recovered").recoverPublicKey(b).toBytes()},Signature:E,hash:b})}function z(a){let b={a:a.a,b:a.b,p:a.Fp.ORDER,n:a.n,h:a.h,Gx:a.Gx,Gy:a.Gy},c=a.Fp,d=a.allowedPrivateKeyLengths?Array.from(new Set(a.allowedPrivateKeyLengths.map(a=>Math.ceil(a/2)))):void 0,e={Fp:c,Fn:(0,h.Field)(b.n,{BITS:a.nBitLength,allowedLengths:d,modFromBytes:a.wrapPrivateKey}),allowInfinityPoint:a.allowInfinityPoint,endo:a.endo,isTorsionFree:a.isTorsionFree,clearCofactor:a.clearCofactor,fromBytes:a.fromBytes,toBytes:a.toBytes};return{CURVE:b,curveOpts:e}}function A(a,b,c){return function(d){let e=a.sqr(d),f=a.mul(e,d);return a.add(a.add(f,a.mul(d,b)),c)}}},110882,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getHash=function(a){return{hash:a}},c.createCurve=function(a,b){let c=b=>(0,d.weierstrass)({...a,hash:b});return{...c(b),create:c}};let d=a.r(55686)},239388,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c._DST_scalar=void 0,c.expand_message_xmd=j,c.expand_message_xof=k,c.hash_to_field=l,c.isogenyMap=function(a,b){let c=b.map(a=>Array.from(a).reverse());return(b,d)=>{let[f,g,h,i]=c.map(c=>c.reduce((c,d)=>a.add(a.mul(c,b),d))),[j,k]=(0,e.FpInvertBatch)(a,[g,i],!0);return b=a.mul(f,j),d=a.mul(d,a.mul(h,k)),{x:b,y:d}}},c.createHasher=function(a,b,d){if("function"!=typeof b)throw Error("mapToCurve() must be defined");function e(c){return a.fromAffine(b(c))}function f(b){let c=b.clearCofactor();return c.equals(a.ZERO)?a.ZERO:(c.assertValidity(),c)}return{defaults:d,hashToCurve(a,b){let c=l(a,2,Object.assign({},d,b)),g=e(c[0]),h=e(c[1]);return f(g.add(h))},encodeToCurve(a,b){let c=d.encodeDST?{DST:d.encodeDST}:{};return f(e(l(a,1,Object.assign({},d,c,b))[0]))},mapToCurve(a){if(!Array.isArray(a))throw Error("expected array of bigints");for(let b of a)if("bigint"!=typeof b)throw Error("expected array of bigints");return f(e(a))},hashToScalar:(b,e)=>l(b,1,Object.assign({},d,{p:a.Fn.ORDER,m:1,DST:c._DST_scalar},e))[0][0]}};let d=a.r(999619),e=a.r(311351),f=d.bytesToNumberBE;function g(a,b){if(h(a),h(b),a<0||a>=1<<8*b)throw Error("invalid I2OSP input: "+a);let c=Array.from({length:b}).fill(0);for(let d=b-1;d>=0;d--)c[d]=255&a,a>>>=8;return new Uint8Array(c)}function h(a){if(!Number.isSafeInteger(a))throw Error("number expected")}function i(a){if(!(0,d.isBytes)(a)&&"string"!=typeof a)throw Error("DST must be Uint8Array or string");return"string"==typeof a?(0,d.utf8ToBytes)(a):a}function j(a,b,c,e){(0,d.abytes)(a),h(c),(b=i(b)).length>255&&(b=e((0,d.concatBytes)((0,d.utf8ToBytes)("H2C-OVERSIZE-DST-"),b)));let{outputLen:f,blockLen:j}=e,k=Math.ceil(c/f);if(c>65535||k>255)throw Error("expand_message_xmd: invalid lenInBytes");let l=(0,d.concatBytes)(b,g(b.length,1)),m=g(0,j),n=g(c,2),o=Array(k),p=e((0,d.concatBytes)(m,a,n,g(0,1),l));o[0]=e((0,d.concatBytes)(p,g(1,1),l));for(let a=1;a<=k;a++){let b=[function(a,b){let c=new Uint8Array(a.length);for(let d=0;d<a.length;d++)c[d]=a[d]^b[d];return c}(p,o[a-1]),g(a+1,1),l];o[a]=e((0,d.concatBytes)(...b))}return(0,d.concatBytes)(...o).slice(0,c)}function k(a,b,c,e,f){if((0,d.abytes)(a),h(c),(b=i(b)).length>255){let a=Math.ceil(2*e/8);b=f.create({dkLen:a}).update((0,d.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(b).digest()}if(c>65535||b.length>255)throw Error("expand_message_xof: invalid lenInBytes");return f.create({dkLen:c}).update(a).update(g(c,2)).update(b).update(g(b.length,1)).digest()}function l(a,b,c){let g;(0,d._validateObject)(c,{p:"bigint",m:"number",k:"number",hash:"function"});let{p:i,k:l,m,hash:n,expand:o,DST:p}=c;if(!(0,d.isHash)(c.hash))throw Error("expected valid hash");(0,d.abytes)(a),h(b);let q=Math.ceil((i.toString(2).length+l)/8),r=b*m*q;if("xmd"===o)g=j(a,p,r,n);else if("xof"===o)g=k(a,p,r,l,n);else if("_internal_pass"===o)g=a;else throw Error('expand must be "xmd" or "xof"');let s=Array(b);for(let a=0;a<b;a++){let b=Array(m);for(let c=0;c<m;c++){let d=q*(c+a*m),h=g.subarray(d,d+q);b[c]=(0,e.mod)(f(h),i)}s[a]=b}return s}c._DST_scalar=(0,d.utf8ToBytes)("HashToScalar-")},784146,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.encodeToCurve=c.hashToCurve=c.secp256k1_hasher=c.schnorr=c.secp256k1=void 0;let d=a.r(404322),e=a.r(571420),f=a.r(110882),g=a.r(239388),h=a.r(311351),i=a.r(55686),j=a.r(999619),k={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},l={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},m=BigInt(0),n=BigInt(1),o=BigInt(2),p=(0,h.Field)(k.p,{sqrt:function(a){let b=k.p,c=BigInt(3),d=BigInt(6),e=BigInt(11),f=BigInt(22),g=BigInt(23),i=BigInt(44),j=BigInt(88),l=a*a*a%b,m=l*l*a%b,n=(0,h.pow2)(m,c,b)*m%b,q=(0,h.pow2)(n,c,b)*m%b,r=(0,h.pow2)(q,o,b)*l%b,s=(0,h.pow2)(r,e,b)*r%b,t=(0,h.pow2)(s,f,b)*s%b,u=(0,h.pow2)(t,i,b)*t%b,v=(0,h.pow2)(u,j,b)*u%b,w=(0,h.pow2)(v,i,b)*t%b,x=(0,h.pow2)(w,c,b)*m%b,y=(0,h.pow2)(x,g,b)*s%b,z=(0,h.pow2)(y,d,b)*l%b,A=(0,h.pow2)(z,o,b);if(!p.eql(p.sqr(A),a))throw Error("Cannot find square root");return A}});c.secp256k1=(0,f.createCurve)({...k,Fp:p,lowS:!0,endo:l},d.sha256);let q={};function r(a,...b){let c=q[a];if(void 0===c){let b=(0,d.sha256)((0,j.utf8ToBytes)(a));c=(0,j.concatBytes)(b,b),q[a]=c}return(0,d.sha256)((0,j.concatBytes)(c,...b))}let s=a=>a.toBytes(!0).slice(1),t=c.secp256k1.Point;function u(a){let{Fn:b,BASE:c}=t,d=(0,i._normFnElement)(b,a),e=c.multiply(d);return{scalar:e.y%o===m?d:b.neg(d),bytes:s(e)}}function v(a){if(!p.isValidNot0(a))throw Error("invalid x: Fail if x  p");let b=p.create(a*a),c=p.create(b*a+BigInt(7)),d=p.sqrt(c);d%o!==m&&(d=p.neg(d));let e=t.fromAffine({x:a,y:d});return e.assertValidity(),e}let w=j.bytesToNumberBE;function x(...a){return t.Fn.create(w(r("BIP0340/challenge",...a)))}function y(a){return u(a).bytes}function z(a,b,c=(0,e.randomBytes)(32)){let{Fn:d}=t,f=(0,j.ensureBytes)("message",a),{bytes:g,scalar:h}=u(b),i=(0,j.ensureBytes)("auxRand",c,32),k=d.toBytes(h^w(r("BIP0340/aux",i))),{bytes:l,scalar:m}=u(r("BIP0340/nonce",k,g,f)),n=x(l,g,f),o=new Uint8Array(64);if(o.set(l,0),o.set(d.toBytes(d.create(m+n*h)),32),!A(o,f,g))throw Error("sign: Invalid signature produced");return o}function A(a,b,c){let{Fn:d,BASE:e}=t,f=(0,j.ensureBytes)("signature",a,64),g=(0,j.ensureBytes)("message",b),h=(0,j.ensureBytes)("publicKey",c,32);try{let a=v(w(h)),b=w(f.subarray(0,32));if(!(0,j.inRange)(b,n,k.p))return!1;let c=w(f.subarray(32,64));if(!(0,j.inRange)(c,n,k.n))return!1;let i=x(d.toBytes(b),s(a),g),l=e.multiplyUnsafe(c).add(a.multiplyUnsafe(d.neg(i))),{x:p,y:q}=l.toAffine();if(l.is0()||q%o!==m||p!==b)return!1;return!0}catch(a){return!1}}c.schnorr=(()=>{let a=48,b=(b=(0,e.randomBytes)(a))=>(0,h.mapHashToField)(b,k.n);return c.secp256k1.utils.randomSecretKey,{keygen:function(a){let c=b(a);return{secretKey:c,publicKey:y(c)}},getPublicKey:y,sign:z,verify:A,Point:t,utils:{randomSecretKey:b,randomPrivateKey:b,taggedHash:r,lift_x:v,pointToBytes:s,numberToBytesBE:j.numberToBytesBE,bytesToNumberBE:j.bytesToNumberBE,mod:h.mod},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:a}}})();let B=(0,g.isogenyMap)(p,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(a=>a.map(a=>BigInt(a)))),C=(0,i.mapToCurveSimpleSWU)(p,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:p.create(BigInt("-11"))});c.secp256k1_hasher=(0,g.createHasher)(c.secp256k1.Point,a=>{let{x:b,y:c}=C(p.create(a[0]));return B(b,c)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:p.ORDER,m:1,k:128,expand:"xmd",hash:d.sha256}),c.hashToCurve=c.secp256k1_hasher.hashToCurve,c.encodeToCurve=c.secp256k1_hasher.encodeToCurve},965005,(a,b,c)=>{var d="__lodash_hash_undefined__",e="[object Arguments]",f="[object Boolean]",g="[object Date]",h="[object Function]",i="[object GeneratorFunction]",j="[object Map]",k="[object Number]",l="[object Object]",m="[object Promise]",n="[object RegExp]",o="[object Set]",p="[object String]",q="[object Symbol]",r="[object WeakMap]",s="[object ArrayBuffer]",t="[object DataView]",u="[object Float32Array]",v="[object Float64Array]",w="[object Int8Array]",x="[object Int16Array]",y="[object Int32Array]",z="[object Uint8Array]",A="[object Uint8ClampedArray]",B="[object Uint16Array]",C="[object Uint32Array]",D=/\w*$/,E=/^\[object .+?Constructor\]$/,F=/^(?:0|[1-9]\d*)$/,G={};G[e]=G["[object Array]"]=G[s]=G[t]=G[f]=G[g]=G[u]=G[v]=G[w]=G[x]=G[y]=G[j]=G[k]=G[l]=G[n]=G[o]=G[p]=G[q]=G[z]=G[A]=G[B]=G[C]=!0,G["[object Error]"]=G[h]=G[r]=!1;var H=a.g&&a.g.Object===Object&&a.g,I="object"==typeof self&&self&&self.Object===Object&&self,J=H||I||Function("return this")(),K=c&&!c.nodeType&&c,L=K&&b&&!b.nodeType&&b,M=L&&L.exports===K;function N(a,b){return a.set(b[0],b[1]),a}function O(a,b){return a.add(b),a}function P(a,b,c,d){var e=-1,f=a?a.length:0;for(d&&f&&(c=a[++e]);++e<f;)c=b(c,a[e],e,a);return c}function Q(a){var b=!1;if(null!=a&&"function"!=typeof a.toString)try{b=!!(a+"")}catch(a){}return b}function R(a){var b=-1,c=Array(a.size);return a.forEach(function(a,d){c[++b]=[d,a]}),c}function S(a,b){return function(c){return a(b(c))}}function T(a){var b=-1,c=Array(a.size);return a.forEach(function(a){c[++b]=a}),c}var U=Array.prototype,V=Function.prototype,W=Object.prototype,X=J["__core-js_shared__"],Y=function(){var a=/[^.]+$/.exec(X&&X.keys&&X.keys.IE_PROTO||"");return a?"Symbol(src)_1."+a:""}(),Z=V.toString,$=W.hasOwnProperty,_=W.toString,aa=RegExp("^"+Z.call($).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),ab=M?J.Buffer:void 0,ac=J.Symbol,ad=J.Uint8Array,ae=S(Object.getPrototypeOf,Object),af=Object.create,ag=W.propertyIsEnumerable,ah=U.splice,ai=Object.getOwnPropertySymbols,aj=ab?ab.isBuffer:void 0,ak=S(Object.keys,Object),al=aH(J,"DataView"),am=aH(J,"Map"),an=aH(J,"Promise"),ao=aH(J,"Set"),ap=aH(J,"WeakMap"),aq=aH(Object,"create"),ar=aL(al),as=aL(am),at=aL(an),au=aL(ao),av=aL(ap),aw=ac?ac.prototype:void 0,ax=aw?aw.valueOf:void 0;function ay(a){var b=-1,c=a?a.length:0;for(this.clear();++b<c;){var d=a[b];this.set(d[0],d[1])}}function az(a){var b=-1,c=a?a.length:0;for(this.clear();++b<c;){var d=a[b];this.set(d[0],d[1])}}function aA(a){var b=-1,c=a?a.length:0;for(this.clear();++b<c;){var d=a[b];this.set(d[0],d[1])}}function aB(a){this.__data__=new az(a)}function aC(a,b,c){var d=a[b];$.call(a,b)&&aM(d,c)&&(void 0!==c||b in a)||(a[b]=c)}function aD(a,b){for(var c=a.length;c--;)if(aM(a[c][0],b))return c;return -1}function aE(a){var b=new a.constructor(a.byteLength);return new ad(b).set(new ad(a)),b}function aF(a,b,c,d){c||(c={});for(var e=-1,f=b.length;++e<f;){var g=b[e],h=d?d(c[g],a[g],g,c,a):void 0;aC(c,g,void 0===h?a[g]:h)}return c}function aG(a,b){var c,d,e=a.__data__;return("string"==(d=typeof(c=b))||"number"==d||"symbol"==d||"boolean"==d?"__proto__"!==c:null===c)?e["string"==typeof b?"string":"hash"]:e.map}function aH(a,b){var c,d=null==a?void 0:a[b];return!(!aR(d)||(c=d,Y&&Y in c))&&(aQ(d)||Q(d)?aa:E).test(aL(d))?d:void 0}ay.prototype.clear=function(){this.__data__=aq?aq(null):{}},ay.prototype.delete=function(a){return this.has(a)&&delete this.__data__[a]},ay.prototype.get=function(a){var b=this.__data__;if(aq){var c=b[a];return c===d?void 0:c}return $.call(b,a)?b[a]:void 0},ay.prototype.has=function(a){var b=this.__data__;return aq?void 0!==b[a]:$.call(b,a)},ay.prototype.set=function(a,b){return this.__data__[a]=aq&&void 0===b?d:b,this},az.prototype.clear=function(){this.__data__=[]},az.prototype.delete=function(a){var b=this.__data__,c=aD(b,a);return!(c<0)&&(c==b.length-1?b.pop():ah.call(b,c,1),!0)},az.prototype.get=function(a){var b=this.__data__,c=aD(b,a);return c<0?void 0:b[c][1]},az.prototype.has=function(a){return aD(this.__data__,a)>-1},az.prototype.set=function(a,b){var c=this.__data__,d=aD(c,a);return d<0?c.push([a,b]):c[d][1]=b,this},aA.prototype.clear=function(){this.__data__={hash:new ay,map:new(am||az),string:new ay}},aA.prototype.delete=function(a){return aG(this,a).delete(a)},aA.prototype.get=function(a){return aG(this,a).get(a)},aA.prototype.has=function(a){return aG(this,a).has(a)},aA.prototype.set=function(a,b){return aG(this,a).set(a,b),this},aB.prototype.clear=function(){this.__data__=new az},aB.prototype.delete=function(a){return this.__data__.delete(a)},aB.prototype.get=function(a){return this.__data__.get(a)},aB.prototype.has=function(a){return this.__data__.has(a)},aB.prototype.set=function(a,b){var c=this.__data__;if(c instanceof az){var d=c.__data__;if(!am||d.length<199)return d.push([a,b]),this;c=this.__data__=new aA(d)}return c.set(a,b),this};var aI=ai?S(ai,Object):function(){return[]},aJ=function(a){return _.call(a)};function aK(a){var b=a&&a.constructor;return a===("function"==typeof b&&b.prototype||W)}function aL(a){if(null!=a){try{return Z.call(a)}catch(a){}try{return a+""}catch(a){}}return""}function aM(a,b){return a===b||a!=a&&b!=b}(al&&aJ(new al(new ArrayBuffer(1)))!=t||am&&aJ(new am)!=j||an&&aJ(an.resolve())!=m||ao&&aJ(new ao)!=o||ap&&aJ(new ap)!=r)&&(aJ=function(a){var b=_.call(a),c=b==l?a.constructor:void 0,d=c?aL(c):void 0;if(d)switch(d){case ar:return t;case as:return j;case at:return m;case au:return o;case av:return r}return b});var aN=Array.isArray;function aO(a){var b;return null!=a&&"number"==typeof(b=a.length)&&b>-1&&b%1==0&&b<=0x1fffffffffffff&&!aQ(a)}var aP=aj||function(){return!1};function aQ(a){var b=aR(a)?_.call(a):"";return b==h||b==i}function aR(a){var b=typeof a;return!!a&&("object"==b||"function"==b)}function aS(a){return aO(a)?function(a,b){var c,d,f,g,h,i=aN(a)||(f=d=c=a)&&"object"==typeof f&&aO(d)&&$.call(c,"callee")&&(!ag.call(c,"callee")||_.call(c)==e)?function(a,b){for(var c=-1,d=Array(a);++c<a;)d[c]=b(c);return d}(a.length,String):[],j=i.length,k=!!j;for(var l in a){$.call(a,l)&&!(k&&("length"==l||(g=l,(h=null==(h=j)?0x1fffffffffffff:h)&&("number"==typeof g||F.test(g))&&g>-1&&g%1==0&&g<h)))&&i.push(l)}return i}(a):function(a){if(!aK(a))return ak(a);var b=[];for(var c in Object(a))$.call(a,c)&&"constructor"!=c&&b.push(c);return b}(a)}b.exports=function(a){return function a(b,c,d,m,r,E,F){if(m&&(H=E?m(b,r,E,F):m(b)),void 0!==H)return H;if(!aR(b))return b;var H,I=aN(b);if(I){if(K=(J=b).length,L=J.constructor(K),K&&"string"==typeof J[0]&&$.call(J,"index")&&(L.index=J.index,L.input=J.input),H=L,!c){var J,K,L,M=b,S=H,U=-1,V=M.length;for(S||(S=Array(V));++U<V;)S[U]=M[U];return S}}else{var W,X,Y,Z,_,aa=aJ(b),ab=aa==h||aa==i;if(aP(b)){var ac=b,ad=c;if(ad)return ac.slice();var ag=new ac.constructor(ac.length);return ac.copy(ag),ag}if(aa==l||aa==e||ab&&!E){if(Q(b))return E?b:{};if(H="function"!=typeof(W=ab?{}:b).constructor||aK(W)?{}:aR(X=ae(W))?af(X):{},!c){return Y=b,Z=(_=H)&&aF(b,aS(b),_),aF(Y,aI(Y),Z)}}else{if(!G[aa])return E?b:{};H=function(a,b,c,d){var e,h,i,l=a.constructor;switch(b){case s:return aE(a);case f:case g:return new l(+a);case t:return e=d?aE(a.buffer):a.buffer,new a.constructor(e,a.byteOffset,a.byteLength);case u:case v:case w:case x:case y:case z:case A:case B:case C:return h=d?aE(a.buffer):a.buffer,new a.constructor(h,a.byteOffset,a.length);case j:return P(d?c(R(a),!0):R(a),N,new a.constructor);case k:case p:return new l(a);case n:return(i=new a.constructor(a.source,D.exec(a))).lastIndex=a.lastIndex,i;case o:return P(d?c(T(a),!0):T(a),O,new a.constructor);case q:return ax?Object(ax.call(a)):{}}}(b,aa,a,c)}}F||(F=new aB);var ah=F.get(b);if(ah)return ah;if(F.set(b,H),!I)var ai=d?function(a){var b;return b=aS(a),aN(a)?b:function(a,b){for(var c=-1,d=b.length,e=a.length;++c<d;)a[e+c]=b[c];return a}(b,aI(a))}(b):aS(b);return!function(a,b){for(var c=-1,d=a?a.length:0;++c<d&&!1!==b(a[c],c,a););}(ai||b,function(e,f){ai&&(e=b[f=e]),aC(H,f,a(e,c,d,m,f,b,F))}),H}(a,!0,!0)}},518040,(a,b,c)=>{"use strict";let d=a.r(575440).sha256,e=a.r(813248),f=a.r(674898).Buffer,g=a.r(133028),h=a.r(784146).secp256k1,i=a.r(965005),j={bech32:"bc",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0,1],wif:128},k={bech32:"tb",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0,1],wif:239},l={bech32:"bcrt",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0,1],wif:239},m={bech32:"sb",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0,1],wif:239},n={word_length:4,var_onion_optin:{required:!1,supported:!0},payment_secret:{required:!1,supported:!0}},o=["option_data_loss_protect","initial_routing_sync","option_upfront_shutdown_script","gossip_queries","var_onion_optin","gossip_queries_ex","option_static_remotekey","payment_secret","basic_mpp","option_support_large_channel"],p={m:1000n,u:1000000n,n:1000000000n,p:1000000000000n},q={payment_hash:1,payment_secret:16,description:13,payee_node_key:19,purpose_commit_hash:23,expire_time:6,min_final_cltv_expiry:24,fallback_address:9,routing_info:3,feature_bits:5,blinded_payinfo:20},r={};for(let a=0,b=Object.keys(q);a<b.length;a++){let c=b[a];r[q[b[a]].toString()]=c}let s={payment_hash:B,payment_secret:B,description:function(a){let b=f.from(a,"utf8");return e.toWords(b)},payee_node_key:B,purpose_commit_hash:function(a){let b;if(void 0!==a&&("string"==typeof a||a instanceof String))b=a.match(/^([a-zA-Z0-9]{2})*$/)?f.from(a,"hex"):x(f.from(a,"utf8"));else throw Error("purpose or purpose commit must be a string or hex string");return e.toWords(b)},expire_time:w,min_final_cltv_expiry:w,fallback_address:function(a,b){return[a.code].concat(B(a.addressHash))},routing_info:function(a){let b=f.from([]);return a.forEach(a=>{b=f.concat([b,A(a.pubkey)]),b=f.concat([b,A(a.short_channel_id)]),b=f.concat([b,f.from([0,0,0].concat(w(a.fee_base_msat,8)).slice(-4))]),b=f.concat([b,f.from([0,0,0].concat(w(a.fee_proportional_millionths,8)).slice(-4))]),b=f.concat([b,f.from([0].concat(w(a.cltv_expiry_delta,8)).slice(-2))])}),B(b)},feature_bits:function(a){let b=a.word_length,c=[];for(o.forEach(b=>{c.push(!!(a[b]||{}).required),c.push(!!(a[b]||{}).supported)});!1===c[c.length-1];)c.pop();for(;c.length%5!=0;)c.push(!1);if(a.extra_bits&&Array.isArray(a.extra_bits.bits)&&a.extra_bits.bits.length>0){for(;c.length<a.extra_bits.start_bit;)c.push(!1);c=c.concat(a.extra_bits.bits)}if(void 0!==b&&c.length/5>b)throw Error("word_length is too small to contain all featureBits");return void 0===b&&(b=Math.ceil(c.length/5)),Array(b).fill(0).map((a,b)=>c[5*b+4]<<4|c[5*b+3]<<3|c[5*b+2]<<2|c[5*b+1]<<1|(0|c[5*b])).reverse()}},t={1:a=>z(a,!0).toString("hex"),16:a=>z(a,!0).toString("hex"),13:a=>z(a,!0).toString("utf8"),19:a=>z(a,!0).toString("hex"),23:a=>z(a,!0).toString("hex"),6:v,24:v,9:function(a,b){let c=a[0],d=z(a=a.slice(1),!0),e=null;switch(c){case 17:e=g.Address(b).encode({type:"pkh",hash:d});break;case 18:e=g.Address(b).encode({type:"sh",hash:d});break;case 0:e=20===d.length?g.Address(b).encode({type:"wpkh",hash:d}):g.Address(b).encode({type:"wsh",hash:d});break;case 1:e=g.Address(b).encode({type:"tr",pubkey:d})}return{code:c,address:e,addressHash:d.toString("hex")}},3:function(a){let b,c,d,e,f,g=[],h=z(a,!0);for(;h.length>0;)b=h.slice(0,33).toString("hex"),c=h.slice(33,41).toString("hex"),d=parseInt(h.slice(41,45).toString("hex"),16),e=parseInt(h.slice(45,49).toString("hex"),16),f=parseInt(h.slice(49,51).toString("hex"),16),h=h.slice(51),g.push({pubkey:b,short_channel_id:c,fee_base_msat:d,fee_proportional_millionths:e,cltv_expiry_delta:f});return g},5:function(a){let b=a.slice().reverse().map(a=>[!!(1&a),!!(2&a),!!(4&a),!!(8&a),!!(16&a)]).reduce((a,b)=>a.concat(b),[]);for(;b.length<2*o.length;)b.push(!1);let c={word_length:a.length};if(o.forEach((a,d)=>{c[a]={required:b[2*d],supported:b[2*d+1]}}),b.length>2*o.length){let a=b.slice(2*o.length);c.extra_bits={start_bit:2*o.length,bits:a,has_required:a.reduce((a,b,c)=>c%2!=0?a||!1:a||b,!1)}}else c.extra_bits={start_bit:2*o.length,bits:[],has_required:!1};return c},20:function(a){let b=z(a,!0),c=b.readUInt32BE(0),d=b.readUInt32BE(4),e=b.readUInt16BE(8),f=BigInt("0x"+b.slice(10,18).toString("hex")),g=BigInt("0x"+b.slice(18,26).toString("hex")),h=b.readUInt16BE(26),i=28,j=[...b.slice(i,i+h)];i+=h;let k=b.slice(i,i+33).toString("hex");i+=33;let l=b.readUInt8(i);i++;let m=[];for(let a=0;a<l;a++){let[a,c]=function(a,b){let c=a.slice(b,b+33),[d,e]=function(a,b){let c=a.readUInt8(b);switch(b++,c){case 253:return[a.readUInt16BE(b),b+2];case 254:return[a.readUInt32BE(b),b+4];case 255:return[parseInt(a.slice(b,b+8).toString("hex"),16),b+8];default:return[c,b]}}(a,b+=33);b=e;let f=a.slice(b,b+d);return b+=d,[{blinded_node_pubkey:c.toString("hex"),cipher_text:f.toString("hex")},b]}(b,i);i=c,m.push(a)}return{fee_base_msat:c,fee_proportional_millionths:d,cltv_expiry_delta:e,htlc_minimum_msat:f,htlc_maximum_msat:g,features:j,first_ephemeral_blinding_point:k,blinded_hops:m,introduction_node:m[0].blinded_node_pubkey}}},u="unknownTag";function v(a){return a.reverse().reduce((a,b,c)=>a+b*Math.pow(32,c),0)}function w(a,b){let c=[];if(void 0===b&&(b=5),0===(a=Math.floor(a)))return[0];for(;a>0;)c.push(a&Math.pow(2,b)-1),a=Math.floor(a/Math.pow(2,b));return c.reverse()}function x(a){return f.from(d(a))}function y(a,b,c){let d=0,e=0,f=(1<<c)-1,g=[];for(let h=0;h<a.length;++h)for(d=d<<b|a[h],e+=b;e>=c;)g.push(d>>(e-=c)&f);return e>0&&g.push(d<<c-e&f),g}function z(a,b){let c=f.from(y(a,5,8,!0));return b&&5*a.length%8!=0&&(c=c.slice(0,-1)),c}function A(a){return void 0!==a&&("string"==typeof a||a instanceof String)&&a.match(/^([a-zA-Z0-9]{2})*$/)?f.from(a,"hex"):a}function B(a){let b=A(a);return e.toWords(b)}function C(a,b){let c=a.filter(a=>a.tagName===b);return c.length>0?c[0].data:null}function D(a,b){return null!==C(a,b)}function E(a,b){let c={};if(Object.keys(a).sort().forEach(b=>{c[b]=a[b]}),!0===b){let a="__tagsObject_cache";Object.defineProperty(c,"tagsObject",{get(){return this[a]||Object.defineProperty(this,a,{value:function(a){let b={};return a.forEach(a=>{a.tagName===u?(b.unknownTags||(b.unknownTags=[]),b.unknownTags.push(a.data)):"blinded_payinfo"===a.tagName?(null==b[a.tagName]&&(b[a.tagName]=[]),b[a.tagName].push(a.data)):b[a.tagName]=a.data}),b}(this.tags)}),this[a]}})}return c}function F(a){if(!a.toString().match(/^\d+$/))throw Error("satoshis must be an integer");return G(1000n*BigInt(a))}function G(a){let b,c;if(!a.toString().match(/^\d+$/))throw Error("millisatoshis must be an integer");let d=BigInt(a),e=d.toString(10),f=e.length;return f>11&&/0{11}$/.test(e)?(b="",c=(d/100000000000n).toString(10)):f>8&&/0{8}$/.test(e)?(b="m",c=(d/100000000n).toString(10)):f>5&&/0{5}$/.test(e)?(b="u",c=(d/100000n).toString(10)):f>2&&/0{2}$/.test(e)?(b="n",c=(d/100n).toString(10)):(b="p",c=(10n*d).toString(10)),c+b}function H(a,b){let c=I(a,!1);if(c%1000n!==0n)throw Error("Amount is outside of valid range");let d=c/1000n;return b?d.toString(10):d}function I(a,b){let c,d;if(a.slice(-1).match(/^[munp]$/))c=a.slice(-1),d=a.slice(0,-1);else if(a.slice(-1).match(/^[^munp0-9]$/))throw Error("Not a valid multiplier for the amount");else d=a;if(!d.match(/^\d+$/))throw Error("Not a valid human readable amount");let e=BigInt(d),f=c?100000000000n*e/p[c]:100000000000n*e;if("p"===c&&e%10n!==0n||f>0x1d24b2dfac520000n)throw Error("Amount is outside of valid range");return b?f.toString(10):f}b.exports={encode:function(a,b){let c,d,k,l,m,o,p,t,v=i(a);void 0===b&&(b=!0);let z=void 0!==v.signature&&void 0!==v.recoveryFlag;if(void 0!==v.network||z)if(void 0===v.network&&z)throw Error("Need network for proper payment request reconstruction");else{if(!v.network.bech32||void 0===v.network.pubKeyHash||void 0===v.network.scriptHash||!Array.isArray(v.network.validWitnessVersions)||void 0===v.network.wif)throw Error("Invalid network");c=v.network}else v.network=j,c=j;if(void 0!==v.timestamp||z){if(void 0===v.timestamp&&z)throw Error("Need timestamp for proper payment request reconstruction")}else v.timestamp=Math.floor(new Date().getTime()/1e3);if(void 0===v.tags)throw Error("Payment Requests need tags array");if(!D(v.tags,r["1"]))throw Error("Lightning Payment Request needs a payment hash");if(D(v.tags,r["16"]))if(D(v.tags,r["5"])){let a=C(v.tags,r["5"]);if(!a.payment_secret||!a.payment_secret.supported&&!a.payment_secret.required)throw Error("Payment request requires feature bits with at least payment secret support flagged if payment secret is included")}else if(b)v.tags.push({tagName:r["5"],data:n});else throw Error("Payment request requires feature bits with at least payment secret support flagged if payment secret is included");if(!D(v.tags,r["13"])&&!D(v.tags,r["23"]))if(b)v.tags.push({tagName:r["13"],data:""});else throw Error("Payment request requires description or purpose commit hash");if(D(v.tags,r["13"])&&f.from(C(v.tags,r["13"]),"utf8").length>639)throw Error("Description is too long: Max length 639 bytes");if(D(v.tags,r["6"])||z||!b||v.tags.push({tagName:r["6"],data:3600}),D(v.tags,r["24"])||z||!b||v.tags.push({tagName:r["24"],data:9}),D(v.tags,r["19"])&&(k=A(C(v.tags,r["19"]))),v.payeeNodeKey&&(d=A(v.payeeNodeKey)),d&&k&&!k.equals(d))throw Error("payeeNodeKey and tag payee node key do not match");if((d=d||k)&&(v.payeeNodeKey=d.toString("hex")),D(v.tags,r["9"])){let a=C(v.tags,r["9"]);if(o=a.address,m=a.addressHash,l=a.code,void 0===m||void 0===l){let b;try{b=g.Address(c).decode(o)}catch(a){throw Error("Fallback address invalid format")}switch(b.type){case"pkh":m=b.hash,l=17;break;case"sh":m=b.hash,l=18;break;case"wsh":case"wpkh":m=b.hash,l=0;break;case"tr":m=b.pubkey,l=1;break;default:throw Error("Fallback address format is unknown")}a.addressHash=f.from(m).toString("hex"),a.code=l}}D(v.tags,r["3"])&&C(v.tags,r["3"]).forEach(a=>{if(void 0===a.pubkey||void 0===a.short_channel_id||void 0===a.fee_base_msat||void 0===a.fee_proportional_millionths||void 0===a.cltv_expiry_delta)throw Error("Routing info is incomplete");try{h.ProjectivePoint.fromHex(A(a.pubkey))}catch(a){throw Error("Routing info pubkey is not a valid pubkey")}let b=A(a.short_channel_id);if(!(b instanceof f)||8!==b.length)throw Error("Routing info short channel id must be 8 bytes");if("number"!=typeof a.fee_base_msat||Math.floor(a.fee_base_msat)!==a.fee_base_msat)throw Error("Routing info fee base msat is not an integer");if("number"!=typeof a.fee_proportional_millionths||Math.floor(a.fee_proportional_millionths)!==a.fee_proportional_millionths)throw Error("Routing info fee proportional millionths is not an integer");if("number"!=typeof a.cltv_expiry_delta||Math.floor(a.cltv_expiry_delta)!==a.cltv_expiry_delta)throw Error("Routing info cltv expiry delta is not an integer")});let H="ln";if(H+=c.bech32,v.millisatoshis&&v.satoshis){if(p=G(BigInt(v.millisatoshis)),F(BigInt(v.satoshis))!==p)throw Error("satoshis and millisatoshis do not match")}else p=v.millisatoshis?G(BigInt(v.millisatoshis)):v.satoshis?F(BigInt(v.satoshis)):"";H+=p;let I=w(v.timestamp);for(;I.length<7;)I.unshift(0);let J=v.tags,K=[];J.forEach(a=>{let b,c=Object.keys(s);if(z&&c.push(u),-1===c.indexOf(a.tagName))throw Error("Unknown tag key: "+a.tagName);if(a.tagName!==u)K.push(q[a.tagName]),b=(0,s[a.tagName])(a.data);else{var d;let c=((d=a.data).words=e.decode(d.words,Number.MAX_SAFE_INTEGER).words,d);K.push(c.tagCode),b=c.words}K=(K=K.concat([0].concat(w(b.length)).slice(-2))).concat(b)});let L=I.concat(K),M=x(f.concat([f.from(H,"utf8"),f.from(y(L,5,8))]));if(z)if(d){let a=h.Signature.fromCompact(f.from(v.signature,"hex")).addRecoveryBit(v.recoveryFlag),b=f.from(a.recoverPublicKey(M).toRawBytes(!0));if(d&&!d.equals(b))throw Error("Signature, message, and recoveryID did not produce the same pubkey as payeeNodeKey");t=B(v.signature+"0"+v.recoveryFlag)}else throw Error("Reconstruction with signature and recoveryID requires payeeNodeKey to verify correctness of input data.");return t&&(L=L.concat(t)),D(v.tags,r["6"])&&(v.timeExpireDate=v.timestamp+C(v.tags,r["6"]),v.timeExpireDateString=new Date(1e3*v.timeExpireDate).toISOString()),v.timestampString=new Date(1e3*v.timestamp).toISOString(),v.complete=!!t,v.paymentRequest=v.complete?e.encode(H,L,Number.MAX_SAFE_INTEGER):"",v.prefix=H,v.wordsTemp=e.encode("temp",L,Number.MAX_SAFE_INTEGER),E(v)},decode:function(a,b){let c,d,g,i,n,o,p,q,s,w;if("string"!=typeof a)throw Error("Lightning Payment Request must be string");if("ln"!==a.slice(0,2).toLowerCase())throw Error("Not a proper lightning payment request");let A=e.decode(a,Number.MAX_SAFE_INTEGER);a=a.toLowerCase();let B=A.prefix,F=A.words,G=F.slice(-104),J=F.slice(0,-104);F=F.slice(0,-104);let K=z(G,!0),L=K.slice(-1)[0];if(K=K.slice(0,-1),!(L in[0,1,2,3])||64!==K.length)throw Error("Signature is missing or incorrect");let M=B.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);if(M&&!M[2]&&(M=B.match(/^ln(\S+)$/)),!M)throw Error("Not a proper lightning payment request");let N=M[1];if(b){if(void 0===b.bech32||void 0===b.pubKeyHash||void 0===b.scriptHash||!Array.isArray(b.validWitnessVersions)||void 0===b.wif)throw Error("Invalid network");c=b}else switch(N){case j.bech32:c=j;break;case k.bech32:c=k;break;case l.bech32:c=l;break;case m.bech32:c=m}if(!c||c.bech32!==N)throw Error("Unknown coin bech32 prefix");let O=M[2];if(O){let a=M[3];try{d=parseInt(H(O+a,!0))}catch(a){d=null,i=!0}g=I(O+a,!0)}else d=null,g=null;let P=v(F.slice(0,7)),Q=new Date(1e3*P).toISOString();F=F.slice(7);let R=[];for(;F.length>0;){let a=F[0].toString();n=r[a]||u,o=t[a]||function(a){return b=>({tagCode:parseInt(a),words:e.encode("unknown",b,Number.MAX_SAFE_INTEGER)})}(a),p=v((F=F.slice(1)).slice(0,2)),q=(F=F.slice(2)).slice(0,p),F=F.slice(p),R.push({tagName:n,data:o(q,c)})}D(R,r["6"])&&(w=new Date(1e3*(s=P+C(R,r["6"]))).toISOString());let S=x(f.concat([f.from(B,"utf8"),f.from(y(J,5,8))])),T=h.Signature.fromCompact(K).addRecoveryBit(L),U=f.from(T.recoverPublicKey(S).toRawBytes(!0));if(D(R,r["19"])&&C(R,r["19"])!==U.toString("hex"))throw Error("Lightning Payment Request signature pubkey does not match payee pubkey");let V={paymentRequest:a,complete:!0,prefix:B,wordsTemp:e.encode("temp",J.concat(G),Number.MAX_SAFE_INTEGER),network:c,satoshis:d,millisatoshis:g,timestamp:P,timestampString:Q,payeeNodeKey:U.toString("hex"),signature:K.toString("hex"),recoveryFlag:L,tags:R};return i&&delete V.satoshis,s&&(V=Object.assign(V,{timeExpireDate:s,timeExpireDateString:w})),E(V,!0)},sign:function(a,b){let c,d,g=i(a),j=A(b);if(g.complete&&g.paymentRequest)return g;if(void 0===j||32!==j.length||!h.utils.isValidPrivateKey(j))throw Error("privateKey must be a 32 byte Buffer and valid private key");if(D(g.tags,r["19"])&&(d=A(C(g.tags,r["19"]))),g.payeeNodeKey&&(c=A(g.payeeNodeKey)),c&&d&&!d.equals(c))throw Error("payee node key tag and payeeNodeKey attribute must match");c=d||c;let k=f.from(h.getPublicKey(j,!0));if(c&&!k.equals(c))throw Error("The private key given is not the private key of the node public key given");let l=e.decode(g.wordsTemp,Number.MAX_SAFE_INTEGER).words,m=x(f.concat([f.from(g.prefix,"utf8"),z(l)])),n=h.sign(m,j,{lowS:!0});g.signature=f.from(n.toCompactRawBytes()).toString("hex");let o=B(g.signature+"0"+n.recovery);return g.payeeNodeKey=k.toString("hex"),g.recoveryFlag=n.recovery,g.wordsTemp=e.encode("temp",l.concat(o),Number.MAX_SAFE_INTEGER),g.complete=!0,g.paymentRequest=e.encode(g.prefix,l.concat(o),Number.MAX_SAFE_INTEGER),E(g)},satToHrp:F,millisatToHrp:G,hrpToSat:H,hrpToMillisat:I}},622362,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IEscrowSwap=c.isIEscrowSwapInit=void 0;let d=a.r(19763),e=a.r(163846),f=a.r(213144),g=a.r(500874),h=a.r(294982);function i(a){return"object"==typeof a&&null!=a.feeRate&&(null==a.signatureData||"object"==typeof a.signatureData&&"string"==typeof a.signatureData.prefix&&"string"==typeof a.signatureData.timeout&&"string"==typeof a.signatureData.signature)&&(null==a.data||"object"==typeof a.data)&&(0,d.isISwapInit)(a)}c.isIEscrowSwapInit=i;class j extends d.ISwap{constructor(a,b){super(a,b),i(b)||(this.data=null!=b.data?new a.swapDataDeserializer(b.data):null,this.signatureData=null==b.signature?null:{prefix:b.prefix,timeout:b.timeout,signature:b.signature},this.feeRate=b.feeRate,this.commitTxId=b.commitTxId,this.claimTxId=b.claimTxId,this.refundTxId=b.refundTxId)}getIdentifierHash(){let a=g.Buffer.from(this.getClaimHash(),"hex");return null==this.randomNonce?a:g.Buffer.concat([a,g.Buffer.from(this.randomNonce,"hex")])}getIdentifierHashString(){let a=this.getIdentifierHash();return null==a?null:a.toString("hex")}_getEscrowHash(){return this.data?.getEscrowHash()}getEscrowHash(){return this._getEscrowHash()}getClaimHash(){return this.data?.getClaimHash()}getId(){return this.getIdentifierHashString()}async watchdogWaitTillSignatureExpiry(a,b=5){let c=!1;for(;!c;){await (0,f.timeoutPromise)(1e3*b,a);try{c=await this.wrapper.contract.isInitAuthorizationExpired(this.data,this.signatureData)}catch(a){this.logger.error("watchdogWaitTillSignatureExpiry(): Error when checking signature expiry: ",a)}}null!=a&&a.throwIfAborted()}async watchdogWaitTillCommited(a,b=5){let c={type:e.SwapCommitStateType.NOT_COMMITED};for(;c?.type===e.SwapCommitStateType.NOT_COMMITED;){await (0,f.timeoutPromise)(1e3*b,a);try{if(c=await this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data),c?.type===e.SwapCommitStateType.NOT_COMMITED&&await this.wrapper.contract.isInitAuthorizationExpired(this.data,this.signatureData))return!1}catch(a){this.logger.error("watchdogWaitTillCommited(): Error when fetching commit status or signature expiry: ",a)}}return null!=a&&a.throwIfAborted(),!0}async watchdogWaitTillResult(a,b=5){let c={type:e.SwapCommitStateType.COMMITED};for(;c?.type===e.SwapCommitStateType.COMMITED||c?.type===e.SwapCommitStateType.REFUNDABLE;){await (0,f.timeoutPromise)(1e3*b,a);try{c=await this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data)}catch(a){this.logger.error("watchdogWaitTillResult(): Error when fetching commit status: ",a)}}return null!=a&&a.throwIfAborted(),c}async verifyQuoteDefinitelyExpired(){return(0,f.tryWithRetries)(()=>this.wrapper.contract.isInitAuthorizationExpired(this.data,this.signatureData))}async verifyQuoteValid(){try{return await (0,f.tryWithRetries)(()=>this.wrapper.contract.isValidInitAuthorization(this._getInitiator(),this.data,this.signatureData,this.feeRate),null,e.SignatureVerificationError),!0}catch(a){if(a instanceof e.SignatureVerificationError)return!1}}getCommitFee(){return this.wrapper.contract.getCommitFee(this.data,this.feeRate)}async getSmartChainNetworkFee(){let a=this.wrapper.contract;return(0,h.toTokenAmount)(await (null!=a.getRawCommitFee?a.getRawCommitFee(this.data,this.feeRate):a.getCommitFee(this.data,this.feeRate)),this.wrapper.getNativeToken(),this.wrapper.prices)}serialize(){return{...super.serialize(),data:null!=this.data?this.data.serialize():null,prefix:this.signatureData?.prefix,timeout:this.signatureData?.timeout,signature:this.signatureData?.signature,feeRate:null==this.feeRate?null:this.feeRate.toString(),commitTxId:this.commitTxId,claimTxId:this.claimTxId,refundTxId:this.refundTxId}}}c.IEscrowSwap=j},921304,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.FeeType=void 0,function(a){a[a.SWAP=0]="SWAP",a[a.NETWORK_OUTPUT=1]="NETWORK_OUTPUT"}(c.FeeType||(c.FeeType={}))},806361,(a,b,c)=>{"use strict";var d;Object.defineProperty(c,"__esModule",{value:!0}),c.ToBTCSwapState=c.IToBTCSwap=c.isIToBTCSwapInit=void 0;let e=a.r(163846),f=a.r(774702),g=a.r(974727),h=a.r(213144),i=a.r(294982),j=a.r(622362),k=a.r(921304),l=a.r(19763);function m(a){return"bigint"==typeof a.networkFee&&(null==a.networkFeeBtc||"bigint"==typeof a.networkFeeBtc)&&(0,j.isIEscrowSwapInit)(a)}c.isIToBTCSwapInit=m;class n extends j.IEscrowSwap{constructor(a,b){super(a,b),m(b)?this.state=d.CREATED:(this.networkFee=null==b.networkFee?null:BigInt(b.networkFee),this.networkFeeBtc=null==b.networkFeeBtc?null:BigInt(b.networkFeeBtc))}upgradeVersion(){if(null==this.version){switch(this.state){case -2:this.state=d.REFUNDED;break;case -1:this.state=d.QUOTE_EXPIRED;break;case 0:this.state=d.CREATED;break;case 1:this.state=d.COMMITED;break;case 2:this.state=d.CLAIMED;break;case 3:this.state=d.REFUNDABLE}this.version=1}}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getOutput().rawAmount/this.getInputWithoutFee().rawAmount),null==this.networkFeeBtc&&(this.networkFeeBtc=this.networkFee*this.getOutput().rawAmount/this.getInputWithoutFee().rawAmount),super.tryRecomputeSwapPrice()}getLpIdentifier(){return this.getClaimHash()}getInputTxId(){return this.commitTxId}requiresAction(){return this.isRefundable()}isFinished(){return this.state===d.CLAIMED||this.state===d.REFUNDED||this.state===d.QUOTE_EXPIRED}isRefundable(){return this.state===d.REFUNDABLE}isQuoteExpired(){return this.state===d.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===d.QUOTE_EXPIRED||this.state===d.QUOTE_SOFT_EXPIRED}isSuccessful(){return this.state===d.CLAIMED}isFailed(){return this.state===d.REFUNDED}_getInitiator(){return this.data.getOfferer()}getSwapFee(){let a=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getOutput().rawAmount;return{amountInSrcToken:(0,i.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),amountInDstToken:(0,i.toTokenAmount)(this.swapFeeBtc,this.outputToken,this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,a,b),composition:{base:(0,i.toTokenAmount)(this.pricingInfo.satsBaseFee,this.outputToken,this.wrapper.prices),percentage:(0,l.ppmToPercentage)(a)}}}getNetworkFee(){return{amountInSrcToken:(0,i.toTokenAmount)(this.networkFee,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),amountInDstToken:(0,i.toTokenAmount)(this.networkFeeBtc,this.outputToken,this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(this.networkFeeBtc,a,b)}}getFee(){return{amountInSrcToken:(0,i.toTokenAmount)(this.swapFee+this.networkFee,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),amountInDstToken:(0,i.toTokenAmount)(this.swapFeeBtc+this.networkFeeBtc,this.outputToken,this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc+this.networkFeeBtc,a,b)}}getFeeBreakdown(){return[{type:k.FeeType.SWAP,fee:this.getSwapFee()},{type:k.FeeType.NETWORK_OUTPUT,fee:this.getNetworkFee()}]}getInput(){return(0,i.toTokenAmount)(this.data.getAmount(),this.wrapper.tokens[this.data.getToken()],this.wrapper.prices)}getInputWithoutFee(){return(0,i.toTokenAmount)(this.data.getAmount()-(this.swapFee+this.networkFee),this.wrapper.tokens[this.data.getToken()],this.wrapper.prices)}async hasEnoughBalance(){let[a,b]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.data.getToken(),!1),this.data.getToken()===this.wrapper.chain.getNativeCurrencyAddress()?this.getCommitFee():Promise.resolve(null)]),c=this.data.getAmount();return null!=b&&(c+=b),{enoughBalance:a>=c,balance:(0,i.toTokenAmount)(a,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),required:(0,i.toTokenAmount)(c,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices)}}async hasEnoughForTxFees(){let[a,b]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.wrapper.chain.getNativeCurrencyAddress(),!1),this.getCommitFee()]);return{enoughBalance:a>=b,balance:(0,i.toTokenAmount)(a,this.wrapper.getNativeToken(),this.wrapper.prices),required:(0,i.toTokenAmount)(b,this.wrapper.getNativeToken(),this.wrapper.prices)}}async txsCommit(a){if(this.state!==d.CREATED)throw Error("Must be in CREATED state!");return this.initiated||(this.initiated=!0,await this._saveAndEmit()),await this.wrapper.contract.txsInit(this._getInitiator(),this.data,this.signatureData,a,this.feeRate).catch(a=>Promise.reject(a instanceof e.SignatureVerificationError?Error("Request timed out"):a))}async commit(a,b,c){this.checkSigner(a);let e=await this.wrapper.chain.sendAndConfirm(a,await this.txsCommit(c),!0,b);return this.commitTxId=e[e.length-1],(this.state===d.CREATED||this.state===d.QUOTE_SOFT_EXPIRED||this.state===d.QUOTE_EXPIRED)&&await this._saveAndEmit(d.COMMITED),this.commitTxId}async waitTillCommited(a){if(this.state===d.COMMITED||this.state===d.CLAIMED)return Promise.resolve();if(this.state!==d.CREATED&&this.state!==d.QUOTE_SOFT_EXPIRED)throw Error("Invalid state (not CREATED)");let b=(0,h.extendAbortController)(a),c=await Promise.race([this.watchdogWaitTillCommited(b.signal),this.waitTillState(d.COMMITED,"gte",b.signal).then(()=>0)]);if(b.abort(),0===c&&this.logger.debug("waitTillCommited(): Resolved from state change"),!0===c&&this.logger.debug("waitTillCommited(): Resolved from watchdog - commited"),!1===c){if(this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expiry"),this.state===d.QUOTE_SOFT_EXPIRED||this.state===d.CREATED)throw await this._saveAndEmit(d.QUOTE_EXPIRED),Error("Quote expired while waiting for transaction confirmation!");return}(this.state===d.QUOTE_SOFT_EXPIRED||this.state===d.CREATED||this.state===d.QUOTE_EXPIRED)&&await this._saveAndEmit(d.COMMITED)}async waitTillIntermediarySwapProcessed(a,b=5){let c={code:f.RefundAuthorizationResponseCodes.PENDING,msg:""};for(;!a.aborted&&(c.code===f.RefundAuthorizationResponseCodes.PENDING||c.code===f.RefundAuthorizationResponseCodes.NOT_FOUND);)(c=await f.IntermediaryAPI.getRefundAuthorization(this.url,this.getLpIdentifier(),this.data.getSequence())).code===f.RefundAuthorizationResponseCodes.PAID&&(await this._setPaymentResult(c.data,!0)?(this.state===d.COMMITED||this.state===d.REFUNDABLE)&&await this._saveAndEmit(d.SOFT_CLAIMED):c={code:f.RefundAuthorizationResponseCodes.PENDING,msg:""}),(c.code===f.RefundAuthorizationResponseCodes.PENDING||c.code===f.RefundAuthorizationResponseCodes.NOT_FOUND)&&await (0,h.timeoutPromise)(1e3*b,a);return c}async checkIntermediarySwapProcessed(a=!0){if(this.state===d.CREATED||this.state==d.QUOTE_EXPIRED)return!1;if(this.isFinished()||this.isRefundable())return!0;let b=await f.IntermediaryAPI.getRefundAuthorization(this.url,this.getLpIdentifier(),this.data.getSequence());switch(b.code){case f.RefundAuthorizationResponseCodes.PAID:let c=await this._setPaymentResult(b.data,!0);return c&&(this.state=d.SOFT_CLAIMED,a&&await this._saveAndEmit()),c;case f.RefundAuthorizationResponseCodes.REFUND_DATA:return await (0,h.tryWithRetries)(()=>this.wrapper.contract.isValidRefundAuthorization(this.data,b.data),null,e.SignatureVerificationError),this.state=d.REFUNDABLE,a&&await this._saveAndEmit(),!0;default:return!1}}async waitForPayment(a,b){if(this.state===d.CLAIMED)return Promise.resolve(!0);if(this.state!==d.COMMITED&&this.state!==d.SOFT_CLAIMED)throw Error("Invalid state (not COMMITED)");let c=(0,h.extendAbortController)(a),i=await Promise.race([this.waitTillState(d.CLAIMED,"gte",c.signal),this.waitTillIntermediarySwapProcessed(c.signal,b)]);if(c.abort(),"object"!=typeof i){if(this.state===d.REFUNDABLE)throw Error("Swap expired");return this.logger.debug("waitTillRefunded(): Resolved from state change"),!0}switch(this.logger.debug("waitTillRefunded(): Resolved from intermediary response"),i.code){case f.RefundAuthorizationResponseCodes.PAID:return!0;case f.RefundAuthorizationResponseCodes.REFUND_DATA:return await (0,h.tryWithRetries)(()=>this.wrapper.contract.isValidRefundAuthorization(this.data,i.data),null,e.SignatureVerificationError,a),await this._saveAndEmit(d.REFUNDABLE),!1;case f.RefundAuthorizationResponseCodes.EXPIRED:if(await this.wrapper.contract.isExpired(this._getInitiator(),this.data))throw Error("Swap expired");throw new g.IntermediaryError("Swap expired");case f.RefundAuthorizationResponseCodes.NOT_FOUND:if(this.state===d.CLAIMED)return!0;throw Error("Intermediary swap not found")}}getRefundFee(){return this.wrapper.contract.getRefundFee(this.data)}async txsRefund(a){if(!this.isRefundable())throw Error("Must be in REFUNDABLE state or expired!");if(a??=this._getInitiator(),await this.wrapper.contract.isExpired(this._getInitiator(),this.data))return await this.wrapper.contract.txsRefund(a,this.data,!0,!0);{let b=await f.IntermediaryAPI.getRefundAuthorization(this.url,this.getLpIdentifier(),this.data.getSequence());if(b.code===f.RefundAuthorizationResponseCodes.REFUND_DATA)return await this.wrapper.contract.txsRefundWithAuthorization(a,this.data,b.data,!0,!0);throw new g.IntermediaryError("Invalid intermediary cooperative message returned")}}async refund(a,b){let c=await this.wrapper.chain.sendAndConfirm(a,await this.txsRefund(a.getAddress()),!0,b);return this.refundTxId=c[0],(this.state===d.COMMITED||this.state===d.REFUNDABLE||this.state===d.SOFT_CLAIMED)&&await this._saveAndEmit(d.REFUNDED),c[0]}async waitTillRefunded(a){if(this.state===d.REFUNDED)return Promise.resolve();if(this.state!==d.COMMITED&&this.state!==d.SOFT_CLAIMED)throw Error("Invalid state (not COMMITED)");let b=new AbortController;null!=a&&a.addEventListener("abort",()=>b.abort(a.reason));let c=await Promise.race([this.watchdogWaitTillResult(b.signal),this.waitTillState(d.REFUNDED,"eq",b.signal).then(()=>0),this.waitTillState(d.CLAIMED,"eq",b.signal).then(()=>1)]);if(b.abort(),0===c)return void this.logger.debug("waitTillRefunded(): Resolved from state change (REFUNDED)");if(1===c)throw this.logger.debug("waitTillRefunded(): Resolved from state change (CLAIMED)"),Error("Tried to refund swap, but claimer claimed it in the meantime!");if(this.logger.debug("waitTillRefunded(): Resolved from watchdog"),c?.type===e.SwapCommitStateType.PAID)throw null==this.claimTxId&&(this.claimTxId=await c.getClaimTxId()),await this._saveAndEmit(d.CLAIMED),Error("Tried to refund swap, but claimer claimed it in the meantime!");c?.type===e.SwapCommitStateType.NOT_COMMITED&&(null==this.refundTxId&&null!=c.getRefundTxId&&(this.refundTxId=await c.getRefundTxId()),await this._saveAndEmit(d.REFUNDED))}serialize(){return{...super.serialize(),networkFee:null==this.networkFee?null:this.networkFee.toString(10),networkFeeBtc:null==this.networkFeeBtc?null:this.networkFeeBtc.toString(10)}}async syncStateFromChain(){if(this.state===d.CREATED||this.state===d.QUOTE_SOFT_EXPIRED||this.state===d.COMMITED||this.state===d.SOFT_CLAIMED||this.state===d.REFUNDABLE){let a=!1;(this.state===d.CREATED||this.state===d.QUOTE_SOFT_EXPIRED)&&(a=await this.verifyQuoteDefinitelyExpired());let b=await (0,h.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(b?.type){case e.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await b.getClaimTxId()),this.state=d.CLAIMED,!0;case e.SwapCommitStateType.REFUNDABLE:return this.state=d.REFUNDABLE,!0;case e.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&b.getRefundTxId&&(this.refundTxId=await b.getRefundTxId()),this.state=d.QUOTE_EXPIRED,!0;case e.SwapCommitStateType.NOT_COMMITED:if(null==this.refundTxId&&b.getRefundTxId&&(this.refundTxId=await b.getRefundTxId()),this.state===d.COMMITED||this.state===d.REFUNDABLE)return this.state=d.REFUNDED,!0;break;case e.SwapCommitStateType.COMMITED:if(this.state!==d.COMMITED&&this.state!==d.REFUNDABLE)return this.state=d.COMMITED,!0}if((this.state===d.CREATED||this.state===d.QUOTE_SOFT_EXPIRED)&&a)return this.state=d.QUOTE_EXPIRED,!0}}async _sync(a){let b=await this.syncStateFromChain();return(this.state===d.COMMITED||this.state===d.SOFT_CLAIMED)&&await this.checkIntermediarySwapProcessed(!1)&&(b=!0),a&&b&&await this._saveAndEmit(),b}async _tick(a){switch(this.state){case d.CREATED:if(this.expiry<Date.now())return this.state=d.QUOTE_SOFT_EXPIRED,a&&await this._saveAndEmit(),!0;break;case d.COMMITED:case d.SOFT_CLAIMED:if(await this.wrapper.contract.isExpired(this._getInitiator(),this.data))return this.state=d.REFUNDABLE,a&&await this._saveAndEmit(),!0}return!1}}c.IToBTCSwap=n,function(a){a[a.REFUNDED=-3]="REFUNDED",a[a.QUOTE_EXPIRED=-2]="QUOTE_EXPIRED",a[a.QUOTE_SOFT_EXPIRED=-1]="QUOTE_SOFT_EXPIRED",a[a.CREATED=0]="CREATED",a[a.COMMITED=1]="COMMITED",a[a.SOFT_CLAIMED=2]="SOFT_CLAIMED",a[a.CLAIMED=3]="CLAIMED",a[a.REFUNDABLE=4]="REFUNDABLE"}(d=c.ToBTCSwapState||(c.ToBTCSwapState={}))},353301,(a,b,c)=>{"use strict";function d(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name}function e(a){if("boolean"!=typeof a)throw Error(`boolean expected, not ${a}`)}function f(a){if(!Number.isSafeInteger(a)||a<0)throw Error("positive integer expected, got "+a)}function g(a,...b){if(!d(a))throw Error("Uint8Array expected");if(b.length>0&&!b.includes(a.length))throw Error("Uint8Array expected of length "+b+", got length="+a.length)}function h(a){return new DataView(a.buffer,a.byteOffset,a.byteLength)}Object.defineProperty(c,"__esModule",{value:!0}),c.wrapCipher=c.Hash=c.nextTick=c.isLE=void 0,c.isBytes=d,c.abool=e,c.anumber=f,c.abytes=g,c.ahash=function(a){if("function"!=typeof a||"function"!=typeof a.create)throw Error("Hash should be wrapped by utils.createHasher");f(a.outputLen),f(a.blockLen)},c.aexists=function(a,b=!0){if(a.destroyed)throw Error("Hash instance has been destroyed");if(b&&a.finished)throw Error("Hash#digest() has already been called")},c.aoutput=function(a,b){g(a);let c=b.outputLen;if(a.length<c)throw Error("digestInto() expects output buffer of length at least "+c)},c.u8=function(a){return new Uint8Array(a.buffer,a.byteOffset,a.byteLength)},c.u32=function(a){return new Uint32Array(a.buffer,a.byteOffset,Math.floor(a.byteLength/4))},c.clean=function(...a){for(let b=0;b<a.length;b++)a[b].fill(0)},c.createView=h,c.bytesToHex=k,c.hexToBytes=n,c.hexToNumber=o,c.bytesToNumberBE=function(a){return o(k(a))},c.numberToBytesBE=function(a,b){return n(a.toString(16).padStart(2*b,"0"))},c.utf8ToBytes=p,c.bytesToUtf8=function(a){return new TextDecoder().decode(a)},c.toBytes=function(a){if("string"==typeof a)a=p(a);else if(d(a))a=t(a);else throw Error("Uint8Array expected, got "+typeof a);return a},c.overlapBytes=q,c.complexOverlapBytes=function(a,b){if(q(a,b)&&a.byteOffset<b.byteOffset)throw Error("complex overlap of input and output is not supported")},c.concatBytes=function(...a){let b=0;for(let c=0;c<a.length;c++){let d=a[c];g(d),b+=d.length}let c=new Uint8Array(b);for(let b=0,d=0;b<a.length;b++){let e=a[b];c.set(e,d),d+=e.length}return c},c.checkOpts=function(a,b){if(null==b||"object"!=typeof b)throw Error("options must be defined");return Object.assign(a,b)},c.equalBytes=function(a,b){if(a.length!==b.length)return!1;let c=0;for(let d=0;d<a.length;d++)c|=a[d]^b[d];return 0===c},c.getOutput=function(a,b,c=!0){if(void 0===b)return new Uint8Array(a);if(b.length!==a)throw Error("invalid output length, expected "+a+", got: "+b.length);if(c&&!s(b))throw Error("invalid output, must be aligned");return b},c.setBigUint64=r,c.u64Lengths=function(a,b,c){e(c);let d=new Uint8Array(16),f=h(d);return r(f,0,BigInt(b),c),r(f,8,BigInt(a),c),d},c.isAligned32=s,c.copyBytes=t,c.isLE=68===new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];let i="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,j=Array.from({length:256},(a,b)=>b.toString(16).padStart(2,"0"));function k(a){if(g(a),i)return a.toHex();let b="";for(let c=0;c<a.length;c++)b+=j[a[c]];return b}let l={_0:48,_9:57,A:65,F:70,a:97,f:102};function m(a){return a>=l._0&&a<=l._9?a-l._0:a>=l.A&&a<=l.F?a-(l.A-10):a>=l.a&&a<=l.f?a-(l.a-10):void 0}function n(a){if("string"!=typeof a)throw Error("hex string expected, got "+typeof a);if(i)return Uint8Array.fromHex(a);let b=a.length,c=b/2;if(b%2)throw Error("hex string expected, got unpadded hex of length "+b);let d=new Uint8Array(c);for(let b=0,e=0;b<c;b++,e+=2){let c=m(a.charCodeAt(e)),f=m(a.charCodeAt(e+1));if(void 0===c||void 0===f)throw Error('hex string expected, got non-hex character "'+(a[e]+a[e+1])+'" at index '+e);d[b]=16*c+f}return d}function o(a){if("string"!=typeof a)throw Error("hex string expected, got "+typeof a);return BigInt(""===a?"0":"0x"+a)}function p(a){if("string"!=typeof a)throw Error("string expected");return new Uint8Array(new TextEncoder().encode(a))}function q(a,b){return a.buffer===b.buffer&&a.byteOffset<b.byteOffset+b.byteLength&&b.byteOffset<a.byteOffset+a.byteLength}function r(a,b,c,d){if("function"==typeof a.setBigUint64)return a.setBigUint64(b,c,d);let e=BigInt(32),f=BigInt(0xffffffff),g=Number(c>>e&f),h=Number(c&f),i=4*!!d,j=4*!d;a.setUint32(b+i,g,d),a.setUint32(b+j,h,d)}function s(a){return a.byteOffset%4==0}function t(a){return Uint8Array.from(a)}c.nextTick=async()=>{},c.Hash=class{},c.wrapCipher=(a,b)=>{function d(e,...f){if(g(e),!c.isLE)throw Error("Non little-endian hardware is not yet supported");if(void 0!==a.nonceLength){let b=f[0];if(!b)throw Error("nonce / iv required");a.varSizeNonce?g(b):g(b,a.nonceLength)}let h=a.tagLength;h&&void 0!==f[1]&&g(f[1]);let i=b(e,...f),j=(a,b)=>{if(void 0!==b){if(2!==a)throw Error("cipher output not supported");g(b)}},k=!1;return{encrypt(a,b){if(k)throw Error("cannot encrypt() twice with same key + nonce");return k=!0,g(a),j(i.encrypt.length,b),i.encrypt(a,b)},decrypt(a,b){if(g(a),h&&a.length<h)throw Error("invalid ciphertext length: smaller than tagLength="+h);return j(i.decrypt.length,b),i.decrypt(a,b)}}}return Object.assign(d,a),d}},291498,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.polyval=c.ghash=void 0,c._toGHASHKey=i;let d=a.r(353301),e=new Uint8Array(16),f=(0,d.u32)(e),g=(a,b,c,d)=>({s3:c<<31|d>>>1,s2:b<<31|c>>>1,s1:a<<31|b>>>1,s0:a>>>1^-0x1f000000&-(1&d&1)}),h=a=>(a>>>0&255)<<24|(a>>>8&255)<<16|(a>>>16&255)<<8|a>>>24&255;function i(a){a.reverse();let b=1&a[15],c=0;for(let b=0;b<a.length;b++){let d=a[b];a[b]=d>>>1|c,c=(1&d)<<7}return a[0]^=225&-b,a}class j{constructor(a,b){this.blockLen=16,this.outputLen=16,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,a=(0,d.toBytes)(a),(0,d.abytes)(a,16);let c=(0,d.createView)(a),e=c.getUint32(0,!1),f=c.getUint32(4,!1),i=c.getUint32(8,!1),j=c.getUint32(12,!1),k=[];for(let a=0;a<128;a++)k.push({s0:h(e),s1:h(f),s2:h(i),s3:h(j)}),{s0:e,s1:f,s2:i,s3:j}=g(e,f,i,j);let l=(a=>a>65536?8:a>1024?4:2)(b||1024);if(![1,2,4,8].includes(l))throw Error("ghash: invalid window size, expected 2, 4 or 8");this.W=l;let m=128/l,n=this.windowSize=2**l,o=[];for(let a=0;a<m;a++)for(let b=0;b<n;b++){let c=0,d=0,e=0,f=0;for(let g=0;g<l;g++){if(!(b>>>l-g-1&1))continue;let{s0:h,s1:i,s2:j,s3:m}=k[l*a+g];c^=h,d^=i,e^=j,f^=m}o.push({s0:c,s1:d,s2:e,s3:f})}this.t=o}_updateBlock(a,b,c,d){a^=this.s0,b^=this.s1,c^=this.s2,d^=this.s3;let{W:e,t:f,windowSize:g}=this,h=0,i=0,j=0,k=0,l=(1<<e)-1,m=0;for(let n of[a,b,c,d])for(let a=0;a<4;a++){let b=n>>>8*a&255;for(let a=8/e-1;a>=0;a--){let{s0:c,s1:d,s2:n,s3:o}=f[m*g+(b>>>e*a&l)];h^=c,i^=d,j^=n,k^=o,m+=1}}this.s0=h,this.s1=i,this.s2=j,this.s3=k}update(a){(0,d.aexists)(this),a=(0,d.toBytes)(a),(0,d.abytes)(a);let b=(0,d.u32)(a),c=Math.floor(a.length/16),g=a.length%16;for(let a=0;a<c;a++)this._updateBlock(b[4*a+0],b[4*a+1],b[4*a+2],b[4*a+3]);return g&&(e.set(a.subarray(16*c)),this._updateBlock(f[0],f[1],f[2],f[3]),(0,d.clean)(f)),this}destroy(){let{t:a}=this;for(let b of a)b.s0=0,b.s1=0,b.s2=0,b.s3=0}digestInto(a){(0,d.aexists)(this),(0,d.aoutput)(a,this),this.finished=!0;let{s0:b,s1:c,s2:e,s3:f}=this,g=(0,d.u32)(a);return g[0]=b,g[1]=c,g[2]=e,g[3]=f,a}digest(){let a=new Uint8Array(16);return this.digestInto(a),this.destroy(),a}}class k extends j{constructor(a,b){a=(0,d.toBytes)(a),(0,d.abytes)(a);let c=i((0,d.copyBytes)(a));super(c,b),(0,d.clean)(c)}update(a){a=(0,d.toBytes)(a),(0,d.aexists)(this);let b=(0,d.u32)(a),c=a.length%16,g=Math.floor(a.length/16);for(let a=0;a<g;a++)this._updateBlock(h(b[4*a+3]),h(b[4*a+2]),h(b[4*a+1]),h(b[4*a+0]));return c&&(e.set(a.subarray(16*g)),this._updateBlock(h(f[3]),h(f[2]),h(f[1]),h(f[0])),(0,d.clean)(f)),this}digestInto(a){(0,d.aexists)(this),(0,d.aoutput)(a,this),this.finished=!0;let{s0:b,s1:c,s2:e,s3:f}=this,g=(0,d.u32)(a);return g[0]=b,g[1]=c,g[2]=e,g[3]=f,a.reverse()}}function l(a){let b=(b,c)=>a(c,b.length).update((0,d.toBytes)(b)).digest(),c=a(new Uint8Array(16),0);return b.outputLen=c.outputLen,b.blockLen=c.blockLen,b.create=(b,c)=>a(b,c),b}c.ghash=l((a,b)=>new j(a,b)),c.polyval=l((a,b)=>new k(a,b))},511322,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.unsafe=c.aeskwp=c.aeskw=c.siv=c.gcmsiv=c.gcm=c.cfb=c.cbc=c.ecb=c.ctr=void 0;let d=a.r(291498),e=a.r(353301),f=new Uint8Array(16);function g(a){return a<<1^283&-(a>>7)}function h(a,b){let c=0;for(;b>0;b>>=1)c^=a&-(1&b),a=g(a);return c}let i=(()=>{let a=new Uint8Array(256);for(let b=0,c=1;b<256;b++,c^=g(c))a[b]=c;let b=new Uint8Array(256);b[0]=99;for(let c=0;c<255;c++){let d=a[255-c];d|=d<<8,b[a[c]]=(d^d>>4^d>>5^d>>6^d>>7^99)&255}return(0,e.clean)(a),b})(),j=i.map((a,b)=>i.indexOf(b)),k=a=>a<<24|a>>>8,l=a=>a<<8|a>>>24,m=a=>a<<24&0xff000000|a<<8&0xff0000|a>>>8&65280|a>>>24&255;function n(a,b){if(256!==a.length)throw Error("Wrong sbox length");let c=new Uint32Array(256).map((c,d)=>b(a[d])),d=c.map(l),e=d.map(l),f=e.map(l),g=new Uint32Array(65536),h=new Uint32Array(65536),i=new Uint16Array(65536);for(let b=0;b<256;b++)for(let j=0;j<256;j++){let k=256*b+j;g[k]=c[b]^d[j],h[k]=e[b]^f[j],i[k]=a[b]<<8|a[j]}return{sbox:a,sbox2:i,T0:c,T1:d,T2:e,T3:f,T01:g,T23:h}}let o=n(i,a=>h(a,3)<<24|a<<16|a<<8|h(a,2)),p=n(j,a=>h(a,11)<<24|h(a,13)<<16|h(a,9)<<8|h(a,14)),q=(()=>{let a=new Uint8Array(16);for(let b=0,c=1;b<16;b++,c=g(c))a[b]=c;return a})();function r(a){(0,e.abytes)(a);let b=a.length;if(![16,24,32].includes(b))throw Error("aes: invalid key size, should be 16, 24 or 32, got "+b);let{sbox2:c}=o,d=[];(0,e.isAligned32)(a)||d.push(a=(0,e.copyBytes)(a));let f=(0,e.u32)(a),g=f.length,h=a=>u(c,a,a,a,a),i=new Uint32Array(b+28);i.set(f);for(let a=g;a<i.length;a++){let b=i[a-1];a%g==0?b=h(k(b))^q[a/g-1]:g>6&&a%g==4&&(b=h(b)),i[a]=i[a-g]^b}return(0,e.clean)(...d),i}function s(a){let b=r(a),c=b.slice(),d=b.length,{sbox2:f}=o,{T0:g,T1:h,T2:i,T3:j}=p;for(let a=0;a<d;a+=4)for(let e=0;e<4;e++)c[a+e]=b[d-a-4+e];(0,e.clean)(b);for(let a=4;a<d-4;a++){let b=c[a],d=u(f,b,b,b,b);c[a]=g[255&d]^h[d>>>8&255]^i[d>>>16&255]^j[d>>>24]}return c}function t(a,b,c,d,e,f){return a[c<<8&65280|d>>>8&255]^b[e>>>8&65280|f>>>24&255]}function u(a,b,c,d,e){return a[255&b|65280&c]|a[d>>>16&255|e>>>16&65280]<<16}function v(a,b,c,d,e){let{sbox2:f,T01:g,T23:h}=o,i=0;b^=a[i++],c^=a[i++],d^=a[i++],e^=a[i++];let j=a.length/4-2;for(let f=0;f<j;f++){let f=a[i++]^t(g,h,b,c,d,e),j=a[i++]^t(g,h,c,d,e,b),k=a[i++]^t(g,h,d,e,b,c),l=a[i++]^t(g,h,e,b,c,d);b=f,c=j,d=k,e=l}let k=a[i++]^u(f,b,c,d,e),l=a[i++]^u(f,c,d,e,b);return{s0:k,s1:l,s2:a[i++]^u(f,d,e,b,c),s3:a[i++]^u(f,e,b,c,d)}}function w(a,b,c,d,e){let{sbox2:f,T01:g,T23:h}=p,i=0;b^=a[i++],c^=a[i++],d^=a[i++],e^=a[i++];let j=a.length/4-2;for(let f=0;f<j;f++){let f=a[i++]^t(g,h,b,e,d,c),j=a[i++]^t(g,h,c,b,e,d),k=a[i++]^t(g,h,d,c,b,e),l=a[i++]^t(g,h,e,d,c,b);b=f,c=j,d=k,e=l}let k=a[i++]^u(f,b,e,d,c),l=a[i++]^u(f,c,b,e,d);return{s0:k,s1:l,s2:a[i++]^u(f,d,c,b,e),s3:a[i++]^u(f,e,d,c,b)}}function x(a,b,c,d){(0,e.abytes)(b,16),(0,e.abytes)(c);let f=c.length;d=(0,e.getOutput)(f,d),(0,e.complexOverlapBytes)(c,d);let g=(0,e.u32)(b),{s0:h,s1:i,s2:j,s3:k}=v(a,g[0],g[1],g[2],g[3]),l=(0,e.u32)(c),m=(0,e.u32)(d);for(let c=0;c+4<=l.length;c+=4){m[c+0]=l[c+0]^h,m[c+1]=l[c+1]^i,m[c+2]=l[c+2]^j,m[c+3]=l[c+3]^k;let d=1;for(let a=b.length-1;a>=0;a--)d=d+(255&b[a])|0,b[a]=255&d,d>>>=8;({s0:h,s1:i,s2:j,s3:k}=v(a,g[0],g[1],g[2],g[3]))}let n=16*Math.floor(l.length/4);if(n<f){let a=new Uint32Array([h,i,j,k]),b=(0,e.u8)(a);for(let a=n,e=0;a<f;a++,e++)d[a]=c[a]^b[e];(0,e.clean)(a)}return d}function y(a,b,c,d,f){(0,e.abytes)(c,16),(0,e.abytes)(d),f=(0,e.getOutput)(d.length,f);let g=(0,e.u32)(c),h=(0,e.createView)(c),i=(0,e.u32)(d),j=(0,e.u32)(f),k=12*!b,l=d.length,m=h.getUint32(k,b),{s0:n,s1:o,s2:p,s3:q}=v(a,g[0],g[1],g[2],g[3]);for(let c=0;c+4<=i.length;c+=4)j[c+0]=i[c+0]^n,j[c+1]=i[c+1]^o,j[c+2]=i[c+2]^p,j[c+3]=i[c+3]^q,m=m+1>>>0,h.setUint32(k,m,b),{s0:n,s1:o,s2:p,s3:q}=v(a,g[0],g[1],g[2],g[3]);let r=16*Math.floor(i.length/4);if(r<l){let a=new Uint32Array([n,o,p,q]),b=(0,e.u8)(a);for(let a=r,c=0;a<l;a++,c++)f[a]=d[a]^b[c];(0,e.clean)(a)}return f}function z(a){if((0,e.abytes)(a),a.length%16!=0)throw Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size 16")}function A(a,b,c){(0,e.abytes)(a);let d=a.length,f=d%16;if(!b&&0!==f)throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");(0,e.isAligned32)(a)||(a=(0,e.copyBytes)(a));let g=(0,e.u32)(a);if(b){let a=16-f;a||(a=16),d+=a}return c=(0,e.getOutput)(d,c),(0,e.complexOverlapBytes)(a,c),{b:g,o:(0,e.u32)(c),out:c}}function B(a,b){if(!b)return a;let c=a.length;if(!c)throw Error("aes/pcks5: empty ciphertext not allowed");let d=a[c-1];if(d<=0||d>16)throw Error("aes/pcks5: wrong padding");let e=a.subarray(0,-d);for(let b=0;b<d;b++)if(a[c-b-1]!==d)throw Error("aes/pcks5: wrong padding");return e}function C(a){let b=new Uint8Array(16),c=(0,e.u32)(b);b.set(a);let d=16-a.length;for(let a=16-d;a<16;a++)b[a]=d;return c}function D(a,b,c,d,f){let g=f?f.length:0,h=a.create(c,d.length+g);f&&h.update(f);let i=(0,e.u64Lengths)(8*d.length,8*g,b);h.update(d),h.update(i);let j=h.digest();return(0,e.clean)(i),j}c.ctr=(0,e.wrapCipher)({blockSize:16,nonceLength:16},function(a,b){function c(c,d){if((0,e.abytes)(c),void 0!==d&&((0,e.abytes)(d),!(0,e.isAligned32)(d)))throw Error("unaligned destination");let f=r(a),g=(0,e.copyBytes)(b),h=[f,g];(0,e.isAligned32)(c)||h.push(c=(0,e.copyBytes)(c));let i=x(f,g,c,d);return(0,e.clean)(...h),i}return{encrypt:(a,b)=>c(a,b),decrypt:(a,b)=>c(a,b)}}),c.ecb=(0,e.wrapCipher)({blockSize:16},function(a,b={}){let c=!b.disablePadding;return{encrypt(b,d){let{b:f,o:g,out:h}=A(b,c,d),i=r(a),j=0;for(;j+4<=f.length;){let{s0:a,s1:b,s2:c,s3:d}=v(i,f[j+0],f[j+1],f[j+2],f[j+3]);g[j++]=a,g[j++]=b,g[j++]=c,g[j++]=d}if(c){let a=C(b.subarray(4*j)),{s0:c,s1:d,s2:e,s3:f}=v(i,a[0],a[1],a[2],a[3]);g[j++]=c,g[j++]=d,g[j++]=e,g[j++]=f}return(0,e.clean)(i),h},decrypt(b,d){z(b);let f=s(a);d=(0,e.getOutput)(b.length,d);let g=[f];(0,e.isAligned32)(b)||g.push(b=(0,e.copyBytes)(b)),(0,e.complexOverlapBytes)(b,d);let h=(0,e.u32)(b),i=(0,e.u32)(d);for(let a=0;a+4<=h.length;){let{s0:b,s1:c,s2:d,s3:e}=w(f,h[a+0],h[a+1],h[a+2],h[a+3]);i[a++]=b,i[a++]=c,i[a++]=d,i[a++]=e}return(0,e.clean)(...g),B(d,c)}}}),c.cbc=(0,e.wrapCipher)({blockSize:16,nonceLength:16},function(a,b,c={}){let d=!c.disablePadding;return{encrypt(c,f){let g=r(a),{b:h,o:i,out:j}=A(c,d,f),k=b,l=[g];(0,e.isAligned32)(k)||l.push(k=(0,e.copyBytes)(k));let m=(0,e.u32)(k),n=m[0],o=m[1],p=m[2],q=m[3],s=0;for(;s+4<=h.length;)n^=h[s+0],o^=h[s+1],p^=h[s+2],q^=h[s+3],({s0:n,s1:o,s2:p,s3:q}=v(g,n,o,p,q)),i[s++]=n,i[s++]=o,i[s++]=p,i[s++]=q;if(d){let a=C(c.subarray(4*s));n^=a[0],o^=a[1],p^=a[2],q^=a[3],({s0:n,s1:o,s2:p,s3:q}=v(g,n,o,p,q)),i[s++]=n,i[s++]=o,i[s++]=p,i[s++]=q}return(0,e.clean)(...l),j},decrypt(c,f){z(c);let g=s(a),h=b,i=[g];(0,e.isAligned32)(h)||i.push(h=(0,e.copyBytes)(h));let j=(0,e.u32)(h);f=(0,e.getOutput)(c.length,f),(0,e.isAligned32)(c)||i.push(c=(0,e.copyBytes)(c)),(0,e.complexOverlapBytes)(c,f);let k=(0,e.u32)(c),l=(0,e.u32)(f),m=j[0],n=j[1],o=j[2],p=j[3];for(let a=0;a+4<=k.length;){let b=m,c=n,d=o,e=p;m=k[a+0],n=k[a+1];let{s0:f,s1:h,s2:i,s3:j}=w(g,m,n,o=k[a+2],p=k[a+3]);l[a++]=f^b,l[a++]=h^c,l[a++]=i^d,l[a++]=j^e}return(0,e.clean)(...i),B(f,d)}}}),c.cfb=(0,e.wrapCipher)({blockSize:16,nonceLength:16},function(a,b){function c(c,d,f){(0,e.abytes)(c);let g=c.length;if(f=(0,e.getOutput)(g,f),(0,e.overlapBytes)(c,f))throw Error("overlapping src and dst not supported.");let h=r(a),i=b,j=[h];(0,e.isAligned32)(i)||j.push(i=(0,e.copyBytes)(i)),(0,e.isAligned32)(c)||j.push(c=(0,e.copyBytes)(c));let k=(0,e.u32)(c),l=(0,e.u32)(f),m=d?l:k,n=(0,e.u32)(i),o=n[0],p=n[1],q=n[2],s=n[3];for(let a=0;a+4<=k.length;){let{s0:b,s1:c,s2:d,s3:e}=v(h,o,p,q,s);l[a+0]=k[a+0]^b,l[a+1]=k[a+1]^c,l[a+2]=k[a+2]^d,l[a+3]=k[a+3]^e,o=m[a++],p=m[a++],q=m[a++],s=m[a++]}let t=16*Math.floor(k.length/4);if(t<g){({s0:o,s1:p,s2:q,s3:s}=v(h,o,p,q,s));let a=(0,e.u8)(new Uint32Array([o,p,q,s]));for(let b=t,d=0;b<g;b++,d++)f[b]=c[b]^a[d];(0,e.clean)(a)}return(0,e.clean)(...j),f}return{encrypt:(a,b)=>c(a,!0,b),decrypt:(a,b)=>c(a,!1,b)}}),c.gcm=(0,e.wrapCipher)({blockSize:16,nonceLength:12,tagLength:16,varSizeNonce:!0},function(a,b,c){if(b.length<8)throw Error("aes/gcm: invalid nonce length");function g(a,b,e){let f=D(d.ghash,!1,a,e,c);for(let a=0;a<b.length;a++)f[a]^=b[a];return f}function h(){let c=r(a),g=f.slice(),h=f.slice();if(y(c,!1,h,h,g),12===b.length)h.set(b);else{let a=f.slice(),c=(0,e.createView)(a);(0,e.setBigUint64)(c,8,BigInt(8*b.length),!1);let i=d.ghash.create(g).update(b).update(a);i.digestInto(h),i.destroy()}let i=y(c,!1,h,f);return{xk:c,authKey:g,counter:h,tagMask:i}}return{encrypt(a){let{xk:b,authKey:c,counter:d,tagMask:f}=h(),i=new Uint8Array(a.length+16),j=[b,c,d,f];(0,e.isAligned32)(a)||j.push(a=(0,e.copyBytes)(a)),y(b,!1,d,a,i.subarray(0,a.length));let k=g(c,f,i.subarray(0,i.length-16));return j.push(k),i.set(k,a.length),(0,e.clean)(...j),i},decrypt(a){let{xk:b,authKey:c,counter:d,tagMask:f}=h(),i=[b,c,f,d];(0,e.isAligned32)(a)||i.push(a=(0,e.copyBytes)(a));let j=a.subarray(0,-16),k=a.subarray(-16),l=g(c,f,j);if(i.push(l),!(0,e.equalBytes)(l,k))throw Error("aes/gcm: invalid ghash tag");let m=y(b,!1,d,j);return(0,e.clean)(...i),m}}});let E=(a,b,c)=>d=>{if(!Number.isSafeInteger(d)||b>d||d>c)throw Error(""+a+": expected value in range "+("["+b+"..")+c+"], got "+d)};function F(a){return a instanceof Uint32Array||ArrayBuffer.isView(a)&&"Uint32Array"===a.constructor.name}function G(a,b){if((0,e.abytes)(b,16),!F(a))throw Error("_encryptBlock accepts result of expandKeyLE");let c=(0,e.u32)(b),{s0:d,s1:f,s2:g,s3:h}=v(a,c[0],c[1],c[2],c[3]);return c[0]=d,c[1]=f,c[2]=g,c[3]=h,b}function H(a,b){if((0,e.abytes)(b,16),!F(a))throw Error("_decryptBlock accepts result of expandKeyLE");let c=(0,e.u32)(b),{s0:d,s1:f,s2:g,s3:h}=w(a,c[0],c[1],c[2],c[3]);return c[0]=d,c[1]=f,c[2]=g,c[3]=h,b}c.gcmsiv=(0,e.wrapCipher)({blockSize:16,nonceLength:12,tagLength:16,varSizeNonce:!0},function(a,b,c){let f=E("AAD",0,0x1000000000),g=E("plaintext",0,0x1000000000),h=E("nonce",12,12),i=E("ciphertext",16,0x1000000000+16);function j(){let c=r(a),d=new Uint8Array(a.length),f=new Uint8Array(16),g=[c,d],h=b;(0,e.isAligned32)(h)||g.push(h=(0,e.copyBytes)(h));let i=(0,e.u32)(h),j=0,k=i[0],l=i[1],m=i[2],n=0;for(let a of[f,d].map(e.u32)){let b=(0,e.u32)(a);for(let a=0;a<b.length;a+=2){let{s0:d,s1:e}=v(c,j,k,l,m);b[a+0]=d,b[a+1]=e,j=++n}}let o={authKey:f,encKey:r(d)};return(0,e.clean)(...g),o}function k(a,f,g){let h=D(d.polyval,!0,f,g,c);for(let a=0;a<12;a++)h[a]^=b[a];h[15]&=127;let i=(0,e.u32)(h),j=i[0],k=i[1],l=i[2],m=i[3];return{s0:j,s1:k,s2:l,s3:m}=v(a,j,k,l,m),i[0]=j,i[1]=k,i[2]=l,i[3]=m,h}function l(a,b,c){let d=(0,e.copyBytes)(b);d[15]|=128;let f=y(a,!0,d,c);return(0,e.clean)(d),f}return(0,e.abytes)(a,16,24,32),h(b.length),void 0!==c&&f(c.length),{encrypt(a){g(a.length);let{encKey:b,authKey:c}=j(),d=k(b,c,a),f=[b,c,d];(0,e.isAligned32)(a)||f.push(a=(0,e.copyBytes)(a));let h=new Uint8Array(a.length+16);return h.set(d,a.length),h.set(l(b,d,a)),(0,e.clean)(...f),h},decrypt(a){i(a.length);let b=a.subarray(-16),{encKey:c,authKey:d}=j(),f=[c,d];(0,e.isAligned32)(a)||f.push(a=(0,e.copyBytes)(a));let g=l(c,b,a.subarray(0,-16)),h=k(c,d,g);if(f.push(h),!(0,e.equalBytes)(b,h))throw(0,e.clean)(...f),Error("invalid polyval tag");return(0,e.clean)(...f),g}}}),c.siv=c.gcmsiv;let I={encrypt(a,b){if(b.length>=0x100000000)throw Error("plaintext should be less than 4gb");let c=r(a);if(16===b.length)G(c,b);else{let a=(0,e.u32)(b),d=a[0],f=a[1];for(let b=0,e=1;b<6;b++)for(let b=2;b<a.length;b+=2,e++){let{s0:g,s1:h,s2:i,s3:j}=v(c,d,f,a[b],a[b+1]);d=g,f=h^m(e),a[b]=i,a[b+1]=j}a[0]=d,a[1]=f}c.fill(0)},decrypt(a,b){if(b.length-8>=0x100000000)throw Error("ciphertext should be less than 4gb");let c=s(a),d=b.length/8-1;if(1===d)H(c,b);else{let a=(0,e.u32)(b),f=a[0],g=a[1];for(let b=0,e=6*d;b<6;b++)for(let b=2*d;b>=1;b-=2,e--){let{s0:d,s1:h,s2:i,s3:j}=w(c,f,g^=m(e),a[b],a[b+1]);f=d,g=h,a[b]=i,a[b+1]=j}a[0]=f,a[1]=g}c.fill(0)}},J=new Uint8Array(8).fill(166);c.aeskw=(0,e.wrapCipher)({blockSize:8},a=>({encrypt(b){if(!b.length||b.length%8!=0)throw Error("invalid plaintext length");if(8===b.length)throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");let c=(0,e.concatBytes)(J,b);return I.encrypt(a,c),c},decrypt(b){if(b.length%8!=0||b.length<24)throw Error("invalid ciphertext length");let c=(0,e.copyBytes)(b);if(I.decrypt(a,c),!(0,e.equalBytes)(c.subarray(0,8),J))throw Error("integrity check failed");return c.subarray(0,8).fill(0),c.subarray(8)}})),c.aeskwp=(0,e.wrapCipher)({blockSize:8},a=>({encrypt(b){if(!b.length)throw Error("invalid plaintext length");let c=new Uint8Array(8+8*Math.ceil(b.length/8));c.set(b,8);let d=(0,e.u32)(c);return d[0]=0xa65959a6,d[1]=m(b.length),I.encrypt(a,c),c},decrypt(b){if(b.length<16)throw Error("invalid ciphertext length");let c=(0,e.copyBytes)(b),d=(0,e.u32)(c);I.decrypt(a,c);let f=m(d[1])>>>0,g=8*Math.ceil(f/8);if(0xa65959a6!==d[0]||c.length-8!==g)throw Error("integrity check failed");for(let a=f;a<g;a++)if(0!==c[8+a])throw Error("integrity check failed");return c.subarray(0,8).fill(0),c.subarray(8,8+f)}})),c.unsafe={expandKeyLE:r,expandKeyDecLE:s,encrypt:v,decrypt:w,encryptBlock:G,decryptBlock:H,ctrCounter:x,ctr32:y}},314595,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.LNURL=c.MAIL_REGEX=c.BASE64_REGEX=c.isLNURLPaySuccessAction=c.isLNURLPayResult=c.isLNURLWithdrawParams=c.isLNURLPayParams=c.isLNURLError=c.isLNURLWithdraw=c.isLNURLPay=void 0;let d=a.r(570536),e=a.r(518040),f=a.r(339834),g=a.r(213144),h=a.r(67528),i=a.r(511322),j=a.r(500874),k=a.r(404322);function l(a){return"ERROR"===a.status&&(null==a.reason||"string"==typeof a.reason)}function m(a){return"payRequest"===a.tag}function n(a){return"withdrawRequest"===a.tag}function o(a,b){return"string"==typeof a.pr&&(null==a.routes||Array.isArray(a.routes))&&(null===a.disposable||void 0===a.disposable||"boolean"==typeof a.disposable)&&(null==a.successAction||p(a.successAction,b))}function p(a,b){if(null==a||"object"!=typeof a||"string"!=typeof a.tag)return!1;switch(a.tag){case"message":return null!=a.message&&a.message.length<=144;case"url":return null!=a.description&&a.description.length<=144&&null!=a.url&&(null==b||new URL(a.url).hostname===b);case"aes":return null!=a.description&&a.description.length<=144&&null!=a.ciphertext&&a.ciphertext.length<=4096&&c.BASE64_REGEX.test(a.ciphertext)&&null!=a.iv&&a.iv.length<=24&&c.BASE64_REGEX.test(a.iv);default:return!1}}c.isLNURLPay=function(a){return"object"==typeof a&&null!=a&&"pay"===a.type&&"bigint"==typeof a.min&&"bigint"==typeof a.max&&"number"==typeof a.commentMaxLength&&"string"==typeof a.shortDescription&&(void 0===a.longDescription||"string"==typeof a.longDescription)&&(void 0===a.icon||"string"==typeof a.icon)&&m(a.params)},c.isLNURLWithdraw=function(a){return"object"==typeof a&&null!=a&&"withdraw"===a.type&&"bigint"==typeof a.min&&"bigint"==typeof a.max&&n(a.params)},c.isLNURLError=l,c.isLNURLPayParams=m,c.isLNURLWithdrawParams=n,c.isLNURLPayResult=o,c.isLNURLPaySuccessAction=p,c.BASE64_REGEX=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,c.MAIL_REGEX=/(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[A-z0-9](?:[A-z0-9-]*[A-z0-9])?\.)+[A-z0-9](?:[A-z0-9-]*[A-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[A-z0-9-]*[A-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/;class q{static findBech32LNURL(a){let b=/,*?((lnurl)([0-9]{1,}[a-z0-9]+){1})/.exec(a.toLowerCase());return null==b?null:b[1]}static isBech32LNURL(a){return null!=this.findBech32LNURL(a)}static isBareLNURL(a){try{return a.startsWith("lnurlw://")||a.startsWith("lnurlp://")}catch(a){}return!1}static isLightningAddress(a){return c.MAIL_REGEX.test(a)}static isLNURL(a){return q.isBech32LNURL(a)||q.isLightningAddress(a)||q.isBareLNURL(a)}static extractCallUrl(a){if(c.MAIL_REGEX.test(a)){let b=a.split("@"),c=b[0],d=b[1],e="https";return d.endsWith(".onion")&&(e="http"),e+"://"+d+"/.well-known/lnurlp/"+c}if(q.isBareLNURL(a)){let b=a.substring(9),c=new URL("http://"+b),d="https";return c.hostname.endsWith(".onion")&&(d="http"),d+"://"+b}{let b=q.findBech32LNURL(a);if(null!=b){let{prefix:a,words:c}=h.bech32.decode(b,2e3),d=h.bech32.fromWords(c);return j.Buffer.from(d).toString()}}return null}static async getLNURL(a,b=!0,c,e){null==b&&(b=!0);let f=q.extractCallUrl(a);if(null!=f){let h=()=>(0,g.httpGet)(f,c,e,!0),i=b?await (0,g.tryWithRetries)(h,null,d.RequestError,e):await h();if(l(i))return null;if("payRequest"===i.tag)try{i.decodedMetadata=JSON.parse(i.metadata)}catch(a){i.decodedMetadata=[]}return m(i)||n(i)?{...i,url:a}:null}}static async getLNURLType(a,b,c,d){let e=await q.getLNURL(a,b,c,d);if("payRequest"===e.tag){let a,b,c;return e.decodedMetadata.forEach(d=>{switch(d[0]){case"text/plain":a=d[1];break;case"text/long-desc":b=d[1];break;case"image/png;base64":case"image/jpeg;base64":c="data:"+d[0]+","+d[1]}}),{type:"pay",min:BigInt(e.minSendable)/1000n,max:BigInt(e.maxSendable)/1000n,commentMaxLength:e.commentAllowed||0,shortDescription:a,longDescription:b,icon:c,params:e}}return"withdrawRequest"===e.tag?{type:"withdraw",min:BigInt(e.minWithdrawable)/1000n,max:BigInt(e.maxWithdrawable)/1000n,params:e}:null}static async useLNURLPay(a,b,c,f,h){let i=["amount="+(1000n*b).toString(10)];null!=c&&i.push("comment="+encodeURIComponent(c));let m=(a.callback.includes("?")?"&":"?")+i.join("&"),n=await (0,g.tryWithRetries)(()=>(0,g.httpGet)(a.callback+m,f,h,!0),null,d.RequestError,h);if(l(n))throw new d.RequestError("LNURL callback error: "+n.reason,200);if(!o(n))throw new d.RequestError("Invalid LNURL response!",200);let p=(0,e.decode)(n.pr),q=j.Buffer.from((0,k.sha256)(a.metadata)).toString("hex");if(p.tagsObject.purpose_commit_hash!==q)throw new d.RequestError("Invalid invoice received (description hash)!",200);if(BigInt(p.millisatoshis)!==1000n*b)throw new d.RequestError("Invalid invoice received (amount)!",200);return{invoice:n.pr,parsedInvoice:p,successAction:n.successAction}}static async postInvoiceToLNURLWithdraw(a,b){let c=["pr="+b,"k1="+a.k1],e=(a.callback.includes("?")?"&":"?")+c.join("&"),f=await (0,g.tryWithRetries)(()=>(0,g.httpGet)(a.callback+e,null,null,!0),null,d.RequestError);if(l(f))throw new d.RequestError("LNURL callback error: "+f.reason,200)}static async useLNURLWithdraw(a,b){let c=BigInt(a.minWithdrawable)/1000n,d=BigInt(a.maxWithdrawable)/1000n,g=(BigInt((0,e.decode)(b).millisatoshis)+999n)/1000n;if(g<c)throw new f.UserError("Invoice amount less than minimum LNURL-withdraw limit");if(g>d)throw new f.UserError("Invoice amount more than maximum LNURL-withdraw limit");return await q.postInvoiceToLNURLWithdraw(a,b)}static decodeSuccessAction(a,b){if(null==b)return null;if("message"===a.tag)return{description:a.message};if("url"===a.tag)return{description:a.description,url:a.url};if("aes"===a.tag){let c=(0,i.cbc)(j.Buffer.from(b,"hex"),j.Buffer.from(a.iv,"hex")).decrypt(j.Buffer.from(a.ciphertext,"base64")),d=c.length,e=c[d-1];return{description:a.description,text:j.Buffer.from(c).toString("utf8",0,d-e)}}}}c.LNURL=q},171877,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ToBTCLNSwap=c.isToBTCLNSwapInit=void 0;let d=a.r(518040),e=a.r(806361),f=a.r(813954),g=a.r(500874),h=a.r(404322),i=a.r(974727),j=a.r(314595),k=a.r(294982),l=a.r(213144);function m(a){return"number"==typeof a.confidence&&"string"==typeof a.pr&&(null==a.lnurl||"string"==typeof a.lnurl)&&(null==a.successAction||(0,j.isLNURLPaySuccessAction)(a.successAction))&&(0,e.isIToBTCSwapInit)(a)}c.isToBTCLNSwapInit=m;let n=new Set(["038f8f113c580048d847d6949371726653e02b928196bad310e3eda39ff61723f6","03a6ce61fcaacd38d31d4e3ce2d506602818e3856b4b44faff1dde9642ba705976"]);class o extends e.IToBTCSwap{constructor(a,b){m(b)&&(b.url+="/tobtcln"),super(a,b),this.outputToken=k.BitcoinTokens.BTCLN,this.TYPE=f.SwapType.TO_BTCLN,m(b)||(this.confidence=b.confidence,this.pr=b.pr,this.lnurl=b.lnurl,this.successAction=b.successAction,this.secret=b.secret),this.paymentHash=this.getPaymentHash().toString("hex"),this.logger=(0,l.getLogger)("ToBTCLN("+this.getIdentifierHashString()+"): "),this.tryRecomputeSwapPrice()}_setPaymentResult(a,b=!1){if(null==a)return Promise.resolve(!1);if(null==a.secret)throw new i.IntermediaryError("No payment secret returned!");if(b){let b=g.Buffer.from(a.secret,"hex");if(!g.Buffer.from((0,h.sha256)(b)).equals(this.getPaymentHash()))throw new i.IntermediaryError("Invalid payment secret returned")}return this.secret=a.secret,Promise.resolve(!0)}getOutput(){let a=(BigInt((0,d.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,k.toTokenAmount)(a,this.outputToken,this.wrapper.prices)}getOutputTxId(){return this.getLpIdentifier()}getOutputAddress(){return this.lnurl??this.pr}getSecret(){return this.secret}getConfidence(){return this.confidence}willLikelyFail(){let a=(0,d.decode)(this.pr);if(null!=a.tagsObject.routing_info){for(let b of a.tagsObject.routing_info)if(n.has(b.pubkey))return!1}return 0===this.confidence}isPayingToNonCustodialWallet(){let a=(0,d.decode)(this.pr);return null!=a.tagsObject.routing_info&&a.tagsObject.routing_info.length>0}getIdentifierHash(){let a=this.getPaymentHash();return null==this.randomNonce?a:g.Buffer.concat([a,g.Buffer.from(this.randomNonce,"hex")])}getPaymentHash(){if(null==this.pr)return null;let a=(0,d.decode)(this.pr);return g.Buffer.from(a.tagsObject.payment_hash,"hex")}getLpIdentifier(){return null==this.pr?null:(0,d.decode)(this.pr).tagsObject.payment_hash}isLNURL(){return null!=this.lnurl}getLNURL(){return this.lnurl}hasSuccessAction(){return null!=this.successAction}getSuccessAction(){return j.LNURL.decodeSuccessAction(this.successAction,this.secret)}serialize(){return{...super.serialize(),paymentHash:this.getPaymentHash().toString("hex"),pr:this.pr,confidence:this.confidence,secret:this.secret,lnurl:this.lnurl,successAction:this.successAction}}}c.ToBTCLNSwap=o},333789,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IEscrowSwapWrapper=void 0;let d=a.r(366927),e=a.r(163846),f=a.r(213144);class g extends d.ISwapWrapper{constructor(a,b,c,d,e,f,g,h,i,j){super(a,b,c,d,f,g,i,j),this.swapDataDeserializer=h,this.contract=e}preFetchSignData(a){return null==this.contract.preFetchForInitSignatureVerification?Promise.resolve(null):a.then(a=>null==a?null:this.contract.preFetchForInitSignatureVerification(a)).catch(a=>(this.logger.error("preFetchSignData(): Error: ",a),null))}async verifyReturnedSignature(a,b,c,d,g,h){let[i,j]=await Promise.all([d,g]);return await (0,f.tryWithRetries)(()=>this.contract.isValidInitAuthorization(a,b,c,i,j),null,e.SignatureVerificationError,h),await (0,f.tryWithRetries)(()=>this.contract.getInitAuthorizationExpiry(b,c,j),null,e.SignatureVerificationError,h)}async processEvent(a,b){if(null==b)return;let c=!1;return a instanceof e.InitializeEvent&&(c=await this.processEventInitialize(b,a),a.meta?.txId!=null&&b.commitTxId!==a.meta.txId&&(b.commitTxId=a.meta.txId,c||=!0)),a instanceof e.ClaimEvent&&(c=await this.processEventClaim(b,a),a.meta?.txId!=null&&b.claimTxId!==a.meta.txId&&(b.claimTxId=a.meta.txId,c||=!0)),a instanceof e.RefundEvent&&(c=await this.processEventRefund(b,a),a.meta?.txId!=null&&b.refundTxId!==a.meta.txId&&(b.refundTxId=a.meta.txId,c||=!0)),this.logger.info("processEvents(): "+a.constructor.name+" processed for "+b.getId()+" swap: ",b),c&&await b._saveAndEmit(),!0}}c.IEscrowSwapWrapper=g},543183,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IToBTCWrapper=void 0;let d=a.r(806361),e=a.r(213144),f=a.r(974727),g=a.r(333789);class h extends g.IEscrowSwapWrapper{constructor(){super(...arguments),this.pendingSwapStates=[d.ToBTCSwapState.CREATED,d.ToBTCSwapState.QUOTE_SOFT_EXPIRED,d.ToBTCSwapState.COMMITED,d.ToBTCSwapState.SOFT_CLAIMED,d.ToBTCSwapState.REFUNDABLE],this.tickSwapState=[d.ToBTCSwapState.CREATED,d.ToBTCSwapState.COMMITED,d.ToBTCSwapState.SOFT_CLAIMED],this.refundableSwapStates=[d.ToBTCSwapState.REFUNDABLE]}preFetchIntermediaryReputation(a,b,c){return b.getReputation(this.chainIdentifier,this.contract,[a.token.toString()],c.signal).then(a=>{if(null==a)throw new f.IntermediaryError("Invalid data returned - invalid LP vault");return a}).catch(a=>(this.logger.warn("preFetchIntermediaryReputation(): Error: ",a),c.abort(a),null))}preFetchFeeRate(a,b,c,d){return(0,e.tryWithRetries)(()=>this.contract.getInitPayInFeeRate(a,null,b.token,c),null,null,d.signal).catch(a=>(this.logger.warn("preFetchFeeRate(): Error: ",a),d.abort(a),null))}async processEventInitialize(a,b){if(a.state===d.ToBTCSwapState.CREATED||a.state===d.ToBTCSwapState.QUOTE_SOFT_EXPIRED){let c=await b.swapData();return(null==a.data||!!a.data.equals(c))&&((a.state===d.ToBTCSwapState.CREATED||a.state===d.ToBTCSwapState.QUOTE_SOFT_EXPIRED)&&(a.state=d.ToBTCSwapState.COMMITED),a.data=c,!0)}}processEventClaim(a,b){return a.state!==d.ToBTCSwapState.REFUNDED&&a.state!==d.ToBTCSwapState.CLAIMED?(a.state=d.ToBTCSwapState.CLAIMED,a._setPaymentResult({secret:b.result,txId:Buffer.from(b.result,"hex").reverse().toString("hex")}),Promise.resolve(!0)):Promise.resolve(!1)}processEventRefund(a,b){return a.state!==d.ToBTCSwapState.CLAIMED&&a.state!==d.ToBTCSwapState.REFUNDED?(a.state=d.ToBTCSwapState.REFUNDED,Promise.resolve(!0)):Promise.resolve(!1)}}c.IToBTCWrapper=h},2697,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ToBTCLNWrapper=void 0;let d=a.r(518040),e=a.r(171877),f=a.r(543183),g=a.r(339834),h=a.r(163846),i=a.r(974727),j=a.r(813954),k=a.r(213144),l=a.r(774702),m=a.r(570536),n=a.r(314595),o=a.r(806361);class p extends f.IToBTCWrapper{constructor(a,b,c,d,f,g,h,i,k,l){null==k&&(k={}),k.paymentTimeoutSeconds??=345600,k.lightningBaseFee??=10,k.lightningFeePPM??=2e3,super(a,b,c,d,f,g,h,i,k,l),this.TYPE=j.SwapType.TO_BTCLN,this.swapDeserializer=e.ToBTCLNSwap}async checkPaymentHashWasPaid(a){for(let b of(await this.unifiedStorage.query([[{key:"type",value:this.TYPE},{key:"paymentHash",value:a}]],a=>new this.swapDeserializer(this,a))))if(b.state===o.ToBTCSwapState.CLAIMED||b.state===o.ToBTCSwapState.SOFT_CLAIMED)throw new g.UserError("Lightning invoice was already paid!")}calculateFeeForAmount(a,b,c){return BigInt(b??this.options.lightningBaseFee)+a*BigInt(c??this.options.lightningFeePPM)/1000000n}async verifyReturnedData(a,b,c,d,e,f,g){if(a.routingFeeSats>await e.maxFee)throw new i.IntermediaryError("Invalid max fee sats returned");if(null!=g&&a.total!==g)throw new i.IntermediaryError("Invalid data returned - total amount");let j=this.contract.getHashForHtlc(Buffer.from(b.tagsObject.payment_hash,"hex"));if(f.getAmount()!==a.total||!Buffer.from(f.getClaimHash(),"hex").equals(j)||f.getExpiry()!==e.expiryTimestamp||f.getType()!==h.ChainSwapType.HTLC||!f.isPayIn()||!f.isToken(c)||f.getClaimer()!==d.getAddress(this.chainIdentifier))throw new i.IntermediaryError("Invalid data returned")}async getIntermediaryQuote(a,b,c,d,f,g,h,i,n){let o=i instanceof AbortController?i:(0,k.extendAbortController)(i);h.reputationPromise??=this.preFetchIntermediaryReputation(b,c,o);try{let{signDataPromise:i,resp:p}=await (0,k.tryWithRetries)(async e=>{let{signDataPrefetch:f,response:i}=l.IntermediaryAPI.initToBTCLN(this.chainIdentifier,c.url,{offerer:a,pr:d,maxFee:await g.maxFee,expiryTimestamp:g.expiryTimestamp,token:b.token,feeRate:h.feeRatePromise,additionalParams:n},this.options.postRequestTimeout,o.signal,!(e>0)&&null);return{signDataPromise:this.preFetchSignData(f),resp:await i}},null,a=>a instanceof m.RequestError,o.signal),q=(BigInt(f.millisatoshis)+999n)/1000n;p.swapFee,p.maxFee;let r=new this.swapDataDeserializer(p.data);r.setOfferer(a),await this.verifyReturnedData(p,f,b.token,c,g,r);let[s,t,u]=await Promise.all([this.verifyReturnedPrice(c.services[j.SwapType.TO_BTCLN],!0,q,r.getAmount(),b.token,{networkFee:p.maxFee},h.pricePreFetchPromise,o.signal),this.verifyReturnedSignature(a,r,p,h.feeRatePromise,i,o.signal),h.reputationPromise]);o.signal.throwIfAborted(),c.reputation[b.token.toString()]=u;let v=new e.ToBTCLNSwap(this,{pricingInfo:s,url:c.url,expiry:t,swapFee:p.swapFee,feeRate:await h.feeRatePromise,signatureData:p,data:r,networkFee:p.maxFee,networkFeeBtc:p.routingFeeSats,confidence:p.confidence,pr:d,exactIn:!1});return await v._save(),v}catch(a){throw o.abort(a),a}}async create(a,b,c,e,f,h,i,j){f??={},f.expirySeconds??=this.options.paymentTimeoutSeconds,f.expiryTimestamp??=BigInt(Math.floor(Date.now()/1e3)+f.expirySeconds);let l=(0,d.decode)(b);if(null==l.millisatoshis)throw new g.UserError("Must be an invoice with amount");let m=(BigInt(l.millisatoshis)+999n)/1000n;f.maxFee??=this.calculateFeeForAmount(m,f.maxRoutingBaseFee,f.maxRoutingPPM),await this.checkPaymentHashWasPaid(l.tagsObject.payment_hash);let n=this.contract.getHashForHtlc(Buffer.from(l.tagsObject.payment_hash,"hex")),o=(0,k.extendAbortController)(i);return null==j&&(j={pricePreFetchPromise:this.preFetchPrice(c,o.signal),feeRatePromise:this.preFetchFeeRate(a,c,n.toString("hex"),o)}),e.map(d=>({intermediary:d,quote:this.getIntermediaryQuote(a,c,d,b,l,f,j,o.signal,h)}))}async getLNURLPay(a,b){if("string"!=typeof a)return a;let c=await n.LNURL.getLNURL(a,!0,this.options.getRequestTimeout,b);if(null==c)throw new g.UserError("Invalid LNURL");if("payRequest"!==c.tag)throw new g.UserError("Not a LNURL-pay");return c}async getIntermediaryQuoteExactIn(a,b,c,d,f,h,o,p,q){let r=(0,k.extendAbortController)(p),s=this.preFetchIntermediaryReputation(b,d,r);try{let{signDataPromise:t,prepareResp:u}=await (0,k.tryWithRetries)(async c=>{let{signDataPrefetch:e,response:g}=l.IntermediaryAPI.prepareToBTCLNExactIn(this.chainIdentifier,d.url,{token:b.token,offerer:a,pr:f,amount:b.amount,maxFee:await h.maxFee,expiryTimestamp:h.expiryTimestamp,additionalParams:q},this.options.postRequestTimeout,r.signal,!(c>0)&&null);return{signDataPromise:this.preFetchSignData(e),prepareResp:await g}},null,a=>a instanceof m.RequestError,r.signal);if(u.amount<=0n)throw new i.IntermediaryError("Invalid amount returned (zero or negative)");let v=BigInt(c.minSendable)/1000n,w=BigInt(c.maxSendable)/1000n;if(u.amount<v)throw new g.UserError("Amount less than minimum");if(u.amount>w)throw new g.UserError("Amount more than maximum");let{invoice:x,parsedInvoice:y,successAction:z}=await n.LNURL.useLNURLPay(c,u.amount,h.comment,this.options.getRequestTimeout,r.signal),A=await (0,k.tryWithRetries)(a=>l.IntermediaryAPI.initToBTCLNExactIn(d.url,{pr:x,reqId:u.reqId,feeRate:o.feeRatePromise,additionalParams:q},this.options.postRequestTimeout,r.signal,!(a>0)&&null),null,m.RequestError,r.signal);A.swapFee,A.maxFee;let B=new this.swapDataDeserializer(A.data);B.setOfferer(a),await this.verifyReturnedData(A,y,b.token,d,h,B,b.amount);let[C,D,E]=await Promise.all([this.verifyReturnedPrice(d.services[j.SwapType.TO_BTCLN],!0,u.amount,B.getAmount(),b.token,{networkFee:A.maxFee},o.pricePreFetchPromise,p),this.verifyReturnedSignature(a,B,A,o.feeRatePromise,t,r.signal),s]);r.signal.throwIfAborted(),d.reputation[b.token.toString()]=E;let F=new e.ToBTCLNSwap(this,{pricingInfo:C,url:d.url,expiry:D,swapFee:A.swapFee,feeRate:await o.feeRatePromise,signatureData:A,data:B,networkFee:A.maxFee,networkFeeBtc:A.routingFeeSats,confidence:A.confidence,pr:x,lnurl:c.url,successAction:z,exactIn:!0});return await F._save(),F}catch(a){throw r.abort(a),a}}async createViaLNURL(a,b,c,d,e,f,h){if(!this.isInitialized)throw Error("Not initialized, call init() first!");e??={},e.expirySeconds??=this.options.paymentTimeoutSeconds,e.expiryTimestamp??=BigInt(Math.floor(Date.now()/1e3)+e.expirySeconds);let i=(0,k.extendAbortController)(h),j=this.preFetchPrice(c,i.signal),l=this.preFetchFeeRate(a,c,null,i);e.maxRoutingPPM??=BigInt(this.options.lightningFeePPM),e.maxRoutingBaseFee??=BigInt(this.options.lightningBaseFee),c.exactIn?e.maxFee??=j.then(a=>this.prices.getFromBtcSwapAmount(this.chainIdentifier,e.maxRoutingBaseFee,c.token,h,a)).then(a=>this.calculateFeeForAmount(c.amount,a,e.maxRoutingPPM)):e.maxFee=this.calculateFeeForAmount(c.amount,e.maxRoutingBaseFee,e.maxRoutingPPM);try{let h=await this.getLNURLPay(b,i.signal);if(null!=e.comment&&(null==h.commentAllowed||e.comment.length>h.commentAllowed))throw new g.UserError("Comment not allowed or too long");if(c.exactIn){let{invoice:b}=await n.LNURL.useLNURLPay(h,BigInt(h.minSendable)/1000n,null,this.options.getRequestTimeout,i.signal);return d.map(d=>({quote:this.getIntermediaryQuoteExactIn(a,c,h,d,b,e,{pricePreFetchPromise:j,feeRatePromise:l},i.signal,f),intermediary:d}))}{let b=BigInt(h.minSendable)/1000n,k=BigInt(h.maxSendable)/1000n;if(c.amount<b)throw new g.UserError("Amount less than minimum");if(c.amount>k)throw new g.UserError("Amount more than maximum");let{invoice:m,parsedInvoice:o,successAction:p}=await n.LNURL.useLNURLPay(h,c.amount,e.comment,this.options.getRequestTimeout,i.signal);return(await this.create(a,m,c,d,e,f,i.signal,{feeRatePromise:l,pricePreFetchPromise:j})).map(a=>({quote:a.quote.then(a=>(a.lnurl=h.url,a.successAction=p,a)),intermediary:a.intermediary}))}}catch(a){throw i.abort(a),a}}}c.ToBTCLNWrapper=p},25319,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ToBTCSwap=c.isToBTCSwapInit=void 0;let d=a.r(806361),e=a.r(813954),f=a.r(500874),g=a.r(974727),h=a.r(294982),i=a.r(213144);function j(a){return"string"==typeof a.address&&"bigint"==typeof a.amount&&"number"==typeof a.confirmationTarget&&"number"==typeof a.satsPerVByte&&(0,d.isIToBTCSwapInit)(a)}c.isToBTCSwapInit=j;class k extends d.IToBTCSwap{constructor(a,b){j(b)&&(b.url+="/tobtc"),super(a,b),this.outputToken=h.BitcoinTokens.BTC,this.TYPE=e.SwapType.TO_BTC,j(b)||(this.address=b.address,this.amount=BigInt(b.amount),this.confirmationTarget=b.confirmationTarget,this.satsPerVByte=b.satsPerVByte,this.txId=b.txId,this.requiredConfirmations=b.requiredConfirmations??this.data.getConfirmationsHint(),this.nonce=(null==b.nonce?null:BigInt(b.nonce))??this.data.getNonceHint()),this.logger=(0,i.getLogger)("ToBTC("+this.getIdentifierHashString()+"): "),this.tryRecomputeSwapPrice()}async _setPaymentResult(a,b=!1){if(null==a)return!1;if(null==a.txId)throw new g.IntermediaryError("No btc txId returned!");if(b){let b=await this.wrapper.btcRpc.getTransaction(a.txId);if(null==b)return!1;if(null==b.outs.find(a=>this.data.getClaimHash()===this.wrapper.contract.getHashForOnchain(f.Buffer.from(a.scriptPubKey.hex,"hex"),BigInt(a.value),this.requiredConfirmations,this.nonce).toString("hex")))throw new g.IntermediaryError("Invalid btc txId returned")}return this.txId=a.txId,!0}getOutput(){return(0,h.toTokenAmount)(this.amount,this.outputToken,this.wrapper.prices)}getOutputAddress(){return this.address}getOutputTxId(){return this.txId}getBitcoinFeeRate(){return this.satsPerVByte}serialize(){return{...super.serialize(),address:this.address,amount:this.amount.toString(10),confirmationTarget:this.confirmationTarget,satsPerVByte:this.satsPerVByte,nonce:null==this.nonce?null:this.nonce.toString(10),requiredConfirmations:this.requiredConfirmations,txId:this.txId}}}c.ToBTCSwap=k},342729,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.ToBTCWrapper=void 0;let d=a.r(25319),e=a.r(543183),f=a.r(163846),g=a.r(339834),h=a.r(974727),i=a.r(813954),j=a.r(213144),k=a.r(774702),l=a.r(570536),m=a.r(411320);class n extends e.IToBTCWrapper{constructor(a,b,c,e,f,g,h,j,k,l,n){null==l&&(l={}),l.bitcoinNetwork=l.bitcoinNetwork??m.TEST_NETWORK,l.safetyFactor=l.safetyFactor||2,l.maxConfirmations=l.maxConfirmations||6,l.bitcoinBlocktime=l.bitcoinBlocktime||600,l.maxExpectedOnchainSendSafetyFactor=l.maxExpectedOnchainSendSafetyFactor||4,l.maxExpectedOnchainSendGracePeriodBlocks=l.maxExpectedOnchainSendGracePeriodBlocks||12,super(a,b,c,e,f,g,h,j,l,n),this.TYPE=i.SwapType.TO_BTC,this.swapDeserializer=d.ToBTCSwap,this.btcRpc=k}getRandomNonce(){return BigInt(Math.floor(Date.now()/1e3)-7e8)<<24n|f.BigIntBufferUtils.fromBuffer((0,j.randomBytes)(3))}btcAddressToOutputScript(a){try{return(0,j.toOutputScript)(this.options.bitcoinNetwork,a)}catch(a){throw new g.UserError("Invalid address specified")}}verifyReturnedData(a,b,c,d,e,g){if(a.totalFee!==a.swapFee+a.networkFee)throw new h.IntermediaryError("Invalid totalFee returned");if(b.exactIn){if(a.total!==b.amount)throw new h.IntermediaryError("Invalid total returned")}else if(a.amount!==b.amount)throw new h.IntermediaryError("Invalid amount returned");let i=BigInt(d.confirmations+d.confirmationTarget+this.options.maxExpectedOnchainSendGracePeriodBlocks)*BigInt(this.options.maxExpectedOnchainSendSafetyFactor)*BigInt(this.options.bitcoinBlocktime),j=BigInt(Math.floor(Date.now()/1e3));if(e.getExpiry()>j+i)throw new h.IntermediaryError("Expiry time returned too high!");if(e.getAmount()!==a.total||e.getClaimHash()!==g||e.getType()!==f.ChainSwapType.CHAIN_NONCED||!e.isPayIn()||!e.isToken(b.token)||e.getClaimer()!==c.getAddress(this.chainIdentifier))throw new h.IntermediaryError("Invalid data returned")}create(a,b,c,e,f,g,h){if(!this.isInitialized)throw Error("Not initialized, call init() first!");f??={},f.confirmationTarget??=3,f.confirmations??=2;let m=this.getRandomNonce(),n=this.btcAddressToOutputScript(b),o=c.exactIn?null:this.contract.getHashForOnchain(n,c.amount,f.confirmations,m).toString("hex"),p=(0,j.extendAbortController)(h),q=this.preFetchPrice(c,p.signal),r=this.preFetchFeeRate(a,c,o,p);return e.map(e=>({intermediary:e,quote:(async()=>{let h=(0,j.extendAbortController)(p.signal),s=this.preFetchIntermediaryReputation(c,e,h);try{let{signDataPromise:p,resp:t}=await (0,j.tryWithRetries)(async d=>{let{signDataPrefetch:i,response:j}=k.IntermediaryAPI.initToBTC(this.chainIdentifier,e.url,{btcAddress:b,amount:c.amount,confirmationTarget:f.confirmationTarget,confirmations:f.confirmations,nonce:m,token:c.token,offerer:a,exactIn:c.exactIn,feeRate:r,additionalParams:g},this.options.postRequestTimeout,h.signal,!(d>0)&&null);return{signDataPromise:this.preFetchSignData(i),resp:await j}},null,l.RequestError,h.signal),u=c.exactIn?this.contract.getHashForOnchain(n,t.amount,f.confirmations,m).toString("hex"):o,v=new this.swapDataDeserializer(t.data);v.setOfferer(a),this.verifyReturnedData(t,c,e,f,v,u);let[w,x,y]=await Promise.all([this.verifyReturnedPrice(e.services[i.SwapType.TO_BTC],!0,t.amount,v.getAmount(),c.token,t,q,h.signal),this.verifyReturnedSignature(a,v,t,r,p,h.signal),s]);h.signal.throwIfAborted(),e.reputation[c.token.toString()]=y;let z=new d.ToBTCSwap(this,{pricingInfo:w,url:e.url,expiry:x,swapFee:t.swapFee,feeRate:await r,signatureData:t,data:v,networkFee:t.networkFee,address:b,amount:t.amount,confirmationTarget:f.confirmationTarget,satsPerVByte:Number(t.satsPervByte),exactIn:c.exactIn??!1,requiredConfirmations:f.confirmations,nonce:m});return await z._save(),z}catch(a){throw h.abort(a),a}})()}))}}c.ToBTCWrapper=n},64251,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IFromBTCSwap=void 0;let d=a.r(19763),e=a.r(163846),f=a.r(294982),g=a.r(622362),h=a.r(921304);class i extends g.IEscrowSwap{constructor(a,b){super(a,b)}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getInput().rawAmount/this.getOutAmountWithoutFee()),super.tryRecomputeSwapPrice()}getSwapData(){return this.data}_getInitiator(){return this.getSwapData().getClaimer()}getOutputTxId(){return this.claimTxId}getOutputAddress(){return this._getInitiator()}requiresAction(){return this.isClaimable()}getOutAmountWithoutFee(){return this.getSwapData().getAmount()+this.swapFee}getSwapFee(){let a=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getInputWithoutFee().rawAmount;return{amountInSrcToken:(0,f.toTokenAmount)(this.swapFeeBtc,this.inputToken,this.wrapper.prices),amountInDstToken:(0,f.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.getSwapData().getToken()],this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,a,b),composition:{base:(0,f.toTokenAmount)(this.pricingInfo.satsBaseFee,this.inputToken,this.wrapper.prices),percentage:(0,d.ppmToPercentage)(a)}}}getFee(){return this.getSwapFee()}getFeeBreakdown(){return[{type:h.FeeType.SWAP,fee:this.getSwapFee()}]}getOutput(){return(0,f.toTokenAmount)(this.getSwapData().getAmount(),this.wrapper.tokens[this.getSwapData().getToken()],this.wrapper.prices)}getInputWithoutFee(){return(0,f.toTokenAmount)(this.getInput().rawAmount-this.swapFeeBtc,this.inputToken,this.wrapper.prices)}getSecurityDeposit(){return(0,f.toTokenAmount)(this.getSwapData().getSecurityDeposit(),this.wrapper.getNativeToken(),this.wrapper.prices)}getTotalDeposit(){return(0,f.toTokenAmount)(this.getSwapData().getTotalDeposit(),this.wrapper.getNativeToken(),this.wrapper.prices)}async hasEnoughForTxFees(){let[a,b]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.wrapper.chain.getNativeCurrencyAddress(),!1),this.getCommitFee()]),c=b+this.getSwapData().getTotalDeposit();return{enoughBalance:a>=c,balance:(0,f.toTokenAmount)(a,this.wrapper.getNativeToken(),this.wrapper.prices),required:(0,f.toTokenAmount)(c,this.wrapper.getNativeToken(),this.wrapper.prices)}}async txsCommit(a){if(!this.canCommit())throw Error("Must be in CREATED state!");return this.initiated||(this.initiated=!0,await this._saveAndEmit()),await this.wrapper.contract.txsInit(this._getInitiator(),this.data,this.signatureData,a,this.feeRate).catch(a=>Promise.reject(a instanceof e.SignatureVerificationError?Error("Request timed out"):a))}getClaimFee(){return this.wrapper.contract.getClaimFee(this._getInitiator(),this.getSwapData())}}c.IFromBTCSwap=i},438427,(a,b,c)=>{"use strict";var d;Object.defineProperty(c,"__esModule",{value:!0}),c.FromBTCLNSwap=c.isFromBTCLNSwapInit=c.FromBTCLNSwapState=void 0;let e=a.r(518040),f=a.r(64251),g=a.r(813954),h=a.r(163846),i=a.r(500874),j=a.r(314595),k=a.r(339834),l=a.r(774702),m=a.r(974727),n=a.r(213144),o=a.r(294982),p=a.r(622362);function q(a){return"string"==typeof a.pr&&"string"==typeof a.secret&&(null==a.lnurl||"string"==typeof a.lnurl)&&(null==a.lnurlK1||"string"==typeof a.lnurlK1)&&(null==a.lnurlCallback||"string"==typeof a.lnurlCallback)&&(0,p.isIEscrowSwapInit)(a)}!function(a){a[a.FAILED=-4]="FAILED",a[a.QUOTE_EXPIRED=-3]="QUOTE_EXPIRED",a[a.QUOTE_SOFT_EXPIRED=-2]="QUOTE_SOFT_EXPIRED",a[a.EXPIRED=-1]="EXPIRED",a[a.PR_CREATED=0]="PR_CREATED",a[a.PR_PAID=1]="PR_PAID",a[a.CLAIM_COMMITED=2]="CLAIM_COMMITED",a[a.CLAIM_CLAIMED=3]="CLAIM_CLAIMED"}(d=c.FromBTCLNSwapState||(c.FromBTCLNSwapState={})),c.isFromBTCLNSwapInit=q;class r extends f.IFromBTCSwap{getSwapData(){return this.data??this.initialSwapData}constructor(a,b){q(b)&&(b.url+="/frombtcln"),super(a,b),this.inputToken=o.BitcoinTokens.BTCLN,this.TYPE=g.SwapType.FROM_BTCLN,this.lnurlFailSignal=new AbortController,this.prPosted=!1,q(b)?this.state=d.PR_CREATED:(this.pr=b.pr,this.secret=b.secret,this.initialSwapData=null==b.initialSwapData?null:h.SwapData.deserialize(b.initialSwapData),this.lnurl=b.lnurl,this.lnurlK1=b.lnurlK1,this.lnurlCallback=b.lnurlCallback,this.prPosted=b.prPosted,this.state===d.PR_CREATED&&null!=this.data&&(this.initialSwapData=this.data,delete this.data)),this.tryRecomputeSwapPrice(),this.logger=(0,n.getLogger)("FromBTCLN("+this.getIdentifierHashString()+"): ")}upgradeVersion(){if(null==this.version){switch(this.state){case -2:this.state=d.QUOTE_EXPIRED;break;case -1:this.state=d.FAILED;break;case 0:this.state=d.PR_CREATED;break;case 1:this.state=d.PR_PAID;break;case 2:this.state=d.CLAIM_COMMITED;break;case 3:this.state=d.CLAIM_CLAIMED}this.version=1}}getIdentifierHash(){let a=this.getPaymentHash();return null==this.randomNonce?a:i.Buffer.concat([a,i.Buffer.from(this.randomNonce,"hex")])}getPaymentHash(){if(null==this.pr)return null;let a=(0,e.decode)(this.pr);return i.Buffer.from(a.tagsObject.payment_hash,"hex")}canCommit(){return this.state===d.PR_PAID}getInputTxId(){return this.getPaymentHash().toString("hex")}getAddress(){return this.pr}getHyperlink(){return"lightning:"+this.pr.toUpperCase()}getTimeoutTime(){return null==this.pr?null:1e3*(0,e.decode)(this.pr).timeExpireDate}getHtlcTimeoutTime(){return 1e3*Number(this.wrapper.getHtlcTimeout(this.data))}isFinished(){return this.state===d.CLAIM_CLAIMED||this.state===d.QUOTE_EXPIRED||this.state===d.FAILED}isClaimable(){return this.state===d.PR_PAID||this.state===d.CLAIM_COMMITED}isSuccessful(){return this.state===d.CLAIM_CLAIMED}isFailed(){return this.state===d.FAILED||this.state===d.EXPIRED}isQuoteExpired(){return this.state===d.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===d.QUOTE_EXPIRED||this.state===d.QUOTE_SOFT_EXPIRED}verifyQuoteValid(){return this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED&&null==this.signatureData?Promise.resolve(this.getTimeoutTime()>Date.now()):super.verifyQuoteValid()}getInput(){let a=(BigInt((0,e.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,o.toTokenAmount)(a,this.inputToken,this.wrapper.prices)}async getSmartChainNetworkFee(){return(0,o.toTokenAmount)(await this.getCommitAndClaimFee(),this.wrapper.getNativeToken(),this.wrapper.prices)}async hasEnoughForTxFees(){let[a,b]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.wrapper.chain.getNativeCurrencyAddress(),!1),null!=this.feeRate?Promise.resolve(this.feeRate):this.wrapper.contract.getInitFeeRate(this.getSwapData().getOfferer(),this.getSwapData().getClaimer(),this.getSwapData().getToken(),this.getSwapData().getClaimHash())]),c=await this.wrapper.contract.getCommitFee(this.getSwapData(),b)+await this.wrapper.contract.getClaimFee(this._getInitiator(),this.getSwapData(),b)+this.getSwapData().getTotalDeposit();return{enoughBalance:a>=c,balance:(0,o.toTokenAmount)(a,this.wrapper.getNativeToken(),this.wrapper.prices),required:(0,o.toTokenAmount)(c,this.wrapper.getNativeToken(),this.wrapper.prices)}}async checkIntermediaryPaymentReceived(a=!0){if(this.state===d.PR_PAID||this.state===d.CLAIM_COMMITED||this.state===d.CLAIM_CLAIMED||this.state===d.FAILED)return!0;if(this.state===d.QUOTE_EXPIRED||this.state===d.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)return!1;let b=await l.IntermediaryAPI.getPaymentAuthorization(this.url,this.getPaymentHash().toString("hex"));switch(b.code){case l.PaymentAuthorizationResponseCodes.AUTH_DATA:let c=new this.wrapper.swapDataDeserializer(b.data.data);try{return await this.checkIntermediaryReturnedAuthData(this._getInitiator(),c,b.data),this.expiry=await (0,n.tryWithRetries)(()=>this.wrapper.contract.getInitAuthorizationExpiry(c,b.data)),this.state=d.PR_PAID,delete this.initialSwapData,this.data=c,this.signatureData={prefix:b.data.prefix,timeout:b.data.timeout,signature:b.data.signature},this.initiated=!0,a&&await this._saveAndEmit(),!0}catch(a){}return null;case l.PaymentAuthorizationResponseCodes.EXPIRED:return this.state=d.QUOTE_EXPIRED,this.initiated=!0,a&&await this._saveAndEmit(),!1;default:return null}}async checkIntermediaryReturnedAuthData(a,b,c){if(b.setClaimer(a),b.getOfferer()!==this.getSwapData().getOfferer())throw new m.IntermediaryError("Invalid offerer used");if(!b.isToken(this.getSwapData().getToken()))throw new m.IntermediaryError("Invalid token used");if(b.getSecurityDeposit()>this.getSwapData().getSecurityDeposit())throw new m.IntermediaryError("Invalid security deposit!");if(b.getAmount()<this.getSwapData().getAmount())throw new m.IntermediaryError("Invalid amount received!");if(b.getClaimHash()!==this.getSwapData().getClaimHash())throw new m.IntermediaryError("Invalid payment hash used!");if(!b.isDepositToken(this.getSwapData().getDepositToken()))throw new m.IntermediaryError("Invalid deposit token used!");await Promise.all([(0,n.tryWithRetries)(()=>this.wrapper.contract.isValidInitAuthorization(this._getInitiator(),b,c,this.feeRate),null,h.SignatureVerificationError),(0,n.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(b.getClaimer(),b)).then(a=>{if(a?.type!==h.SwapCommitStateType.NOT_COMMITED)throw Error("Swap already committed on-chain!")})])}async waitForPayment(a,b=5){if(this.state!==d.PR_CREATED&&(this.state!==d.QUOTE_SOFT_EXPIRED||null!=this.signatureData))throw Error("Must be in PR_CREATED state!");let c=new AbortController;null!=a&&a.addEventListener("abort",()=>c.abort(a.reason));let e=!1;null==this.lnurl||this.prPosted||(j.LNURL.postInvoiceToLNURLWithdraw({k1:this.lnurlK1,callback:this.lnurlCallback},this.pr).catch(a=>{this.lnurlFailSignal.abort(a)}),this.prPosted=!0,e||=!0),this.initiated||(this.initiated=!0,e||=!0),e&&await this._saveAndEmit();let f=()=>c.abort(this.lnurlFailSignal.signal.reason);this.lnurlFailSignal.signal.addEventListener("abort",f),this.lnurlFailSignal.signal.throwIfAborted();let g={code:l.PaymentAuthorizationResponseCodes.PENDING,msg:""};for(;!c.signal.aborted&&g.code===l.PaymentAuthorizationResponseCodes.PENDING;)(g=await l.IntermediaryAPI.getPaymentAuthorization(this.url,this.getPaymentHash().toString("hex"))).code===l.PaymentAuthorizationResponseCodes.PENDING&&await (0,n.timeoutPromise)(1e3*b,c.signal);if(this.lnurlFailSignal.signal.removeEventListener("abort",f),c.signal.throwIfAborted(),g.code===l.PaymentAuthorizationResponseCodes.AUTH_DATA){let a=g.data,b=new this.wrapper.swapDataDeserializer(g.data.data);return await this.checkIntermediaryReturnedAuthData(this._getInitiator(),b,a),this.expiry=await (0,n.tryWithRetries)(()=>this.wrapper.contract.getInitAuthorizationExpiry(b,a)),(this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED)&&(delete this.initialSwapData,this.data=b,this.signatureData={prefix:a.prefix,timeout:a.timeout,signature:a.signature},await this._saveAndEmit(d.PR_PAID)),!0}if(this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED)return g.code===l.PaymentAuthorizationResponseCodes.EXPIRED&&await this._saveAndEmit(d.QUOTE_EXPIRED),!1}async commit(a,b,c){this.checkSigner(a);let e=await this.wrapper.chain.sendAndConfirm(a,await this.txsCommit(c),!0,b);return this.commitTxId=e[0],(this.state===d.PR_PAID||this.state===d.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(d.CLAIM_COMMITED),e[0]}async waitTillCommited(a){if(this.state===d.CLAIM_COMMITED||this.state===d.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==d.PR_PAID&&this.state!==d.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)throw Error("Invalid state");let b=(0,n.extendAbortController)(a),c=await Promise.race([this.watchdogWaitTillCommited(b.signal),this.waitTillState(d.CLAIM_COMMITED,"gte",b.signal).then(()=>0)]);if(b.abort(),0===c&&this.logger.debug("waitTillCommited(): Resolved from state changed"),!0===c&&this.logger.debug("waitTillCommited(): Resolved from watchdog - commited"),!1===c){this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expired"),(this.state===d.PR_PAID||this.state===d.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(d.QUOTE_EXPIRED);return}(this.state===d.PR_PAID||this.state===d.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(d.CLAIM_COMMITED)}txsClaim(a){if(this.state!==d.CLAIM_COMMITED)throw Error("Must be in CLAIM_COMMITED state!");return this.wrapper.contract.txsClaimWithSecret(a??this._getInitiator(),this.data,this.secret,!0,!0)}async claim(a,b){let c=await this.wrapper.chain.sendAndConfirm(a,await this.txsClaim(),!0,b);return this.claimTxId=c[0],(d.CLAIM_COMMITED||d.EXPIRED||d.FAILED)&&await this._saveAndEmit(d.CLAIM_CLAIMED),c[0]}async waitTillClaimed(a){if(this.state===d.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==d.CLAIM_COMMITED)throw Error("Invalid state (not CLAIM_COMMITED)");let b=new AbortController;null!=a&&a.addEventListener("abort",()=>b.abort(a.reason));let c=await Promise.race([this.watchdogWaitTillResult(b.signal),this.waitTillState(d.CLAIM_CLAIMED,"eq",b.signal).then(()=>0),this.waitTillState(d.EXPIRED,"eq",b.signal).then(()=>1)]);if(b.abort(),0===c)return void this.logger.debug("waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)");if(1===c)throw this.logger.debug("waitTillClaimed(): Resolved from state change (EXPIRED)"),Error("Swap expired during claiming");this.logger.debug("waitTillClaimed(): Resolved from watchdog"),c?.type===h.SwapCommitStateType.PAID&&this.state!==d.CLAIM_CLAIMED&&(this.claimTxId=await c.getClaimTxId(),await this._saveAndEmit(d.CLAIM_CLAIMED)),(c?.type===h.SwapCommitStateType.NOT_COMMITED||c?.type===h.SwapCommitStateType.EXPIRED)&&this.state!==d.CLAIM_CLAIMED&&this.state!==d.FAILED&&(this.refundTxId=null==c.getRefundTxId?null:await c.getRefundTxId(),await this._saveAndEmit(d.FAILED))}async getCommitAndClaimFee(){let a=this.wrapper.contract,b=this.feeRate??await a.getInitFeeRate(this.getSwapData().getOfferer(),this.getSwapData().getClaimer(),this.getSwapData().getToken(),this.getSwapData().getClaimHash());return await (null!=a.getRawCommitFee?a.getRawCommitFee(this.getSwapData(),b):a.getCommitFee(this.getSwapData(),b))+await (null!=a.getRawClaimFee?a.getRawClaimFee(this._getInitiator(),this.getSwapData(),b):a.getClaimFee(this._getInitiator(),this.getSwapData(),b))}canCommitAndClaimInOneShot(){return null!=this.wrapper.contract.initAndClaimWithSecret}async txsCommitAndClaim(a){if(this.state===d.CLAIM_COMMITED)return await this.txsClaim();if(this.state!==d.PR_PAID&&(this.state!==d.QUOTE_SOFT_EXPIRED||null==this.signatureData))throw Error("Must be in PR_PAID state!");let b=await this.txsCommit(a),c=await this.wrapper.contract.txsClaimWithSecret(this._getInitiator(),this.data,this.secret,!0,!0,null,!0);return b.concat(c)}async commitAndClaim(a,b,c){if(!this.canCommitAndClaimInOneShot())throw Error("Cannot commitAndClaim in single action, please run commit and claim separately!");if(this.checkSigner(a),this.state===d.CLAIM_COMMITED)return[null,await this.claim(a)];let e=await this.wrapper.chain.sendAndConfirm(a,await this.txsCommitAndClaim(c),!0,b);return this.commitTxId=e[0]||this.commitTxId,this.claimTxId=e[e.length-1]||this.claimTxId,this.state!==d.CLAIM_CLAIMED&&await this._saveAndEmit(d.CLAIM_CLAIMED),e}isLNURL(){return null!=this.lnurl}getLNURL(){return this.lnurl}async settleWithLNURLWithdraw(a){let b;if(null!=this.lnurl)throw Error("Cannot settle LNURL-withdraw swap with different LNURL");if("string"==typeof a){let c=await j.LNURL.getLNURL(a);if(null==c||"withdrawRequest"!==c.tag)throw new k.UserError("Invalid LNURL-withdraw to settle the swap");b=c}else b=a.params;j.LNURL.useLNURLWithdraw(b,this.pr).catch(a=>this.lnurlFailSignal.abort(a)),this.lnurl=b.url,this.lnurlCallback=b.callback,this.lnurlK1=b.k1,this.prPosted=!0,await this._saveAndEmit()}serialize(){return{...super.serialize(),pr:this.pr,secret:this.secret,lnurl:this.lnurl,lnurlK1:this.lnurlK1,lnurlCallback:this.lnurlCallback,prPosted:this.prPosted,initialSwapData:null==this.initialSwapData?null:this.initialSwapData.serialize()}}async syncStateFromChain(){let a=!1;if((this.state===d.PR_PAID||this.state===d.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)&&(a=await this.verifyQuoteDefinitelyExpired()),this.state===d.CLAIM_COMMITED||this.state===d.EXPIRED){let a=await (0,n.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));if(a?.type===h.SwapCommitStateType.PAID)return null==this.claimTxId&&(this.claimTxId=await a.getClaimTxId()),this.state=d.CLAIM_CLAIMED,!0;if(a?.type===h.SwapCommitStateType.NOT_COMMITED||a?.type===h.SwapCommitStateType.EXPIRED)return null==this.refundTxId&&a.getRefundTxId&&(this.refundTxId=await a.getRefundTxId()),this.state=d.FAILED,!0}if(this.state===d.PR_PAID||this.state===d.QUOTE_SOFT_EXPIRED&&null!=this.signatureData){let a=await (0,n.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(a?.type){case h.SwapCommitStateType.COMMITED:return this.state=d.CLAIM_COMMITED,!0;case h.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&a.getRefundTxId&&(this.refundTxId=await a.getRefundTxId()),this.state=d.QUOTE_EXPIRED,!0;case h.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await a.getClaimTxId()),this.state=d.CLAIM_CLAIMED,!0}}if((this.state===d.PR_PAID||this.state===d.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)&&a)return this.state=d.QUOTE_EXPIRED,!0}async _sync(a){let b=!1;return(this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED&&null==this.signatureData)&&(this.getTimeoutTime()<Date.now()&&(this.state=d.QUOTE_SOFT_EXPIRED,b||=!0),null!==await this.checkIntermediaryPaymentReceived(!1)&&(b||=!0)),await this.syncStateFromChain()&&(b=!0),a&&b&&await this._saveAndEmit(),b}async _tick(a){switch(this.state){case d.PR_CREATED:if(this.getTimeoutTime()<Date.now())return this.state=d.QUOTE_SOFT_EXPIRED,a&&await this._saveAndEmit(),!0;break;case d.PR_PAID:if(this.expiry<Date.now())return this.state=d.QUOTE_SOFT_EXPIRED,a&&await this._saveAndEmit(),!0;break;case d.CLAIM_COMMITED:if(await this.wrapper.contract.isExpired(this._getInitiator(),this.data))return this.state=d.EXPIRED,a&&await this._saveAndEmit(),!0}}}c.FromBTCLNSwap=r},856365,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IFromBTCWrapper=void 0;let d=a.r(974727),e=a.r(213144),f=a.r(163846),g=a.r(333789);class h extends g.IEscrowSwapWrapper{getRandomSequence(){return f.BigIntBufferUtils.fromBuffer((0,e.randomBytes)(8))}preFetchFeeRate(a,b,c,d){return(0,e.tryWithRetries)(()=>this.contract.getInitFeeRate(null,a,b.token,c),null,null,d.signal).catch(a=>(this.logger.warn("preFetchFeeRate(): Error: ",a),d.abort(a),null))}preFetchIntermediaryLiquidity(a,b,c){return b.getLiquidity(this.chainIdentifier,this.contract,a.token.toString(),c.signal).catch(a=>(this.logger.warn("preFetchIntermediaryLiquidity(): Error: ",a),c.abort(a),null))}async verifyIntermediaryLiquidity(a,b){if(await b<a)throw new d.IntermediaryError("Intermediary doesn't have enough liquidity")}}c.IFromBTCWrapper=h},53731,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.FromBTCLNWrapper=void 0;let d=a.r(438427),e=a.r(856365),f=a.r(518040),g=a.r(163846),h=a.r(500874),i=a.r(339834),j=a.r(404322),k=a.r(974727),l=a.r(813954),m=a.r(213144),n=a.r(774702),o=a.r(570536),p=a.r(314595);class q extends e.IFromBTCWrapper{constructor(a,b,c,e,f,g,h,i,j,k,m){super(a,b,c,e,f,g,h,i,k,m),this.TYPE=l.SwapType.FROM_BTCLN,this.swapDeserializer=d.FromBTCLNSwap,this.pendingSwapStates=[d.FromBTCLNSwapState.PR_CREATED,d.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED,d.FromBTCLNSwapState.PR_PAID,d.FromBTCLNSwapState.CLAIM_COMMITED,d.FromBTCLNSwapState.EXPIRED],this.tickSwapState=[d.FromBTCLNSwapState.PR_CREATED,d.FromBTCLNSwapState.PR_PAID,d.FromBTCLNSwapState.CLAIM_COMMITED],this.lnApi=j}processEventInitialize(a,b){return a.state===d.FromBTCLNSwapState.PR_PAID||a.state===d.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED?(a.state=d.FromBTCLNSwapState.CLAIM_COMMITED,Promise.resolve(!0)):Promise.resolve(!1)}processEventClaim(a,b){return a.state!==d.FromBTCLNSwapState.FAILED&&a.state!==d.FromBTCLNSwapState.CLAIM_CLAIMED?(a.state=d.FromBTCLNSwapState.CLAIM_CLAIMED,Promise.resolve(!0)):Promise.resolve(!1)}processEventRefund(a,b){return a.state!==d.FromBTCLNSwapState.CLAIM_CLAIMED&&a.state!==d.FromBTCLNSwapState.FAILED?(a.state=d.FromBTCLNSwapState.FAILED,Promise.resolve(!0)):Promise.resolve(!1)}getHtlcTimeout(a){return a.getExpiry()-600n}getSecretAndHash(){let a=(0,m.randomBytes)(32),b=h.Buffer.from((0,j.sha256)(a));return{secret:a,paymentHash:b}}preFetchLnCapacity(a){return a.then(a=>null==a?null:this.lnApi.getLNNodeLiquidity(a)).catch(a=>(this.logger.warn("preFetchLnCapacity(): Error: ",a),null))}verifyReturnedData(a,b,c,d,e,f){if(c.getAddress(this.chainIdentifier)!==a.intermediaryKey)throw new k.IntermediaryError("Invalid intermediary address/pubkey");if(null!=d.descriptionHash&&e.tagsObject.purpose_commit_hash!==d.descriptionHash.toString("hex"))throw new k.IntermediaryError("Invalid pr returned - description hash");if(b.exactIn){if(f!==b.amount)throw new k.IntermediaryError("Invalid payment request returned, amount mismatch")}else if(a.total!=b.amount)throw new k.IntermediaryError("Invalid amount returned")}async verifyLnNodeCapacity(a,b,c,d,e){let f=null==d?null:await d;if(null==f&&(f=await this.lnApi.getLNNodeLiquidity(b.payeeNodeKey)),null!=e&&e.throwIfAborted(),null===f)throw new k.IntermediaryError("LP's lightning node not found in the lightning network graph!");if(a.lnData=f,b.payeeNodeKey!==f.publicKey)throw new k.IntermediaryError("Invalid pr returned - payee pubkey");if(f.capacity<c)throw new k.IntermediaryError("LP's lightning node doesn't have enough inbound capacity for the swap!");if(f.capacity/2n<c)throw Error("LP's lightning node probably doesn't have enough inbound capacity for the swap!")}create(a,b,c,e,h,j,k){if(null==e&&(e={}),e.unsafeSkipLnNodeCheck??=this.options.unsafeSkipLnNodeCheck,null==k&&(k={}),null!=e.descriptionHash&&32!==e.descriptionHash.length)throw new i.UserError("Invalid description hash length");let{secret:p,paymentHash:q}=this.getSecretAndHash(),r=this.contract.getHashForHtlc(q),s=(0,m.extendAbortController)(j);k.pricePrefetchPromise??=this.preFetchPrice(b,s.signal);let t=this.chain.getNativeCurrencyAddress();return k.feeRatePromise??=this.preFetchFeeRate(a,b,r.toString("hex"),s),c.map(c=>({intermediary:c,quote:(async()=>{let i=(0,m.extendAbortController)(s.signal),j=this.preFetchIntermediaryLiquidity(b,c,i),{lnCapacityPromise:u,resp:v}=await (0,m.tryWithRetries)(async d=>{let{lnPublicKey:f,response:g}=n.IntermediaryAPI.initFromBTCLN(this.chainIdentifier,c.url,t,{paymentHash:q,amount:b.amount,claimer:a,token:b.token.toString(),descriptionHash:e.descriptionHash,exactOut:!b.exactIn,feeRate:k.feeRatePromise,additionalParams:h},this.options.postRequestTimeout,i.signal,!(d>0)&&null);return{lnCapacityPromise:e.unsafeSkipLnNodeCheck?null:this.preFetchLnCapacity(f),resp:await g}},null,o.RequestError,i.signal),w=(0,f.decode)(v.pr),x=(BigInt(w.millisatoshis)+999n)/1000n;try{this.verifyReturnedData(v,b,c,e,w,x);let[f]=await Promise.all([this.verifyReturnedPrice(c.services[l.SwapType.FROM_BTCLN],!1,x,v.total,b.token,{},k.pricePrefetchPromise,i.signal),this.verifyIntermediaryLiquidity(v.total,j),e.unsafeSkipLnNodeCheck?Promise.resolve():this.verifyLnNodeCapacity(c,w,x,u,i.signal)]),h=new d.FromBTCLNSwap(this,{pricingInfo:f,url:c.url,expiry:1e3*w.timeExpireDate,swapFee:v.swapFee,feeRate:await k.feeRatePromise,initialSwapData:await this.contract.createSwapData(g.ChainSwapType.HTLC,c.getAddress(this.chainIdentifier),a,b.token,v.total,r.toString("hex"),this.getRandomSequence(),BigInt(Math.floor(Date.now()/1e3)),!1,!0,v.securityDeposit,0n,t),pr:v.pr,secret:p.toString("hex"),exactIn:b.exactIn??!0});return await h._save(),h}catch(a){throw i.abort(a),a}})()}))}async getLNURLWithdraw(a,b){if("string"!=typeof a)return a;let c=await p.LNURL.getLNURL(a,!0,this.options.getRequestTimeout,b);if(null==c)throw new i.UserError("Invalid LNURL");if("withdrawRequest"!==c.tag)throw new i.UserError("Not a LNURL-withdrawal");return c}async createViaLNURL(a,b,c,d,e,f){if(!this.isInitialized)throw Error("Not initialized, call init() first!");let g=(0,m.extendAbortController)(f),h={pricePrefetchPromise:this.preFetchPrice(c,g.signal),feeRatePromise:this.preFetchFeeRate(a,c,null,g)};try{let j=c.exactIn?null:h.pricePrefetchPromise.then(a=>this.prices.getToBtcSwapAmount(this.chainIdentifier,c.amount,c.token,g.signal,a)).catch(a=>(g.abort(a),null)),k=await this.getLNURLWithdraw(b,g.signal),l=BigInt(k.minWithdrawable)/1000n,m=BigInt(k.maxWithdrawable)/1000n;if(c.exactIn){if(c.amount<l)throw new i.UserError("Amount less than LNURL-withdraw minimum");if(c.amount>m)throw new i.UserError("Amount more than LNURL-withdraw maximum")}else{let a=await j;if(g.signal.throwIfAborted(),95n*a/100n<l)throw new i.UserError("Amount less than LNURL-withdraw minimum");if(105n*a/100n>m)throw new i.UserError("Amount more than LNURL-withdraw maximum")}return this.create(a,c,d,null,e,f,h).map(a=>({quote:a.quote.then(a=>{a.lnurl=k.url,a.lnurlK1=k.k1,a.lnurlCallback=k.callback;let b=a.getInput().rawAmount;if(b<l)throw new i.UserError("Amount less than LNURL-withdraw minimum");if(b>m)throw new i.UserError("Amount more than LNURL-withdraw maximum");return a}),intermediary:a.intermediary}))}catch(a){throw g.abort(a),a}}}c.FromBTCLNWrapper=q},552363,(a,b,c)=>{"use strict";var d;Object.defineProperty(c,"__esModule",{value:!0}),c.FromBTCSwap=c.isFromBTCSwapInit=c.FromBTCSwapState=void 0;let e=a.r(64251),f=a.r(813954),g=a.r(163846),h=a.r(500874),i=a.r(294982),j=a.r(213144),k=a.r(622362),l=a.r(963002),m=a.r(680302),n=a.r(823212);function o(a){return"string"==typeof a.address&&"bigint"==typeof a.amount&&(0,k.isIEscrowSwapInit)(a)}!function(a){a[a.FAILED=-4]="FAILED",a[a.EXPIRED=-3]="EXPIRED",a[a.QUOTE_EXPIRED=-2]="QUOTE_EXPIRED",a[a.QUOTE_SOFT_EXPIRED=-1]="QUOTE_SOFT_EXPIRED",a[a.PR_CREATED=0]="PR_CREATED",a[a.CLAIM_COMMITED=1]="CLAIM_COMMITED",a[a.BTC_TX_CONFIRMED=2]="BTC_TX_CONFIRMED",a[a.CLAIM_CLAIMED=3]="CLAIM_CLAIMED"}(d=c.FromBTCSwapState||(c.FromBTCSwapState={})),c.isFromBTCSwapInit=o;class p extends e.IFromBTCSwap{constructor(a,b){o(b)&&(b.url+="/frombtc"),super(a,b),this.inputToken=i.BitcoinTokens.BTC,this.TYPE=f.SwapType.FROM_BTC,o(b)?this.state=d.PR_CREATED:(this.address=b.address,this.amount=BigInt(b.amount),this.txId=b.txId,this.vout=b.vout,this.requiredConfirmations=b.requiredConfirmations??this.data.getConfirmationsHint()),this.tryRecomputeSwapPrice(),this.logger=(0,j.getLogger)("FromBTC("+this.getIdentifierHashString()+"): ")}upgradeVersion(){if(null==this.version){switch(this.state){case -2:this.state=d.FAILED;break;case -1:this.state=d.QUOTE_EXPIRED;break;case 0:this.state=d.PR_CREATED;break;case 1:this.state=d.CLAIM_COMMITED;break;case 2:this.state=d.BTC_TX_CONFIRMED;break;case 3:this.state=d.CLAIM_CLAIMED}this.version=1}}getAddress(){return this.state===d.PR_CREATED?null:this.address}getHyperlink(){return this.state===d.PR_CREATED?null:"bitcoin:"+this.address+"?amount="+encodeURIComponent((Number(this.amount)/1e8).toString(10))}getInputTxId(){return this.txId}getTimeoutTime(){return 1e3*Number(this.wrapper.getOnchainSendTimeout(this.data,this.requiredConfirmations))}requiresAction(){return this.isClaimable()||this.state===d.CLAIM_COMMITED&&this.getTimeoutTime()>Date.now()}isFinished(){return this.state===d.CLAIM_CLAIMED||this.state===d.QUOTE_EXPIRED||this.state===d.FAILED}isClaimable(){return this.state===d.BTC_TX_CONFIRMED}isSuccessful(){return this.state===d.CLAIM_CLAIMED}isFailed(){return this.state===d.FAILED||this.state===d.EXPIRED&&null!=this.txId}isQuoteExpired(){return this.state===d.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===d.QUOTE_EXPIRED||this.state===d.QUOTE_SOFT_EXPIRED}canCommit(){return this.state===d.PR_CREATED&&this.wrapper.getOnchainSendTimeout(this.data,this.requiredConfirmations)-BigInt(Math.floor(Date.now()/1e3))>=this.wrapper.options.minSendWindow}getInput(){return(0,i.toTokenAmount)(this.amount,this.inputToken,this.wrapper.prices)}getClaimerBounty(){return(0,i.toTokenAmount)(this.data.getClaimerBounty(),this.wrapper.tokens[this.data.getDepositToken()],this.wrapper.prices)}getRequiredConfirmationsCount(){return this.requiredConfirmations}async getBitcoinPayment(){let a=await this.wrapper.btcRpc.checkAddressTxos(this.address,h.Buffer.from(this.data.getTxoHashHint(),"hex"));return null==a?null:{txId:a.tx.txid,vout:a.vout,confirmations:a.tx.confirmations,targetConfirmations:this.requiredConfirmations}}async waitForBitcoinTransaction(a,b,c){if(this.state!==d.CLAIM_COMMITED&&this.state!==d.EXPIRED)throw Error("Must be in COMMITED state!");let e=await this.wrapper.btcRpc.waitForAddressTxo(this.address,h.Buffer.from(this.data.getTxoHashHint(),"hex"),this.requiredConfirmations,(a,b,d,e)=>{null!=c&&c(b,a,this.requiredConfirmations,e)},a,b);return null!=a&&a.throwIfAborted(),this.txId=e.tx.txid,this.vout=e.vout,this.state!==d.CLAIM_CLAIMED&&this.state!==d.FAILED&&(this.state=d.BTC_TX_CONFIRMED),await this._saveAndEmit(),e.tx.txid}async getFundedPsbt(a,b){let c;if(this.state!==d.CLAIM_COMMITED)throw Error("Swap not committed yet, please initiate the swap first with commit() call!");c=(0,l.isIBitcoinWallet)(a)?a:new n.SingleAddressBitcoinWallet(this.wrapper.btcRpc,this.wrapper.options.bitcoinNetwork,a),null==b&&(b=await c.getFeeRate());let e=new m.Transaction({allowUnknownOutputs:!0,allowLegacyWitnessUtxo:!0});e.addOutput({amount:this.amount,script:(0,j.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address)});let f=await c.fundPsbt(e,b),g=[];for(let a=0;a<f.inputsLength;a++)g.push(a);return{psbt:f,signInputs:g}}async submitPsbt(a){if(this.state!==d.CLAIM_COMMITED)throw Error("Swap not committed yet, please initiate the swap first with commit() call!");if(this.getTimeoutTime()<Date.now())throw Error("Swap address expired!");let b=a.getOutput(0);if(b.amount!==this.amount)throw Error("PSBT output amount invalid, expected: "+this.amount+" got: "+b.amount);if(!(0,j.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address).equals(b.script))throw Error("PSBT output script invalid!");return a.isFinal||a.finalize(),await this.wrapper.btcRpc.sendRawTransaction(h.Buffer.from(a.toBytes(!0,!0)).toString("hex"))}async estimateBitcoinFee(a,b){let c=await a.getTransactionFee(this.address,this.amount,b);return(0,i.toTokenAmount)(null==c?null:BigInt(c),i.BitcoinTokens.BTC,this.wrapper.prices)}async sendBitcoinTransaction(a,b){if(this.state!==d.CLAIM_COMMITED)throw Error("Swap not committed yet, please initiate the swap first with commit() call!");return await a.sendTransaction(this.address,this.amount,b)}async commit(a,b,c){this.checkSigner(a);let e=await this.wrapper.chain.sendAndConfirm(a,await this.txsCommit(c),!0,b);return this.commitTxId=e[0],(this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(d.CLAIM_COMMITED),e[0]}async waitTillCommited(a){if(this.state===d.CLAIM_COMMITED||this.state===d.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==d.PR_CREATED&&this.state!==d.QUOTE_SOFT_EXPIRED)throw Error("Invalid state");let b=(0,j.extendAbortController)(a),c=await Promise.race([this.watchdogWaitTillCommited(b.signal),this.waitTillState(d.CLAIM_COMMITED,"gte",b.signal).then(()=>0)]);if(b.abort(),0===c&&this.logger.debug("waitTillCommited(): Resolved from state changed"),!0===c&&this.logger.debug("waitTillCommited(): Resolved from watchdog - commited"),!1===c){this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expired"),(this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(d.QUOTE_EXPIRED);return}(this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(d.CLAIM_COMMITED)}async txsClaim(a){if(this.state!==d.BTC_TX_CONFIRMED)throw Error("Must be in BTC_TX_CONFIRMED state!");let b=await this.wrapper.btcRpc.getTransaction(this.txId);return await this.wrapper.contract.txsClaimWithTxData(a??this._getInitiator(),this.data,{blockhash:b.blockhash,confirmations:b.confirmations,txid:b.txid,hex:b.hex,height:b.blockheight},this.requiredConfirmations,this.vout,null,this.wrapper.synchronizer,!0)}async claim(a,b){let c;try{c=await this.wrapper.chain.sendAndConfirm(a,await this.txsClaim(a),!0,b)}catch(b){if(this.logger.info("claim(): Failed to claim ourselves, checking swap claim state..."),this.state===d.CLAIM_CLAIMED)return this.logger.info("claim(): Transaction state is CLAIM_CLAIMED, swap was successfully claimed by the watchtower"),this.claimTxId;let a=await this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data);if(a?.type===g.SwapCommitStateType.PAID)return this.logger.info("claim(): Transaction commit status is PAID, swap was successfully claimed by the watchtower"),null==this.claimTxId&&(this.claimTxId=await a.getClaimTxId()),await this._saveAndEmit(d.CLAIM_CLAIMED),this.claimTxId;throw b}return this.claimTxId=c[c.length-1],(this.state===d.CLAIM_COMMITED||this.state===d.BTC_TX_CONFIRMED||this.state===d.EXPIRED||this.state===d.FAILED)&&await this._saveAndEmit(d.CLAIM_CLAIMED),c[0]}async waitTillClaimed(a){if(this.state===d.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==d.BTC_TX_CONFIRMED)throw Error("Invalid state (not BTC_TX_CONFIRMED)");let b=new AbortController;null!=a&&a.addEventListener("abort",()=>b.abort(a.reason));let c=await Promise.race([this.watchdogWaitTillResult(b.signal),this.waitTillState(d.CLAIM_CLAIMED,"eq",b.signal).then(()=>0),this.waitTillState(d.FAILED,"eq",b.signal).then(()=>1)]);if(b.abort(),0===c)return void this.logger.debug("waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)");if(1===c)throw this.logger.debug("waitTillClaimed(): Resolved from state change (FAILED)"),Error("Offerer refunded during claiming");this.logger.debug("waitTillClaimed(): Resolved from watchdog"),c?.type===g.SwapCommitStateType.PAID&&this.state!==d.CLAIM_CLAIMED&&(this.claimTxId=await c.getClaimTxId(),await this._saveAndEmit(d.CLAIM_CLAIMED)),(c?.type===g.SwapCommitStateType.NOT_COMMITED||c?.type===g.SwapCommitStateType.EXPIRED)&&this.state!==d.CLAIM_CLAIMED&&this.state!==d.FAILED&&(this.refundTxId=null==c.getRefundTxId?null:await c.getRefundTxId(),await this._saveAndEmit(d.FAILED))}serialize(){return{...super.serialize(),address:this.address,amount:this.amount.toString(10),requiredConfirmations:this.requiredConfirmations,txId:this.txId,vout:this.vout}}async syncStateFromChain(){if(this.state===d.PR_CREATED||this.state===d.QUOTE_SOFT_EXPIRED){let a=await this.verifyQuoteDefinitelyExpired(),b=await (0,j.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(b?.type){case g.SwapCommitStateType.COMMITED:return this.state=d.CLAIM_COMMITED,!0;case g.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&b.getRefundTxId&&(this.refundTxId=await b.getRefundTxId()),this.state=d.QUOTE_EXPIRED,!0;case g.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await b.getClaimTxId()),this.state=d.CLAIM_CLAIMED,!0}return!!a&&(this.state=d.QUOTE_EXPIRED,!0)}if(this.state===d.CLAIM_COMMITED||this.state===d.BTC_TX_CONFIRMED||this.state===d.EXPIRED){let a=await (0,j.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(a?.type){case g.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await a.getClaimTxId()),this.state=d.CLAIM_CLAIMED,!0;case g.SwapCommitStateType.NOT_COMMITED:case g.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&a.getRefundTxId&&(this.refundTxId=await a.getRefundTxId()),this.state=d.FAILED,!0;case g.SwapCommitStateType.COMMITED:let b=await this.getBitcoinPayment();if(null!=b&&b.confirmations>=this.requiredConfirmations)return this.txId=b.txId,this.vout=b.vout,this.state=d.BTC_TX_CONFIRMED,!0}}}async _sync(a){let b=await this.syncStateFromChain();return b&&a&&await this._saveAndEmit(),b}async _tick(a){switch(this.state){case d.PR_CREATED:if(this.expiry<Date.now())return this.state=d.QUOTE_SOFT_EXPIRED,a&&await this._saveAndEmit(),!0;break;case d.CLAIM_COMMITED:if(this.getTimeoutTime()<Date.now())return this.state=d.EXPIRED,a&&await this._saveAndEmit(),!0;case d.EXPIRED:if(Math.floor(Date.now()/1e3)%120==0)try{let b=await this.getBitcoinPayment();if(null!=b&&b.confirmations>=this.requiredConfirmations)return this.txId=b.txId,this.vout=b.vout,this.state=d.BTC_TX_CONFIRMED,a&&await this._saveAndEmit(),!0}catch(a){this.logger.warn("tickSwap("+this.getIdentifierHashString()+"): ",a)}}}}c.FromBTCSwap=p},598743,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.FromBTCWrapper=void 0;let d=a.r(856365),e=a.r(552363),f=a.r(163846),g=a.r(500874),h=a.r(974727),i=a.r(813954),j=a.r(213144),k=a.r(774702),l=a.r(570536),m=a.r(411320);class n extends d.IFromBTCWrapper{constructor(a,b,c,d,f,g,h,j,k,l,n,o,p){null==o&&(o={}),o.bitcoinNetwork=o.bitcoinNetwork??m.TEST_NETWORK,o.safetyFactor=o.safetyFactor||2,o.blocksTillTxConfirms=o.blocksTillTxConfirms||12,o.maxConfirmations=o.maxConfirmations||6,o.minSendWindow=o.minSendWindow||1800,o.bitcoinBlocktime=o.bitcoinBlocktime||600,super(a,b,c,d,f,g,h,j,o,p),this.TYPE=i.SwapType.FROM_BTC,this.swapDeserializer=e.FromBTCSwap,this.pendingSwapStates=[e.FromBTCSwapState.PR_CREATED,e.FromBTCSwapState.QUOTE_SOFT_EXPIRED,e.FromBTCSwapState.CLAIM_COMMITED,e.FromBTCSwapState.BTC_TX_CONFIRMED,e.FromBTCSwapState.EXPIRED],this.tickSwapState=[e.FromBTCSwapState.PR_CREATED,e.FromBTCSwapState.CLAIM_COMMITED,e.FromBTCSwapState.EXPIRED],this.btcRelay=k,this.synchronizer=l,this.btcRpc=n}processEventInitialize(a,b){return a.state===e.FromBTCSwapState.PR_CREATED||a.state===e.FromBTCSwapState.QUOTE_SOFT_EXPIRED?(a.state=e.FromBTCSwapState.CLAIM_COMMITED,Promise.resolve(!0)):Promise.resolve(!1)}processEventClaim(a,b){return a.state!==e.FromBTCSwapState.FAILED&&a.state!==e.FromBTCSwapState.CLAIM_CLAIMED?(a.state=e.FromBTCSwapState.CLAIM_CLAIMED,Promise.resolve(!0)):Promise.resolve(!1)}processEventRefund(a,b){return a.state!==e.FromBTCSwapState.CLAIM_CLAIMED&&a.state!==e.FromBTCSwapState.FAILED?(a.state=e.FromBTCSwapState.FAILED,Promise.resolve(!0)):Promise.resolve(!1)}getOnchainSendTimeout(a,b){let c=(this.options.blocksTillTxConfirms+b)*this.options.bitcoinBlocktime*this.options.safetyFactor;return a.getExpiry()-BigInt(c)}async preFetchClaimerBounty(a,b,c,d){let e=BigInt(Math.floor(Date.now()/1e3));if(c.unsafeZeroWatchtowerFee)return{feePerBlock:0n,safetyFactor:c.blockSafetyFactor,startTimestamp:e,addBlock:0,addFee:0n};let g=BigInt(Math.floor(0x1000000*Math.random())),h=await this.contract.createSwapData(f.ChainSwapType.CHAIN,a,a,b.token,g,this.contract.getHashForOnchain((0,j.randomBytes)(20),g,3).toString("hex"),this.getRandomSequence(),e,!1,!0,BigInt(Math.floor(65536*Math.random())),BigInt(Math.floor(65536*Math.random())));try{let[b,f,g,i]=await Promise.all([(0,j.tryWithRetries)(()=>this.btcRelay.getFeePerBlock(),null,null,d.signal),(0,j.tryWithRetries)(()=>this.btcRelay.getTipData(),null,null,d.signal),this.btcRpc.getTipHeight(),(0,j.tryWithRetries)(()=>this.contract.getClaimFee(a,h),null,null,d.signal)]),k=f.blockheight,l=Math.max(g-k,0);return{feePerBlock:b*c.feeSafetyFactor,safetyFactor:c.blockSafetyFactor,startTimestamp:e,addBlock:l,addFee:i*c.feeSafetyFactor}}catch(a){return d.abort(a),null}}getClaimerBounty(a,b,c){let d=(a.getExpiry()-c.startTimestamp)/BigInt(this.options.bitcoinBlocktime)*BigInt(b.blockSafetyFactor)+BigInt(c.addBlock);return c.addFee+d*c.feePerBlock}verifyReturnedData(a,b,c,d,e,k,l,m){if(b.exactIn){if(a.amount!==b.amount)throw new h.IntermediaryError("Invalid amount returned")}else if(a.total!==b.amount)throw new h.IntermediaryError("Invalid total returned");let n=a.confirmations??c.services[i.SwapType.FROM_BTC].data.confirmations;if(n>this.options.maxConfirmations)throw new h.IntermediaryError("Requires too many confirmations");let o=this.getClaimerBounty(e,d,l);if(e.getClaimerBounty()!==o||e.getType()!=f.ChainSwapType.CHAIN||e.getSequence()!==k||e.getAmount()!==a.total||e.isPayIn()||!e.isToken(b.token)||e.getOfferer()!==c.getAddress(this.chainIdentifier)||!e.isDepositToken(m))throw new h.IntermediaryError("Invalid data returned");if(this.getOnchainSendTimeout(e,n)-BigInt(Math.floor(Date.now()/1e3))<BigInt(this.options.minSendWindow))throw new h.IntermediaryError("Send window too low");let p=(0,j.toOutputScript)(this.options.bitcoinNetwork,a.btcAddress),q=this.contract.getExtraData(p,a.amount,n);if(!this.contract.getHashForOnchain(p,a.amount,n).equals(g.Buffer.from(e.getClaimHash(),"hex")))throw new h.IntermediaryError("Invalid claim hash returned!");if(!q.equals(g.Buffer.from(e.getExtraData(),"hex")))throw new h.IntermediaryError("Invalid extra data returned!")}create(a,b,c,d,f,g){d??={},d.blockSafetyFactor??=1,d.feeSafetyFactor??=2n;let h=this.getRandomSequence(),m=(0,j.extendAbortController)(g),n=this.preFetchPrice(b,m.signal),o=this.preFetchClaimerBounty(a,b,d,m),p=this.chain.getNativeCurrencyAddress(),q=this.preFetchFeeRate(a,b,null,m);return c.map(c=>({intermediary:c,quote:(async()=>{let g=(0,j.extendAbortController)(m.signal),r=this.preFetchIntermediaryLiquidity(b,c,g);try{let{signDataPromise:m,resp:s}=await (0,j.tryWithRetries)(async d=>{let{signDataPrefetch:e,response:i}=k.IntermediaryAPI.initFromBTC(this.chainIdentifier,c.url,p,{claimer:a,amount:b.amount,token:b.token.toString(),exactOut:!b.exactIn,sequence:h,claimerBounty:o,feeRate:q,additionalParams:f},this.options.postRequestTimeout,g.signal,!(d>0)&&null);return{signDataPromise:this.preFetchSignData(e),resp:await i}},null,a=>a instanceof l.RequestError,g.signal),t=new this.swapDataDeserializer(s.data);t.setClaimer(a),this.verifyReturnedData(s,b,c,d,t,h,await o,p);let[u,v]=await Promise.all([this.verifyReturnedPrice(c.services[i.SwapType.FROM_BTC],!1,s.amount,s.total,b.token,{},n,g.signal),this.verifyReturnedSignature(a,t,s,q,m,g.signal),this.verifyIntermediaryLiquidity(t.getAmount(),r)]),w=new e.FromBTCSwap(this,{pricingInfo:u,url:c.url,expiry:v,swapFee:s.swapFee,feeRate:await q,signatureData:s,data:t,address:s.btcAddress,amount:s.amount,exactIn:b.exactIn??!0,requiredConfirmations:s.confirmations??c.services[i.SwapType.FROM_BTC].data.confirmations});return await w._save(),w}catch(a){throw g.abort(a),a}})()}))}}c.FromBTCWrapper=n},73961,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.TrustedIntermediaryAPI=c.InvoiceStatusResponseCodes=c.AddressStatusResponseCodes=void 0;let d=a.r(213144),e=a.r(570536),f=a.r(266022);!function(a){a[a.EXPIRED=10001]="EXPIRED",a[a.PAID=1e4]="PAID",a[a.AWAIT_PAYMENT=10010]="AWAIT_PAYMENT",a[a.AWAIT_CONFIRMATION=10011]="AWAIT_CONFIRMATION",a[a.PENDING=10013]="PENDING",a[a.TX_SENT=10012]="TX_SENT",a[a.REFUNDED=10014]="REFUNDED",a[a.DOUBLE_SPENT=10015]="DOUBLE_SPENT",a[a.REFUNDABLE=10016]="REFUNDABLE"}(c.AddressStatusResponseCodes||(c.AddressStatusResponseCodes={}));let g={paymentHash:f.FieldTypeEnum.String,sequence:f.FieldTypeEnum.BigInt,btcAddress:f.FieldTypeEnum.String,amountSats:f.FieldTypeEnum.BigInt,swapFeeSats:f.FieldTypeEnum.BigInt,swapFee:f.FieldTypeEnum.BigInt,total:f.FieldTypeEnum.BigInt,intermediaryKey:f.FieldTypeEnum.String,recommendedFee:f.FieldTypeEnum.Number,expiresAt:f.FieldTypeEnum.Number};!function(a){a[a.EXPIRED=10001]="EXPIRED",a[a.PAID=1e4]="PAID",a[a.AWAIT_PAYMENT=10010]="AWAIT_PAYMENT",a[a.PENDING=10011]="PENDING",a[a.TX_SENT=10012]="TX_SENT"}(c.InvoiceStatusResponseCodes||(c.InvoiceStatusResponseCodes={}));let h={pr:f.FieldTypeEnum.String,swapFee:f.FieldTypeEnum.BigInt,total:f.FieldTypeEnum.BigInt};c.TrustedIntermediaryAPI=class{static async getInvoiceStatus(a,b,c,f){return(0,d.tryWithRetries)(()=>(0,d.httpGet)(a+"/getInvoiceStatus?paymentHash="+encodeURIComponent(b),c,f),null,e.RequestError,f)}static async initTrustedFromBTCLN(a,b,c,g,i){let j=await (0,d.tryWithRetries)(()=>(0,d.httpGet)(b+"/lnforgas/createInvoice?address="+encodeURIComponent(c.address)+"&amount="+encodeURIComponent(c.amount.toString(10))+"&chain="+encodeURIComponent(a)+"&token="+encodeURIComponent(c.token),g,i),null,e.RequestError,i);if(1e4!==j.code)throw e.RequestError.parse(JSON.stringify(j),400);return(0,f.verifySchema)(j.data,h)}static async getAddressStatus(a,b,c,f,g){return(0,d.tryWithRetries)(()=>(0,d.httpGet)(a+"/getAddressStatus?paymentHash="+encodeURIComponent(b)+"&sequence="+encodeURIComponent(c.toString(10)),f,g),null,e.RequestError,g)}static async setRefundAddress(a,b,c,f,g,h){return(0,d.tryWithRetries)(()=>(0,d.httpGet)(a+"/setRefundAddress?paymentHash="+encodeURIComponent(b)+"&sequence="+encodeURIComponent(c.toString(10))+"&refundAddress="+encodeURIComponent(f),g,h),null,e.RequestError,h)}static async initTrustedFromBTC(a,b,c,h,i){let j=await (0,d.tryWithRetries)(()=>(0,d.httpGet)(b+"/frombtc_trusted/getAddress?chain="+encodeURIComponent(a)+"&address="+encodeURIComponent(c.address)+"&amount="+encodeURIComponent(c.amount.toString(10))+"&refundAddress="+encodeURIComponent(c.refundAddress)+"&exactIn=true&token="+encodeURIComponent(c.token),h,i),null,e.RequestError,i);if(1e4!==j.code)throw e.RequestError.parse(JSON.stringify(j),400);return(0,f.verifySchema)(j.data,g)}}},35337,(a,b,c)=>{"use strict";var d;Object.defineProperty(c,"__esModule",{value:!0}),c.LnForGasSwap=c.isLnForGasSwapInit=c.LnForGasSwapState=void 0;let e=a.r(518040),f=a.r(813954),g=a.r(725291),h=a.r(213144),i=a.r(19763),j=a.r(73961),k=a.r(294982),l=a.r(921304);function m(a){return"string"==typeof a.pr&&"bigint"==typeof a.outputAmount&&"string"==typeof a.recipient&&"string"==typeof a.token&&(0,i.isISwapInit)(a)}!function(a){a[a.EXPIRED=-2]="EXPIRED",a[a.FAILED=-1]="FAILED",a[a.PR_CREATED=0]="PR_CREATED",a[a.PR_PAID=1]="PR_PAID",a[a.FINISHED=2]="FINISHED"}(d=c.LnForGasSwapState||(c.LnForGasSwapState={})),c.isLnForGasSwapInit=m;class n extends i.ISwap{constructor(a,b){if(m(b)&&(b.url+="/lnforgas"),super(a,b),this.currentVersion=2,this.TYPE=f.SwapType.TRUSTED_FROM_BTCLN,m(b)?this.state=d.PR_CREATED:(this.pr=b.pr,this.outputAmount=null==b.outputAmount?null:BigInt(b.outputAmount),this.recipient=b.recipient,this.token=b.token,this.scTxId=b.scTxId),this.tryRecomputeSwapPrice(),null!=this.pr){let a=(0,e.decode)(this.pr);this.expiry=1e3*a.timeExpireDate}this.logger=(0,h.getLogger)("LnForGas("+this.getId()+"): ")}upgradeVersion(){1==this.version&&(1===this.state&&(this.state=d.FINISHED),this.version=2),null==this.version&&(this.version=1)}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getInput().rawAmount/this.getOutAmountWithoutFee()),super.tryRecomputeSwapPrice()}_getEscrowHash(){return this.getId()}getOutputAddress(){return this.recipient}getInputTxId(){return this.getId()}getOutputTxId(){return this.scTxId}getId(){return null==this.pr?null:(0,e.decode)(this.pr).tagsObject.payment_hash}getAddress(){return this.pr}getHyperlink(){return"lightning:"+this.pr.toUpperCase()}requiresAction(){return!1}isFinished(){return this.state===d.FINISHED||this.state===d.FAILED||this.state===d.EXPIRED}isQuoteExpired(){return this.state===d.EXPIRED}isQuoteSoftExpired(){return this.expiry<Date.now()}isFailed(){return this.state===d.FAILED}isSuccessful(){return this.state===d.FINISHED}verifyQuoteValid(){return Promise.resolve(this.expiry>Date.now())}getOutAmountWithoutFee(){return this.outputAmount+this.swapFee}getOutput(){return(0,k.toTokenAmount)(this.outputAmount,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices)}getInput(){let a=(BigInt((0,e.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,k.toTokenAmount)(a,k.BitcoinTokens.BTCLN,this.wrapper.prices)}getInputWithoutFee(){let a=(BigInt((0,e.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,k.toTokenAmount)(a-this.swapFeeBtc,k.BitcoinTokens.BTCLN,this.wrapper.prices)}getSwapFee(){let a=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getInputWithoutFee().rawAmount;return{amountInSrcToken:(0,k.toTokenAmount)(this.swapFeeBtc,k.BitcoinTokens.BTCLN,this.wrapper.prices),amountInDstToken:(0,k.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,a,b),composition:{base:(0,k.toTokenAmount)(this.pricingInfo.satsBaseFee,k.BitcoinTokens.BTCLN,this.wrapper.prices),percentage:(0,i.ppmToPercentage)(a)}}}getFee(){return this.getSwapFee()}getFeeBreakdown(){return[{type:l.FeeType.SWAP,fee:this.getSwapFee()}]}async checkInvoicePaid(a=!0){if(this.state===d.FAILED||this.state===d.EXPIRED)return!1;if(this.state===d.FINISHED)return!0;let b=(0,e.decode)(this.pr).tagsObject.payment_hash,c=await j.TrustedIntermediaryAPI.getInvoiceStatus(this.url,b,this.wrapper.options.getRequestTimeout);switch(this.logger.debug("checkInvoicePaid(): LP response: ",c),c.code){case j.InvoiceStatusResponseCodes.PAID:if(this.scTxId=c.data.txId,"success"===await this.wrapper.chain.getTxIdStatus(this.scTxId))return this.state=d.FINISHED,a&&await this._saveAndEmit(),!0;return null;case j.InvoiceStatusResponseCodes.EXPIRED:return this.state===d.PR_CREATED?this.state=d.EXPIRED:this.state=d.FAILED,a&&await this._saveAndEmit(),!1;case j.InvoiceStatusResponseCodes.TX_SENT:return this.scTxId=c.data.txId,this.state===d.PR_CREATED&&(this.state=d.PR_PAID,a&&await this._saveAndEmit()),null;case j.InvoiceStatusResponseCodes.PENDING:return this.state===d.PR_CREATED&&(this.state=d.PR_PAID,a&&await this._saveAndEmit()),null;case j.InvoiceStatusResponseCodes.AWAIT_PAYMENT:return null;default:return this.state=d.FAILED,a&&await this._saveAndEmit(),!1}}async waitForPayment(a,b=5){if(this.state!==d.PR_CREATED)throw Error("Must be in PR_CREATED state!");for(this.initiated||(this.initiated=!0,await this._saveAndEmit());!a.aborted&&(this.state===d.PR_CREATED||this.state===d.PR_PAID);)await this.checkInvoicePaid(!0),(this.state===d.PR_CREATED||this.state===d.PR_PAID)&&await (0,h.timeoutPromise)(1e3*b,a);if(this.isFailed())throw new g.PaymentAuthError("Swap failed");return!this.isQuoteExpired()}serialize(){return{...super.serialize(),pr:this.pr,outputAmount:null==this.outputAmount?null:this.outputAmount.toString(10),recipient:this.recipient,token:this.token,scTxId:this.scTxId}}_getInitiator(){return this.recipient}async _sync(a){return this.state===d.PR_CREATED&&null!==await this.checkInvoicePaid(!1)&&(a&&await this._saveAndEmit(),!0)}_tick(a){return Promise.resolve(!1)}}c.LnForGasSwap=n},376545,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.LnForGasWrapper=void 0;let d=a.r(35337),e=a.r(366927),f=a.r(73961),g=a.r(518040),h=a.r(974727),i=a.r(813954);class j extends e.ISwapWrapper{constructor(){super(...arguments),this.TYPE=i.SwapType.TRUSTED_FROM_BTCLN,this.swapDeserializer=d.LnForGasSwap,this.pendingSwapStates=[d.LnForGasSwapState.PR_CREATED],this.tickSwapState=null,this.processEvent=null}async create(a,b,c){if(!this.isInitialized)throw Error("Not initialized, call init() first!");let e="string"==typeof c?c:c.url,j=this.chain.getNativeCurrencyAddress(),k=await f.TrustedIntermediaryAPI.initTrustedFromBTCLN(this.chainIdentifier,e,{address:a,amount:b,token:j},this.options.getRequestTimeout),l=(0,g.decode)(k.pr),m=(BigInt(l.millisatoshis)+999n)/1000n;if(k.total!==b)throw new h.IntermediaryError("Invalid total returned");let n=await this.verifyReturnedPrice("string"==typeof c?{swapFeePPM:1e4,swapBaseFee:10}:c.services[i.SwapType.TRUSTED_FROM_BTCLN],!1,m,b,j,{}),o=new d.LnForGasSwap(this,{pr:k.pr,outputAmount:k.total,recipient:a,pricingInfo:n,url:e,expiry:1e3*l.timeExpireDate,swapFee:k.swapFee,token:j,exactIn:!1});return await o._save(),o}}c.LnForGasWrapper=j},638369,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.wrapSwapWithSigner=void 0;let d=a.r(806361),e=a.r(64251),f=a.r(438427);c.wrapSwapWithSigner=function(a,b){return new Proxy(a,{get:(c,g,h)=>"commit"===g&&(a instanceof d.IToBTCSwap||a instanceof e.IFromBTCSwap)?(c,d)=>a.commit(b,c,d):"refund"===g&&a instanceof d.IToBTCSwap?c=>a.refund(b,c):"claim"===g&&a instanceof e.IFromBTCSwap?c=>a.claim(b,c):"commitAndClaim"===g&&a instanceof f.FromBTCLNSwap?(c,d)=>a.commitAndClaim(b,c,d):Reflect.get(c,g,h)})}},838470,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SwapperWithSigner=void 0;let d=a.r(638369);c.SwapperWithSigner=class{get prices(){return this.swapper.prices}get intermediaryDiscovery(){return this.swapper.intermediaryDiscovery}get mempoolApi(){return this.swapper.mempoolApi}get bitcoinRpc(){return this.swapper.bitcoinRpc}get bitcoinNetwork(){return this.swapper.bitcoinNetwork}get Utils(){return this.swapper.Utils}get SwapTypeInfo(){return this.swapper.SwapTypeInfo}constructor(a,b){this.swapper=a,this.signer=b}createToBTCSwap(a,b,c,e,f,g){return this.swapper.createToBTCSwap(this.signer.getAddress(),a,b,c,e,f,g).then(a=>(0,d.wrapSwapWithSigner)(a,this.signer))}createToBTCLNSwap(a,b,c,e){return this.swapper.createToBTCLNSwap(this.signer.getAddress(),a,b,c,e).then(a=>(0,d.wrapSwapWithSigner)(a,this.signer))}createToBTCLNSwapViaLNURL(a,b,c,e,f,g){return this.swapper.createToBTCLNSwapViaLNURL(this.signer.getAddress(),a,b,c,e,f,g).then(a=>(0,d.wrapSwapWithSigner)(a,this.signer))}createFromBTCSwap(a,b,c,e,f){return this.swapper.createFromBTCSwap(this.signer.getAddress(),a,b,c,e,f).then(a=>(0,d.wrapSwapWithSigner)(a,this.signer))}createFromBTCLNSwap(a,b,c,e,f){return this.swapper.createFromBTCLNSwap(this.signer.getAddress(),a,b,c,e,f).then(a=>(0,d.wrapSwapWithSigner)(a,this.signer))}createFromBTCLNSwapViaLNURL(a,b,c,e,f){return this.swapper.createFromBTCLNSwapViaLNURL(this.signer.getAddress(),a,b,c,e,f).then(a=>(0,d.wrapSwapWithSigner)(a,this.signer))}createTrustedLNForGasSwap(a,b){return this.swapper.createTrustedLNForGasSwap(this.signer.getAddress(),a,b)}createTrustedOnchainForGasSwap(a,b,c){return this.swapper.createTrustedOnchainForGasSwap(this.signer.getAddress(),a,b,c)}create(a,b,c,e,f){return this.swapper.create(this.signer.getAddress(),a,b,c,e,f).then(a=>(0,d.wrapSwapWithSigner)(a,this.signer))}getAllSwaps(){return this.swapper.getAllSwaps(this.signer.getAddress())}getActionableSwaps(){return this.swapper.getActionableSwaps(this.signer.getAddress())}getRefundableSwaps(){return this.swapper.getRefundableSwaps(this.signer.getAddress())}getSwapById(a){return this.swapper.getSwapById(a,this.signer.getAddress())}async _syncSwaps(){return this.swapper._syncSwaps(this.signer.getAddress())}supportsSwapType(a){return this.swapper.supportsSwapType(a)}getSwapType(a,b){return this.swapper.getSwapType(a,b)}getSwapLimits(a,b){return this.swapper.getSwapLimits(a,b)}getSwapCounterTokens(a,b){return this.swapper.getSwapCounterTokens(a,b)}getSwapBounds(){return this.swapper.getSwapBounds()}getMaximum(a,b){return this.swapper.getMaximum(a,b)}getMinimum(a,b){return this.swapper.getMinimum(a,b)}}},261724,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SwapperWithChain=void 0;let d=a.r(813954),e=a.r(356603),f=a.r(294982),g=a.r(838470);c.SwapperWithChain=class{get intermediaryDiscovery(){return this.swapper.intermediaryDiscovery}get mempoolApi(){return this.swapper.mempoolApi}get bitcoinRpc(){return this.swapper.bitcoinRpc}get bitcoinNetwork(){return this.swapper.bitcoinNetwork}get Utils(){return this.swapper.Utils}get SwapTypeInfo(){return this.swapper.SwapTypeInfo}constructor(a,b){this.swapper=a,this.chainIdentifier=b,this.prices=new e.SwapPriceWithChain(a.prices,b)}createToBTCSwap(a,b,c,d,e,f,g){return this.swapper.createToBTCSwap(this.chainIdentifier,a,b,c,d,e,f,g)}createToBTCLNSwap(a,b,c,d,e){return this.swapper.createToBTCLNSwap(this.chainIdentifier,a,b,c,d,e)}createToBTCLNSwapViaLNURL(a,b,c,d,e,f,g){return this.swapper.createToBTCLNSwapViaLNURL(this.chainIdentifier,a,b,c,d,e,f,g)}createFromBTCSwap(a,b,c,d,e,f){return this.swapper.createFromBTCSwap(this.chainIdentifier,a,b,c,d,e,f)}createFromBTCLNSwap(a,b,c,d,e,f){return this.swapper.createFromBTCLNSwap(this.chainIdentifier,a,b,c,d,e,f)}createFromBTCLNSwapViaLNURL(a,b,c,d,e,f){return this.swapper.createFromBTCLNSwapViaLNURL(this.chainIdentifier,a,b,c,d,e,f)}createTrustedLNForGasSwap(a,b,c){return this.swapper.createTrustedLNForGasSwap(this.chainIdentifier,a,b,c)}createTrustedOnchainForGasSwap(a,b,c,d){return this.swapper.createTrustedOnchainForGasSwap(this.chainIdentifier,a,b,c,d)}create(a,b,c,d,e,f){return this.swapper.create(a,b,c,d,e,f)}swap(a,b,c,d,e,f,g){return this.swapper.swap(a,b,c,d,e,f,g)}getAllSwaps(a){return this.swapper.getAllSwaps(this.chainIdentifier,a)}getActionableSwaps(a){return this.swapper.getActionableSwaps(this.chainIdentifier,a)}getRefundableSwaps(a){return this.swapper.getRefundableSwaps(this.chainIdentifier,a)}getSwapById(a,b){return this.swapper.getSwapById(a,this.chainIdentifier,b)}async _syncSwaps(a){return this.swapper._syncSwaps(this.chainIdentifier,a)}supportsSwapType(a){return this.swapper.supportsSwapType(this.chainIdentifier,a)}getSwapType(a,b){return this.swapper.getSwapType(a,b)}getSwapLimits(a,b){return this.swapper.getSwapLimits(a,b)}getSupportedTokens(a){let b=[];return this.intermediaryDiscovery.intermediaries.forEach(c=>{let e=a;if((e===d.SwapType.FROM_BTC&&this.supportsSwapType(d.SwapType.SPV_VAULT_FROM_BTC)&&(e=d.SwapType.SPV_VAULT_FROM_BTC),null!=c.services[e])&&null!=c.services[e].chainTokens)for(let a of c.services[e].chainTokens[this.chainIdentifier]){let c=this.swapper.tokens?.[this.chainIdentifier]?.[a];null!=c&&b.push(c)}}),b}getSupportedTokenAddresses(a){let b=new Set;return this.intermediaryDiscovery.intermediaries.forEach(c=>{null!=c.services[a]&&null!=c.services[a].chainTokens&&null!=c.services[a].chainTokens[this.chainIdentifier]&&c.services[a].chainTokens[this.chainIdentifier].forEach(a=>b.add(a))}),b}getSwapCounterTokens(a,b){if((0,f.isSCToken)(a)){let c=[];if(b)this.getSupportedTokenAddresses(d.SwapType.TO_BTCLN).has(a.address)&&c.push(f.BitcoinTokens.BTCLN),this.getSupportedTokenAddresses(d.SwapType.TO_BTC).has(a.address)&&c.push(f.BitcoinTokens.BTC);else{this.getSupportedTokenAddresses(d.SwapType.FROM_BTCLN).has(a.address)&&c.push(f.BitcoinTokens.BTCLN);let b=this.supportsSwapType(d.SwapType.SPV_VAULT_FROM_BTC)?d.SwapType.SPV_VAULT_FROM_BTC:d.SwapType.FROM_BTC;this.getSupportedTokenAddresses(b).has(a.address)&&c.push(f.BitcoinTokens.BTC)}return c}if(b)if(a.lightning)return this.getSupportedTokens(d.SwapType.FROM_BTCLN);else return this.getSupportedTokens(d.SwapType.FROM_BTC);return a.lightning?this.getSupportedTokens(d.SwapType.TO_BTCLN):this.getSupportedTokens(d.SwapType.TO_BTC)}withChain(a){return new g.SwapperWithSigner(this,a)}getSwapBounds(){return this.swapper.getSwapBounds(this.chainIdentifier)}getMaximum(a,b){return this.swapper.getMaximum(this.chainIdentifier,a,b)}getMinimum(a,b){return this.swapper.getMinimum(this.chainIdentifier,a,b)}}},765989,(a,b,c)=>{"use strict";var d;Object.defineProperty(c,"__esModule",{value:!0}),c.OnchainForGasSwap=c.isOnchainForGasSwapInit=c.OnchainForGasSwapState=void 0;let e=a.r(813954),f=a.r(725291),g=a.r(213144),h=a.r(19763),i=a.r(73961),j=a.r(294982),k=a.r(921304),l=a.r(963002),m=a.r(680302),n=a.r(823212),o=a.r(500874);function p(a){return"string"==typeof a.paymentHash&&"bigint"==typeof a.sequence&&"string"==typeof a.address&&"bigint"==typeof a.inputAmount&&"bigint"==typeof a.outputAmount&&"string"==typeof a.recipient&&"string"==typeof a.token&&(null==a.refundAddress||"string"==typeof a.refundAddress)&&(0,h.isISwapInit)(a)}!function(a){a[a.EXPIRED=-3]="EXPIRED",a[a.FAILED=-2]="FAILED",a[a.REFUNDED=-1]="REFUNDED",a[a.PR_CREATED=0]="PR_CREATED",a[a.FINISHED=1]="FINISHED",a[a.REFUNDABLE=2]="REFUNDABLE"}(d=c.OnchainForGasSwapState||(c.OnchainForGasSwapState={})),c.isOnchainForGasSwapInit=p;class q extends h.ISwap{constructor(a,b){p(b)&&(b.url+="/frombtc_trusted"),super(a,b),this.getSmartChainNetworkFee=null,this.TYPE=e.SwapType.TRUSTED_FROM_BTC,p(b)?this.state=d.PR_CREATED:(this.paymentHash=b.paymentHash,this.sequence=null==b.sequence?null:BigInt(b.sequence),this.address=b.address,this.inputAmount=null==b.inputAmount?null:BigInt(b.inputAmount),this.outputAmount=null==b.outputAmount?null:BigInt(b.outputAmount),this.recipient=b.recipient,this.token=b.token,this.refundAddress=b.refundAddress,this.scTxId=b.scTxId,this.txId=b.txId,this.refundTxId=b.refundTxId),this.logger=(0,g.getLogger)("OnchainForGas("+this.getId()+"): "),this.tryRecomputeSwapPrice()}upgradeVersion(){null==this.version&&(this.version=1)}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getInput().rawAmount/this.getOutAmountWithoutFee()),super.tryRecomputeSwapPrice()}_getEscrowHash(){return this.paymentHash}getOutputAddress(){return this.recipient}getInputTxId(){return this.txId}getOutputTxId(){return this.scTxId}getId(){return this.paymentHash}getAddress(){return this.address}getHyperlink(){return"bitcoin:"+this.address+"?amount="+encodeURIComponent((Number(this.inputAmount)/1e8).toString(10))}requiresAction(){return this.state===d.REFUNDABLE}isFinished(){return this.state===d.FINISHED||this.state===d.FAILED||this.state===d.EXPIRED||this.state===d.REFUNDED}isQuoteExpired(){return this.state===d.EXPIRED}isQuoteSoftExpired(){return this.expiry<Date.now()}isFailed(){return this.state===d.FAILED}isSuccessful(){return this.state===d.FINISHED}verifyQuoteValid(){return Promise.resolve(this.expiry>Date.now())}getOutAmountWithoutFee(){return this.outputAmount+this.swapFee}getOutput(){return(0,j.toTokenAmount)(this.outputAmount,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices)}getInput(){return(0,j.toTokenAmount)(this.inputAmount,j.BitcoinTokens.BTC,this.wrapper.prices)}getInputWithoutFee(){return(0,j.toTokenAmount)(this.inputAmount-this.swapFeeBtc,j.BitcoinTokens.BTC,this.wrapper.prices)}getSwapFee(){let a=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getInputWithoutFee().rawAmount;return{amountInSrcToken:(0,j.toTokenAmount)(this.swapFeeBtc,j.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,j.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,a,b),composition:{base:(0,j.toTokenAmount)(this.pricingInfo.satsBaseFee,j.BitcoinTokens.BTC,this.wrapper.prices),percentage:(0,h.ppmToPercentage)(a)}}}getFee(){return this.getSwapFee()}getFeeBreakdown(){return[{type:k.FeeType.SWAP,fee:this.getSwapFee()}]}getRequiredConfirmationsCount(){return 1}async getFundedPsbt(a,b){let c;if(this.state!==d.PR_CREATED)throw Error("Swap already paid for!");c=(0,l.isIBitcoinWallet)(a)?a:new n.SingleAddressBitcoinWallet(this.wrapper.btcRpc,this.wrapper.options.bitcoinNetwork,a),null==b&&(b=await c.getFeeRate());let e=new m.Transaction({allowUnknownOutputs:!0,allowLegacyWitnessUtxo:!0});e.addOutput({amount:this.outputAmount,script:(0,g.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address)});let f=await c.fundPsbt(e,b),h=[];for(let a=0;a<f.inputsLength;a++)h.push(a);return{psbt:f,signInputs:h}}async submitPsbt(a){if(this.state!==d.PR_CREATED)throw Error("Swap already paid for!");if(this.expiry<Date.now())throw Error("Swap expired!");let b=a.getOutput(0);if(b.amount!==this.outputAmount)throw Error("PSBT output amount invalid, expected: "+this.outputAmount+" got: "+b.amount);if(!(0,g.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address).equals(b.script))throw Error("PSBT output script invalid!");return a.isFinal||a.finalize(),await this.wrapper.btcRpc.sendRawTransaction(o.Buffer.from(a.toBytes(!0,!0)).toString("hex"))}async estimateBitcoinFee(a,b){let c=await a.getTransactionFee(this.address,this.inputAmount,b);return(0,j.toTokenAmount)(null==c?null:BigInt(c),j.BitcoinTokens.BTC,this.wrapper.prices)}async sendBitcoinTransaction(a,b){if(this.state!==d.PR_CREATED)throw Error("Swap already paid for!");return await a.sendTransaction(this.address,this.inputAmount,b)}async checkAddress(a=!0){if(this.state===d.FAILED||this.state===d.EXPIRED||this.state===d.REFUNDED||this.state===d.FINISHED)return!1;let b=await i.TrustedIntermediaryAPI.getAddressStatus(this.url,this.paymentHash,this.sequence,this.wrapper.options.getRequestTimeout);switch(b.code){case i.AddressStatusResponseCodes.AWAIT_PAYMENT:if(null!=this.txId)return this.txId=null,a&&await this._save(),!0;return!1;case i.AddressStatusResponseCodes.AWAIT_CONFIRMATION:case i.AddressStatusResponseCodes.PENDING:case i.AddressStatusResponseCodes.TX_SENT:let c=BigInt(b.data.adjustedAmount),e=BigInt(b.data.adjustedTotal),f=null==b.data.adjustedFee?null:BigInt(b.data.adjustedFee),g=null==b.data.adjustedFeeSats?null:BigInt(b.data.adjustedFeeSats),h=b.data.txId;if(this.txId!=h||this.inputAmount!==c||this.outputAmount!==e)return this.txId=h,this.inputAmount=c,this.outputAmount=e,null!=f&&(this.swapFee=f),null!=g&&(this.swapFeeBtc=g),a&&await this._save(),!0;return!1;case i.AddressStatusResponseCodes.PAID:if("success"===await this.wrapper.chain.getTxIdStatus(b.data.txId))return this.state=d.FINISHED,this.scTxId=b.data.txId,a&&await this._saveAndEmit(),!0;return!1;case i.AddressStatusResponseCodes.EXPIRED:return this.state=d.EXPIRED,a&&await this._saveAndEmit(),!0;case i.AddressStatusResponseCodes.REFUNDABLE:if(this.state===d.REFUNDABLE)return null;return this.state=d.REFUNDABLE,a&&await this._saveAndEmit(),!0;case i.AddressStatusResponseCodes.REFUNDED:return this.state=d.REFUNDED,this.refundTxId=b.data.txId,a&&await this._saveAndEmit(),!0;default:return this.state=d.FAILED,a&&await this._saveAndEmit(),!0}}async setRefundAddress(a){if(null!=this.refundAddress){if(this.refundAddress!==a)throw Error("Different refund address already set!");return}await i.TrustedIntermediaryAPI.setRefundAddress(this.url,this.paymentHash,this.sequence,a,this.wrapper.options.getRequestTimeout),this.refundAddress=a}async waitForBitcoinTransaction(a,b=5,c){if(this.state!==d.PR_CREATED)throw Error("Must be in PR_CREATED state!");for(this.initiated||(this.initiated=!0,await this._saveAndEmit());!a.aborted&&this.state===d.PR_CREATED;){if(await this.checkAddress(!0),null!=this.txId&&null!=c){let a=await this.wrapper.btcRpc.getTransaction(this.txId);if(null==a)c(null,null,1,null);else if(a.confirmations>0)c(a.txid,a.confirmations,1,0);else{let b=await this.wrapper.btcRpc.getConfirmationDelay(a,1);c(a.txid,0,1,b)}}this.state===d.PR_CREATED&&await (0,g.timeoutPromise)(1e3*b,a)}if(this.state===d.REFUNDABLE||this.state===d.REFUNDED)return this.txId;if(this.isQuoteExpired())throw new f.PaymentAuthError("Swap expired");if(this.isFailed())throw new f.PaymentAuthError("Swap failed");return this.txId}async waitTillRefunded(a,b=5){if(this.state!==d.REFUNDED){if(this.state!==d.REFUNDABLE)throw Error("Must be in REFUNDABLE state!");for(;!a.aborted&&this.state===d.REFUNDABLE;)await this.checkAddress(!0),this.state===d.REFUNDABLE&&await (0,g.timeoutPromise)(1e3*b,a);if(this.isQuoteExpired())throw new f.PaymentAuthError("Swap expired");if(this.isFailed())throw new f.PaymentAuthError("Swap failed")}}async requestRefund(a,b){null!=a&&await this.setRefundAddress(a),await this.waitTillRefunded(b)}serialize(){return{...super.serialize(),paymentHash:this.paymentHash,sequence:null==this.sequence?null:this.sequence.toString(10),address:this.address,inputAmount:null==this.inputAmount?null:this.inputAmount.toString(10),outputAmount:null==this.outputAmount?null:this.outputAmount.toString(10),recipient:this.recipient,token:this.token,refundAddress:this.refundAddress,scTxId:this.scTxId,txId:this.txId,refundTxId:this.refundTxId}}_getInitiator(){return this.recipient}async _sync(a){return!!(this.state===d.PR_CREATED&&await this.checkAddress(!1))&&(a&&await this._saveAndEmit(),!0)}_tick(a){return Promise.resolve(!1)}}c.OnchainForGasSwap=q},297468,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.OnchainForGasWrapper=void 0;let d=a.r(366927),e=a.r(73961),f=a.r(974727),g=a.r(765989),h=a.r(813954);class i extends d.ISwapWrapper{constructor(a,b,c,d,e,f,i,j,k){super(a,b,c,d,e,f,j,k),this.TYPE=h.SwapType.TRUSTED_FROM_BTC,this.swapDeserializer=g.OnchainForGasSwap,this.pendingSwapStates=[g.OnchainForGasSwapState.PR_CREATED],this.tickSwapState=null,this.processEvent=null,this.btcRpc=i}async create(a,b,c,d){if(!this.isInitialized)throw Error("Not initialized, call init() first!");let i="string"==typeof c?c:c.url,j=this.chain.getNativeCurrencyAddress(),k=await e.TrustedIntermediaryAPI.initTrustedFromBTC(this.chainIdentifier,i,{address:a,amount:b,refundAddress:d,token:j},this.options.getRequestTimeout);if(k.total!==b)throw new f.IntermediaryError("Invalid total returned");let l=await this.verifyReturnedPrice("string"==typeof c?{swapFeePPM:1e4,swapBaseFee:10}:c.services[h.SwapType.TRUSTED_FROM_BTC],!1,k.amountSats,b,this.chain.getNativeCurrencyAddress(),{}),m=new g.OnchainForGasSwap(this,{paymentHash:k.paymentHash,sequence:k.sequence,address:k.btcAddress,inputAmount:k.amountSats,outputAmount:k.total,recipient:a,refundAddress:d,pricingInfo:l,url:i,expiry:k.expiresAt,swapFee:k.swapFee,swapFeeBtc:k.swapFeeSats,exactIn:!1,token:j});return await m._save(),m}}c.OnchainForGasWrapper=i},129515,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.IndexedDBUnifiedStorage=void 0;let d=a.r(213144),e={escrowHash:{key:"escrowHash",unique:!0},type:{key:"type",unique:!1},initiator:{key:"initiator",unique:!1},"initiator, id":{key:["initiator","id"],unique:!1},"type, state":{key:["type","state"],unique:!1},"type, paymentHash":{key:["type","paymentHash"],unique:!1},"type, initiator, state":{key:["type","initiator","state"],unique:!1}};c.IndexedDBUnifiedStorage=class{constructor(a){this.storageKey=a,this.logger=(0,d.getLogger)("IndexedDBUnifiedStorage("+this.storageKey+"): ")}async tryMigrateLocalStorage(a,b,c){let d,e=window.localStorage.getItem(a);if(null==e)return!1;try{d=JSON.parse(e)}catch(b){return this.logger.warn("tryMigrate("+a+"): Tried to migrate the database, but cannot parse old local storage!"),!1}let f=Object.keys(d).map(a=>{let e=d[a];return e.type=b,c(e)});return await this.saveAll(f.map(a=>a.serialize())),window.localStorage.removeItem(a),this.logger.info("tryMigrate("+a+"): Database successfully migrated from localStorage to unifiedIndexedDB!"),!0}async tryMigrateOldIndexedDB(a,b,c){let d;if(null==(await window.indexedDB.databases()).find(b=>b.name===a))return this.logger.info("tryMigrateOldIndexedDB("+a+"): Old database not found!"),!1;this.logger.debug("tryMigrateOldIndexedDB("+a+"): Old database found!");try{d=await new Promise((b,c)=>{let d=window.indexedDB.open(a,1);d.onerror=a=>c(a),d.onsuccess=a=>b(a.target.result)})}catch(b){return this.logger.warn("tryMigrateOldIndexedDB("+a+"): Error opening old IndexedDB!",b),!1}this.logger.debug("tryMigrateOldIndexedDB("+a+"): Connection opened!");try{let e=await new Promise((a,b)=>{let c=d.transaction("swaps","readonly",{durability:"strict"}).objectStore("swaps").getAll();c.onsuccess=b=>a(b.target.result),c.onerror=a=>b(a)});this.logger.debug("tryMigrateOldIndexedDB("+a+"): Data retrieved!");let f=e.map(({id:a,data:d})=>(d.type=b,c(d)));return this.logger.debug("tryMigrateOldIndexedDB("+a+"): Data revived!"),await this.saveAll(f.map(a=>a.serialize())),this.logger.debug("tryMigrateOldIndexedDB("+a+"): Data saved!"),d.close(),this.logger.debug("tryMigrateOldIndexedDB("+a+"): DB connection closed!"),await new Promise((b,c)=>{let d=window.indexedDB.deleteDatabase(a);d.onsuccess=()=>b(),d.onerror=a=>c(a)}),this.logger.info("tryMigrateOldIndexedDB("+a+"): Database successfully migrated from oldIndexedDB to unifiedIndexedDB!"),!0}catch(b){return this.logger.warn("tryMigrateOldIndexedDB("+a+"): Tried to migrate the database, but cannot parse oldIndexedDB!",b),!1}}async tryMigrate(a,b){let c=!1;for(let d of a)this.logger.info("tryMigrate(): Trying to migrate...",d),await this.tryMigrateLocalStorage(d[0],d[1],b)&&(c=!0),await this.tryMigrateOldIndexedDB(d[0],d[1],b)&&(c=!0);return c}executeTransaction(a,b){return new Promise((c,d)=>{let e=a(this.db.transaction("swaps",b?"readonly":"readwrite",{durability:"strict"}).objectStore("swaps"));e.onsuccess=a=>c(a.target.result),e.onerror=a=>d(a)})}executeTransactionArr(a,b){return Promise.all(a(this.db.transaction("swaps",b?"readonly":"readwrite",{durability:"strict"}).objectStore("swaps")).map(a=>new Promise((b,c)=>{a.onsuccess=a=>b(a.target.result),a.onerror=a=>c(a)})))}executeTransactionWithCursor(a,b){return new Promise((c,d)=>{let e=a(this.db.transaction("swaps","readonly",{durability:"strict"}).objectStore("swaps")),f=[];for(let a of e)a.onsuccess=a=>{let d=a.target.result;if(null!=d){let a=d.value;b(a)&&f.push(a),d.continue()}else c(f)},a.onerror=a=>d(a)})}async init(){null==this.db&&(this.db=await new Promise((a,b)=>{let c=window.indexedDB.open(this.storageKey,1);c.onupgradeneeded=a=>{let b=a.target.result.createObjectStore("swaps",{keyPath:"id"});Object.keys(e).forEach(a=>{let c=e[a];b.createIndex(a,c.key,{unique:c.unique})})},c.onerror=a=>b(a),c.onsuccess=b=>a(b.target.result)}))}async query(a){return 0===a.length?await this.querySingle([]):Array.from(new Set((await Promise.all(a.map(a=>this.querySingle(a)))).flat()))}async querySingle(a){if(0===a.length)return await this.executeTransaction(a=>a.getAll(),!0);let b=a.map(a=>a.key).join(", ");if("id"===b){let b=Array.isArray(a[0].value)?a[0].value:[a[0].value];return(await this.executeTransactionArr(a=>b.map(b=>a.getAll(b)),!0)).flat()}if(null!=e[b]){let c=function a(b){if(0===b.length)return[];if(1===b.length)return b[0];{let c=[],d=b.shift(),e=a(b);for(let a of d)for(let b of e)c.push([a].concat(b));return c}}(a.map(a=>Array.isArray(a.value)?a.value:[a.value]));return(await this.executeTransactionArr(a=>{let d=a.index(b);return c.map(a=>d.getAll(a))},!0)).flat()}{this.logger.warn("query(): Index cannot be used for query, required index: "+b+" query params: ",a);let c=a.map(a=>({key:a.key,values:new Set(Array.isArray(a.value)?a.value:[a.value])}));return await this.executeTransactionWithCursor(a=>[a.openCursor()],a=>(function(a,b){for(let c of a){let a=b[c.key];if(!c.values.has(a))return!1}return!0})(c,a))}}async remove(a){await this.executeTransaction(b=>b.delete(a.id),!1).catch(()=>null)}async removeAll(a){0!==a.length&&await this.executeTransactionArr(b=>a.map(a=>b.delete(a.id)),!1)}async save(a){await this.executeTransaction(b=>b.put(a),!1)}async saveAll(a){0!==a.length&&await this.executeTransactionArr(b=>a.map(a=>b.put(a)),!1)}}},604433,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.UnifiedSwapStorage=void 0;let d=(0,a.r(213144).getLogger)("UnifiedSwapStorage: "),e=[{key:"id",type:"string",unique:!0,nullable:!1},{key:"escrowHash",type:"string",unique:!0,nullable:!0},{key:"type",type:"number",unique:!1,nullable:!1},{key:"initiator",type:"string",unique:!1,nullable:!1},{key:"state",type:"number",unique:!1,nullable:!1},{key:"paymentHash",type:"string",unique:!1,nullable:!0}],f=[{keys:["initiator","id"],unique:!1},{keys:["type","state"],unique:!1},{keys:["type","paymentHash"],unique:!1},{keys:["type","initiator","state"],unique:!1}];c.UnifiedSwapStorage=class{constructor(a,b){this.weakRefCache=new Map,this.storage=a,this.noWeakRefMap=b}init(){return this.storage.init(e,f)}async query(a,b){return(await this.storage.query(a)).map(a=>{if(!this.noWeakRefMap){let b=this.weakRefCache.get(a.id)?.deref();if(null!=b)return b;d.debug("query(): Reviving new swap instance: "+a.id)}let c=b(a);return this.noWeakRefMap||this.weakRefCache.set(a.id,new WeakRef(c)),c})}save(a){return this.noWeakRefMap||this.weakRefCache.set(a.getId(),new WeakRef(a)),this.storage.save(a.serialize())}saveAll(a){return this.noWeakRefMap||a.forEach(a=>this.weakRefCache.set(a.getId(),new WeakRef(a))),this.storage.saveAll(a.map(a=>a.serialize()))}remove(a){return this.noWeakRefMap||this.weakRefCache.delete(a.getId()),this.storage.remove(a.serialize())}removeAll(a){return this.noWeakRefMap||a.forEach(a=>this.weakRefCache.delete(a.getId())),this.storage.removeAll(a.map(a=>a.serialize()))}}},656293,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.UnifiedSwapEventListener=void 0;let d=a.r(163846);function e(a){return a instanceof d.SwapEvent?a.escrowHash:a instanceof d.SpvVaultFrontEvent||a instanceof d.SpvVaultClaimEvent||a instanceof d.SpvVaultCloseEvent?a.btcTxId:void 0}c.UnifiedSwapEventListener=class{constructor(a,b){this.listeners={},this.storage=a,this.events=b}async processEvents(a){let b={};for(let c of(a.forEach(a=>{b[e(a)]=null}),(await this.storage.query([[{key:"escrowHash",value:Object.keys(b)}]],a=>{let b=this.listeners[a.type];return null==b?null:new b.reviver(a)})).forEach(a=>b[a._getEscrowHash()]=a),a)){let a=b[e(c)];if(null==a)continue;let d=this.listeners[a.getType()];null!=d&&await d.listener(c,a)}}async start(){null==this.listener&&(await this.storage.init(),await this.events.init(),this.events.registerListener(this.listener=async a=>(await this.processEvents(a),!0)))}stop(){return this.events.unregisterListener(this.listener),this.events.stop()}registerListener(a,b,c){this.listeners[a]={listener:b,reviver:c}}unregisterListener(a){return!this.listeners[a]&&(delete this.listeners[a],!0)}}},490271,(a,b,c)=>{"use strict";var d;Object.defineProperty(c,"__esModule",{value:!0}),c.SpvFromBTCSwap=c.isSpvFromBTCSwapInit=c.SpvFromBTCSwapState=void 0;let e=a.r(19763),f=a.r(163846),g=a.r(813954),h=a.r(213144),i=a.r(680302),j=a.r(294982),k=a.r(500874),l=a.r(921304),m=a.r(963002),n=a.r(774702),o=a.r(823212);function p(a){return"object"==typeof a&&"string"==typeof a.quoteId&&"string"==typeof a.recipient&&"string"==typeof a.vaultOwner&&"bigint"==typeof a.vaultId&&"number"==typeof a.vaultRequiredConfirmations&&Array.isArray(a.vaultTokenMultipliers)&&a.vaultTokenMultipliers.reduce((a,b)=>a&&"bigint"==typeof b,!0)&&"string"==typeof a.vaultBtcAddress&&"string"==typeof a.vaultUtxo&&"bigint"==typeof a.vaultUtxoValue&&"string"==typeof a.btcDestinationAddress&&"bigint"==typeof a.btcAmount&&"bigint"==typeof a.btcAmountSwap&&"bigint"==typeof a.btcAmountGas&&"number"==typeof a.minimumBtcFeeRate&&"bigint"==typeof a.outputTotalSwap&&"string"==typeof a.outputSwapToken&&"bigint"==typeof a.outputTotalGas&&"string"==typeof a.outputGasToken&&"bigint"==typeof a.gasSwapFeeBtc&&"bigint"==typeof a.gasSwapFee&&"bigint"==typeof a.callerFeeShare&&"bigint"==typeof a.frontingFeeShare&&"bigint"==typeof a.executionFeeShare&&(0,e.isISwapInit)(a)}!function(a){a[a.CLOSED=-5]="CLOSED",a[a.FAILED=-4]="FAILED",a[a.DECLINED=-3]="DECLINED",a[a.QUOTE_EXPIRED=-2]="QUOTE_EXPIRED",a[a.QUOTE_SOFT_EXPIRED=-1]="QUOTE_SOFT_EXPIRED",a[a.CREATED=0]="CREATED",a[a.SIGNED=1]="SIGNED",a[a.POSTED=2]="POSTED",a[a.BROADCASTED=3]="BROADCASTED",a[a.FRONTED=4]="FRONTED",a[a.BTC_TX_CONFIRMED=5]="BTC_TX_CONFIRMED",a[a.CLAIMED=6]="CLAIMED"}(d=c.SpvFromBTCSwapState||(c.SpvFromBTCSwapState={})),c.isSpvFromBTCSwapInit=p;class q extends e.ISwap{constructor(a,b){if(p(b)&&(b.url+="/frombtc_spv"),super(a,b),this.TYPE=g.SwapType.SPV_VAULT_FROM_BTC,p(b)){this.state=d.CREATED;let a=(0,h.toCoinselectAddressType)((0,h.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.vaultBtcAddress));if("p2tr"!==a&&"p2wpkh"!==a&&"p2wsh"!==a)throw Error("Vault address type must be of witness type: p2tr, p2wpkh, p2wsh")}else this.quoteId=b.quoteId,this.recipient=b.recipient,this.vaultOwner=b.vaultOwner,this.vaultId=BigInt(b.vaultId),this.vaultRequiredConfirmations=b.vaultRequiredConfirmations,this.vaultTokenMultipliers=b.vaultTokenMultipliers.map(a=>BigInt(a)),this.vaultBtcAddress=b.vaultBtcAddress,this.vaultUtxo=b.vaultUtxo,this.vaultUtxoValue=BigInt(b.vaultUtxoValue),this.btcDestinationAddress=b.btcDestinationAddress,this.btcAmount=BigInt(b.btcAmount),this.btcAmountSwap=BigInt(b.btcAmountSwap),this.btcAmountGas=BigInt(b.btcAmountGas),this.minimumBtcFeeRate=b.minimumBtcFeeRate,this.outputTotalSwap=BigInt(b.outputTotalSwap),this.outputSwapToken=b.outputSwapToken,this.outputTotalGas=BigInt(b.outputTotalGas),this.outputGasToken=b.outputGasToken,this.gasSwapFeeBtc=BigInt(b.gasSwapFeeBtc),this.gasSwapFee=BigInt(b.gasSwapFee),this.callerFeeShare=BigInt(b.callerFeeShare),this.frontingFeeShare=BigInt(b.frontingFeeShare),this.executionFeeShare=BigInt(b.executionFeeShare),this.claimTxId=b.claimTxId,this.frontTxId=b.frontTxId,this.data=null==b.data?null:new this.wrapper.spvWithdrawalDataDeserializer(b.data);this.tryCalculateSwapFee(),this.logger=(0,h.getLogger)("SPVFromBTC("+this.getId()+"): ")}upgradeVersion(){}tryCalculateSwapFee(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.btcAmountSwap/this.getOutputWithoutFee().rawAmount),null==this.pricingInfo.swapPriceUSatPerToken&&(this.pricingInfo=this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier,this.btcAmountSwap,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,this.getOutputWithoutFee().rawAmount,this.outputSwapToken))}async refreshPriceData(){if(null==this.pricingInfo)return null;this.pricingInfo=await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier,this.btcAmountSwap,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,this.getOutputWithoutFee().rawAmount,this.outputSwapToken)}_getInitiator(){return this.recipient}_getEscrowHash(){return this.data?.btcTx?.txid}getId(){return this.quoteId+this.randomNonce}getQuoteExpiry(){return this.expiry-2e4}verifyQuoteValid(){return Promise.resolve(this.expiry>Date.now()&&(this.state===d.CREATED||this.state===d.QUOTE_SOFT_EXPIRED))}getOutputAddress(){return this.recipient}getOutputTxId(){return this.frontTxId??this.claimTxId}getInputTxId(){return this.data?.btcTx?.txid}requiresAction(){return this.state===d.BTC_TX_CONFIRMED}isFinished(){return this.state===d.CLAIMED||this.state===d.QUOTE_EXPIRED||this.state===d.FAILED}isClaimable(){return this.state===d.BTC_TX_CONFIRMED}isSuccessful(){return this.state===d.FRONTED||this.state===d.CLAIMED}isFailed(){return this.state===d.FAILED||this.state===d.DECLINED||this.state===d.CLOSED}isQuoteExpired(){return this.state===d.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===d.QUOTE_EXPIRED||this.state===d.QUOTE_SOFT_EXPIRED}getInputSwapAmountWithoutFee(){return(this.btcAmountSwap-this.swapFeeBtc)*100000n/(100000n+this.callerFeeShare+this.frontingFeeShare+this.executionFeeShare)}getInputGasAmountWithoutFee(){return(this.btcAmountGas-this.gasSwapFeeBtc)*100000n/(100000n+this.callerFeeShare+this.frontingFeeShare)}getInputAmountWithoutFee(){return this.getInputSwapAmountWithoutFee()+this.getInputGasAmountWithoutFee()}getOutputWithoutFee(){return(0,j.toTokenAmount)(this.outputTotalSwap*(100000n+this.callerFeeShare+this.frontingFeeShare+this.executionFeeShare)/100000n+this.swapFee,this.wrapper.tokens[this.outputSwapToken],this.wrapper.prices)}getSwapFee(){let a=this.wrapper.tokens[this.outputSwapToken],b=this.gasSwapFeeBtc*10n**BigInt(a.decimals)*1000000n/this.pricingInfo.swapPriceUSatPerToken,c=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/(this.btcAmount-this.swapFeeBtc-this.gasSwapFeeBtc);return{amountInSrcToken:(0,j.toTokenAmount)(this.swapFeeBtc+this.gasSwapFeeBtc,j.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,j.toTokenAmount)(this.swapFee+b,a,this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc+this.gasSwapFeeBtc,a,b),composition:{base:(0,j.toTokenAmount)(this.pricingInfo.satsBaseFee,j.BitcoinTokens.BTC,this.wrapper.prices),percentage:(0,e.ppmToPercentage)(c)}}}getWatchtowerFee(){let a=this.callerFeeShare+this.frontingFeeShare,b=this.wrapper.tokens[this.outputSwapToken],c=this.getInputGasAmountWithoutFee()*a*10n**BigInt(b.decimals)*1000000n/this.pricingInfo.swapPriceUSatPerToken/100000n,d=this.getInputAmountWithoutFee()*(a+this.executionFeeShare)/100000n;return{amountInSrcToken:(0,j.toTokenAmount)(d,j.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,j.toTokenAmount)(this.outputTotalSwap*(a+this.executionFeeShare)/100000n+c,b,this.wrapper.prices),usdValue:(a,b)=>this.wrapper.prices.getBtcUsdValue(d,a,b)}}getFee(){let a=this.getSwapFee(),b=this.getWatchtowerFee();return{amountInSrcToken:(0,j.toTokenAmount)(a.amountInSrcToken.rawAmount+b.amountInSrcToken.rawAmount,j.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,j.toTokenAmount)(a.amountInDstToken.rawAmount+b.amountInDstToken.rawAmount,this.wrapper.tokens[this.outputSwapToken],this.wrapper.prices),usdValue:(c,d)=>this.wrapper.prices.getBtcUsdValue(a.amountInSrcToken.rawAmount+b.amountInSrcToken.rawAmount,c,d)}}getFeeBreakdown(){return[{type:l.FeeType.SWAP,fee:this.getSwapFee()},{type:l.FeeType.NETWORK_OUTPUT,fee:this.getWatchtowerFee()}]}getOutput(){return(0,j.toTokenAmount)(this.outputTotalSwap,this.wrapper.tokens[this.outputSwapToken],this.wrapper.prices)}getGasDropOutput(){return(0,j.toTokenAmount)(this.outputTotalGas,this.wrapper.tokens[this.outputGasToken],this.wrapper.prices)}getInputWithoutFee(){return(0,j.toTokenAmount)(this.getInputAmountWithoutFee(),j.BitcoinTokens.BTC,this.wrapper.prices)}getInput(){return(0,j.toTokenAmount)(this.btcAmount,j.BitcoinTokens.BTC,this.wrapper.prices)}getRequiredConfirmationsCount(){return this.vaultRequiredConfirmations}async getTransactionDetails(){let[a,b]=this.vaultUtxo.split(":"),c=(0,h.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.vaultBtcAddress),d=(0,h.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.btcDestinationAddress),e=this.wrapper.contract.toOpReturnData(this.recipient,[this.outputTotalSwap/this.vaultTokenMultipliers[0],this.outputTotalGas/this.vaultTokenMultipliers[1]]),f=k.Buffer.concat([e.length>75?k.Buffer.from([106,76,e.length]):k.Buffer.from([106,e.length]),e]);if(this.callerFeeShare<0n||this.callerFeeShare>1048575n)throw Error("Caller fee out of bounds!");if(this.frontingFeeShare<0n||this.frontingFeeShare>1048575n)throw Error("Fronting fee out of bounds!");if(this.executionFeeShare<0n||this.executionFeeShare>1048575n)throw Error("Execution fee out of bounds!");let g=2147483648n|1048575n&this.callerFeeShare|(1047552n&this.frontingFeeShare)<<10n,i=2147483648n|1048575n&this.executionFeeShare|(1023n&this.frontingFeeShare)<<20n;return{in0txid:a,in0vout:parseInt(b),in0sequence:Number(g),vaultAmount:this.vaultUtxoValue,vaultScript:c,in1sequence:Number(i),out1script:f,out2amount:this.btcAmount,out2script:d,locktime:5e8+Math.floor(1e9*Math.random())}}async getPsbt(){let a=await this.getTransactionDetails(),b=new i.Transaction({allowUnknownOutputs:!0,allowLegacyWitnessUtxo:!0,lockTime:a.locktime});return b.addInput({txid:a.in0txid,index:a.in0vout,witnessUtxo:{amount:a.vaultAmount,script:a.vaultScript},sequence:a.in0sequence}),b.addOutput({amount:a.vaultAmount,script:a.vaultScript}),b.addOutput({amount:0n,script:a.out1script}),b.addOutput({amount:a.out2amount,script:a.out2script}),{psbt:b,in1sequence:a.in1sequence}}async getFundedPsbt(a,b){let c;if(c=(0,m.isIBitcoinWallet)(a)?a:new o.SingleAddressBitcoinWallet(this.wrapper.btcRpc,this.wrapper.options.bitcoinNetwork,a),null!=b){if(b<this.minimumBtcFeeRate)throw Error("Bitcoin tx fee needs to be at least "+this.minimumBtcFeeRate+" sats/vB")}else b=Math.max(this.minimumBtcFeeRate,await c.getFeeRate());let{psbt:d,in1sequence:e}=await this.getPsbt();(d=await c.fundPsbt(d,b)).updateInput(1,{sequence:e});let f=[];for(let a=1;a<d.inputsLength;a++)f.push(a);return{psbt:d,signInputs:f}}async submitPsbt(a){if(this.expiry<Date.now())throw Error("Quote expired!");if(this.state!==d.QUOTE_SOFT_EXPIRED&&this.state!==d.CREATED)throw Error("Invalid swap state!");for(let b=1;b<a.inputsLength;b++){if("legacy"===(0,i.getInputType)(a.getInput(b)).txType)throw Error("Legacy (non-segwit) inputs are not allowed in the transaction!");a.finalizeIdx(b)}let b=await this.wrapper.btcRpc.parseTransaction(k.Buffer.from(a.toBytes(!0)).toString("hex")),c=await this.wrapper.contract.getWithdrawalData(b);if(this.logger.debug("submitPsbt(): parsed withdrawal data: ",c),!c.isRecipient(this.recipient)||c.rawAmounts[0]*this.vaultTokenMultipliers[0]!==this.outputTotalSwap||(c.rawAmounts[1]??0n)*this.vaultTokenMultipliers[1]!==this.outputTotalGas||c.callerFeeRate!==this.callerFeeShare||c.frontingFeeRate!==this.frontingFeeShare||c.executionFeeRate!==this.executionFeeShare||c.getSpentVaultUtxo()!==this.vaultUtxo||BigInt(c.getNewVaultBtcAmount())!==this.vaultUtxoValue||!c.getNewVaultScript().equals((0,h.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.vaultBtcAddress))||null!=c.getExecutionData())throw Error("Invalid withdrawal tx data submitted!");let e=a.getOutput(2);if(e.amount!==this.btcAmount||!(0,h.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.btcDestinationAddress).equals(k.Buffer.from(e.script)))throw Error("Invalid LP bitcoin output in transaction!");if(await this.wrapper.btcRpc.isSpent(this.vaultUtxo))throw Error("Vault UTXO already spent, please create new swap!");try{await this.wrapper.contract.checkWithdrawalTx(c)}catch(a){throw Error("Transaction not parsable by the contract: "+(a.message??a.toString()))}if(this.expiry<Date.now())throw Error("Quote expired!");this.data=c,this.initiated=!0,await this._saveAndEmit(d.SIGNED);try{await n.IntermediaryAPI.initSpvFromBTC(this.chainIdentifier,this.url,{quoteId:this.quoteId,psbtHex:k.Buffer.from(a.toPSBT(0)).toString("hex")}),await this._saveAndEmit(d.POSTED)}catch(a){throw await this._saveAndEmit(d.DECLINED),a}return this.data.getTxId()}async estimateBitcoinFee(a,b){let c=await a.getFundedPsbtFee((await this.getPsbt()).psbt,b);return(0,j.toTokenAmount)(null==c?null:BigInt(c),j.BitcoinTokens.BTC,this.wrapper.prices)}async sendBitcoinTransaction(a,b){let{psbt:c,signInputs:d}=await this.getFundedPsbt(a,b);return c=await a.signPsbt(c,d),await this.submitPsbt(c)}async getBitcoinPayment(){if(this.data?.btcTx?.txid==null)return null;let a=await this.wrapper.btcRpc.getTransaction(this.data?.btcTx?.txid);return null==a?null:{txId:a.txid,confirmations:a.confirmations,targetConfirmations:this.vaultRequiredConfirmations}}async waitForBitcoinTransaction(a,b,c){if(this.state!==d.POSTED&&this.state!==d.BROADCASTED&&!(this.state===d.QUOTE_SOFT_EXPIRED&&this.initiated))throw Error("Must be in POSTED or BROADCASTED state!");let e=await this.wrapper.btcRpc.waitForTransaction(this.data.btcTx.txid,this.vaultRequiredConfirmations,(a,b,e)=>{null!=c&&c(b,a,this.vaultRequiredConfirmations,e),null!=b&&(this.state===d.POSTED||this.state==d.QUOTE_SOFT_EXPIRED)&&this._saveAndEmit(d.BROADCASTED)},a,b);return null!=a&&a.throwIfAborted(),this.state!==d.FRONTED&&this.state!==d.CLAIMED&&await this._saveAndEmit(d.BTC_TX_CONFIRMED),e.txid}async txsClaim(a){if(!this.isClaimable())throw Error("Must be in BTC_TX_CONFIRMED state!");let b=await this.wrapper.contract.getVaultData(this.vaultOwner,this.vaultId),c=[await this.wrapper.btcRpc.getTransaction(this.data.btcTx.txid)],d=b.getUtxo();for(;c[0].ins[0].txid+":"+c[0].ins[0].vout!==d;)c.unshift(await this.wrapper.btcRpc.getTransaction(c[0].ins[0].txid));let e=[];for(let a of c)e.push(await this.wrapper.contract.getWithdrawalData(a));return await this.wrapper.contract.txsClaim(null==a?this._getInitiator():a.getAddress(),b,e.map(a=>({tx:a})),this.wrapper.synchronizer,!0)}async claim(a,b){let c;try{c=await this.wrapper.chain.sendAndConfirm(a,await this.txsClaim(a),!0,b)}catch(b){if(this.logger.info("claim(): Failed to claim ourselves, checking swap claim state..."),this.state===d.CLAIMED)return this.logger.info("claim(): Transaction state is CLAIMED, swap was successfully claimed by the watchtower"),this.claimTxId;let a=await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);if(a.type===f.SpvWithdrawalStateType.CLAIMED)return this.logger.info("claim(): Transaction status is CLAIMED, swap was successfully claimed by the watchtower"),this.claimTxId=a.txId,await this._saveAndEmit(d.CLAIMED),null;throw b}return this.claimTxId=c[0],(this.state===d.POSTED||this.state===d.BROADCASTED||this.state===d.BTC_TX_CONFIRMED||this.state===d.FAILED||this.state===d.FRONTED)&&await this._saveAndEmit(d.CLAIMED),c[0]}async watchdogWaitTillResult(a,b=5){let c={type:f.SpvWithdrawalStateType.NOT_FOUND};for(;c.type===f.SpvWithdrawalStateType.NOT_FOUND;){await (0,h.timeoutPromise)(1e3*b,a);try{c=await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid)}catch(a){this.logger.error("watchdogWaitTillResult(): Error when fetching commit status: ",a)}}return null!=a&&a.throwIfAborted(),c}async waitTillClaimedOrFronted(a){if(this.state===d.CLAIMED||this.state===d.FRONTED)return Promise.resolve();let b=new AbortController;null!=a&&a.addEventListener("abort",()=>b.abort(a.reason));let c=await Promise.race([this.watchdogWaitTillResult(b.signal),this.waitTillState(d.CLAIMED,"eq",b.signal).then(()=>0),this.waitTillState(d.FRONTED,"eq",b.signal).then(()=>1),this.waitTillState(d.FAILED,"eq",b.signal).then(()=>2)]);if(b.abort(),"number"==typeof c){if(0===c)return void this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (CLAIMED)");if(1===c)return void this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (FRONTED)");if(2===c)throw this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (FAILED)"),Error("Swap failed while waiting for claim or front");return}this.logger.debug("waitTillClaimedOrFronted(): Resolved from watchdog"),c.type===f.SpvWithdrawalStateType.FRONTED&&(this.state!==d.FRONTED||this.state!==d.CLAIMED)&&(this.frontTxId=c.txId,await this._saveAndEmit(d.FRONTED)),c.type===f.SpvWithdrawalStateType.CLAIMED&&this.state!==d.CLAIMED&&(this.claimTxId=c.txId,await this._saveAndEmit(d.FRONTED)),c.type===f.SpvWithdrawalStateType.CLOSED&&this.state!==d.CLOSED&&await this._saveAndEmit(d.CLOSED)}async waitTillExecuted(a,b,c){await this.waitForBitcoinTransaction(a,b,c),await this.waitTillClaimedOrFronted(a)}serialize(){return{...super.serialize(),quoteId:this.quoteId,recipient:this.recipient,vaultOwner:this.vaultOwner,vaultId:this.vaultId.toString(10),vaultRequiredConfirmations:this.vaultRequiredConfirmations,vaultTokenMultipliers:this.vaultTokenMultipliers.map(a=>a.toString(10)),vaultBtcAddress:this.vaultBtcAddress,vaultUtxo:this.vaultUtxo,vaultUtxoValue:this.vaultUtxoValue.toString(10),btcDestinationAddress:this.btcDestinationAddress,btcAmount:this.btcAmount.toString(10),btcAmountSwap:this.btcAmountSwap.toString(10),btcAmountGas:this.btcAmountGas.toString(10),minimumBtcFeeRate:this.minimumBtcFeeRate,outputTotalSwap:this.outputTotalSwap.toString(10),outputSwapToken:this.outputSwapToken,outputTotalGas:this.outputTotalGas.toString(10),outputGasToken:this.outputGasToken,gasSwapFeeBtc:this.gasSwapFeeBtc.toString(10),gasSwapFee:this.gasSwapFee.toString(10),callerFeeShare:this.callerFeeShare.toString(10),frontingFeeShare:this.frontingFeeShare.toString(10),executionFeeShare:this.executionFeeShare.toString(10),claimTxId:this.claimTxId,frontTxId:this.frontTxId,data:this.data?.serialize()}}async syncStateFromBitcoin(a){if(this.data?.btcTx==null)return!1;let b=await this.getBitcoinPayment();if(null==b){for(let b of this.data.btcTx.ins)if(await this.wrapper.btcRpc.isSpent(b.txid+":"+b.vout,!0))return this.state===d.SIGNED||this.state===d.POSTED||this.state===d.QUOTE_SOFT_EXPIRED||this.state===d.DECLINED?this.state=d.QUOTE_EXPIRED:this.state=d.FAILED,a&&await this._saveAndEmit(),!0}else if(b.confirmations>=this.vaultRequiredConfirmations){if(this.state!==d.FRONTED&&this.state!==d.CLAIMED)return this.state=d.BTC_TX_CONFIRMED,a&&await this._saveAndEmit(),!0}else if(this.state===d.QUOTE_SOFT_EXPIRED||this.state===d.POSTED||this.state===d.SIGNED||this.state===d.DECLINED)return this.state=d.BROADCASTED,a&&await this._saveAndEmit(),!0;return!1}async syncStateFromChain(){let a=!1;if((this.state===d.SIGNED||this.state===d.POSTED||this.state===d.BROADCASTED||this.state===d.QUOTE_SOFT_EXPIRED||this.state===d.DECLINED)&&await this.syncStateFromBitcoin(!1)&&(a||=!0),this.state===d.BROADCASTED||this.state===d.BTC_TX_CONFIRMED){let b=await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);switch(this.logger.debug("syncStateFromChain(): status of "+this.data.btcTx.txid,b),b.type){case f.SpvWithdrawalStateType.FRONTED:this.frontTxId=b.txId,this.state=d.FRONTED,a||=!0;break;case f.SpvWithdrawalStateType.CLAIMED:this.claimTxId=b.txId,this.state=d.CLAIMED,a||=!0;break;case f.SpvWithdrawalStateType.CLOSED:this.state=d.CLOSED,a||=!0}}return(this.state===d.CREATED||this.state===d.SIGNED||this.state===d.POSTED)&&this.expiry<Date.now()&&(this.state===d.CREATED?this.state=d.QUOTE_EXPIRED:this.state=d.QUOTE_SOFT_EXPIRED,a||=!0),a}async _sync(a){let b=await this.syncStateFromChain();return b&&a&&await this._saveAndEmit(),b}async _tick(a){if((this.state===d.CREATED||this.state===d.SIGNED)&&this.getQuoteExpiry()<Date.now())return this.state=d.QUOTE_SOFT_EXPIRED,a&&await this._saveAndEmit(),!0;if(this.state===d.QUOTE_SOFT_EXPIRED&&!this.initiated&&this.expiry<Date.now())return this.state=d.QUOTE_EXPIRED,a&&await this._saveAndEmit(),!0;if(Math.floor(Date.now()/1e3)%120==0&&(this.state===d.POSTED||this.state===d.BROADCASTED))try{return await this.syncStateFromBitcoin(a)}catch(a){this.logger.error("tickSwap("+this.getId()+"): ",a)}}}c.SpvFromBTCSwap=q},639333,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SpvFromBTCWrapper=void 0;let d=a.r(366927),e=a.r(163846),f=a.r(490271),g=a.r(411320),h=a.r(813954),i=a.r(213144),j=a.r(774702),k=a.r(570536),l=a.r(974727),m=a.r(680302);class n extends d.ISwapWrapper{constructor(a,b,c,d,e,i,j,k,l,m,n,o,p){null==o&&(o={}),o.bitcoinNetwork??=g.TEST_NETWORK,o.maxConfirmations??=6,o.bitcoinBlocktime??=600,o.maxTransactionsDelta??=3,o.maxRawAmountAdjustmentDifferencePPM??=100,o.maxBtcFeeOffset??=5,o.maxBtcFeeMultiplier??=1.5,super(a,b,c,d,i,j,o,p),this.TYPE=h.SwapType.SPV_VAULT_FROM_BTC,this.swapDeserializer=f.SpvFromBTCSwap,this.pendingSwapStates=[f.SpvFromBTCSwapState.CREATED,f.SpvFromBTCSwapState.SIGNED,f.SpvFromBTCSwapState.POSTED,f.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,f.SpvFromBTCSwapState.BROADCASTED,f.SpvFromBTCSwapState.DECLINED,f.SpvFromBTCSwapState.BTC_TX_CONFIRMED],this.tickSwapState=[f.SpvFromBTCSwapState.CREATED,f.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,f.SpvFromBTCSwapState.SIGNED,f.SpvFromBTCSwapState.POSTED,f.SpvFromBTCSwapState.BROADCASTED],this.spvWithdrawalDataDeserializer=k,this.contract=e,this.btcRelay=l,this.synchronizer=m,this.btcRpc=n}processEventFront(a,b){return(b.state===f.SpvFromBTCSwapState.SIGNED||b.state===f.SpvFromBTCSwapState.POSTED||b.state===f.SpvFromBTCSwapState.BROADCASTED||b.state===f.SpvFromBTCSwapState.DECLINED||b.state===f.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED||b.state===f.SpvFromBTCSwapState.BTC_TX_CONFIRMED)&&(b.state=f.SpvFromBTCSwapState.FRONTED,!0)}processEventClaim(a,b){return(b.state===f.SpvFromBTCSwapState.SIGNED||b.state===f.SpvFromBTCSwapState.POSTED||b.state===f.SpvFromBTCSwapState.BROADCASTED||b.state===f.SpvFromBTCSwapState.DECLINED||b.state===f.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED||b.state===f.SpvFromBTCSwapState.BTC_TX_CONFIRMED)&&(b.state=f.SpvFromBTCSwapState.CLAIMED,!0)}processEventClose(a,b){return(b.state===f.SpvFromBTCSwapState.SIGNED||b.state===f.SpvFromBTCSwapState.POSTED||b.state===f.SpvFromBTCSwapState.BROADCASTED||b.state===f.SpvFromBTCSwapState.DECLINED||b.state===f.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED||b.state===f.SpvFromBTCSwapState.BTC_TX_CONFIRMED)&&(b.state=f.SpvFromBTCSwapState.CLOSED,!0)}async processEvent(a,b){if(null==b)return;let c=!1;return a instanceof e.SpvVaultFrontEvent&&(c=this.processEventFront(a,b),a.meta?.txId!=null&&b.frontTxId!==a.meta.txId&&(b.frontTxId=a.meta.txId,c||=!0)),a instanceof e.SpvVaultClaimEvent&&(c=this.processEventClaim(a,b),a.meta?.txId!=null&&b.claimTxId!==a.meta.txId&&(b.claimTxId=a.meta.txId,c||=!0)),a instanceof e.SpvVaultCloseEvent&&(c=this.processEventClose(a,b)),this.logger.info("processEvents(): "+a.constructor.name+" processed for "+b.getId()+" swap: ",b),c&&await b._saveAndEmit(),!0}async preFetchCallerFeeShare(a,b,c,d,e,f){if(c.unsafeZeroWatchtowerFee||0n===b.amount)return 0n;try{let a,[g,h,j,k,l]=await Promise.all([(0,i.tryWithRetries)(()=>this.btcRelay.getFeePerBlock(),null,null,f.signal),(0,i.tryWithRetries)(()=>this.btcRelay.getTipData(),null,null,f.signal),this.btcRpc.getTipHeight(),(0,i.tryWithRetries)(()=>this.contract.getClaimFee(this.chain.randomAddress(),null,null),null,null,f.signal),e??(b.token===this.chain.getNativeCurrencyAddress()?d:this.prices.preFetchPrice(this.chainIdentifier,this.chain.getNativeCurrencyAddress(),f.signal))]),m=h.blockheight,n=Math.max(j-m+this.options.maxConfirmations,0),o=(BigInt(n)*g+k*BigInt(this.options.maxTransactionsDelta))*BigInt(Math.floor(1e6*c.feeSafetyFactor))/1000000n;if(b.exactIn)a=await this.prices.getFromBtcSwapAmount(this.chainIdentifier,b.amount,this.chain.getNativeCurrencyAddress(),f.signal,l)-o;else if(b.token===this.chain.getNativeCurrencyAddress())a=b.amount;else{let c=await this.prices.getToBtcSwapAmount(this.chainIdentifier,b.amount,b.token,f.signal,await d);a=await this.prices.getFromBtcSwapAmount(this.chainIdentifier,c,this.chain.getNativeCurrencyAddress(),f.signal,l)}this.logger.debug("preFetchCallerFeeShare(): Caller fee in native token: "+o.toString(10)+" total payout in native token: "+a.toString(10));let p=(100000n*o+a-1n)/a;if(p<0n)return 0n;if(p>=2n**20n)return 2n**20n-1n;return p}catch(a){return f.abort(a),null}}async verifyReturnedData(a,b,c,d,e,f){let g,h,j,k,m;if(a.btcFeeRate>await f)throw new l.IntermediaryError("Bitcoin fee rate returned too high!");try{g=(0,i.toOutputScript)(this.options.bitcoinNetwork,a.vaultBtcAddress),h=(0,i.toCoinselectAddressType)(g),j=(0,i.toOutputScript)(this.options.bitcoinNetwork,a.btcAddress)}catch(a){throw new l.IntermediaryError("Invalid btc address data returned!")}let n=a.btcUtxo.split(":");if(a.address!==c.getAddress(this.chainIdentifier)||a.vaultId<0n||null==g||null==j||"p2pkh"===h||"p2sh-p2wpkh"===h||2!==n.length||64!==n[0].length||isNaN(parseInt(n[1]))||a.btcFeeRate<1||a.btcFeeRate>1e4)throw new l.IntermediaryError("Invalid vault data returned!");if(a.btcAmountSwap+a.btcAmountGas!==a.btcAmount)throw Error("Btc amount mismatch");if(a.swapFeeBtc+a.gasSwapFeeBtc!==a.totalFeeBtc)throw Error("Btc fee mismatch");if(a.callerFeeShare!==e||0n!==a.frontingFeeShare||0n!==a.executionFeeShare)throw new l.IntermediaryError("Invalid caller/fronting/execution fee returned");if(a.expiry<Math.floor(Date.now()/1e3))throw new l.IntermediaryError("Quote already expired");try{k=await this.contract.getVaultData(a.address,a.vaultId)}catch(b){throw this.logger.error("Error getting spv vault (owner: "+a.address+" vaultId: "+a.vaultId.toString(10)+"): ",b),new l.IntermediaryError("Spv swap vault not found!")}if(!k.isOpened())throw new l.IntermediaryError("Returned spv swap vault is not opened!");if(k.getConfirmations()>this.options.maxConfirmations)throw new l.IntermediaryError("SPV swap vault needs too many confirmations: "+k.getConfirmations());let o=k.getTokenData();if(b.exactIn){if(a.btcAmount!==b.amount)throw new l.IntermediaryError("Invalid amount returned")}else{let c=b.amount/o[0].multiplier*o[0].multiplier;if((b.amount-c)*1000000n/b.amount>this.options.maxRawAmountAdjustmentDifferencePPM)throw new l.IntermediaryError("Invalid amount0 multiplier used, rawAmount diff too high");if(a.total!==c)throw new l.IntermediaryError("Invalid total returned")}if(null==d.gasAmount||0n===d.gasAmount){if(0n!==a.totalGas)throw new l.IntermediaryError("Invalid gas total returned")}else{let b=d.gasAmount/o[0].multiplier*o[0].multiplier;if((d.gasAmount-b)*1000000n/d.gasAmount>this.options.maxRawAmountAdjustmentDifferencePPM)throw new l.IntermediaryError("Invalid amount1 multiplier used, rawAmount diff too high");if(a.totalGas!==b)throw new l.IntermediaryError("Invalid gas total returned")}let p=a.btcUtxo.toLowerCase(),[q,r]=p.split(":"),s=await this.btcRpc.getTransaction(q);if(null==s.confirmations||s.confirmations<1)throw new l.IntermediaryError("SPV vault UTXO not confirmed");let t=parseInt(r);if(null==s.outs[t])throw new l.IntermediaryError("Invalid UTXO, doesn't exist");let u=s.outs[t].value;if(await this.btcRpc.isSpent(p))throw new l.IntermediaryError("Returned spv vault UTXO is already spent");this.logger.debug("verifyReturnedData(): Vault UTXO: "+k.getUtxo()+" current utxo: "+p);let v=[];for(;k.getUtxo()!==p;){let[a,b]=p.split(":");s.txid!==a&&(s=await this.btcRpc.getTransaction(a));let c=await this.contract.getWithdrawalData(s);if(v.unshift(c),p=v[0].getSpentVaultUtxo(),this.logger.debug("verifyReturnedData(): Vault UTXO: "+k.getUtxo()+" current utxo: "+p),v.length>=this.options.maxTransactionsDelta)throw new l.IntermediaryError("BTC <> SC state difference too deep, maximum: "+this.options.maxTransactionsDelta)}try{m=k.calculateStateAfter(v)}catch(b){throw this.logger.error("Error calculating spv vault balance (owner: "+a.address+" vaultId: "+a.vaultId.toString(10)+"): ",b),new l.IntermediaryError("Spv swap vault balance prediction failed!")}if(m.balances[0].scaledAmount<a.total)throw new l.IntermediaryError("SPV swap vault, insufficient balance, required: "+a.total.toString(10)+" has: "+m.balances[0].scaledAmount.toString(10));if(m.balances[1].scaledAmount<a.totalGas)throw new l.IntermediaryError("SPV swap vault, insufficient balance, required: "+a.totalGas.toString(10)+" has: "+m.balances[1].scaledAmount.toString(10));try{for(let a of v)await this.contract.checkWithdrawalTx(a)}catch(b){throw this.logger.error("Error calculating spv vault balance (owner: "+a.address+" vaultId: "+a.vaultId.toString(10)+"): ",b),new l.IntermediaryError("Spv swap vault balance prediction failed!")}return{vault:k,vaultUtxoValue:u}}create(a,b,c,d,e,g){d??={},d.gasAmount??=0n,d.feeSafetyFactor??=1.25;let l=(0,i.extendAbortController)(g),m=this.preFetchPrice(b,l.signal),n=this.chain.getNativeCurrencyAddress(),o=0n===d.gasAmount?null:this.preFetchPrice({token:n},l.signal),p=this.preFetchCallerFeeShare(a,b,d,m,o,l),q=null!=d.maxAllowedNetworkFeeRate?Promise.resolve(d.maxAllowedNetworkFeeRate):this.btcRpc.getFeeRate().then(a=>this.options.maxBtcFeeOffset+a*this.options.maxBtcFeeMultiplier).catch(a=>(l.abort(a),null));return c.map(c=>({intermediary:c,quote:(async()=>{let g=(0,i.extendAbortController)(l.signal);try{let l=await (0,i.tryWithRetries)(async f=>await j.IntermediaryAPI.prepareSpvFromBTC(this.chainIdentifier,c.url,{address:a,amount:b.amount,token:b.token.toString(),exactOut:!b.exactIn,gasToken:n,gasAmount:d.gasAmount,callerFeeRate:p,frontingFeeRate:0n,additionalParams:e},this.options.postRequestTimeout,g.signal,!(f>0)&&null),null,a=>a instanceof k.RequestError,g.signal);this.logger.debug("create("+c.url+"): LP response: ",l);let r=await p,[s,t,{vault:u,vaultUtxoValue:v}]=await Promise.all([this.verifyReturnedPrice(c.services[h.SwapType.SPV_VAULT_FROM_BTC],!1,l.btcAmountSwap,l.total*(100000n+r)/100000n,b.token,{},m,g.signal),0n===d.gasAmount?Promise.resolve():this.verifyReturnedPrice({...c.services[h.SwapType.SPV_VAULT_FROM_BTC],swapBaseFee:0},!1,l.btcAmountGas,l.totalGas*(100000n+r)/100000n,n,{},o,g.signal),this.verifyReturnedData(l,b,c,d,r,q)]),w={pricingInfo:s,url:c.url,expiry:1e3*l.expiry,swapFee:l.swapFee,swapFeeBtc:l.swapFeeBtc,exactIn:b.exactIn??!0,quoteId:l.quoteId,recipient:a,vaultOwner:l.address,vaultId:l.vaultId,vaultRequiredConfirmations:u.getConfirmations(),vaultTokenMultipliers:u.getTokenData().map(a=>a.multiplier),vaultBtcAddress:l.vaultBtcAddress,vaultUtxo:l.btcUtxo,vaultUtxoValue:BigInt(v),btcDestinationAddress:l.btcAddress,btcAmount:l.btcAmount,btcAmountSwap:l.btcAmountSwap,btcAmountGas:l.btcAmountGas,minimumBtcFeeRate:l.btcFeeRate,outputTotalSwap:l.total,outputSwapToken:b.token,outputTotalGas:l.totalGas,outputGasToken:n,gasSwapFeeBtc:l.gasSwapFeeBtc,gasSwapFee:l.gasSwapFee,callerFeeShare:l.callerFeeShare,frontingFeeShare:l.frontingFeeShare,executionFeeShare:l.executionFeeShare},x=new f.SpvFromBTCSwap(this,w);return await x._save(),x}catch(a){throw g.abort(a),a}})()}))}getDummySwapPsbt(a=!1){let b=new m.Transaction({allowUnknownInputs:!0,allowLegacyWitnessUtxo:!0,allowUnknownOutputs:!0}),c=m.OutScript.encode({type:"tr",pubkey:Buffer.from("0101010101010101010101010101010101010101010101010101010101010101","hex")});b.addInput({txid:(0,i.randomBytes)(32),index:0,witnessUtxo:{script:c,amount:600n}}),b.addOutput({script:c,amount:600n});let d=this.contract.toOpReturnData(this.chain.randomAddress(),a?[0xffffffffffffffffn,0xffffffffffffffffn]:[0xffffffffffffffffn]);return b.addOutput({script:Buffer.concat([d.length<=75?Buffer.from([106,d.length]):Buffer.from([106,76,d.length]),d]),amount:0n}),b}}c.SpvFromBTCWrapper=n},412878,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SwapperUtils=void 0;let d=a.r(518040),e=a.r(680302),f=a.r(314595),g=a.r(813954),h=a.r(294982),i=a.r(823212),j=a.r(163846),k=a.r(213144);c.SwapperUtils=class{constructor(a){this.bitcoinNetwork=a.bitcoinNetwork,this.root=a}isLightningInvoice(a){try{return(0,d.decode)(a),!0}catch(a){}return!1}isValidBitcoinAddress(a){try{return(0,e.Address)(this.bitcoinNetwork).decode(a),!0}catch(a){return!1}}isValidLightningInvoice(a){try{let b=(0,d.decode)(a);if(null!=b.millisatoshis)return!0}catch(a){}return!1}isValidLNURL(a){return f.LNURL.isLNURL(a)}getLNURLTypeAndData(a,b){return f.LNURL.getLNURLType(a,b)}getLightningInvoiceValue(a){let b=(0,d.decode)(a);return null!=b.millisatoshis?(BigInt(b.millisatoshis)+999n)/1000n:null}parseBitcoinAddress(a){let b=null;if(a.includes("?")){let c=a.split("?");for(let d of(a=c[0],c[1].split("&"))){let a=d.split("="),c=a[0],e=decodeURIComponent(a[1]);"amount"===c&&(b=(0,h.fromDecimal)(parseFloat(e).toFixed(8),8))}}if(this.isValidBitcoinAddress(a))return{address:a,type:"BITCOIN",swapType:g.SwapType.TO_BTC,amount:(0,h.toTokenAmount)(b,h.BitcoinTokens.BTC,this.root.prices)}}parseLNURLSync(a){if(this.isValidLNURL(a))return{address:a,type:"LNURL",swapType:null}}async parseLNURL(a){if(this.isValidLNURL(a))try{let b=await this.getLNURLTypeAndData(a);if(null==b)throw Error("Invalid LNURL specified!");let c={address:a,type:"LNURL",swapType:(0,f.isLNURLPay)(b)?g.SwapType.TO_BTCLN:(0,f.isLNURLWithdraw)(b)?g.SwapType.FROM_BTCLN:null,lnurl:b};if(b.min===b.max)return{...c,amount:(0,h.toTokenAmount)(b.min,h.BitcoinTokens.BTCLN,this.root.prices)};return{...c,min:(0,h.toTokenAmount)(b.min,h.BitcoinTokens.BTCLN,this.root.prices),max:(0,h.toTokenAmount)(b.max,h.BitcoinTokens.BTCLN,this.root.prices)}}catch(a){throw Error("Failed to contact LNURL service, check your internet connection and retry later.")}}parseLightningInvoice(a){if(this.isLightningInvoice(a))if(this.isValidLightningInvoice(a)){let b=this.getLightningInvoiceValue(a);return{address:a,type:"LIGHTNING",swapType:g.SwapType.TO_BTCLN,amount:(0,h.toTokenAmount)(b,h.BitcoinTokens.BTCLN,this.root.prices)}}else throw Error("Lightning invoice needs to contain an amount!")}parseSmartchainAddress(a){for(let b of this.root.getSmartChains())if(this.root.chains[b].chainInterface.isValidAddress(a))if(this.root.supportsSwapType(b,g.SwapType.SPV_VAULT_FROM_BTC))return{address:a,type:b,swapType:g.SwapType.SPV_VAULT_FROM_BTC};else return{address:a,type:b,swapType:null}}async parseAddress(a){if(a.startsWith("bitcoin:")){let b=this.parseBitcoinAddress(a.substring(8));if(null!=b)return b;throw Error("Invalid bitcoin address!")}let b=this.parseBitcoinAddress(a);if(null!=b)return b;if(a.startsWith("lightning:")){let b=a.substring(10),c=await this.parseLNURL(b);if(null!=c)return c;let d=this.parseLightningInvoice(b);if(null!=d)return d;throw Error("Invalid lightning network invoice or LNURL!")}let c=await this.parseLNURL(a);if(null!=c)return c;let d=this.parseLightningInvoice(a);return null!=d?d:this.parseSmartchainAddress(a)}parseAddressSync(a){if(a.startsWith("bitcoin:")){let b=this.parseBitcoinAddress(a.substring(8));if(null!=b)return b;throw Error("Invalid bitcoin address!")}let b=this.parseBitcoinAddress(a);if(null!=b)return b;if(a.startsWith("lightning:")){let b=a.substring(10),c=this.parseLNURLSync(b);if(null!=c)return c;let d=this.parseLightningInvoice(b);if(null!=d)return d;throw Error("Invalid lightning network invoice or LNURL!")}let c=this.parseLNURLSync(a);if(null!=c)return c;let d=this.parseLightningInvoice(a);return null!=d?d:this.parseSmartchainAddress(a)}getRandomSpvVaultPsbt(a,b){let c=this.root.chains[a].wrappers[g.SwapType.SPV_VAULT_FROM_BTC];if(null==c)throw Error("Chain doesn't support spv vault swaps!");return c.getDummySwapPsbt(b)}async getBitcoinSpendableBalance(a,b,c){let d,e;if("string"!=typeof a&&null==a.getTransactionFee)throw Error("Wallet must be a string address or IBitcoinWallet");d="string"==typeof a?new i.SingleAddressBitcoinWallet(this.root.bitcoinRpc,this.bitcoinNetwork,a):a;let f=c?.feeRate??await d.getFeeRate();return c?.minFeeRate!=null&&(f=Math.max(f,c.minFeeRate)),e=null!=b&&this.root.supportsSwapType(b,g.SwapType.SPV_VAULT_FROM_BTC)?await d.getSpendableBalance(this.getRandomSpvVaultPsbt(b,c?.gasDrop),f):await d.getSpendableBalance(void 0,f),{balance:(0,h.toTokenAmount)(e.balance,h.BitcoinTokens.BTC,this.root.prices),feeRate:e.feeRate}}async getSpendableBalance(a,b,c){let d;if("string"!=typeof a&&null==a.getAddress)throw Error("Signer must be a string or smart chain signer");if(null==this.root.chains[b.chainId])throw Error("Invalid chain identifier! Unknown chain: "+b.chainId);let{swapContract:e,chainInterface:f}=this.root.chains[b.chainId],g="string"==typeof a?a:a.getAddress();if(f.getNativeCurrencyAddress()!==b.address)d=await f.getBalance(g,b.address);else{let[a,h]=await Promise.all([f.getBalance(g,b.address),e.getCommitFee(await e.createSwapData(j.ChainSwapType.HTLC,g,null,b.address,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn,e.getHashForHtlc((0,k.randomBytes)(32)).toString("hex"),j.BigIntBufferUtils.fromBuffer((0,k.randomBytes)(8)),BigInt(Math.floor(Date.now()/1e3)),!0,!1,j.BigIntBufferUtils.fromBuffer((0,k.randomBytes)(2)),j.BigIntBufferUtils.fromBuffer((0,k.randomBytes)(2))),c?.feeRate)]);c?.feeMultiplier!=null&&(h=h*BigInt(Math.floor(1e6*c.feeMultiplier))/1000000n),d=(0,k.bigIntMax)(a-h,0n)}return(0,h.toTokenAmount)(d,b,this.root.prices)}getNativeToken(a){if(null==this.root.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);return this.root.tokens[a][this.root.chains[a].chainInterface.getNativeCurrencyAddress()]}randomSigner(a){if(null==this.root.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);return this.root.chains[a].chainInterface.randomSigner()}randomAddress(a){if(null==this.root.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);return this.root.chains[a].chainInterface.randomAddress()}}},377342,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.Swapper=void 0;let d=a.r(163846),e=a.r(2697),f=a.r(342729),g=a.r(53731),h=a.r(598743),i=a.r(947317),j=a.r(518040),k=a.r(974727),l=a.r(813954),m=a.r(255707),n=a.r(376545),o=a.r(427699),p=a.r(314595),q=a.r(213144),r=a.r(570536),s=a.r(261724),t=a.r(294982),u=a.r(297468),v=a.r(411320),w=a.r(129515),x=a.r(604433),y=a.r(656293),z=a.r(639333),A=a.r(412878);class B extends o.EventEmitter{constructor(a,b,c,j,k){super(),this.logger=(0,q.getLogger)(this.constructor.name+": "),this.SwapTypeInfo={[l.SwapType.TO_BTC]:{requiresInputWallet:!0,requiresOutputWallet:!1,supportsGasDrop:!1},[l.SwapType.TO_BTCLN]:{requiresInputWallet:!0,requiresOutputWallet:!1,supportsGasDrop:!1},[l.SwapType.FROM_BTC]:{requiresInputWallet:!1,requiresOutputWallet:!0,supportsGasDrop:!1},[l.SwapType.FROM_BTCLN]:{requiresInputWallet:!1,requiresOutputWallet:!0,supportsGasDrop:!1},[l.SwapType.SPV_VAULT_FROM_BTC]:{requiresInputWallet:!0,requiresOutputWallet:!1,supportsGasDrop:!0},[l.SwapType.TRUSTED_FROM_BTC]:{requiresInputWallet:!1,requiresOutputWallet:!1,supportsGasDrop:!1},[l.SwapType.TRUSTED_FROM_BTCLN]:{requiresInputWallet:!1,requiresOutputWallet:!1,supportsGasDrop:!1}};let o=k?.storagePrefix??"atomiq-";for(let b of(k.bitcoinNetwork=null==k.bitcoinNetwork?d.BitcoinNetwork.TESTNET:k.bitcoinNetwork,k.swapStorage??=a=>new w.IndexedDBUnifiedStorage(a),this._bitcoinNetwork=k.bitcoinNetwork,this.bitcoinNetwork=k.bitcoinNetwork===d.BitcoinNetwork.MAINNET?v.NETWORK:k.bitcoinNetwork===d.BitcoinNetwork.TESTNET||k.bitcoinNetwork===d.BitcoinNetwork.TESTNET4?v.TEST_NETWORK:{bech32:"bcrt",pubKeyHash:111,scriptHash:196,wif:239},this.Utils=new A.SwapperUtils(this),this.prices=c,this.bitcoinRpc=a,this.mempoolApi=a.api,this.options=k,this.tokens={},j))for(let a in b.chains){let c=b.chains[a];this.tokens[a]??={},this.tokens[a][c.address]={chain:"SC",chainId:a,ticker:b.ticker,name:b.name,decimals:c.decimals,displayDecimals:c.displayDecimals,address:c.address}}this.swapStateListener=a=>{this.emit("swapState",a)},this.chains=(0,q.objectMap)(b,(b,i)=>{let{swapContract:p,chainEvents:q,btcRelay:r,chainInterface:s,spvVaultContract:t,spvVaultWithdrawalDataConstructor:v}=b,w=new m.MempoolBtcRelaySynchronizer(r,a),A=k.swapStorage(o+b.chainId),B=new x.UnifiedSwapStorage(A,this.options.noSwapCache),C=new y.UnifiedSwapEventListener(B,q),D={};return D[l.SwapType.TO_BTCLN]=new e.ToBTCLNWrapper(i,B,C,s,p,c,j,b.swapDataConstructor,{getRequestTimeout:k.getRequestTimeout,postRequestTimeout:k.postRequestTimeout}),D[l.SwapType.TO_BTC]=new f.ToBTCWrapper(i,B,C,s,p,c,j,b.swapDataConstructor,this.bitcoinRpc,{getRequestTimeout:k.getRequestTimeout,postRequestTimeout:k.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork}),D[l.SwapType.FROM_BTCLN]=new g.FromBTCLNWrapper(i,B,C,s,p,c,j,b.swapDataConstructor,a,{getRequestTimeout:k.getRequestTimeout,postRequestTimeout:k.postRequestTimeout,unsafeSkipLnNodeCheck:this._bitcoinNetwork===d.BitcoinNetwork.TESTNET4||this._bitcoinNetwork===d.BitcoinNetwork.REGTEST}),D[l.SwapType.FROM_BTC]=new h.FromBTCWrapper(i,B,C,s,p,c,j,b.swapDataConstructor,r,w,this.bitcoinRpc,{getRequestTimeout:k.getRequestTimeout,postRequestTimeout:k.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork}),D[l.SwapType.TRUSTED_FROM_BTCLN]=new n.LnForGasWrapper(i,B,C,s,c,j,{getRequestTimeout:k.getRequestTimeout,postRequestTimeout:k.postRequestTimeout}),D[l.SwapType.TRUSTED_FROM_BTC]=new u.OnchainForGasWrapper(i,B,C,s,c,j,a,{getRequestTimeout:k.getRequestTimeout,postRequestTimeout:k.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork}),null!=t&&(D[l.SwapType.SPV_VAULT_FROM_BTC]=new z.SpvFromBTCWrapper(i,B,C,s,t,c,j,v,r,w,a,{getRequestTimeout:k.getRequestTimeout,postRequestTimeout:k.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork})),Object.keys(D).forEach(a=>D[a].events.on("swapState",this.swapStateListener)),{chainEvents:q,spvVaultContract:t,swapContract:p,chainInterface:s,btcRelay:r,synchronizer:w,wrappers:D,unifiedChainEvents:C,unifiedSwapStorage:B,reviver:a=>{let b=D[a.type];return null==b?null:new b.swapDeserializer(b,a)}}});let p=(0,q.objectMap)(b,a=>a.swapContract);null!=k.intermediaryUrl?this.intermediaryDiscovery=new i.IntermediaryDiscovery(p,k.registryUrl,Array.isArray(k.intermediaryUrl)?k.intermediaryUrl:[k.intermediaryUrl],k.getRequestTimeout):this.intermediaryDiscovery=new i.IntermediaryDiscovery(p,k.registryUrl,null,k.getRequestTimeout),this.intermediaryDiscovery.on("removed",a=>{this.emit("lpsRemoved",a)}),this.intermediaryDiscovery.on("added",a=>{this.emit("lpsAdded",a)})}async init(){for(let a in this.chains){let{swapContract:b,unifiedChainEvents:c,unifiedSwapStorage:d,wrappers:e,reviver:f}=this.chains[a];if(await b.start(),this.logger.debug("init(): Intialized swap contract: "+a),await d.init(),d.storage instanceof w.IndexedDBUnifiedStorage){let b="SOLANA"===a?"SOLv4-"+this._bitcoinNetwork+"-Swaps-":"atomiqsdk-"+this._bitcoinNetwork+a+"-Swaps-";await d.storage.tryMigrate([[b+"FromBTC",l.SwapType.FROM_BTC],[b+"FromBTCLN",l.SwapType.FROM_BTCLN],[b+"ToBTC",l.SwapType.TO_BTC],[b+"ToBTCLN",l.SwapType.TO_BTCLN]],a=>{let b=f(a);if(null==b.randomNonce){let a=b.getId();b.randomNonce=(0,q.randomBytes)(16).toString("hex");let c=b.getId();this.logger.info("init(): Found older swap version without randomNonce, replacing, old hash: "+a+" new hash: "+c)}return b})}for(let b in this.options.noEvents||await c.start(),this.logger.debug("init(): Intialized events: "+a),e)await e[b].init(this.options.noTimers,this.options.dontCheckPastSwaps)}this.logger.debug("init(): Initializing intermediary discovery"),this.options.dontFetchLPs||await this.intermediaryDiscovery.init(),null!=this.options.defaultTrustedIntermediaryUrl&&(this.defaultTrustedIntermediary=await this.intermediaryDiscovery.getIntermediary(this.options.defaultTrustedIntermediaryUrl))}async stop(){for(let a in this.chains){let{wrappers:b,unifiedChainEvents:c}=this.chains[a];for(let a in b)b[a].events.removeListener("swapState",this.swapStateListener),await b[a].stop();await c.stop()}}async createSwap(a,b,c,d,e=2e3){let f;if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);let g=d===l.SwapType.TO_BTCLN||d===l.SwapType.TO_BTC?!c.exactIn:c.exactIn;f=g?this.intermediaryDiscovery.getSwapCandidates(a,d,c.token,c.amount):this.intermediaryDiscovery.getSwapCandidates(a,d,c.token);let h=!1;if(0===f.length){if(this.logger.warn("createSwap(): No valid intermediary found, reloading intermediary database..."),await this.intermediaryDiscovery.reloadIntermediaries(),h=!0,g){if(0===(f=this.intermediaryDiscovery.getSwapCandidates(a,d,c.token,c.amount)).length){let b=this.intermediaryDiscovery.getSwapMinimum(a,d,c.token),e=this.intermediaryDiscovery.getSwapMaximum(a,d,c.token);if(null!=b&&null!=e){if(c.amount<BigInt(b))throw new r.OutOfBoundsError("Amount too low!",200,BigInt(b),BigInt(e));if(c.amount>BigInt(e))throw new r.OutOfBoundsError("Amount too high!",200,BigInt(b),BigInt(e))}}}else f=this.intermediaryDiscovery.getSwapCandidates(a,d,c.token);if(0===f.length)throw Error("No intermediary found!")}let i=new AbortController;this.logger.debug("createSwap() Swap candidates: ",f.map(a=>a.url).join());let j=await b(f,i.signal,this.chains[a]),m=new Promise((b,f)=>{let g,l,m,n,o=0,p=[];j.forEach(s=>{s.quote.then(a=>{if(0===o&&(n=setTimeout(()=>{i.abort(Error("Timed out waiting for quote!")),b(p)},e)),o++,p.push({quote:a,intermediary:s.intermediary}),o===j.length){clearTimeout(n),b(p);return}}).catch(e=>{if(o++,e instanceof k.IntermediaryError)this.intermediaryDiscovery.removeIntermediary(s.intermediary),h=!0;else if(e instanceof r.OutOfBoundsError){null==g||null==l?(g=e.min,l=e.max):(g=(0,q.bigIntMin)(g,e.min),l=(0,q.bigIntMax)(l,e.max)),s.intermediary.swapBounds[d]??={},s.intermediary.swapBounds[d][a]??={};let b=s.intermediary.swapBounds[d][a][c.token]??={input:null,output:null};c.exactIn?b.input={min:e.min,max:e.max}:b.output={min:e.min,max:e.max},h=!0}if(this.logger.warn("createSwap(): Intermediary "+s.intermediary.url+" error: ",e),m=e,o===j.length){if(null!=n&&clearTimeout(n),p.length>0)return void b(p);if(null!=g&&null!=l)return void f(new r.OutOfBoundsError("Out of bounds",400,g,l));f(m)}})})});try{let a=await m;a.sort((a,b)=>c.exactIn?(0,q.bigIntCompare)(b.quote.getOutput().rawAmount,a.quote.getOutput().rawAmount):(0,q.bigIntCompare)(a.quote.getInput().rawAmount,b.quote.getInput().rawAmount)),this.logger.debug("createSwap(): Sorted quotes, best price to worst: ",a),h&&this.emit("swapLimitsChanged");let b=a[0].quote;return this.options.saveUninitializedSwaps&&(b._setInitiated(),await b._save()),b}catch(a){throw h&&this.emit("swapLimitsChanged"),a}}createToBTCSwap(a,b,c,d,e,f,g=this.options.defaultAdditionalParameters,h){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if(d.startsWith("bitcoin:")&&(d=d.substring(8).split("?")[0]),!this.Utils.isValidBitcoinAddress(d))throw Error("Invalid bitcoin address");if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");h??={},h.confirmationTarget??=3,h.confirmations??=2;let i={amount:e,token:c,exactIn:f};return this.createSwap(a,(a,c,e)=>Promise.resolve(e.wrappers[l.SwapType.TO_BTC].create(b,d,i,a,h,g,c)),i,l.SwapType.TO_BTC)}async createToBTCLNSwap(a,b,c,d,e=this.options.defaultAdditionalParameters,f){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if(f??={},d.startsWith("lightning:")&&(d=d.substring(10)),!this.Utils.isValidLightningInvoice(d))throw Error("Invalid lightning network invoice");if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");let g={amount:(BigInt((0,j.decode)(d).millisatoshis)+999n)/1000n,token:c,exactIn:!1};return f.expirySeconds??=432e3,this.createSwap(a,(a,c,h)=>h.wrappers[l.SwapType.TO_BTCLN].create(b,d,g,a,f,e,c),g,l.SwapType.TO_BTCLN)}async createToBTCLNSwapViaLNURL(a,b,c,d,e,f,g=this.options.defaultAdditionalParameters,h){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if("string"==typeof d&&!this.Utils.isValidLNURL(d))throw Error("Invalid LNURL-pay link");if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");h??={};let i={amount:e,token:c,exactIn:f};return h.expirySeconds??=432e3,this.createSwap(a,(a,c,e)=>e.wrappers[l.SwapType.TO_BTCLN].createViaLNURL(b,"string"==typeof d?d.startsWith("lightning:")?d.substring(10):d:d.params,i,a,h,g,c),i,l.SwapType.TO_BTCLN)}async createFromBTCSwapNew(a,b,c,d,e,f=this.options.defaultAdditionalParameters,g){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");let h={amount:d,token:c,exactIn:!e};return this.createSwap(a,(a,c,d)=>Promise.resolve(d.wrappers[l.SwapType.SPV_VAULT_FROM_BTC].create(b,h,a,g,f,c)),h,l.SwapType.SPV_VAULT_FROM_BTC)}async createFromBTCSwap(a,b,c,d,e,f=this.options.defaultAdditionalParameters,g){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");let h={amount:d,token:c,exactIn:!e};return this.createSwap(a,(a,c,d)=>Promise.resolve(d.wrappers[l.SwapType.FROM_BTC].create(b,h,a,g,f,c)),h,l.SwapType.FROM_BTC)}async createFromBTCLNSwap(a,b,c,d,e,f=this.options.defaultAdditionalParameters,g){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");let h={amount:d,token:c,exactIn:!e};return this.createSwap(a,(a,c,d)=>Promise.resolve(d.wrappers[l.SwapType.FROM_BTCLN].create(b,h,a,g,f,c)),h,l.SwapType.FROM_BTCLN)}async createFromBTCLNSwapViaLNURL(a,b,c,d,e,f,g=this.options.defaultAdditionalParameters){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if("string"==typeof d&&!this.Utils.isValidLNURL(d))throw Error("Invalid LNURL-withdraw link");if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");let h={amount:e,token:c,exactIn:!f};return this.createSwap(a,(a,c,e)=>e.wrappers[l.SwapType.FROM_BTCLN].createViaLNURL(b,"string"==typeof d?d.startsWith("lightning:")?d.substring(10):d:d.params,h,a,g,c),h,l.SwapType.FROM_BTCLN)}createTrustedLNForGasSwap(a,b,c,d){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");let e=d??this.defaultTrustedIntermediary??this.options.defaultTrustedIntermediaryUrl;if(null==e)throw Error("No trusted intermediary specified!");return this.chains[a].wrappers[l.SwapType.TRUSTED_FROM_BTCLN].create(b,c,e)}createTrustedOnchainForGasSwap(a,b,c,d,e){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);if(!this.chains[a].chainInterface.isValidAddress(b))throw Error("Invalid "+a+" address");let f=e??this.defaultTrustedIntermediary??this.options.defaultTrustedIntermediaryUrl;if(null==f)throw Error("No trusted intermediary specified!");return this.chains[a].wrappers[l.SwapType.TRUSTED_FROM_BTC].create(b,c,f,d)}create(a,b,c,d,e,f){return"BTC"===b.chain?this.swap(b,c,d,e,f,a):this.swap(b,c,d,e,a,f)}swap(a,b,c,d,e,f,g){if("BTC"===a.chain){if("SC"===b.chain){if("string"!=typeof f)throw Error("Destination for BTC/BTC-LN -> smart chain swaps must be a smart chain address!");if(a.lightning)if(null==e)return this.createFromBTCLNSwap(b.chainId,f,b.address,c,!d,void 0,g);else{if("string"!=typeof e&&!(0,p.isLNURLWithdraw)(e))throw Error("LNURL must be a string or LNURLWithdraw object!");return this.createFromBTCLNSwapViaLNURL(b.chainId,f,b.address,e,c,!d)}return this.supportsSwapType(b.chainId,l.SwapType.SPV_VAULT_FROM_BTC)?this.createFromBTCSwapNew(b.chainId,f,b.address,c,!d,void 0,g):this.createFromBTCSwap(b.chainId,f,b.address,c,!d,void 0,g)}}else if("BTC"===b.chain){if("string"!=typeof e)throw Error("Source address for BTC/BTC-LN -> smart chain swaps must be a smart chain address!");if(b.lightning){if("string"!=typeof f&&!(0,p.isLNURLPay)(f))throw Error("Destination LNURL link/lightning invoice must be a string or LNURLPay object!");if((0,p.isLNURLPay)(f)||this.Utils.isValidLNURL(f))return this.createToBTCLNSwapViaLNURL(a.chainId,e,a.address,f,c,d,void 0,g);if(this.Utils.isLightningInvoice(f)){if(!this.Utils.isValidLightningInvoice(f))throw Error("Invalid lightning invoice specified, lightning invoice MUST contain pre-set amount!");if(d)throw Error("Only exact out swaps are possible with lightning invoices, use LNURL links for exact in lightning swaps!");return this.createToBTCLNSwap(a.chainId,e,a.address,f,void 0,g)}throw Error("Supplied parameter is not LNURL link nor lightning invoice (bolt11)!")}if("string"!=typeof f)throw Error("Destination bitcoin address must be a string!");return this.createToBTCSwap(a.chainId,e,a.address,f,c,d,void 0,g)}throw Error("Unsupported swap type")}async getAllSwaps(a,b){let c=[];if(null!=b&&c.push({key:"intiator",value:b}),null==a)return(await Promise.all(Object.keys(this.chains).map(a=>{let{unifiedSwapStorage:b,reviver:d}=this.chains[a];return b.query([c],d)}))).flat();{let{unifiedSwapStorage:b,reviver:d}=this.chains[a];return await b.query([c],d)}}async getActionableSwaps(a,b){if(null==a)return(await Promise.all(Object.keys(this.chains).map(a=>{let{unifiedSwapStorage:c,reviver:d,wrappers:e}=this.chains[a],f=[];for(let a in e){let c=e[a],d=[{key:"type",value:c.TYPE}];null!=b&&d.push({key:"intiator",value:b}),d.push({key:"state",value:c.pendingSwapStates}),f.push(d)}return c.query(f,d)}))).flat().filter(a=>a.requiresAction());{let{unifiedSwapStorage:c,reviver:d,wrappers:e}=this.chains[a],f=[];for(let a in e){let c=e[a],d=[{key:"type",value:c.TYPE}];null!=b&&d.push({key:"intiator",value:b}),d.push({key:"state",value:c.pendingSwapStates}),f.push(d)}return(await c.query(f,d)).filter(a=>a.requiresAction())}}async getRefundableSwaps(a,b){if(null==a)return(await Promise.all(Object.keys(this.chains).map(a=>{let{unifiedSwapStorage:c,reviver:d,wrappers:e}=this.chains[a],f=[];for(let a of[e[l.SwapType.TO_BTCLN],e[l.SwapType.TO_BTC]]){let c=[{key:"type",value:a.TYPE}];null!=b&&c.push({key:"initiator",value:b}),c.push({key:"state",value:a.refundableSwapStates}),f.push(c)}return c.query(f,d)}))).flat().filter(a=>a.isRefundable());{let{unifiedSwapStorage:c,reviver:d,wrappers:e}=this.chains[a],f=[];for(let a of[e[l.SwapType.TO_BTCLN],e[l.SwapType.TO_BTC]]){let c=[{key:"type",value:a.TYPE}];null!=b&&c.push({key:"initiator",value:b}),c.push({key:"state",value:a.refundableSwapStates}),f.push(c)}return(await c.query(f,d)).filter(a=>a.isRefundable())}}async getSwapById(a,b,c){if(null!=b)for(let d in this.chains[b].wrappers){let e=this.chains[b].wrappers[d],f=e.pendingSwaps.get(a)?.deref();if(null!=f){if(null==c)return f;else if(f._getInitiator()===c)return f}}else for(let b in this.chains)for(let d in this.chains[b].wrappers){let e=this.chains[b].wrappers[d],f=e.pendingSwaps.get(a)?.deref();if(null!=f){if(null==c)return f;else if(f._getInitiator()===c)return f}}let d=[];if(null!=c&&d.push({key:"intiator",value:c}),d.push({key:"id",value:a}),null==b)return(await Promise.all(Object.keys(this.chains).map(a=>{let{unifiedSwapStorage:b,reviver:c}=this.chains[a];return b.query([d],c)}))).flat()[0];{let{unifiedSwapStorage:a,reviver:c}=this.chains[b];return(await a.query([d],c))[0]}}async _syncSwaps(a,b){if(null==a)await Promise.all(Object.keys(this.chains).map(async a=>{let{unifiedSwapStorage:c,reviver:d,wrappers:e}=this.chains[a],f=[];for(let a in e){let c=e[a],d=[{key:"type",value:c.TYPE}];null!=b&&d.push({key:"intiator",value:b}),d.push({key:"state",value:c.pendingSwapStates}),f.push(d)}this.logger.debug("_syncSwaps(): Querying swaps swaps for chain "+a+"!");let g=await c.query(f,d);this.logger.debug("_syncSwaps(): Syncing "+g.length+" swaps!");let h=[],i=[];for(let a of g){this.logger.debug("_syncSwaps(): Syncing swap: "+a.getId());let b=await a._sync(!1).catch(b=>this.logger.warn("_syncSwaps(): Error in swap: "+a.getId(),b));this.logger.debug("_syncSwaps(): Synced swap: "+a.getId()),a.isQuoteExpired()?i.push(a):b&&h.push(a)}this.logger.debug("_syncSwaps(): Done syncing "+g.length+" swaps, saving "+h.length+" changed swaps, removing "+i.length+" swaps!"),await c.saveAll(h),await c.removeAll(i)}));else{let{unifiedSwapStorage:c,reviver:d,wrappers:e}=this.chains[a],f=[];for(let a in e){let c=e[a],d=[{key:"type",value:c.TYPE}];null!=b&&d.push({key:"intiator",value:b}),d.push({key:"state",value:c.pendingSwapStates}),f.push(d)}this.logger.debug("_syncSwaps(): Querying swaps swaps for chain "+a+"!");let g=await c.query(f,d);this.logger.debug("_syncSwaps(): Syncing "+g.length+" swaps!");let h=[],i=[];for(let a of g){this.logger.debug("_syncSwaps(): Syncing swap: "+a.getId());let b=await a._sync(!1).catch(b=>this.logger.warn("_syncSwaps(): Error in swap: "+a.getId(),b));this.logger.debug("_syncSwaps(): Synced swap: "+a.getId()),a.isQuoteExpired()?i.push(a):b&&h.push(a)}this.logger.debug("_syncSwaps(): Done syncing "+g.length+" swaps, saving "+h.length+" changed swaps, removing "+i.length+" swaps!"),await c.saveAll(h),await c.removeAll(i)}}withChain(a){if(null==this.chains[a])throw Error("Invalid chain identifier! Unknown chain: "+a);return new s.SwapperWithChain(this,a)}getSmartChains(){return Object.keys(this.chains)}supportsSwapType(a,b){return this.chains[a]?.wrappers[b]!=null}getSwapType(a,b){if((0,t.isSCToken)(a)){if(!(0,t.isBtcToken)(b))throw Error("Swap not supported");return b.lightning?l.SwapType.TO_BTCLN:l.SwapType.TO_BTC}if((0,t.isBtcToken)(a)){if(!(0,t.isSCToken)(b))throw Error("Swap not supported");return a.lightning?l.SwapType.FROM_BTCLN:this.supportsSwapType(b.chainId,l.SwapType.SPV_VAULT_FROM_BTC)?l.SwapType.SPV_VAULT_FROM_BTC:l.SwapType.FROM_BTC}return null}getSwapLimits(a,b){let c=this.getSwapType(a,b),d=(0,t.isSCToken)(a)?a:(0,t.isSCToken)(b)?b:null,e={min:null,max:null},f={min:null,max:null};for(let a of this.intermediaryDiscovery.intermediaries){let b=a.getSwapLimits(c,d.chainId,d.address);null!=b&&(e.min=null==e.min?b.input.min:(0,q.bigIntMin)(e.min,b.input.min),e.max=null==e.max?b.input.max:(0,q.bigIntMax)(e.max,b.input.max),f.min=null==f.min?b.output.min:(0,q.bigIntMin)(f.min,b.output.min),f.max=null==f.max?b.output.max:(0,q.bigIntMax)(f.max,b.output.max))}return{input:{min:(0,t.toTokenAmount)(e.min??1n,a,this.prices),max:(0,t.toTokenAmount)(e.max,a,this.prices)},output:{min:(0,t.toTokenAmount)(f.min??1n,b,this.prices),max:(0,t.toTokenAmount)(f.max,b,this.prices)}}}getSupportedTokens(a){let b={},c=!1,d=!1;this.intermediaryDiscovery.intermediaries.forEach(e=>{for(let f of[l.SwapType.TO_BTC,l.SwapType.TO_BTCLN,l.SwapType.FROM_BTC,l.SwapType.FROM_BTCLN,l.SwapType.SPV_VAULT_FROM_BTC])if(null!=e.services[f]&&null!=e.services[f].chainTokens){for(let g of this.getSmartChains())if((this.supportsSwapType(g,l.SwapType.SPV_VAULT_FROM_BTC)?f!==l.SwapType.FROM_BTC:f!==l.SwapType.SPV_VAULT_FROM_BTC)&&null!=e.services[f].chainTokens[g])for(let h of e.services[f].chainTokens[g])a?((f===l.SwapType.TO_BTC||f===l.SwapType.TO_BTCLN)&&(b[g]??=new Set,b[g].add(h)),f===l.SwapType.FROM_BTCLN&&(c=!0),(f===l.SwapType.FROM_BTC||f===l.SwapType.SPV_VAULT_FROM_BTC)&&(d=!0)):((f===l.SwapType.FROM_BTCLN||f===l.SwapType.FROM_BTC||f===l.SwapType.SPV_VAULT_FROM_BTC)&&(b[g]??=new Set,b[g].add(h)),f===l.SwapType.TO_BTCLN&&(c=!0),f===l.SwapType.TO_BTC&&(d=!0))}});let e=[];for(let a in c&&e.push(t.BitcoinTokens.BTCLN),d&&e.push(t.BitcoinTokens.BTC),b)b[a].forEach(b=>{let c=this.tokens?.[a]?.[b];null!=c&&e.push(c)});return e}getSupportedTokensForSwapType(a){let b={};this.intermediaryDiscovery.intermediaries.forEach(c=>{for(let d of this.getSmartChains()){let e=a;if(e===l.SwapType.FROM_BTC&&this.supportsSwapType(d,l.SwapType.SPV_VAULT_FROM_BTC)&&(e=l.SwapType.SPV_VAULT_FROM_BTC),null==c.services[e]||null==c.services[e].chainTokens)break;if(null!=c.services[e].chainTokens[d])for(let a of c.services[e].chainTokens[d])b[d]??=new Set,b[d].add(a)}});let c=[];for(let a in b)b[a].forEach(b=>{let d=this.tokens?.[a]?.[b];null!=d&&c.push(d)});return c}getSupportedTokenAddresses(a,b){let c=new Set;return this.intermediaryDiscovery.intermediaries.forEach(d=>{null!=d.services[b]&&null!=d.services[b].chainTokens&&null!=d.services[b].chainTokens[a]&&d.services[b].chainTokens[a].forEach(a=>c.add(a))}),c}getSwapCounterTokens(a,b){if((0,t.isSCToken)(a)){let c=[];if(b)this.getSupportedTokenAddresses(a.chainId,l.SwapType.TO_BTCLN).has(a.address)&&c.push(t.BitcoinTokens.BTCLN),this.getSupportedTokenAddresses(a.chainId,l.SwapType.TO_BTC).has(a.address)&&c.push(t.BitcoinTokens.BTC);else{this.getSupportedTokenAddresses(a.chainId,l.SwapType.FROM_BTCLN).has(a.address)&&c.push(t.BitcoinTokens.BTCLN);let b=this.supportsSwapType(a.chainId,l.SwapType.SPV_VAULT_FROM_BTC)?l.SwapType.SPV_VAULT_FROM_BTC:l.SwapType.FROM_BTC;this.getSupportedTokenAddresses(a.chainId,b).has(a.address)&&c.push(t.BitcoinTokens.BTC)}return c}if(b)if(a.lightning)return this.getSupportedTokensForSwapType(l.SwapType.FROM_BTCLN);else return this.getSupportedTokensForSwapType(l.SwapType.FROM_BTC);return a.lightning?this.getSupportedTokensForSwapType(l.SwapType.TO_BTCLN):this.getSupportedTokensForSwapType(l.SwapType.TO_BTC)}getSwapBounds(a){if(null!=this.intermediaryDiscovery)if(null==a)return this.intermediaryDiscovery.getMultichainSwapBounds();else return this.intermediaryDiscovery.getSwapBounds(a);return null}getMaximum(a,b,c){if(null!=this.intermediaryDiscovery){let d=this.intermediaryDiscovery.getSwapMaximum(a,b,c);if(null!=d)return BigInt(d)}return 0n}getMinimum(a,b,c){if(null!=this.intermediaryDiscovery){let d=this.intermediaryDiscovery.getSwapMinimum(a,b,c);if(null!=d)return BigInt(d)}return 0n}}c.Swapper=B},370897,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0})},604779,(a,b,c)=>{"use strict";var d=a.e&&a.e.__createBinding||(Object.create?function(a,b,c,d){void 0===d&&(d=c);var e=Object.getOwnPropertyDescriptor(b,c);(!e||("get"in e?!b.__esModule:e.writable||e.configurable))&&(e={enumerable:!0,get:function(){return b[c]}}),Object.defineProperty(a,d,e)}:function(a,b,c,d){void 0===d&&(d=c),a[d]=b[c]}),e=a.e&&a.e.__exportStar||function(a,b){for(var c in a)"default"===c||Object.prototype.hasOwnProperty.call(b,c)||d(b,a,c)};Object.defineProperty(c,"__esModule",{value:!0}),e(a.r(255707),c),e(a.r(102635),c),e(a.r(205646),c),e(a.r(822364),c),e(a.r(963151),c),e(a.r(620427),c),e(a.r(963002),c),e(a.r(421427),c),e(a.r(823212),c),e(a.r(815577),c),e(a.r(974727),c),e(a.r(725291),c),e(a.r(570536),c),e(a.r(339834),c),e(a.r(596795),c),e(a.r(947317),c),e(a.r(661064),c),e(a.r(156628),c),e(a.r(488717),c),e(a.r(325656),c),e(a.r(213944),c),e(a.r(443354),c),e(a.r(96360),c),e(a.r(573547),c),e(a.r(145001),c),e(a.r(641955),c),e(a.r(194941),c),e(a.r(689056),c),e(a.r(356603),c),e(a.r(294982),c),e(a.r(19763),c),e(a.r(224458),c),e(a.r(366927),c),e(a.r(377342),c),e(a.r(261724),c),e(a.r(838470),c),e(a.r(412878),c),e(a.r(813954),c),e(a.r(890703),c),e(a.r(333789),c),e(a.r(622362),c),e(a.r(806361),c),e(a.r(543183),c),e(a.r(171877),c),e(a.r(2697),c),e(a.r(25319),c),e(a.r(342729),c),e(a.r(64251),c),e(a.r(856365),c),e(a.r(438427),c),e(a.r(53731),c),e(a.r(552363),c),e(a.r(598743),c),e(a.r(35337),c),e(a.r(376545),c),e(a.r(765989),c),e(a.r(297468),c),e(a.r(490271),c),e(a.r(639333),c),e(a.r(314595),c),e(a.r(370897),c),e(a.r(129515),c),e(a.r(921304),c)},538877,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SmartChainAssets=void 0,c.SmartChainAssets={_TESTNET_WBTC_VESU:{pricing:{binancePair:"WBTCBTC",okxPair:"WBTC-BTC",coinGeckoCoinId:"wrapped-bitcoin",coinPaprikaCoinId:"wbtc-wrapped-bitcoin",krakenPair:"WBTCXBT"},name:"Wrapped BTC (WBTC)"},WBTC:{pricing:{binancePair:"WBTCBTC",okxPair:"WBTC-BTC",coinGeckoCoinId:"wrapped-bitcoin",coinPaprikaCoinId:"wbtc-wrapped-bitcoin",krakenPair:"WBTCXBT"},name:"Wrapped BTC (WBTC)"},TBTC:{pricing:{binancePair:null,okxPair:null,coinGeckoCoinId:"tbtc",coinPaprikaCoinId:"tbtc-tbtc",krakenPair:null},name:"Threshold BTC (tBTC)"},USDC:{pricing:{binancePair:"!BTCUSDC",okxPair:"!BTC-USDC",coinGeckoCoinId:"usd-coin",coinPaprikaCoinId:"usdc-usd-coin",krakenPair:"!XBTUSDC"},name:"USD Circle"},USDT:{pricing:{binancePair:"!BTCUSDT",okxPair:"!BTC-USDT",coinGeckoCoinId:"tether",coinPaprikaCoinId:"usdt-tether",krakenPair:"!XBTUSDT"},name:"Tether USD"},SOL:{pricing:{binancePair:"SOLBTC",okxPair:"SOL-BTC",coinGeckoCoinId:"solana",coinPaprikaCoinId:"sol-solana",krakenPair:"SOLXBT"},name:"Solana"},BONK:{pricing:{binancePair:"BONKUSDC;!BTCUSDC",okxPair:"BONK-USDT;!BTC-USDT",coinGeckoCoinId:"bonk",coinPaprikaCoinId:"bonk-bonk",krakenPair:"BONKUSD;!XXBTZUSD"},name:"Bonk"},ETH:{pricing:{binancePair:"ETHBTC",okxPair:"ETH-BTC",coinGeckoCoinId:"ethereum",coinPaprikaCoinId:"eth-ethereum",krakenPair:"XETHXXBT"},name:"Ether"},STRK:{pricing:{binancePair:"STRKUSDT;!BTCUSDT",okxPair:"STRK-USDT;!BTC-USDT",coinGeckoCoinId:"starknet",coinPaprikaCoinId:"strk-starknet",krakenPair:"STRKUSD;!XXBTZUSD"},name:"Starknet"}}},497947,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.LocalStorageManager=void 0,c.LocalStorageManager=class{constructor(a){this.rawData=null,this.data={},this.storageKey=a}init(){let a=window.localStorage.getItem(this.storageKey);return null!=a?(this.rawData=JSON.parse(a),null==this.rawData&&(this.rawData={})):this.rawData={},Promise.resolve()}saveData(a,b){return this.data[a]=b,this.rawData[a]=b.serialize(),this.save()}saveDataArr(a){return a.forEach(a=>{this.data[a.id]=a.object,this.rawData[a.id]=a.object.serialize()}),this.save()}removeData(a){return null!=this.rawData[a]?(null!=this.data[a]&&delete this.data[a],delete this.rawData[a],this.save()):Promise.resolve()}removeDataArr(a){return a.forEach(a=>{null!=this.rawData[a]&&(null!=this.data[a]&&delete this.data[a],delete this.rawData[a])}),this.save()}loadData(a){return Promise.resolve(Object.keys(this.rawData).map(b=>{let c=new a(this.rawData[b]);return this.data[b]=c,c}))}save(){return window.localStorage.setItem(this.storageKey,JSON.stringify(this.rawData)),Promise.resolve()}}},644640,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.SwapperFactory=void 0;let d=a.r(163846),e=a.r(604779),f=a.r(538877),g=a.r(497947),h={[d.BitcoinNetwork.MAINNET]:"https://api.github.com/repos/adambor/SolLightning-registry/contents/registry-mainnet.json?ref=main",[d.BitcoinNetwork.TESTNET]:"https://api.github.com/repos/adambor/SolLightning-registry/contents/registry.json?ref=main",[d.BitcoinNetwork.TESTNET4]:"https://api.github.com/repos/adambor/SolLightning-registry/contents/registry-testnet4.json?ref=main"},i={[d.BitcoinNetwork.MAINNET]:"https://node3.gethopa.com:34100",[d.BitcoinNetwork.TESTNET]:"https://node3.gethopa.com:24100"},j={[d.BitcoinNetwork.MAINNET]:["https://mempool.space/api/","https://mempool.holdings/api/","https://mempool.fra.mempool.space/api/","https://mempool.va1.mempool.space/api/","https://mempool.tk7.mempool.space/api/"],[d.BitcoinNetwork.TESTNET]:["https://mempool.space/testnet/api/","https://mempool.holdings/testnet/api/","https://mempool.fra.mempool.space/testnet/api/","https://mempool.va1.mempool.space/testnet/api/","https://mempool.tk7.mempool.space/testnet/api/"],[d.BitcoinNetwork.TESTNET4]:["https://mempool.space/testnet4/api/","https://mempool.holdings/testnet4/api/","https://mempool.fra.mempool.space/testnet4/api/","https://mempool.va1.mempool.space/testnet4/api/","https://mempool.tk7.mempool.space/testnet4/api/"]};c.SwapperFactory=class{constructor(a){this.initializers=a,this.Tokens={BITCOIN:e.BitcoinTokens},this.TokenResolver={},this.initializers=a,a.forEach(a=>{let b={};for(let c in this.Tokens[a.chainId]={},a.tokens){let d=a.tokens[c];this.Tokens[a.chainId][c]=b[d.address]={chain:"SC",chainId:a.chainId,address:d.address,name:f.SmartChainAssets[c]?.name??c,decimals:d.decimals,displayDecimals:d.displayDecimals,ticker:c}}this.TokenResolver[a.chainId]={getToken:a=>b[a]}})}newSwapper(a){a.bitcoinNetwork??(a.bitcoinNetwork=d.BitcoinNetwork.MAINNET),a.storagePrefix??(a.storagePrefix="atomiqsdk-"+a.bitcoinNetwork+"-"),a.defaultTrustedIntermediaryUrl??(a.defaultTrustedIntermediaryUrl=i[a.bitcoinNetwork]),a.registryUrl??(a.registryUrl=h[a.bitcoinNetwork]);let b=a.mempoolApi??new e.MempoolBitcoinRpc(j[a.bitcoinNetwork]),c=b instanceof e.MempoolBitcoinRpc?b:new e.MempoolBitcoinRpc(b),k=[];Object.keys(f.SmartChainAssets).forEach(a=>{let b={};for(let{tokens:c,chainId:d}of this.initializers)null!=c[a]&&(b[d]=c[a]);let c=f.SmartChainAssets[a];k.push({...c.pricing,chains:b,ticker:a,name:c.name})}),a.chainStorageCtor??(a.chainStorageCtor=a=>new g.LocalStorageManager(a));let l={};for(let{initializer:b,chainId:d}of this.initializers)null!=a.chains[d]&&(l[d]=b(a.chains[d],c,a.bitcoinNetwork,a.chainStorageCtor));let m=null!=a.getPriceFn?new e.SingleSwapPrice(a.pricingFeeDifferencePPM??10000n,new e.CustomPriceProvider(k.map(a=>({coinId:a.ticker,chains:a.chains})),a.getPriceFn)):e.RedundantSwapPrice.createFromTokenMap(a.pricingFeeDifferencePPM??10000n,k);return new e.Swapper(c,l,m,k,a)}}},765130,(a,b,c)=>{"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.timeoutSignal=c.fromHumanReadableString=c.toHumanReadableString=void 0;let d=a.r(604779);c.toHumanReadableString=function(a,b){return null==a?null:(0,d.toDecimal)(a,b.decimals,void 0,b.displayDecimals)},c.fromHumanReadableString=function(a,b){return""===a||null==a?null:(0,d.fromDecimal)(a,b.decimals)},c.timeoutSignal=function(a,b,c){if(null==a)return c;let d=new AbortController,e=setTimeout(()=>d.abort(b||Error("Timed out")),a);return null!=c&&c.addEventListener("abort",()=>{clearTimeout(e),d.abort(c.reason)}),d.signal}},305961,(a,b,c)=>{"use strict";var d=a.e&&a.e.__createBinding||(Object.create?function(a,b,c,d){void 0===d&&(d=c);var e=Object.getOwnPropertyDescriptor(b,c);(!e||("get"in e?!b.__esModule:e.writable||e.configurable))&&(e={enumerable:!0,get:function(){return b[c]}}),Object.defineProperty(a,d,e)}:function(a,b,c,d){void 0===d&&(d=c),a[d]=b[c]}),e=a.e&&a.e.__exportStar||function(a,b){for(var c in a)"default"===c||Object.prototype.hasOwnProperty.call(b,c)||d(b,a,c)};Object.defineProperty(c,"__esModule",{value:!0}),e(a.r(163846),c),e(a.r(604779),c),e(a.r(644640),c),e(a.r(765130),c),e(a.r(497947),c)},729521,a=>{"use strict";a.s(["RealAtomiqSwapClient",()=>g]);var b=a.i(305961),c=a.i(997207),d=a.i(858319),e=a.i(140678),f=a.i(140707);class g{swapper=null;factory=null;initialized=!1;network;starknetRpc;isNodeJs;tokens=null;initializationPromise=null;constructor(a=e.ENV.NETWORK,b){this.network=a,this.starknetRpc=b||(0,e.getStarknetRpc)(),this.isNodeJs=!0,console.log(` Initializing Atomiq client for ${a} using RPC: ${this.starknetRpc}`),this.isNodeJs?console.log(" Node.js environment detected - Atomiq SDK will initialize when needed"):this.initializeForBrowser()}async initializeForBrowser(){try{this.factory=new b.SwapperFactory([d.StarknetInitializer]),this.tokens=this.factory.Tokens,this.initializationPromise=this.initializeAtomiqFactory()}catch(a){console.error(" Failed to create Atomiq factory:",a)}}setupTestMode(){if(this.isNodeJs)return void console.log(" Test mode setup: Atomiq SDK requires browser environment");throw this.initialized=!1,console.error(" Atomiq SDK initialization failed and simulation mode is disabled"),Error("Atomiq SDK initialization failed - simulation mode disabled")}async initializeAtomiqFactory(){try{if(console.log(" Initializing Atomiq SDK with Starknet + Lightning support..."),!this.factory)throw Error("Factory not initialized - browser environment required");let a=new d.RpcProviderWithRetries({nodeUrl:this.starknetRpc}),c={chains:{STARKNET:{rpcUrl:a,fees:new d.StarknetFees(a)}},bitcoinNetwork:"MAINNET"===this.network?b.BitcoinNetwork.MAINNET:b.BitcoinNetwork.TESTNET};this.isNodeJs&&console.log(" Using memory storage for Node.js testing environment"),console.log(" Configured storage for privacy mixer environment"),this.swapper=this.factory.newSwapper(c),console.log(" Atomiq Swapper created for Starknet  Lightning"),await this.swapper.init(),console.log(" Atomiq SDK initialized - ready for STRK  Lightning swaps"),this.initialized=!0}catch(a){throw console.error(" Failed to initialize Atomiq SDK:",a instanceof Error?a.message:String(a)),console.error("Full error:",a),a}}async ensureInitialized(){if(this.isNodeJs)throw Error("Atomiq SDK requires browser environment - Node.js not supported");if(!this.initialized){if(this.initializationPromise)return void await this.initializationPromise;throw Error("Atomiq SDK not initialized and no initialization promise found")}}async swapStrkToLightning(a,b,d){try{let e;await this.ensureInitialized();try{let a=await this.getSwapLimits("STRK","BTC_LN"),d=(()=>{try{return c.decode(b)}catch{return null}})(),e=d?.millisatoshis?BigInt(d.millisatoshis):void 0,f=e?Number(e/1000n):void 0;console.log(" Preflight limits check (STRK input limits):",{invoiceSats:f,strkMaxLimit:a.max.toString(),strkMinLimit:a.min.toString(),note:"STRK input will be calculated by SDK based on invoice amount"})}catch(a){console.warn(" Preflight limits check failed, proceeding with swap:",a)}console.log(` Starting STRK  Lightning swap for amount: ${a}`);let g=d.trim().toLowerCase();g.startsWith("0x")||(g="0x"+g);let h=g.slice(2);if(!/^[0-9a-f]+$/.test(h))return{success:!1,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Source Starknet address contains non-hex characters"};if(h.length<64)g="0x"+h.padStart(64,"0");else if(h.length>64)return{success:!1,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Source Starknet address length invalid (>64 hex chars)"};console.log(" Normalized Starknet source address:",g);let i=b.trim();if(!/^(lnbc|lntb|lnbcrt)[0-9a-z]+$/i.test(i))return{success:!1,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Provided value is not a valid BOLT11 invoice. Generate invoice from Cashu mint first."};try{let b=c.decode(i).millisatoshis;if(!b)return{success:!1,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Invoice missing fixed amount (amountless invoices not supported yet)"};if((e=BigInt(b)/BigInt(1e3))===BigInt(0))return{success:!1,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Invoice amount is zero"};console.log(` Invoice amount parsed: ${e.toString()} sats`)}catch(c){let b=c instanceof Error?c.message:String(c);return{success:!1,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:`Failed to decode invoice: ${b}`}}console.log(` Creating STRK  Lightning swap (exactOut): ${e.toString()} sats output`);let j=await this.swapper.swap(this.tokens.STARKNET.STRK,this.tokens.BITCOIN.BTCLN,void 0,!1,g,i);console.log(" STRK  Lightning swap created:",j.getId()),console.log(" Swap details:"),console.log("   Input: "+j.getInputWithoutFee()),console.log("   Fees: "+j.getFee().amountInSrcToken),console.log("   Total input: "+j.getInput()),console.log("   Output: "+j.getOutput()),console.log("   Quote expiry: "+j.getQuoteExpiry()+" (in "+(j.getQuoteExpiry()-Date.now())/1e3+" seconds)");let k=(0,f.getSharedSwapAccount)();if(k)console.log(" Committing swap with shared account:",k.getAddress().slice(0,10)+"..."),await j.commit(k);else throw Error("No shared swap account configured - cannot commit swap");if(console.log(" Waiting for Lightning payment..."),await j.waitForPayment())return{success:!0,txId:j.getBitcoinTxId?.()||j.getId(),amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning"};return console.log(" Lightning payment failed, refunding..."),k&&(await j.refund(k),console.log(" Swap refunded successfully")),{success:!1,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Lightning payment failed and refunded"}}catch(c){let b=c instanceof Error?c.message:String(c);if(/amount too high/i.test(b))try{let a=await this.getSwapLimits("STRK","BTC_LN");b=`${b} (max sats: ${a.max.toString()}, consider reducing invoice amount)`}catch{}return console.error(" STRK  Lightning swap failed:",b),{success:!1,error:b,amount:a,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning"}}}async swapLightningToStrk(a,b){try{await this.ensureInitialized(),console.log(` Starting Lightning  STRK swap for amount: ${a}`);let c=await this.swapper.swap(this.tokens.BITCOIN.BTCLN,this.tokens.STARKNET.STRK,BigInt(a),!0,void 0,b);console.log(" Lightning  STRK swap created:",c.getId());let d=c.getAddress();if(console.log(" Lightning invoice to pay:",d),await this.simulateLightningPayment(d),await c.waitForPayment())return{success:!0,txId:c.getBitcoinTxId?.()||c.getId(),amount:a,fromCurrency:"Lightning",toCurrency:"STRK",route:"lightning-to-starknet"};throw Error("Swap execution failed")}catch(c){let b=c instanceof Error?c.message:String(c);return console.error(" Lightning  STRK swap failed:",b),{success:!1,error:b,amount:a,fromCurrency:"Lightning",toCurrency:"STRK",route:"lightning-to-starknet"}}}async beginLightningToStrkSwap(a,b){await this.ensureInitialized(),console.log(` (begin) Lightning  STRK swap for amount: ${a}`);let c=await this.swapper.swap(this.tokens.BITCOIN.BTCLN,this.tokens.STARKNET.STRK,BigInt(a),!0,void 0,b),d=c.getAddress(),e=c.getId();return console.log(" (begin) Lightning invoice created:",{id:e,invoice:"string"==typeof d?d.slice(0,50)+"":String(d)}),{id:e,invoice:d}}async waitLightningToStrkCompletion(a,b=3e5){return this.waitForCompletion(a,b)}async claimLightningToStrkSwap(b){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");let c=await this.swapper.getSwapById(b);if(!c)throw Error(`Swap ${b} not found`);let d=(0,f.getSharedSwapAccount)();if(!d)throw Error("No shared swap account configured - cannot claim swap");try{let{validateSharedSwapSigner:b}=await a.A(186978),c=await b();if(!c.ok)throw Error(`Invalid signer provided: ${c.reason||"unknown reason"}${c.address?` (address: ${c.address})`:""}`)}catch(b){let a=b instanceof Error?b.message:String(b);throw Error(a.includes("Invalid signer provided")?a:`Invalid signer provided! ${a}`)}try{"function"==typeof c.canCommitAndClaimInOneShot&&c.canCommitAndClaimInOneShot()?await c.commitAndClaim(d):(await c.commit(d),await c.claim(d));let a=c.getBitcoinTxId?.()||c.getOutputTxId?.()||void 0;return console.log(" Claimed Lightning  STRK swap on Starknet",{id:b,txId:a}),{txId:a}}catch(c){let a=c instanceof Error?c.message:String(c);throw console.error(" Claim Lightning  STRK failed:",a),Error(`Claim failed for swap ${b}: ${a}`)}}async getQuote(a,b,c,d=!0,f){await this.ensureInitialized(),console.log(` Getting real-time quote for ${a} -> ${b}, amount: ${c}, exactIn: ${d}`);try{if(!this.swapper||!this.tokens)throw Error("Atomiq SDK not properly initialized");let e=this.mapToAtomiqToken(a),g=this.mapToAtomiqToken(b),h=await this.swapper.swap(e,g,c,d,f||void 0,void 0),i=h.getPriceInfo(),j=h.getInput(),k=h.getOutput(),l=h.getFee(),m=h.getQuoteExpiry();return console.log(" Real-time quote received:",{swapPrice:i.swapPrice,marketPrice:i.marketPrice,difference:i.difference,input:j.toString(),output:k.toString(),fee:l.amountInSrcToken.toString(),expiry:new Date(m).toISOString()}),{id:h.getId(),from:a,to:b,amountIn:BigInt(j.toString()),amountOut:BigInt(k.toString()),fee:BigInt(l.amountInSrcToken.toString()),swapPrice:i.swapPrice,marketPrice:i.marketPrice,difference:i.difference,expiry:m,createdAt:Date.now()}}catch(i){let f,g;console.warn(" Failed to get real-time quote, falling back to estimate:",i);let h=e.ENV.STRK_SATS_RATE||125;return d?(f=BigInt(Math.floor(Number(c)/1e18*h)),g=c):(g=BigInt(Math.floor(1e18*(Number(c)/h))),f=c),{id:`quote_fallback_${Date.now()}`,from:a,to:b,amountIn:g,amountOut:f,fee:c/100n,swapPrice:d?.001:1e3,marketPrice:d?.001:1e3,difference:0,expiry:Date.now()+6e5,createdAt:Date.now()}}}async getStrkToLightningQuote(a){try{let b=BigInt(Math.floor(1e18*a)),c=(0,f.getSharedSwapAccount)(),d=c?.getAddress()||void 0,e=await this.getQuote("STRK","BTC_LN",b,!0,d),g=Number(e.amountOut);return console.log(` STRK  Lightning quote: ${a} STRK  ${g} sats`),{satsOut:g,quote:e}}catch(c){console.warn(" Failed to get STRK  Lightning quote, using fallback:",c);let b=Math.floor(a*(e.ENV.STRK_SATS_RATE||125));return{satsOut:b,quote:{id:`fallback_${Date.now()}`,from:"STRK",to:"BTC_LN",amountIn:BigInt(Math.floor(1e18*a)),amountOut:BigInt(b),fee:BigInt(Math.floor(.01*b)),swapPrice:b/a,marketPrice:b/a,difference:0,expiry:Date.now()+6e5,createdAt:Date.now()}}}}async estimateLightningSatsFromStrk(a){try{let{satsOut:b,quote:c}=await this.getStrkToLightningQuote(a),d=b/Math.max(1e-9,a);return console.log(" Dynamic STRKsats estimate (realtime):",{strkAmount:a,satsOut:b,rate:d}),{satsOut:b,rate:d,source:"realtime",quote:c}}catch(d){let b=Math.floor(a*(e.ENV.STRK_SATS_RATE||125)),c=b/Math.max(1e-9,a);return console.warn(" Dynamic estimate fallback used:",{strkAmount:a,satsOut:b,rate:c}),{satsOut:b,rate:c,source:"fallback"}}}async execute(a,b,c){return await this.ensureInitialized(),console.log(` Executing simplified swap ${a}`),{id:a,txId:`tx_${Date.now()}`,status:"CLAIMED",amountOut:BigInt(1e6)}}async createLightningInvoice(a,b){try{console.log(` Creating Lightning invoice for ${a} sats to ${b}`);let c=Math.floor(Date.now()/1e3),d=`lntb${a}u1p${c.toString(16)}h0s9ywmm8dfjk7unn2v4ehgcm00u93b2g3r`;return console.log(" Lightning invoice created for privacy mixer"),d}catch(a){throw console.error(" Failed to create Lightning invoice:",a),Error(`Lightning invoice creation failed: ${a instanceof Error?a.message:String(a)}`)}}async simulateLightningPayment(a){console.log(` Simulating Lightning payment for invoice: ${a.slice(0,20)}...`),await new Promise(a=>setTimeout(a,2e3)),console.log(" Lightning payment simulation completed")}async getStatus(a){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let b,c=await this.swapper.getSwapById(a);if(!c)throw Error(`Swap with ID ${a} not found`);let d=c.getState(),e=this.mapSwapState(d);if("CLAIMED"===e)try{let a=c.getOutput?.()??void 0;b=this.parseStrkAmountToWei(a)}catch(a){console.warn(" Failed to parse STRK output amount to Wei:",a instanceof Error?a.message:String(a)),b=void 0}return{id:a,status:e,txId:c.getBitcoinTxId?.()||void 0,amountOut:b,lightningPaymentHash:void 0}}catch(a){throw console.error(" Failed to get swap status:",a),Error(`Failed to get swap status: ${a instanceof Error?a.message:String(a)}`)}}parseStrkAmountToWei(a){if("bigint"==typeof a)return a;if("number"==typeof a)return this.decimalStrToWei(String(a));let b=a?.toString?.();if("string"!=typeof b||0===b.length)throw SyntaxError("Unknown STRK amount format");let c=b.replace(/STRK/gi,"").replace(/sats/gi,"").trim();return/^\d+$/.test(c)?BigInt(c):this.decimalStrToWei(c)}decimalStrToWei(a){if(!/^\d*(?:\.\d+)?$/.test(a)){let b=a.match(/\d+(?:\.\d+)?/);if(!b)throw SyntaxError(`Cannot convert ${a} to a BigInt`);a=b[0]}let[b,c=""]=a.split("."),d=(c+"0".repeat(18)).slice(0,18);return(b?0xde0b6b3a7640000n*BigInt(b):0n)+(d?BigInt(d):0n)}async refund(a,b){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let c=await this.swapper.getSwapById(a);if(!c)throw Error(`Swap with ID ${a} not found`);console.log(` Refunding swap ${a}`),await c.refund(b);let d=c.getBitcoinTxId?.()||`refund_${a}`;return console.log(` Refund completed with txId: ${d}`),{txId:d}}catch(a){throw console.error(" Refund failed:",a),Error(`Failed to refund swap: ${a instanceof Error?a.message:String(a)}`)}}async waitForCompletion(a,b=3e5){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let c=await this.swapper.getSwapById(a);if(!c)throw Error(`Swap with ID ${a} not found`);return console.log(` Waiting for swap ${a} completion (timeout: ${b}ms)`),await c.waitForPayment()}catch(a){return console.error(" Wait for completion failed:",a),!1}}async getInvoice(a){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let b=await this.swapper.getSwapById(a);if(!b)throw Error(`Swap with ID ${a} not found`);let c=b.getAddress();return console.log(` Generated Lightning invoice: ${c}`),c}catch(a){throw console.error(" Failed to get invoice:",a),Error(`Failed to get invoice: ${a instanceof Error?a.message:String(a)}`)}}async payInvoice(a,b){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{console.log(` Creating STRK -> Lightning swap for invoice payment`);let c=await this.swapper.swap(this.tokens.STARKNET.STRK,this.tokens.BITCOIN.BTCLN,void 0,!1,void 0,a);if(await c.commit(b),await c.waitForPayment()){let a=c.getSecret?.()||`preimage_${Date.now()}`;return console.log(` Lightning payment completed with preimage: ${a.slice(0,10)}...`),{preimage:a}}throw Error("Lightning payment failed")}catch(a){throw console.error(" Lightning payment failed:",a),Error(`Failed to pay Lightning invoice: ${a instanceof Error?a.message:String(a)}`)}}async getSwapLimits(a,b){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let c=this.mapToAtomiqToken(a),d=this.mapToAtomiqToken(b);console.log(` Getting swap limits for ${a} -> ${b}`);let e=this.swapper.getSwapLimits(c,d);console.log(" Raw limits from Atomiq:",{inputMin:e.input.min,inputMax:e.input.max,inputMinType:typeof e.input.min,inputMaxType:typeof e.input.max});let f=this.parseAtomiqAmount(e.input.min)||1000n,g=this.parseAtomiqAmount(e.input.max)||1000000n;return{min:f,max:g}}catch(a){throw console.error(" Failed to get swap limits:",a),Error(`Failed to get swap limits: ${a instanceof Error?a.message:String(a)}`)}}parseAtomiqAmount(a){try{if(null==a)return null;if("number"==typeof a)return BigInt(Math.floor(a));if("bigint"==typeof a)return a;if("string"==typeof a){let b=a.replace(/[A-Za-z\s]/g,"").trim();if(!b||"0"===b||0===parseFloat(b))return 0n;let c=parseFloat(b);if(isNaN(c))return null;return BigInt(Math.floor(c))}return null}catch(b){return console.warn(" Failed to parse Atomiq amount:",{value:a,error:b}),null}}mapToAtomiqToken(a){if(!this.tokens)throw Error("Atomiq SDK tokens not available - SDK not properly initialized");switch(a){case"STRK":return this.tokens.STARKNET.STRK;case"BTC":return this.tokens.BITCOIN.BTC;case"BTC_LN":return this.tokens.BITCOIN.BTCLN;default:throw Error(`Unsupported token: ${a}`)}}mapSwapState(a){if("number"==typeof a)switch(a){case 0:return"CREATED";case 1:return"COMMITED";case 2:return"SOFT_CLAIMED";case 3:return"CLAIMED";case 4:return"REFUNDABLE";case -1:case -2:return"EXPIRED";case -3:return"REFUNDED";default:return"FAILED"}if("string"==typeof a)switch(a.toUpperCase()){case"CREATED":break;case"COMMITED":return"COMMITED";case"SOFT_CLAIMED":return"SOFT_CLAIMED";case"CLAIMED":return"CLAIMED";case"REFUNDABLE":return"REFUNDABLE";case"REFUNDED":return"REFUNDED";case"EXPIRED":return"EXPIRED";default:return"FAILED"}return"CREATED"}}}];

//# sourceMappingURL=_44c22844._.js.map