{"version":3,"sources":["turbopack:///[project]/src/integrations/cashu/direct.ts","turbopack:///[project]/src/orchestrator/steps/redeemCashu.ts"],"sourcesContent":["/**\n * Direct Cashu integration following standalone script pattern exactly\n * Receive token ONCE, then use received proofs for all operations\n */\n\n/**\n * Server-side Cashu operations following standalone script pattern exactly\n * 1. Receive token ONCE and immediately melt (with built-in retry)\n * 2. Retry capability built into single API call\n * 3. Never try to receive same token twice\n */\nexport async function serverSideCashuMelt(\n    encodedToken: string,\n    invoice: string,\n    quoteId?: string // Optional for backward compatibility\n): Promise<{ success: true; result: { invoiceAmount: number; change: any[]; changeAmount: number; mintUrl: string } } | { success: false; error: string; details?: any }> {\n    try {\n        console.log('üîç Server-side Cashu Melt: Starting single-API melt with retry...');\n\n        const response = await fetch('/api/cashu/receive-and-melt', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify({\n                encodedToken,\n                invoice\n            }),\n        });\n\n        const data = await response.json();\n\n        if (!response.ok) {\n            console.error('‚ùå Server-side Cashu Melt: API error:', data);\n\n            // Handle specific insufficient balance error\n            if (data.error === 'INSUFFICIENT_BALANCE') {\n                return {\n                    success: false,\n                    error: 'Insufficient balance for invoice + fees',\n                    details: data.details\n                };\n            }\n\n            return {\n                success: false,\n                error: data.error || 'Server-side melt failed'\n            };\n        }\n\n        console.log('‚úÖ Server-side Cashu Melt: Completed successfully:', data.result);\n\n        return {\n            success: true,\n            result: data.result\n        };\n\n    } catch (error) {\n        console.error('‚ùå Server-side Cashu Melt: Network error:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Network error during melt'\n        };\n    }\n}\n\n/**\n * Pre-calculate maximum invoice amount that will fit in token balance\n * Uses fee formula: max(2 sats, 0.01 * amount) + 1\n */\nexport async function calculateMaxInvoiceAmount(encodedToken: string): Promise<{ success: true; maxAmount: number; availableBalance: number } | { success: false; error: string }> {\n    try {\n        console.log('üßÆ Calculating max invoice amount from token balance...');\n\n        // Import here to avoid issues if running client-side\n        const { getDecodedToken } = await import('@cashu/cashu-ts');\n\n        // Decode token to get available balance\n        const decoded = getDecodedToken(encodedToken);\n        const availableBalance = decoded.proofs.reduce((sum: number, p: any) => sum + p.amount, 0);\n\n        // Use fee formula to estimate fees: max(2 sats, 0.01 * amount) + 1\n        // We need to solve: amount + max(2, 0.01 * amount) + 1 <= availableBalance\n        // Since fee grows with amount, we use iterative approach\n\n        let maxAmount = 0;\n        for (let testAmount = 1; testAmount <= availableBalance; testAmount++) {\n            const estimatedFee = Math.max(2, Math.ceil(0.01 * testAmount)) + 1;\n            const totalRequired = testAmount + estimatedFee;\n\n            if (totalRequired <= availableBalance) {\n                maxAmount = testAmount;\n            } else {\n                break; // Found the limit\n            }\n        }\n\n        console.log('‚úÖ Max invoice calculation:', {\n            availableBalance,\n            maxAmount,\n            estimatedFee: Math.max(2, Math.ceil(0.01 * maxAmount)) + 1\n        });\n\n        return {\n            success: true,\n            maxAmount,\n            availableBalance\n        };\n\n    } catch (error) {\n        console.error('‚ùå Failed to calculate max invoice amount:', error);\n        return {\n            success: false,\n            error: error instanceof Error ? error.message : 'Calculation failed'\n        };\n    }\n}\n\n/**\n * Helper function to retrieve encoded token from storage\n */\nexport async function getEncodedTokenFromStorage(quoteId: string): Promise<string | null> {\n    console.log('üîç Getting encoded token from storage for quote:', quoteId);\n\n    try {\n        // Try browser localStorage first\n        if (typeof window !== 'undefined') {\n            const key = `slpm:cashu-token:${quoteId}`;\n            const token = window.localStorage.getItem(key);\n            if (token) {\n                console.log('‚úÖ Found token in localStorage');\n                return token;\n            }\n        }\n\n        // Try server-side storage\n        if (typeof window === 'undefined') {\n            try {\n                const { default: TokenVault } = await import('@/storage/tokenVault.server');\n                const tokenData = await TokenVault.get(quoteId);\n                if (tokenData?.token) {\n                    console.log('‚úÖ Found token in server vault');\n                    return tokenData.token;\n                }\n            } catch (e) {\n                console.warn('‚ö†Ô∏è Could not access server vault:', e);\n            }\n        }\n\n        console.warn('‚ùå No encoded token found for quote:', quoteId);\n        return null;\n\n    } catch (error) {\n        console.error('‚ùå Error retrieving encoded token:', error);\n        return null;\n    }\n}","/**\n * Redeem Cashu Token Orchestrator\n * Converts ecash token ‚Üí Lightning ‚Üí STRK via Atomiq\n */\n\nimport { RealAtomiqSwapClient } from '@/integrations/swaps/atomiq';\nimport { serverSideCashuMelt, calculateMaxInvoiceAmount } from '@/integrations/cashu/direct';\nimport { getSharedSwapAddress, transferStrkFromShared } from '@/integrations/starknet/sharedAccount';\nimport type { OrchestratorEvent } from '@/lib/types';\n\nexport async function redeemCashuToken(\n    encodedToken: string,\n    recipientAddress: string,\n    onEvent: (event: OrchestratorEvent & { txHash?: string; changeToken?: string }) => void\n): Promise<void> {\n    try {\n        onEvent({ type: 'redeem:validating', message: 'Validating ecash token' });\n\n        // Calculate safe amount for invoice\n        const maxCalc = await calculateMaxInvoiceAmount(encodedToken);\n        if (!maxCalc.success) {\n            throw new Error(maxCalc.error);\n        }\n\n        const safeAmount = maxCalc.maxAmount;\n        console.log('Safe invoice amount:', safeAmount, 'sats');\n\n        onEvent({ type: 'redeem:creating_swap', message: 'Creating Lightning to STRK swap' });\n\n        // Determine destination (shared or direct)\n        const sharedDest = getSharedSwapAddress();\n        const swapDestination = sharedDest || recipientAddress;\n\n        // Create Atomiq LN ‚Üí STRK swap\n        const atomiq = new RealAtomiqSwapClient();\n        const swap = await atomiq.beginLightningToStrkSwap(safeAmount, swapDestination);\n\n        console.log('Atomiq swap created:', { id: swap.id, invoice: swap.invoice.slice(0, 50) + '...' });\n\n        onEvent({ type: 'redeem:melting', message: 'Melting ecash to Lightning payment' });\n\n        // Melt ecash to pay the Atomiq invoice\n        const meltResult = await serverSideCashuMelt(encodedToken, swap.invoice);\n\n        if (!meltResult.success) {\n            throw new Error(meltResult.error);\n        }\n\n        console.log('Ecash melted successfully');\n\n        // Wait for Lightning payment to settle\n        onEvent({ type: 'redeem:claiming', message: 'Waiting for payment confirmation' });\n\n        const completed = await atomiq.waitLightningToStrkCompletion(swap.id, 300000);\n        if (!completed) {\n            throw new Error('Swap timed out waiting for payment');\n        }\n\n        // Claim the swap on Starknet\n        await atomiq.claimLightningToStrkSwap(swap.id);\n\n        console.log('Swap claimed on Starknet');\n\n        let finalTxHash: string | undefined;\n\n        // If using shared destination, forward to final recipient\n        if (sharedDest && sharedDest.toLowerCase() !== recipientAddress.toLowerCase()) {\n            onEvent({ type: 'redeem:forwarding', message: 'Forwarding STRK to recipient' });\n\n            // Get claimed amount\n            const status = await atomiq.getStatus(swap.id);\n            const amountWei = status.amountOut ?? 0n;\n\n            console.log('Forwarding STRK:', { from: sharedDest, to: recipientAddress, amount: amountWei.toString() });\n\n            finalTxHash = await transferStrkFromShared(recipientAddress, amountWei);\n        }\n\n        // Handle change if any\n        let changeTokenStr: string | undefined;\n        if (meltResult.result.change && meltResult.result.change.length > 0) {\n            const { getEncodedTokenV4 } = await import('@cashu/cashu-ts');\n            changeTokenStr = getEncodedTokenV4({\n                mint: meltResult.result.mintUrl,\n                proofs: meltResult.result.change\n            });\n            console.log('Change token available:', meltResult.result.changeAmount, 'sats');\n        }\n\n        onEvent({\n            type: 'redeem:complete',\n            message: 'Redemption complete',\n            txHash: finalTxHash || swap.id,\n            changeToken: changeTokenStr\n        });\n\n    } catch (error) {\n        console.error('Redeem error:', error);\n        onEvent({\n            type: 'redeem:error',\n            message: error instanceof Error ? error.message : 'Redemption failed'\n        });\n        throw error;\n    }\n}\n\n/**\n * Redeem Cashu Token Directly to Lightning Invoice\n * Melts ecash token to pay a Lightning invoice (no Atomiq swap, no STRK)\n */\nexport async function redeemToLightning(\n    encodedToken: string,\n    lightningInvoice: string,\n    onEvent: (event: OrchestratorEvent & { changeToken?: string }) => void\n): Promise<void> {\n    try {\n        onEvent({ type: 'redeem:validating', message: 'Validating ecash token and invoice' });\n\n        console.log('üîÑ Direct Lightning redemption starting');\n        console.log('Invoice:', lightningInvoice.slice(0, 50) + '...');\n\n        onEvent({ type: 'redeem:melting', message: 'Melting ecash to Lightning payment' });\n\n        // Melt ecash directly to pay the provided Lightning invoice\n        const meltResult = await serverSideCashuMelt(encodedToken, lightningInvoice);\n\n        if (!meltResult.success) {\n            throw new Error(meltResult.error);\n        }\n\n        console.log('‚úÖ Lightning invoice paid successfully');\n\n        // Handle change if any\n        let changeTokenStr: string | undefined;\n        if (meltResult.result.change && meltResult.result.change.length > 0) {\n            const { getEncodedTokenV4 } = await import('@cashu/cashu-ts');\n            changeTokenStr = getEncodedTokenV4({\n                mint: meltResult.result.mintUrl,\n                proofs: meltResult.result.change\n            });\n            console.log('üí∞ Change token available:', meltResult.result.changeAmount, 'sats');\n        }\n\n        onEvent({\n            type: 'redeem:complete',\n            message: 'Lightning invoice paid successfully',\n            changeToken: changeTokenStr\n        });\n\n    } catch (error) {\n        console.error('‚ùå Lightning redemption error:', error);\n        onEvent({\n            type: 'redeem:error',\n            message: error instanceof Error ? error.message : 'Payment failed'\n        });\n        throw error;\n    }\n}\n"],"names":[],"mappings":"wCAWO,eAAe,EAClB,CAAoB,CACpB,CAAe,CACf,CAAiB,EAEjB,GAAI,CACA,QAAQ,GAAG,CAAC,oBAHuC,iDAKnD,IAAM,EAAW,MAAM,MAAM,8BAA+B,CACxD,OAAQ,OACR,QAAS,CACL,eAAgB,kBACpB,EACA,KAAM,KAAK,SAAS,CAAC,cACjB,UACA,CACJ,EACJ,GAEM,EAAO,MAAM,EAAS,IAAI,GAEhC,GAAI,CAAC,EAAS,EAAE,CAAE,CAId,GAHA,QAAQ,KAAK,CAAC,uCAAwC,GAGnC,wBAAwB,CAAvC,EAAK,KAAK,CACV,MAAO,CACH,SAAS,EACT,MAAO,0CACP,QAAS,EAAK,OAAO,AACzB,EAGJ,MAAO,CACH,SAAS,EACT,MAAO,EAAK,KAAK,EAAI,yBACzB,CACJ,CAIA,OAFA,QAAQ,GAAG,CAAC,oDAAqD,EAAK,MAAM,EAErE,CACH,SAAS,EACT,OAAQ,EAAK,MAAM,AACvB,CAEJ,CAAE,MAAO,EAAO,CAEZ,OADA,QAAQ,KAAK,CAAC,2CAA4C,GACnD,CACH,SAAS,EACT,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,2BACpD,CACJ,CACJ,CAMO,eAAe,EAA0B,CAAoB,EAChE,GAAI,CACA,QAAQ,GAAG,CAAC,2DAGZ,GAAM,iBAAE,CAAe,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAItB,EADU,AACS,EADO,GACC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAa,IAAW,EAAM,EAAE,MAAM,CAAE,GAMpF,EAAY,EAChB,IAAK,IAAI,EAAa,EAAG,GAAc,EAAkB,IAAc,CACnE,IAAM,EAAe,KAAK,GAAG,CAAC,EAAG,KAAK,IAAI,CAAC,IAAO,IAAe,EAGjE,GAFsB,AAElB,EAF+B,GAEd,EACjB,EAAY,OAEZ,KAER,CAQA,CAb2C,AAG5B,MAIf,QAAQ,GAAG,CAJsB,AAIrB,6BAA8B,kBACtC,YACA,EACA,aAAc,KAAK,GAAG,CAAC,EAAG,KAAK,IAAI,CAAC,IAAO,IAAc,CAC7D,GAEO,CACH,SAAS,YACT,mBACA,CACJ,CAEJ,CAAE,MAAO,EAAO,CAEZ,OADA,QAAQ,KAAK,CAAC,4CAA6C,GACpD,CACH,SAAS,EACT,MAAO,aAAiB,MAAQ,EAAM,OAAO,CAAG,oBACpD,CACJ,CACJ,CAKO,eAAe,EAA2B,CAAe,EAC5D,QAAQ,GAAG,CAAC,mDAAoD,GAEhE,GAAI,CAaI,GAAI,CACA,GAAM,CAAE,QAAS,CAAU,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,QAC1B,EAAY,MAAM,EAAW,GAAG,CAAC,GACvC,GAAI,GAAW,MAEX,CAFkB,MAClB,QAAQ,GAAG,CAAC,iCACL,EAAU,KAAK,AAE9B,CAAE,MAAO,EAAG,CACR,QAAQ,IAAI,CAAC,oCAAqC,EACtD,CAIJ,OADA,QAAQ,IAAI,CAAC,sCAAuC,GAC7C,IAEX,CAAE,MAAO,EAAO,CAEZ,OADA,QAAQ,KAAK,CAAC,oCAAqC,GAC5C,IACX,CACJ,CAlJC,EAAA,CAAA,CAAA,6HCPA,EAAA,CAAA,CAAA,sDAED,IAAA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QACA,EAAA,EAAA,CAAA,CAAA,QAGO,eAAe,EAClB,CAAoB,CACpB,CAAwB,CACxB,CAAuF,EAEvF,GAAI,KAgDI,EAgBA,EA/DJ,EAAQ,CAAE,KAAM,oBAAqB,QAAS,wBAAyB,GAGvE,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,yBAAA,AAAyB,EAAC,GAChD,GAAI,CAAC,EAAQ,OAAO,CAChB,CADkB,KACR,AAAJ,MAAU,EAAQ,KAAK,EAGjC,IAAM,EAAa,EAAQ,SAAS,CACpC,QAAQ,GAAG,CAAC,uBAAwB,EAAY,QAEhD,EAAQ,CAAE,KAAM,uBAAwB,QAAS,iCAAkC,GAGnF,IAAM,EAAa,CAAA,EAAA,EAAA,oBAAA,AAAoB,IACjC,EAAkB,GAAc,EAGhC,EAAS,IAAI,EAAA,oBAAoB,CACjC,EAAO,MAAM,EAAO,wBAAwB,CAAC,EAAY,GAE/D,QAAQ,GAAG,CAAC,uBAAwB,CAAE,GAAI,EAAK,EAAE,CAAE,QAAS,EAAK,OAAO,CAAC,KAAK,CAAC,EAAG,IAAM,KAAM,GAE9F,EAAQ,CAAE,KAAM,iBAAkB,QAAS,oCAAqC,GAGhF,IAAM,EAAa,MAAM,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,EAAc,EAAK,OAAO,EAEvE,GAAI,CAAC,EAAW,OAAO,CACnB,CADqB,KACf,AAAI,MAAM,EAAW,KAAK,EASpC,GANA,QAAQ,GAAG,CAAC,6BAGZ,EAAQ,CAAE,KAAM,kBAAmB,QAAS,kCAAmC,GAG3E,CAAC,AADa,MAAM,EAAO,GACf,0BAD4C,CAAC,EAAK,EAAE,CAAE,KAElE,MAAM,AAAI,MAAM,sCAWpB,GAPA,MAAM,EAAO,wBAAwB,CAAC,EAAK,EAAE,EAE7C,QAAQ,GAAG,CAAC,4BAKR,GAAc,EAAW,WAAW,KAAO,EAAiB,WAAW,GAAI,CAC3E,EAAQ,CAAE,KAAM,oBAAqB,QAAS,8BAA+B,GAI7E,IAAM,EAAY,CADH,MAAM,EAAO,SAAS,CAAC,EAAK,GAAE,EACpB,SAAS,GAAI,CAAE,CAExC,QAAQ,GAAG,CAAC,mBAAoB,CAAE,KAAM,EAAY,GAAI,EAAkB,OAAQ,EAAU,QAAQ,EAAG,GAEvG,EAAc,MAAM,CAAA,EAAA,EAAA,sBAAA,AAAsB,EAAC,EAAkB,EACjE,CAIA,GAAI,EAAW,MAAM,CAAC,MAAM,EAAI,EAAW,MAAM,CAAC,MAAM,CAAC,MAAM,CAAG,EAAG,CACjE,GAAM,mBAAE,CAAiB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAC9B,EAAiB,EAAkB,CAC/B,KAAM,EAAW,MAAM,CAAC,OAAO,CAC/B,OAAQ,EAAW,MAAM,CAAC,MAAM,AACpC,GACA,QAAQ,GAAG,CAAC,0BAA2B,EAAW,MAAM,CAAC,YAAY,CAAE,OAC3E,CAEA,EAAQ,CACJ,KAAM,kBACN,QAAS,sBACT,OAAQ,GAAe,EAAK,EAAE,CAC9B,YAAa,CACjB,EAEJ,CAAE,MAAO,EAAO,CAMZ,MALA,QAAQ,KAAK,CAAC,gBAAiB,GAC/B,EAAQ,CACJ,KAAM,eACN,QAAS,aAAiB,MAAQ,EAAM,OAAO,CAAG,mBACtD,GACM,CACV,CACJ,CAMO,eAAe,EAClB,CAAoB,CACpB,CAAwB,CACxB,CAAsE,EAEtE,GAAI,KAkBI,EAjBJ,EAAQ,CAAE,KAAM,oBAAqB,QAAS,oCAAqC,GAEnF,QAAQ,GAAG,CAAC,2CACZ,QAAQ,GAAG,CAAC,WAAY,EAAiB,KAAK,CAAC,EAAG,IAAM,OAExD,EAAQ,CAAE,KAAM,iBAAkB,QAAS,oCAAqC,GAGhF,IAAM,EAAa,MAAM,CAAA,EAAA,EAAA,mBAAA,AAAmB,EAAC,EAAc,GAE3D,GAAI,CAAC,EAAW,OAAO,CACnB,CADqB,KACf,AAAI,MAAM,EAAW,KAAK,EAOpC,GAJA,QAAQ,GAAG,CAAC,yCAIR,EAAW,MAAM,CAAC,MAAM,EAAI,EAAW,MAAM,CAAC,MAAM,CAAC,MAAM,CAAG,EAAG,CACjE,GAAM,mBAAE,CAAiB,CAAE,CAAG,MAAA,EAAA,CAAA,CAAA,OAC9B,EAAiB,EAAkB,CAC/B,KAAM,EAAW,MAAM,CAAC,OAAO,CAC/B,OAAQ,EAAW,MAAM,CAAC,MAAM,AACpC,GACA,QAAQ,GAAG,CAAC,6BAA8B,EAAW,MAAM,CAAC,YAAY,CAAE,OAC9E,CAEA,EAAQ,CACJ,KAAM,kBACN,QAAS,sCACT,YAAa,CACjB,EAEJ,CAAE,MAAO,EAAO,CAMZ,MALA,QAAQ,KAAK,CAAC,gCAAiC,GAC/C,EAAQ,CACJ,KAAM,eACN,QAAS,aAAiB,MAAQ,EAAM,OAAO,CAAG,gBACtD,GACM,CACV,CACJ"}