{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/utils-CrQNeCaC.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/node_modules/vite-plugin-node-polyfills/shims/buffer/dist/index.js","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/utils/Bytes.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/util/utils.ts"],"sourcesContent":["var buffer = {};\n\nvar base64Js = {};\n\nbase64Js.byteLength = byteLength;\nbase64Js.toByteArray = toByteArray;\nbase64Js.fromByteArray = fromByteArray;\n\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i];\n  revLookup[code.charCodeAt(i)] = i;\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62;\nrevLookup['_'.charCodeAt(0)] = 63;\n\nfunction getLens (b64) {\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=');\n  if (validLen === -1) validLen = len;\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4);\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp;\n  var lens = getLens(b64);\n  var validLen = lens[0];\n  var placeHoldersLen = lens[1];\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n\n  var curByte = 0;\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen;\n\n  var i;\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)];\n    arr[curByte++] = (tmp >> 16) & 0xFF;\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4);\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2);\n    arr[curByte++] = (tmp >> 8) & 0xFF;\n    arr[curByte++] = tmp & 0xFF;\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF);\n    output.push(tripletToBase64(tmp));\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n  var parts = [];\n  var maxChunkLength = 16383; // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    );\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    );\n  }\n\n  return parts.join('')\n}\n\nvar ieee754 = {};\n\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n\nieee754.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? (nBytes - 1) : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n};\n\nieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = (nBytes * 8) - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);\n  var i = isLE ? 0 : (nBytes - 1);\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n(function (exports) {\n\n\tconst base64 = base64Js;\n\tconst ieee754$1 = ieee754;\n\tconst customInspectSymbol =\n\t  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n\t    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n\t    : null;\n\n\texports.Buffer = Buffer;\n\texports.SlowBuffer = SlowBuffer;\n\texports.INSPECT_MAX_BYTES = 50;\n\n\tconst K_MAX_LENGTH = 0x7fffffff;\n\texports.kMaxLength = K_MAX_LENGTH;\n\tconst { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;\n\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n\t *               implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * We report that the browser does not support typed arrays if the are not subclassable\n\t * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n\t * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n\t * for __proto__ and has a buggy typed array implementation.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n\tif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n\t    typeof console.error === 'function') {\n\t  console.error(\n\t    'This browser lacks typed array (Uint8Array) support which is required by ' +\n\t    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n\t  );\n\t}\n\n\tfunction typedArraySupport () {\n\t  // Can typed array instances can be augmented?\n\t  try {\n\t    const arr = new GlobalUint8Array(1);\n\t    const proto = { foo: function () { return 42 } };\n\t    Object.setPrototypeOf(proto, GlobalUint8Array.prototype);\n\t    Object.setPrototypeOf(arr, proto);\n\t    return arr.foo() === 42\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\n\tObject.defineProperty(Buffer.prototype, 'parent', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.buffer\n\t  }\n\t});\n\n\tObject.defineProperty(Buffer.prototype, 'offset', {\n\t  enumerable: true,\n\t  get: function () {\n\t    if (!Buffer.isBuffer(this)) return undefined\n\t    return this.byteOffset\n\t  }\n\t});\n\n\tfunction createBuffer (length) {\n\t  if (length > K_MAX_LENGTH) {\n\t    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n\t  }\n\t  // Return an augmented `Uint8Array` instance\n\t  const buf = new GlobalUint8Array(length);\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\t  return buf\n\t}\n\n\t/**\n\t * The Buffer constructor returns instances of `Uint8Array` that have their\n\t * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n\t * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n\t * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n\t * returns a single octet.\n\t *\n\t * The `Uint8Array` prototype remains unmodified.\n\t */\n\n\tfunction Buffer (arg, encodingOrOffset, length) {\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    if (typeof encodingOrOffset === 'string') {\n\t      throw new TypeError(\n\t        'The \"string\" argument must be of type string. Received type number'\n\t      )\n\t    }\n\t    return allocUnsafe(arg)\n\t  }\n\t  return from(arg, encodingOrOffset, length)\n\t}\n\n\tBuffer.poolSize = 8192; // not used by this implementation\n\n\tfunction from (value, encodingOrOffset, length) {\n\t  if (typeof value === 'string') {\n\t    return fromString(value, encodingOrOffset)\n\t  }\n\n\t  if (GlobalArrayBuffer.isView(value)) {\n\t    return fromArrayView(value)\n\t  }\n\n\t  if (value == null) {\n\t    throw new TypeError(\n\t      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t      'or Array-like Object. Received type ' + (typeof value)\n\t    )\n\t  }\n\n\t  if (isInstance(value, GlobalArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalArrayBuffer))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&\n\t      (isInstance(value, GlobalSharedArrayBuffer) ||\n\t      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {\n\t    return fromArrayBuffer(value, encodingOrOffset, length)\n\t  }\n\n\t  if (typeof value === 'number') {\n\t    throw new TypeError(\n\t      'The \"value\" argument must not be of type number. Received type number'\n\t    )\n\t  }\n\n\t  const valueOf = value.valueOf && value.valueOf();\n\t  if (valueOf != null && valueOf !== value) {\n\t    return Buffer.from(valueOf, encodingOrOffset, length)\n\t  }\n\n\t  const b = fromObject(value);\n\t  if (b) return b\n\n\t  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n\t      typeof value[Symbol.toPrimitive] === 'function') {\n\t    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n\t  }\n\n\t  throw new TypeError(\n\t    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n\t    'or Array-like Object. Received type ' + (typeof value)\n\t  )\n\t}\n\n\t/**\n\t * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n\t * if value is a number.\n\t * Buffer.from(str[, encoding])\n\t * Buffer.from(array)\n\t * Buffer.from(buffer)\n\t * Buffer.from(arrayBuffer[, byteOffset[, length]])\n\t **/\n\tBuffer.from = function (value, encodingOrOffset, length) {\n\t  return from(value, encodingOrOffset, length)\n\t};\n\n\t// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n\t// https://github.com/feross/buffer/pull/148\n\tObject.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype);\n\tObject.setPrototypeOf(Buffer, GlobalUint8Array);\n\n\tfunction assertSize (size) {\n\t  if (typeof size !== 'number') {\n\t    throw new TypeError('\"size\" argument must be of type number')\n\t  } else if (size < 0) {\n\t    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n\t  }\n\t}\n\n\tfunction alloc (size, fill, encoding) {\n\t  assertSize(size);\n\t  if (size <= 0) {\n\t    return createBuffer(size)\n\t  }\n\t  if (fill !== undefined) {\n\t    // Only pay attention to encoding if it's a string. This\n\t    // prevents accidentally sending in a number that would\n\t    // be interpreted as a start offset.\n\t    return typeof encoding === 'string'\n\t      ? createBuffer(size).fill(fill, encoding)\n\t      : createBuffer(size).fill(fill)\n\t  }\n\t  return createBuffer(size)\n\t}\n\n\t/**\n\t * Creates a new filled Buffer instance.\n\t * alloc(size[, fill[, encoding]])\n\t **/\n\tBuffer.alloc = function (size, fill, encoding) {\n\t  return alloc(size, fill, encoding)\n\t};\n\n\tfunction allocUnsafe (size) {\n\t  assertSize(size);\n\t  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n\t}\n\n\t/**\n\t * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n\t * */\n\tBuffer.allocUnsafe = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\t/**\n\t * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n\t */\n\tBuffer.allocUnsafeSlow = function (size) {\n\t  return allocUnsafe(size)\n\t};\n\n\tfunction fromString (string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') {\n\t    encoding = 'utf8';\n\t  }\n\n\t  if (!Buffer.isEncoding(encoding)) {\n\t    throw new TypeError('Unknown encoding: ' + encoding)\n\t  }\n\n\t  const length = byteLength(string, encoding) | 0;\n\t  let buf = createBuffer(length);\n\n\t  const actual = buf.write(string, encoding);\n\n\t  if (actual !== length) {\n\t    // Writing a hex string, for example, that contains invalid characters will\n\t    // cause everything after the first invalid character to be ignored. (e.g.\n\t    // 'abxxcd' will be treated as 'ab')\n\t    buf = buf.slice(0, actual);\n\t  }\n\n\t  return buf\n\t}\n\n\tfunction fromArrayLike (array) {\n\t  const length = array.length < 0 ? 0 : checked(array.length) | 0;\n\t  const buf = createBuffer(length);\n\t  for (let i = 0; i < length; i += 1) {\n\t    buf[i] = array[i] & 255;\n\t  }\n\t  return buf\n\t}\n\n\tfunction fromArrayView (arrayView) {\n\t  if (isInstance(arrayView, GlobalUint8Array)) {\n\t    const copy = new GlobalUint8Array(arrayView);\n\t    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n\t  }\n\t  return fromArrayLike(arrayView)\n\t}\n\n\tfunction fromArrayBuffer (array, byteOffset, length) {\n\t  if (byteOffset < 0 || array.byteLength < byteOffset) {\n\t    throw new RangeError('\"offset\" is outside of buffer bounds')\n\t  }\n\n\t  if (array.byteLength < byteOffset + (length || 0)) {\n\t    throw new RangeError('\"length\" is outside of buffer bounds')\n\t  }\n\n\t  let buf;\n\t  if (byteOffset === undefined && length === undefined) {\n\t    buf = new GlobalUint8Array(array);\n\t  } else if (length === undefined) {\n\t    buf = new GlobalUint8Array(array, byteOffset);\n\t  } else {\n\t    buf = new GlobalUint8Array(array, byteOffset, length);\n\t  }\n\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(buf, Buffer.prototype);\n\n\t  return buf\n\t}\n\n\tfunction fromObject (obj) {\n\t  if (Buffer.isBuffer(obj)) {\n\t    const len = checked(obj.length) | 0;\n\t    const buf = createBuffer(len);\n\n\t    if (buf.length === 0) {\n\t      return buf\n\t    }\n\n\t    obj.copy(buf, 0, 0, len);\n\t    return buf\n\t  }\n\n\t  if (obj.length !== undefined) {\n\t    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n\t      return createBuffer(0)\n\t    }\n\t    return fromArrayLike(obj)\n\t  }\n\n\t  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n\t    return fromArrayLike(obj.data)\n\t  }\n\t}\n\n\tfunction checked (length) {\n\t  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= K_MAX_LENGTH) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\n\tfunction SlowBuffer (length) {\n\t  if (+length != length) { // eslint-disable-line eqeqeq\n\t    length = 0;\n\t  }\n\t  return Buffer.alloc(+length)\n\t}\n\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return b != null && b._isBuffer === true &&\n\t    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n\t};\n\n\tBuffer.compare = function compare (a, b) {\n\t  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n\t  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError(\n\t      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n\t    )\n\t  }\n\n\t  if (a === b) return 0\n\n\t  let x = a.length;\n\t  let y = b.length;\n\n\t  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n\t    if (a[i] !== b[i]) {\n\t      x = a[i];\n\t      y = b[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'latin1':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t};\n\n\tBuffer.concat = function concat (list, length) {\n\t  if (!Array.isArray(list)) {\n\t    throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t  }\n\n\t  if (list.length === 0) {\n\t    return Buffer.alloc(0)\n\t  }\n\n\t  let i;\n\t  if (length === undefined) {\n\t    length = 0;\n\t    for (i = 0; i < list.length; ++i) {\n\t      length += list[i].length;\n\t    }\n\t  }\n\n\t  const buffer = Buffer.allocUnsafe(length);\n\t  let pos = 0;\n\t  for (i = 0; i < list.length; ++i) {\n\t    let buf = list[i];\n\t    if (isInstance(buf, GlobalUint8Array)) {\n\t      if (pos + buf.length > buffer.length) {\n\t        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);\n\t        buf.copy(buffer, pos);\n\t      } else {\n\t        GlobalUint8Array.prototype.set.call(\n\t          buffer,\n\t          buf,\n\t          pos\n\t        );\n\t      }\n\t    } else if (!Buffer.isBuffer(buf)) {\n\t      throw new TypeError('\"list\" argument must be an Array of Buffers')\n\t    } else {\n\t      buf.copy(buffer, pos);\n\t    }\n\t    pos += buf.length;\n\t  }\n\t  return buffer\n\t};\n\n\tfunction byteLength (string, encoding) {\n\t  if (Buffer.isBuffer(string)) {\n\t    return string.length\n\t  }\n\t  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {\n\t    return string.byteLength\n\t  }\n\t  if (typeof string !== 'string') {\n\t    throw new TypeError(\n\t      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n\t      'Received type ' + typeof string\n\t    )\n\t  }\n\n\t  const len = string.length;\n\t  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n\t  if (!mustMatch && len === 0) return 0\n\n\t  // Use a for loop to avoid recursion\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) {\n\t          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n\t        }\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength;\n\n\tfunction slowToString (encoding, start, end) {\n\t  let loweredCase = false;\n\n\t  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n\t  // property of a typed array.\n\n\t  // This behaves neither like String nor Uint8Array in that we set start/end\n\t  // to their upper/lower bounds if the value passed is out of range.\n\t  // undefined is handled specially as per ECMA-262 6th Edition,\n\t  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\t  if (start === undefined || start < 0) {\n\t    start = 0;\n\t  }\n\t  // Return early if start > this.length. Done here to prevent potential uint32\n\t  // coercion fail below.\n\t  if (start > this.length) {\n\t    return ''\n\t  }\n\n\t  if (end === undefined || end > this.length) {\n\t    end = this.length;\n\t  }\n\n\t  if (end <= 0) {\n\t    return ''\n\t  }\n\n\t  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\t  end >>>= 0;\n\t  start >>>= 0;\n\n\t  if (end <= start) {\n\t    return ''\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\n\t      case 'latin1':\n\t      case 'binary':\n\t        return latin1Slice(this, start, end)\n\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t}\n\n\t// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n\t// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n\t// reliably in a browserify context because there could be multiple different\n\t// copies of the 'buffer' package in use. This method works even for Buffer\n\t// instances that were created from another copy of the `buffer` package.\n\t// See: https://github.com/feross/buffer/issues/154\n\tBuffer.prototype._isBuffer = true;\n\n\tfunction swap (b, n, m) {\n\t  const i = b[n];\n\t  b[n] = b[m];\n\t  b[m] = i;\n\t}\n\n\tBuffer.prototype.swap16 = function swap16 () {\n\t  const len = this.length;\n\t  if (len % 2 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 16-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 2) {\n\t    swap(this, i, i + 1);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap32 = function swap32 () {\n\t  const len = this.length;\n\t  if (len % 4 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 32-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 4) {\n\t    swap(this, i, i + 3);\n\t    swap(this, i + 1, i + 2);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.swap64 = function swap64 () {\n\t  const len = this.length;\n\t  if (len % 8 !== 0) {\n\t    throw new RangeError('Buffer size must be a multiple of 64-bits')\n\t  }\n\t  for (let i = 0; i < len; i += 8) {\n\t    swap(this, i, i + 7);\n\t    swap(this, i + 1, i + 6);\n\t    swap(this, i + 2, i + 5);\n\t    swap(this, i + 3, i + 4);\n\t  }\n\t  return this\n\t};\n\n\tBuffer.prototype.toString = function toString () {\n\t  const length = this.length;\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t};\n\n\tBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t};\n\n\tBuffer.prototype.inspect = function inspect () {\n\t  let str = '';\n\t  const max = exports.INSPECT_MAX_BYTES;\n\t  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n\t  if (this.length > max) str += ' ... ';\n\t  return '<Buffer ' + str + '>'\n\t};\n\tif (customInspectSymbol) {\n\t  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n\t}\n\n\tBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n\t  if (isInstance(target, GlobalUint8Array)) {\n\t    target = Buffer.from(target, target.offset, target.byteLength);\n\t  }\n\t  if (!Buffer.isBuffer(target)) {\n\t    throw new TypeError(\n\t      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n\t      'Received type ' + (typeof target)\n\t    )\n\t  }\n\n\t  if (start === undefined) {\n\t    start = 0;\n\t  }\n\t  if (end === undefined) {\n\t    end = target ? target.length : 0;\n\t  }\n\t  if (thisStart === undefined) {\n\t    thisStart = 0;\n\t  }\n\t  if (thisEnd === undefined) {\n\t    thisEnd = this.length;\n\t  }\n\n\t  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n\t    throw new RangeError('out of range index')\n\t  }\n\n\t  if (thisStart >= thisEnd && start >= end) {\n\t    return 0\n\t  }\n\t  if (thisStart >= thisEnd) {\n\t    return -1\n\t  }\n\t  if (start >= end) {\n\t    return 1\n\t  }\n\n\t  start >>>= 0;\n\t  end >>>= 0;\n\t  thisStart >>>= 0;\n\t  thisEnd >>>= 0;\n\n\t  if (this === target) return 0\n\n\t  let x = thisEnd - thisStart;\n\t  let y = end - start;\n\t  const len = Math.min(x, y);\n\n\t  const thisCopy = this.slice(thisStart, thisEnd);\n\t  const targetCopy = target.slice(start, end);\n\n\t  for (let i = 0; i < len; ++i) {\n\t    if (thisCopy[i] !== targetCopy[i]) {\n\t      x = thisCopy[i];\n\t      y = targetCopy[i];\n\t      break\n\t    }\n\t  }\n\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t};\n\n\t// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n\t// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n\t//\n\t// Arguments:\n\t// - buffer - a Buffer to search\n\t// - val - a string, Buffer, or number\n\t// - byteOffset - an index into `buffer`; will be clamped to an int32\n\t// - encoding - an optional encoding, relevant is val is a string\n\t// - dir - true for indexOf, false for lastIndexOf\n\tfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n\t  // Empty buffer means no match\n\t  if (buffer.length === 0) return -1\n\n\t  // Normalize byteOffset\n\t  if (typeof byteOffset === 'string') {\n\t    encoding = byteOffset;\n\t    byteOffset = 0;\n\t  } else if (byteOffset > 0x7fffffff) {\n\t    byteOffset = 0x7fffffff;\n\t  } else if (byteOffset < -0x80000000) {\n\t    byteOffset = -0x80000000;\n\t  }\n\t  byteOffset = +byteOffset; // Coerce to Number.\n\t  if (numberIsNaN(byteOffset)) {\n\t    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n\t    byteOffset = dir ? 0 : (buffer.length - 1);\n\t  }\n\n\t  // Normalize byteOffset: negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\t  if (byteOffset >= buffer.length) {\n\t    if (dir) return -1\n\t    else byteOffset = buffer.length - 1;\n\t  } else if (byteOffset < 0) {\n\t    if (dir) byteOffset = 0;\n\t    else return -1\n\t  }\n\n\t  // Normalize val\n\t  if (typeof val === 'string') {\n\t    val = Buffer.from(val, encoding);\n\t  }\n\n\t  // Finally, search either indexOf (if dir is true) or lastIndexOf\n\t  if (Buffer.isBuffer(val)) {\n\t    // Special case: looking for empty string/buffer always fails\n\t    if (val.length === 0) {\n\t      return -1\n\t    }\n\t    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n\t  } else if (typeof val === 'number') {\n\t    val = val & 0xFF; // Search for a byte value [0-255]\n\t    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {\n\t      if (dir) {\n\t        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n\t      } else {\n\t        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n\t      }\n\t    }\n\t    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n\t  }\n\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\n\tfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n\t  let indexSize = 1;\n\t  let arrLength = arr.length;\n\t  let valLength = val.length;\n\n\t  if (encoding !== undefined) {\n\t    encoding = String(encoding).toLowerCase();\n\t    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n\t        encoding === 'utf16le' || encoding === 'utf-16le') {\n\t      if (arr.length < 2 || val.length < 2) {\n\t        return -1\n\t      }\n\t      indexSize = 2;\n\t      arrLength /= 2;\n\t      valLength /= 2;\n\t      byteOffset /= 2;\n\t    }\n\t  }\n\n\t  function read (buf, i) {\n\t    if (indexSize === 1) {\n\t      return buf[i]\n\t    } else {\n\t      return buf.readUInt16BE(i * indexSize)\n\t    }\n\t  }\n\n\t  let i;\n\t  if (dir) {\n\t    let foundIndex = -1;\n\t    for (i = byteOffset; i < arrLength; i++) {\n\t      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n\t        if (foundIndex === -1) foundIndex = i;\n\t        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n\t      } else {\n\t        if (foundIndex !== -1) i -= i - foundIndex;\n\t        foundIndex = -1;\n\t      }\n\t    }\n\t  } else {\n\t    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\t    for (i = byteOffset; i >= 0; i--) {\n\t      let found = true;\n\t      for (let j = 0; j < valLength; j++) {\n\t        if (read(arr, i + j) !== read(val, j)) {\n\t          found = false;\n\t          break\n\t        }\n\t      }\n\t      if (found) return i\n\t    }\n\t  }\n\n\t  return -1\n\t}\n\n\tBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n\t  return this.indexOf(val, byteOffset, encoding) !== -1\n\t};\n\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n\t};\n\n\tBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n\t  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n\t};\n\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0;\n\t  const remaining = buf.length - offset;\n\t  if (!length) {\n\t    length = remaining;\n\t  } else {\n\t    length = Number(length);\n\t    if (length > remaining) {\n\t      length = remaining;\n\t    }\n\t  }\n\n\t  const strLen = string.length;\n\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2;\n\t  }\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    const parsed = parseInt(string.substr(i * 2, 2), 16);\n\t    if (numberIsNaN(parsed)) return i\n\t    buf[offset + i] = parsed;\n\t  }\n\t  return i\n\t}\n\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8';\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset;\n\t    length = this.length;\n\t    offset = 0;\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset >>> 0;\n\t    if (isFinite(length)) {\n\t      length = length >>> 0;\n\t      if (encoding === undefined) encoding = 'utf8';\n\t    } else {\n\t      encoding = length;\n\t      length = undefined;\n\t    }\n\t  } else {\n\t    throw new Error(\n\t      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n\t    )\n\t  }\n\n\t  const remaining = this.length - offset;\n\t  if (length === undefined || length > remaining) length = remaining;\n\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('Attempt to write outside buffer bounds')\n\t  }\n\n\t  if (!encoding) encoding = 'utf8';\n\n\t  let loweredCase = false;\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\n\t      case 'ascii':\n\t      case 'latin1':\n\t      case 'binary':\n\t        return asciiWrite(this, string, offset, length)\n\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase();\n\t        loweredCase = true;\n\t    }\n\t  }\n\t};\n\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t};\n\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end);\n\t  const res = [];\n\n\t  let i = start;\n\t  while (i < end) {\n\t    const firstByte = buf[i];\n\t    let codePoint = null;\n\t    let bytesPerSequence = (firstByte > 0xEF)\n\t      ? 4\n\t      : (firstByte > 0xDF)\n\t          ? 3\n\t          : (firstByte > 0xBF)\n\t              ? 2\n\t              : 1;\n\n\t    if (i + bytesPerSequence <= end) {\n\t      let secondByte, thirdByte, fourthByte, tempCodePoint;\n\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte;\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1];\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1];\n\t          thirdByte = buf[i + 2];\n\t          fourthByte = buf[i + 3];\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint;\n\t            }\n\t          }\n\t      }\n\t    }\n\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD;\n\t      bytesPerSequence = 1;\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000;\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n\t      codePoint = 0xDC00 | codePoint & 0x3FF;\n\t    }\n\n\t    res.push(codePoint);\n\t    i += bytesPerSequence;\n\t  }\n\n\t  return decodeCodePointsArray(res)\n\t}\n\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tconst MAX_ARGUMENTS_LENGTH = 0x1000;\n\n\tfunction decodeCodePointsArray (codePoints) {\n\t  const len = codePoints.length;\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  let res = '';\n\t  let i = 0;\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    );\n\t  }\n\t  return res\n\t}\n\n\tfunction asciiSlice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F);\n\t  }\n\t  return ret\n\t}\n\n\tfunction latin1Slice (buf, start, end) {\n\t  let ret = '';\n\t  end = Math.min(buf.length, end);\n\n\t  for (let i = start; i < end; ++i) {\n\t    ret += String.fromCharCode(buf[i]);\n\t  }\n\t  return ret\n\t}\n\n\tfunction hexSlice (buf, start, end) {\n\t  const len = buf.length;\n\n\t  if (!start || start < 0) start = 0;\n\t  if (!end || end < 0 || end > len) end = len;\n\n\t  let out = '';\n\t  for (let i = start; i < end; ++i) {\n\t    out += hexSliceLookupTable[buf[i]];\n\t  }\n\t  return out\n\t}\n\n\tfunction utf16leSlice (buf, start, end) {\n\t  const bytes = buf.slice(start, end);\n\t  let res = '';\n\t  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\t  for (let i = 0; i < bytes.length - 1; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));\n\t  }\n\t  return res\n\t}\n\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  const len = this.length;\n\t  start = ~~start;\n\t  end = end === undefined ? len : ~~end;\n\n\t  if (start < 0) {\n\t    start += len;\n\t    if (start < 0) start = 0;\n\t  } else if (start > len) {\n\t    start = len;\n\t  }\n\n\t  if (end < 0) {\n\t    end += len;\n\t    if (end < 0) end = 0;\n\t  } else if (end > len) {\n\t    end = len;\n\t  }\n\n\t  if (end < start) end = start;\n\n\t  const newBuf = this.subarray(start, end);\n\t  // Return an augmented `Uint8Array` instance\n\t  Object.setPrototypeOf(newBuf, Buffer.prototype);\n\n\t  return newBuf\n\t};\n\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\n\tBuffer.prototype.readUintLE =\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUintBE =\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length);\n\t  }\n\n\t  let val = this[offset + --byteLength];\n\t  let mul = 1;\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul;\n\t  }\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readUint8 =\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  return this[offset]\n\t};\n\n\tBuffer.prototype.readUint16LE =\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return this[offset] | (this[offset + 1] << 8)\n\t};\n\n\tBuffer.prototype.readUint16BE =\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  return (this[offset] << 8) | this[offset + 1]\n\t};\n\n\tBuffer.prototype.readUint32LE =\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t};\n\n\tBuffer.prototype.readUint32BE =\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const lo = first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24;\n\n\t  const hi = this[++offset] +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    last * 2 ** 24;\n\n\t  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n\t});\n\n\tBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const hi = first * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  const lo = this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last;\n\n\t  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n\t});\n\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let val = this[offset];\n\t  let mul = 1;\n\t  let i = 0;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n\t  let i = byteLength;\n\t  let mul = 1;\n\t  let val = this[offset + --i];\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul;\n\t  }\n\t  mul *= 0x80;\n\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n\t  return val\n\t};\n\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 1, this.length);\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t};\n\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset] | (this[offset + 1] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 2, this.length);\n\t  const val = this[offset + 1] | (this[offset] << 8);\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t};\n\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t};\n\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t};\n\n\tBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = this[offset + 4] +\n\t    this[offset + 5] * 2 ** 8 +\n\t    this[offset + 6] * 2 ** 16 +\n\t    (last << 24); // Overflow\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(first +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 24)\n\t});\n\n\tBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n\t  offset = offset >>> 0;\n\t  validateNumber(offset, 'offset');\n\t  const first = this[offset];\n\t  const last = this[offset + 7];\n\t  if (first === undefined || last === undefined) {\n\t    boundsError(offset, this.length - 8);\n\t  }\n\n\t  const val = (first << 24) + // Overflow\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    this[++offset];\n\n\t  return (BigInt(val) << BigInt(32)) +\n\t    BigInt(this[++offset] * 2 ** 24 +\n\t    this[++offset] * 2 ** 16 +\n\t    this[++offset] * 2 ** 8 +\n\t    last)\n\t});\n\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, true, 23, 4)\n\t};\n\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 4, this.length);\n\t  return ieee754$1.read(this, offset, false, 23, 4)\n\t};\n\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, true, 52, 8)\n\t};\n\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkOffset(offset, 8, this.length);\n\t  return ieee754$1.read(this, offset, false, 52, 8)\n\t};\n\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t}\n\n\tBuffer.prototype.writeUintLE =\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let mul = 1;\n\t  let i = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUintBE =\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  byteLength = byteLength >>> 0;\n\t  if (!noAssert) {\n\t    const maxBytes = Math.pow(2, 8 * byteLength) - 1;\n\t    checkInt(this, value, offset, byteLength, maxBytes, 0);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeUint8 =\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeUint16LE =\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint16BE =\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeUint32LE =\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset + 3] = (value >>> 24);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeUint32BE =\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset++] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset++] = hi;\n\t  return offset\n\t}\n\n\tfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n\t  checkIntBI(value, min, max, buf, offset, 7);\n\n\t  let lo = Number(value & BigInt(0xffffffff));\n\t  buf[offset + 7] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 6] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 5] = lo;\n\t  lo = lo >> 8;\n\t  buf[offset + 4] = lo;\n\t  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));\n\t  buf[offset + 3] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 2] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset + 1] = hi;\n\t  hi = hi >> 8;\n\t  buf[offset] = hi;\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = 0;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset] = value & 0xFF;\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    const limit = Math.pow(2, (8 * byteLength) - 1);\n\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit);\n\t  }\n\n\t  let i = byteLength - 1;\n\t  let mul = 1;\n\t  let sub = 0;\n\t  this[offset + i] = value & 0xFF;\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n\t      sub = 1;\n\t    }\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;\n\t  }\n\n\t  return offset + byteLength\n\t};\n\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n\t  if (value < 0) value = 0xff + value + 1;\n\t  this[offset] = (value & 0xff);\n\t  return offset + 1\n\t};\n\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n\t  this[offset] = (value >>> 8);\n\t  this[offset + 1] = (value & 0xff);\n\t  return offset + 2\n\t};\n\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  this[offset] = (value & 0xff);\n\t  this[offset + 1] = (value >>> 8);\n\t  this[offset + 2] = (value >>> 16);\n\t  this[offset + 3] = (value >>> 24);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n\t  if (value < 0) value = 0xffffffff + value + 1;\n\t  this[offset] = (value >>> 24);\n\t  this[offset + 1] = (value >>> 16);\n\t  this[offset + 2] = (value >>> 8);\n\t  this[offset + 3] = (value & 0xff);\n\t  return offset + 4\n\t};\n\n\tBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n\t  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n\t  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n\t});\n\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n\t  if (offset < 0) throw new RangeError('Index out of range')\n\t}\n\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);\n\t  return offset + 4\n\t}\n\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t};\n\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  value = +value;\n\t  offset = offset >>> 0;\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8);\n\t  }\n\t  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);\n\t  return offset + 8\n\t}\n\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t};\n\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t};\n\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n\t  if (!start) start = 0;\n\t  if (!end && end !== 0) end = this.length;\n\t  if (targetStart >= target.length) targetStart = target.length;\n\t  if (!targetStart) targetStart = 0;\n\t  if (end > 0 && end < start) end = start;\n\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length;\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start;\n\t  }\n\n\t  const len = end - start;\n\n\t  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {\n\t    // Use built-in when available, missing from IE11\n\t    this.copyWithin(targetStart, start, end);\n\t  } else {\n\t    GlobalUint8Array.prototype.set.call(\n\t      target,\n\t      this.subarray(start, end),\n\t      targetStart\n\t    );\n\t  }\n\n\t  return len\n\t};\n\n\t// Usage:\n\t//    buffer.fill(number[, offset[, end]])\n\t//    buffer.fill(buffer[, offset[, end]])\n\t//    buffer.fill(string[, offset[, end]][, encoding])\n\tBuffer.prototype.fill = function fill (val, start, end, encoding) {\n\t  // Handle string cases:\n\t  if (typeof val === 'string') {\n\t    if (typeof start === 'string') {\n\t      encoding = start;\n\t      start = 0;\n\t      end = this.length;\n\t    } else if (typeof end === 'string') {\n\t      encoding = end;\n\t      end = this.length;\n\t    }\n\t    if (encoding !== undefined && typeof encoding !== 'string') {\n\t      throw new TypeError('encoding must be a string')\n\t    }\n\t    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n\t      throw new TypeError('Unknown encoding: ' + encoding)\n\t    }\n\t    if (val.length === 1) {\n\t      const code = val.charCodeAt(0);\n\t      if ((encoding === 'utf8' && code < 128) ||\n\t          encoding === 'latin1') {\n\t        // Fast path: If `val` fits into a single byte, use that numeric value.\n\t        val = code;\n\t      }\n\t    }\n\t  } else if (typeof val === 'number') {\n\t    val = val & 255;\n\t  } else if (typeof val === 'boolean') {\n\t    val = Number(val);\n\t  }\n\n\t  // Invalid ranges are not set to a default, so can range check early.\n\t  if (start < 0 || this.length < start || this.length < end) {\n\t    throw new RangeError('Out of range index')\n\t  }\n\n\t  if (end <= start) {\n\t    return this\n\t  }\n\n\t  start = start >>> 0;\n\t  end = end === undefined ? this.length : end >>> 0;\n\n\t  if (!val) val = 0;\n\n\t  let i;\n\t  if (typeof val === 'number') {\n\t    for (i = start; i < end; ++i) {\n\t      this[i] = val;\n\t    }\n\t  } else {\n\t    const bytes = Buffer.isBuffer(val)\n\t      ? val\n\t      : Buffer.from(val, encoding);\n\t    const len = bytes.length;\n\t    if (len === 0) {\n\t      throw new TypeError('The value \"' + val +\n\t        '\" is invalid for argument \"value\"')\n\t    }\n\t    for (i = 0; i < end - start; ++i) {\n\t      this[i + start] = bytes[i % len];\n\t    }\n\t  }\n\n\t  return this\n\t};\n\n\t// CUSTOM ERRORS\n\t// =============\n\n\t// Simplified versions from Node, changed for Buffer-only usage\n\tconst errors = {};\n\tfunction E (sym, getMessage, Base) {\n\t  errors[sym] = class NodeError extends Base {\n\t    constructor () {\n\t      super();\n\n\t      Object.defineProperty(this, 'message', {\n\t        value: getMessage.apply(this, arguments),\n\t        writable: true,\n\t        configurable: true\n\t      });\n\n\t      // Add the error code to the name to include it in the stack trace.\n\t      this.name = `${this.name} [${sym}]`;\n\t      // Access the stack to generate the error message including the error code\n\t      // from the name.\n\t      this.stack; // eslint-disable-line no-unused-expressions\n\t      // Reset the name to the actual name.\n\t      delete this.name;\n\t    }\n\n\t    get code () {\n\t      return sym\n\t    }\n\n\t    set code (value) {\n\t      Object.defineProperty(this, 'code', {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value,\n\t        writable: true\n\t      });\n\t    }\n\n\t    toString () {\n\t      return `${this.name} [${sym}]: ${this.message}`\n\t    }\n\t  };\n\t}\n\n\tE('ERR_BUFFER_OUT_OF_BOUNDS',\n\t  function (name) {\n\t    if (name) {\n\t      return `${name} is outside of buffer bounds`\n\t    }\n\n\t    return 'Attempt to access memory outside buffer bounds'\n\t  }, RangeError);\n\tE('ERR_INVALID_ARG_TYPE',\n\t  function (name, actual) {\n\t    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n\t  }, TypeError);\n\tE('ERR_OUT_OF_RANGE',\n\t  function (str, range, input) {\n\t    let msg = `The value of \"${str}\" is out of range.`;\n\t    let received = input;\n\t    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n\t      received = addNumericalSeparator(String(input));\n\t    } else if (typeof input === 'bigint') {\n\t      received = String(input);\n\t      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n\t        received = addNumericalSeparator(received);\n\t      }\n\t      received += 'n';\n\t    }\n\t    msg += ` It must be ${range}. Received ${received}`;\n\t    return msg\n\t  }, RangeError);\n\n\tfunction addNumericalSeparator (val) {\n\t  let res = '';\n\t  let i = val.length;\n\t  const start = val[0] === '-' ? 1 : 0;\n\t  for (; i >= start + 4; i -= 3) {\n\t    res = `_${val.slice(i - 3, i)}${res}`;\n\t  }\n\t  return `${val.slice(0, i)}${res}`\n\t}\n\n\t// CHECK FUNCTIONS\n\t// ===============\n\n\tfunction checkBounds (buf, offset, byteLength) {\n\t  validateNumber(offset, 'offset');\n\t  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n\t    boundsError(offset, buf.length - (byteLength + 1));\n\t  }\n\t}\n\n\tfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n\t  if (value > max || value < min) {\n\t    const n = typeof min === 'bigint' ? 'n' : '';\n\t    let range;\n\t    if (byteLength > 3) {\n\t      if (min === 0 || min === BigInt(0)) {\n\t        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n\t      } else {\n\t        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n\t                `${(byteLength + 1) * 8 - 1}${n}`;\n\t      }\n\t    } else {\n\t      range = `>= ${min}${n} and <= ${max}${n}`;\n\t    }\n\t    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n\t  }\n\t  checkBounds(buf, offset, byteLength);\n\t}\n\n\tfunction validateNumber (value, name) {\n\t  if (typeof value !== 'number') {\n\t    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n\t  }\n\t}\n\n\tfunction boundsError (value, length, type) {\n\t  if (Math.floor(value) !== value) {\n\t    validateNumber(value, type);\n\t    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n\t  }\n\n\t  if (length < 0) {\n\t    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n\t  }\n\n\t  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n\t                                    `>= ${type ? 1 : 0} and <= ${length}`,\n\t                                    value)\n\t}\n\n\t// HELPER FUNCTIONS\n\t// ================\n\n\tconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n\tfunction base64clean (str) {\n\t  // Node takes equal signs as end of the Base64 encoding\n\t  str = str.split('=')[0];\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = str.trim().replace(INVALID_BASE64_RE, '');\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '=';\n\t  }\n\t  return str\n\t}\n\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity;\n\t  let codePoint;\n\t  const length = string.length;\n\t  let leadSurrogate = null;\n\t  const bytes = [];\n\n\t  for (let i = 0; i < length; ++i) {\n\t    codePoint = string.charCodeAt(i);\n\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t          continue\n\t        }\n\n\t        // valid lead\n\t        leadSurrogate = codePoint;\n\n\t        continue\n\t      }\n\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t        leadSurrogate = codePoint;\n\t        continue\n\t      }\n\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n\t    }\n\n\t    leadSurrogate = null;\n\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint);\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      );\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\n\t  return bytes\n\t}\n\n\tfunction asciiToBytes (str) {\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF);\n\t  }\n\t  return byteArray\n\t}\n\n\tfunction utf16leToBytes (str, units) {\n\t  let c, hi, lo;\n\t  const byteArray = [];\n\t  for (let i = 0; i < str.length; ++i) {\n\t    if ((units -= 2) < 0) break\n\n\t    c = str.charCodeAt(i);\n\t    hi = c >> 8;\n\t    lo = c % 256;\n\t    byteArray.push(lo);\n\t    byteArray.push(hi);\n\t  }\n\n\t  return byteArray\n\t}\n\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  let i;\n\t  for (i = 0; i < length; ++i) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i];\n\t  }\n\t  return i\n\t}\n\n\t// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n\t// the `instanceof` check but they should be treated as of that type.\n\t// See: https://github.com/feross/buffer/issues/166\n\tfunction isInstance (obj, type) {\n\t  return obj instanceof type ||\n\t    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n\t      obj.constructor.name === type.name)\n\t}\n\tfunction numberIsNaN (obj) {\n\t  // For IE11 support\n\t  return obj !== obj // eslint-disable-line no-self-compare\n\t}\n\n\t// Create lookup table for `toString('hex')`\n\t// See: https://github.com/feross/buffer/issues/219\n\tconst hexSliceLookupTable = (function () {\n\t  const alphabet = '0123456789abcdef';\n\t  const table = new Array(256);\n\t  for (let i = 0; i < 16; ++i) {\n\t    const i16 = i * 16;\n\t    for (let j = 0; j < 16; ++j) {\n\t      table[i16 + j] = alphabet[i] + alphabet[j];\n\t    }\n\t  }\n\t  return table\n\t})();\n\n\t// Return not function with Error if BigInt not supported\n\tfunction defineBigIntMethod (fn) {\n\t  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n\t}\n\n\tfunction BufferBigIntNotDefined () {\n\t  throw new Error('BigInt not supported')\n\t} \n} (buffer));\n\nconst Buffer = buffer.Buffer;\n\nconst Blob = buffer.Blob;\nconst BlobOptions = buffer.BlobOptions;\nconst Buffer$1 = buffer.Buffer;\nconst File = buffer.File;\nconst FileOptions = buffer.FileOptions;\nconst INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;\nconst SlowBuffer = buffer.SlowBuffer;\nconst TranscodeEncoding = buffer.TranscodeEncoding;\nconst atob = buffer.atob;\nconst btoa = buffer.btoa;\nconst constants = buffer.constants;\nconst isAscii = buffer.isAscii;\nconst isUtf8 = buffer.isUtf8;\nconst kMaxLength = buffer.kMaxLength;\nconst kStringMaxLength = buffer.kStringMaxLength;\nconst resolveObjectURL = buffer.resolveObjectURL;\nconst transcode = buffer.transcode;\nexport { Blob, BlobOptions, Buffer$1 as Buffer, File, FileOptions, INSPECT_MAX_BYTES, SlowBuffer, TranscodeEncoding, atob, btoa, constants, Buffer as default, isAscii, isUtf8, kMaxLength, kStringMaxLength, resolveObjectURL, transcode };\n//# sourceMappingURL=index.js.map\n","export class Bytes {\n\tstatic fromHex(hex: string): Uint8Array {\n\t\thex = hex.trim();\n\t\tif (hex.length === 0) {\n\t\t\treturn new Uint8Array(0);\n\t\t}\n\t\tif (hex.length < 2 || hex.length & 1) {\n\t\t\tthrow new Error('Invalid hex string: odd length.');\n\t\t}\n\t\tif (hex.startsWith('0x') || hex.startsWith('0X')) {\n\t\t\thex = hex.slice(2);\n\t\t}\n\t\tconst match = hex.match(/^[0-9a-fA-F]*$/);\n\t\tif (!match) {\n\t\t\tthrow new Error('Invalid hex string: contains non-hex characters');\n\t\t}\n\t\tconst matches = hex.match(/.{1,2}/g);\n\t\tif (!matches) {\n\t\t\tthrow new Error('Invalid hex string');\n\t\t}\n\t\treturn new Uint8Array(matches.map((byte) => parseInt(byte, 16)));\n\t}\n\n\tstatic toHex(bytes: Uint8Array): string {\n\t\treturn Array.from(bytes, (byte) => byte.toString(16).padStart(2, '0')).join('');\n\t}\n\n\tstatic fromString(str: string): Uint8Array {\n\t\tstr = str.trim();\n\t\treturn new TextEncoder().encode(str);\n\t}\n\n\tstatic toString(bytes: Uint8Array): string {\n\t\treturn new TextDecoder('utf-8').decode(bytes);\n\t}\n\n\tstatic concat(...arrays: Uint8Array[]): Uint8Array {\n\t\tconst totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);\n\t\tconst result = new Uint8Array(totalLength);\n\t\tlet offset = 0;\n\t\tfor (const arr of arrays) {\n\t\t\tresult.set(arr, offset);\n\t\t\toffset += arr.length;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic alloc(size: number): Uint8Array {\n\t\treturn new Uint8Array(size);\n\t}\n\n\tstatic writeBigUint64BE(value: bigint): Uint8Array {\n\t\tconst buffer = new ArrayBuffer(8);\n\t\tnew DataView(buffer).setBigUint64(0, value, false);\n\t\treturn new Uint8Array(buffer);\n\t}\n\n\tstatic toBase64(bytes: Uint8Array): string {\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn Buffer.from(bytes).toString('base64');\n\t\t}\n\t\t// preventing stack overflow by chunking\n\t\tif (bytes.length > 32768) {\n\t\t\tlet result = '';\n\t\t\tfor (let i = 0; i < bytes.length; i += 32768) {\n\t\t\t\tconst chunk = bytes.slice(i, i + 32768);\n\t\t\t\tresult += btoa(String.fromCharCode(...chunk));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\treturn btoa(String.fromCharCode(...bytes));\n\t}\n\n\tstatic fromBase64(base64: string): Uint8Array {\n\t\tbase64 = base64.trim();\n\t\tif (typeof Buffer !== 'undefined') {\n\t\t\treturn new Uint8Array(Buffer.from(base64, 'base64'));\n\t\t}\n\n\t\tlet normalizedBase64 = base64.replace(/-/g, '+').replace(/_/g, '/');\n\t\twhile (normalizedBase64.length % 4) {\n\t\t\tnormalizedBase64 += '=';\n\t\t}\n\t\treturn new Uint8Array([...atob(normalizedBase64)].map((c) => c.charCodeAt(0)));\n\t}\n\n\tstatic equals(a: Uint8Array, b: Uint8Array): boolean {\n\t\tif (a.length !== b.length) return false;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tresult |= a[i] ^ b[i];\n\t\t}\n\t\treturn result === 0;\n\t}\n\n\tstatic compare(a: Uint8Array, b: Uint8Array): number {\n\t\tconst minLength = Math.min(a.length, b.length);\n\t\tfor (let i = 0; i < minLength; i++) {\n\t\t\tif (a[i] < b[i]) return -1;\n\t\t\tif (a[i] > b[i]) return 1;\n\t\t}\n\t\treturn a.length - b.length;\n\t}\n}\n","import { bytesToHex } from '@noble/curves/abstract/utils';\nimport { Bytes } from '../../utils/Bytes';\n\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\nexport function encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n"],"names":["buffer","base64Js","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","code","i","len","getLens","b64","validLen","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","start","end","output","extraBytes","parts","maxChunkLength","len2","ieee754","offset","isLE","mLen","nBytes","e","m","eLen","eMax","eBias","nBits","d","s","value","c","rt","exports","base64","ieee754$1","customInspectSymbol","Buffer","SlowBuffer","K_MAX_LENGTH","GlobalUint8Array","GlobalArrayBuffer","GlobalSharedArrayBuffer","typedArraySupport","proto","createBuffer","length","buf","arg","encodingOrOffset","allocUnsafe","from","fromString","fromArrayView","isInstance","fromArrayBuffer","valueOf","b","fromObject","assertSize","size","alloc","fill","encoding","checked","string","actual","fromArrayLike","array","arrayView","copy","byteOffset","obj","numberIsNaN","a","x","y","list","pos","mustMatch","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","n","str","max","target","thisStart","thisEnd","thisCopy","targetCopy","bidirectionalIndexOf","val","dir","arrayIndexOf","indexSize","arrLength","valLength","read","foundIndex","found","j","hexWrite","remaining","strLen","parsed","utf8Write","blitBuffer","asciiWrite","asciiToBytes","base64Write","ucs2Write","utf16leToBytes","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","MAX_ARGUMENTS_LENGTH","codePoints","ret","out","hexSliceLookupTable","bytes","newBuf","checkOffset","ext","noAssert","mul","defineBigIntMethod","validateNumber","first","last","boundsError","lo","hi","checkInt","min","maxBytes","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","limit","sub","checkIEEE754","writeFloat","littleEndian","writeDouble","targetStart","errors","E","sym","getMessage","Base","name","range","input","msg","received","addNumericalSeparator","checkBounds","type","INVALID_BASE64_RE","base64clean","units","leadSurrogate","byteArray","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","Bytes","hex","matches","byte","arrays","totalLength","sum","result","chunk","normalizedBase64","minLength","bytesToNumber","hexToNumber","bytesToHex","encodeBase64toUint8","base64String"],"mappings":"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","debugId":null}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/crypto/common.es.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/common/index.ts"],"sourcesContent":["import { type ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { bytesToNumber, encodeBase64toUint8, hexToNumber } from '../util/utils';\nimport { Bytes } from '../../utils/Bytes';\n\nexport type Enumerate<N extends number, Acc extends number[] = []> = Acc['length'] extends N\n\t? Acc[number]\n\t: Enumerate<N, [...Acc, Acc['length']]>;\n\nexport type IntRange<F extends number, T extends number> = Exclude<Enumerate<T>, Enumerate<F>>;\n\nexport type MintKeys = { [k: string]: Uint8Array };\n\nexport type SerializedMintKeys = {\n\t[k: string]: string;\n};\n\nexport type Keyset = {\n\tid: string;\n\tunit: string;\n\tactive: boolean;\n};\n\nexport type BlindSignature = {\n\tC_: ProjPointType<bigint>;\n\tamount: number;\n\tid: string;\n};\n\nexport type SerializedBlindSignature = {\n\tC_: string;\n\tamount: number;\n\tid: string;\n};\n\nexport type DLEQ = {\n\ts: Uint8Array; // signature\n\te: Uint8Array; // challenge\n\tr?: bigint; // optional: blinding factor\n};\n\nexport type Proof = {\n\tC: ProjPointType<bigint>;\n\tsecret: Uint8Array;\n\tamount: number;\n\tid: string;\n\twitness?: Witness;\n};\n\nexport type SerializedProof = {\n\tC: string;\n\tsecret: string;\n\tamount: number;\n\tid: string;\n\twitness?: string;\n};\n\nexport type SerializedBlindedMessage = {\n\tB_: string;\n\tamount: number;\n\twitness?: string;\n};\n\nexport type Secret = [WellKnownSecret, SecretData];\n\nexport type WellKnownSecret = 'P2PK';\n\nexport type SecretData = {\n\tnonce: string;\n\tdata: string;\n\ttags?: string[][];\n};\n\nexport type Witness = {\n\tsignatures: string[];\n};\n\nexport type Tags = {\n\t[k: string]: string;\n};\n\nexport type SigFlag = 'SIG_INPUTS' | 'SIG_ALL';\n\nconst DOMAIN_SEPARATOR = hexToBytes('536563703235366b315f48617368546f43757276655f43617368755f');\n\nexport function hashToCurve(secret: Uint8Array): ProjPointType<bigint> {\n\tconst msgToHash = sha256(Bytes.concat(DOMAIN_SEPARATOR, secret));\n\tconst counter = new Uint32Array(1);\n\tconst maxIterations = 2 ** 16;\n\tfor (let i = 0; i < maxIterations; i++) {\n\t\tconst counterBytes = new Uint8Array(counter.buffer);\n\t\tconst hash = sha256(Bytes.concat(msgToHash, counterBytes));\n\t\ttry {\n\t\t\treturn pointFromHex(bytesToHex(Bytes.concat(new Uint8Array([0x02]), hash)));\n\t\t} catch {\n\t\t\tcounter[0]++;\n\t\t}\n\t}\n\tthrow new Error('No valid point found');\n}\n\nexport function hash_e(pubkeys: Array<ProjPointType<bigint>>): Uint8Array {\n\tconst hexStrings = pubkeys.map((p) => p.toHex(false));\n\tconst e_ = hexStrings.join('');\n\treturn sha256(new TextEncoder().encode(e_));\n}\n\nexport function pointFromBytes(bytes: Uint8Array) {\n\treturn secp256k1.ProjectivePoint.fromHex(bytesToHex(bytes));\n}\n\nexport function pointFromHex(hex: string) {\n\treturn secp256k1.ProjectivePoint.fromHex(hex);\n}\n\nexport const getKeysetIdInt = (keysetId: string): bigint => {\n\tlet keysetIdInt: bigint;\n\tif (/^[a-fA-F0-9]+$/.test(keysetId)) {\n\t\tkeysetIdInt = hexToNumber(keysetId) % BigInt(2 ** 31 - 1);\n\t} else {\n\t\t//legacy keyset compatibility\n\t\tkeysetIdInt = bytesToNumber(encodeBase64toUint8(keysetId)) % BigInt(2 ** 31 - 1);\n\t}\n\treturn keysetIdInt;\n};\n\nexport function createRandomPrivateKey() {\n\treturn secp256k1.utils.randomPrivateKey();\n}\n\nexport function serializeMintKeys(mintKeys: MintKeys): SerializedMintKeys {\n\tconst serializedMintKeys: SerializedMintKeys = {};\n\tObject.keys(mintKeys).forEach((p) => {\n\t\tserializedMintKeys[p] = bytesToHex(mintKeys[p]);\n\t});\n\treturn serializedMintKeys;\n}\n\nexport function deserializeMintKeys(serializedMintKeys: SerializedMintKeys): MintKeys {\n\tconst mintKeys: MintKeys = {};\n\tObject.keys(serializedMintKeys).forEach((p) => {\n\t\tmintKeys[p] = hexToBytes(serializedMintKeys[p]);\n\t});\n\treturn mintKeys;\n}\n\nexport function deriveKeysetId(keys: MintKeys): string {\n\tconst KEYSET_VERSION = '00';\n\tconst mapBigInt = (k: [string, string]): [bigint, string] => {\n\t\treturn [BigInt(k[0]), k[1]];\n\t};\n\tconst pubkeysConcat = Object.entries(serializeMintKeys(keys))\n\t\t.map(mapBigInt)\n\t\t.sort((a, b) => (a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0))\n\t\t.map(([, pubKey]) => hexToBytes(pubKey))\n\t\t.reduce((prev, curr) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\tconst hash = sha256(pubkeysConcat);\n\tconst hashHex = Bytes.toHex(hash).slice(0, 14);\n\treturn KEYSET_VERSION + hashHex;\n}\n\nfunction mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n"],"names":["DOMAIN_SEPARATOR","hexToBytes","hashToCurve","secret","msgToHash","sha256","Bytes","counter","maxIterations","i","counterBytes","hash","pointFromHex","bytesToHex","hash_e","pubkeys","e_","p","pointFromBytes","bytes","secp256k1","hex","getKeysetIdInt","keysetId","keysetIdInt","hexToNumber","bytesToNumber","encodeBase64toUint8","createRandomPrivateKey","serializeMintKeys","mintKeys","serializedMintKeys","deserializeMintKeys","deriveKeysetId","keys","mapBigInt","k","pubkeysConcat","a","b","pubKey","prev","curr","mergeUInt8Arrays","a1","a2","mergedArray"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1046, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT12.es.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT12.ts"],"sourcesContent":["import { type DLEQ, hash_e, hashToCurve } from '../common/index';\nimport { type ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { bytesToHex } from '@noble/curves/abstract/utils';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { bytesToNumber } from '../util/utils';\n\nfunction arraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n\tif (arr1.length !== arr2.length) return false;\n\tfor (let i = 0; i < arr1.length; i++) {\n\t\tif (arr1[i] !== arr2[i]) return false;\n\t}\n\treturn true;\n}\n\nexport const verifyDLEQProof = (\n\tdleq: DLEQ,\n\tB_: ProjPointType<bigint>,\n\tC_: ProjPointType<bigint>,\n\tA: ProjPointType<bigint>,\n) => {\n\tconst sG = secp256k1.ProjectivePoint.fromPrivateKey(bytesToHex(dleq.s));\n\tconst eA = A.multiply(bytesToNumber(dleq.e));\n\tconst sB_ = B_.multiply(bytesToNumber(dleq.s));\n\tconst eC_ = C_.multiply(bytesToNumber(dleq.e));\n\tconst R_1 = sG.subtract(eA); // R1 = sG - eA\n\tconst R_2 = sB_.subtract(eC_); // R2 = sB' - eC'\n\tconst hash = hash_e([R_1, R_2, A, C_]); // e == hash(R1, R2, A, C')\n\treturn arraysEqual(hash, dleq.e);\n};\n\nexport const verifyDLEQProof_reblind = (\n\tsecret: Uint8Array, // secret\n\tdleq: DLEQ,\n\tC: ProjPointType<bigint>, // unblinded e-cash signature point\n\tA: ProjPointType<bigint>, // mint public key point\n) => {\n\tif (dleq.r === undefined) throw new Error('verifyDLEQProof_reblind: Undefined blinding factor');\n\tconst Y = hashToCurve(secret);\n\tconst C_ = C.add(A.multiply(dleq.r)); // Re-blind the e-cash signature\n\tconst bG = secp256k1.ProjectivePoint.fromPrivateKey(dleq.r);\n\tconst B_ = Y.add(bG); // Re-blind the message\n\treturn verifyDLEQProof(dleq, B_, C_, A);\n};\n"],"names":["arraysEqual","arr1","arr2","i","verifyDLEQProof","dleq","B_","C_","A","sG","secp256k1","bytesToHex","eA","bytesToNumber","sB_","eC_","R_1","R_2","hash","hash_e","verifyDLEQProof_reblind","secret","C","Y","hashToCurve","bG"],"mappings":";;;;;;;;;;;;;;AAMA,SAASA,EAAYC,CAAAA,EAAkBC,CAAAA,EAAkB;IACxD,IAAID,EAAK,MAAA,KAAWC,EAAK,MAAA,CAAQ,CAAA,OAAO,CAAA;IACxC,IAAA,IAASC,IAAI,GAAGA,IAAIF,EAAK,MAAA,EAAQE,IAChC,IAAIF,CAAAA,CAAKE,CAAC,CAAA,KAAMD,CAAAA,CAAKC,CAAC,CAAA,CAAG,CAAA,OAAO,CAAA;IAEjC,OAAO,CAAA;AACR;AAEO,MAAMC,IAAkB,CAC9BC,GACAC,GACAC,GACAC,MACI;IACJ,MAAMC,IAAKC,kKAAAA,CAAU,eAAA,CAAgB,cAAA,KAAeC,2KAAAA,EAAWN,EAAK,CAAC,CAAC,GAChEO,IAAKJ,EAAE,QAAA,KAASK,uKAAAA,EAAcR,EAAK,CAAC,CAAC,GACrCS,IAAMR,EAAG,QAAA,KAASO,uKAAAA,EAAcR,EAAK,CAAC,CAAC,GACvCU,IAAMR,EAAG,QAAA,KAASM,uKAAAA,EAAcR,EAAK,CAAC,CAAC,GACvCW,IAAMP,EAAG,QAAA,CAASG,CAAE,GACpBK,IAAMH,EAAI,QAAA,CAASC,CAAG,GACtBG,QAAOC,iLAAAA,EAAO;QAACH;QAAKC;QAAKT;QAAGD,CAAE;KAAC;IACrC,OAAOP,EAAYkB,GAAMb,EAAK,CAAC;AAChC,GAEae,IAA0B,CACtCC,GACAhB,GACAiB,GACAd,MACI;IACJ,IAAIH,EAAK,CAAA,KAAM,KAAA,EAAW,CAAA,MAAM,IAAI,MAAM,oDAAoD;IAC9F,MAAMkB,QAAIC,sLAAAA,EAAYH,CAAM,GACtBd,IAAKe,EAAE,GAAA,CAAId,EAAE,QAAA,CAASH,EAAK,CAAC,CAAC,GAC7BoB,IAAKf,kKAAAA,CAAU,eAAA,CAAgB,cAAA,CAAeL,EAAK,CAAC,GACpDC,IAAKiB,EAAE,GAAA,CAAIE,CAAE;IACnB,OAAOrB,EAAgBC,GAAMC,GAAIC,GAAIC,CAAC;AACvC","debugId":null}},
    {"offset": {"line": 1084, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/NUT09-BsylB_jy.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/base64.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT09.ts"],"sourcesContent":["import { Bytes } from './utils/Bytes';\n\nfunction encodeUint8toBase64(uint8array: Uint8Array): string {\n\treturn Bytes.toBase64(uint8array);\n}\n\nfunction encodeUint8toBase64Url(bytes: Uint8Array): string {\n\treturn Bytes.toBase64(bytes)\n\t\t.replace(/\\+/g, '-') // Replace + with -\n\t\t.replace(/\\//g, '_') // Replace / with _\n\t\t.replace(/=+$/, ''); // Remove padding characters\n}\n\nfunction encodeBase64toUint8(base64String: string): Uint8Array {\n\treturn Bytes.fromBase64(base64String);\n}\n\nfunction encodeJsonToBase64(jsonObj: unknown): string {\n\tconst jsonString = JSON.stringify(jsonObj);\n\treturn base64urlFromBase64(Bytes.toBase64(Bytes.fromString(jsonString)));\n}\n\nfunction encodeBase64ToJson<T extends object>(base64String: string): T {\n\tconst jsonString = Bytes.toString(Bytes.fromBase64(base64urlToBase64(base64String)));\n\tconst jsonObj = JSON.parse(jsonString) as T;\n\treturn jsonObj;\n}\n\nfunction base64urlToBase64(str: string) {\n\treturn str.replace(/-/g, '+').replace(/_/g, '/').split('=')[0];\n\t// .replace(/./g, '=');\n}\n\nfunction base64urlFromBase64(str: string) {\n\treturn str.replace(/\\+/g, '-').replace(/\\//g, '_').split('=')[0];\n\t// .replace(/=/g, '.');\n}\n\nfunction isBase64String(s: string): boolean {\n\tif (typeof s !== 'string' || s.length === 0) return false;\n\n\t// Accept both base64 and base64url char sets\n\tconst base64url = /^[A-Za-z0-9\\-_]+={0,2}$/;\n\tconst base64 = /^[A-Za-z0-9+/]+={0,2}$/;\n\n\t// Quick character-set check\n\tif (!base64url.test(s) && !base64.test(s)) return false;\n\n\t// Normalize base64url to standard base64 for decoding\n\tconst normalized = s.replace(/-/g, '+').replace(/_/g, '/');\n\n\t// Padding: length must be multiple of 4. Add '=' padding if needed (but no more than 2)\n\tconst padLength = (4 - (normalized.length % 4)) % 4;\n\tif (padLength > 2) return false; // should never happen but keep safe\n\tconst padded = normalized + '='.repeat(padLength);\n\n\ttry {\n\t\tconst decoded = Bytes.fromBase64(padded);\n\n\t\t// Re-encode and compare to the original (allowing either standard or url-safe representation)\n\t\tconst reStandard = Bytes.toBase64(decoded);\n\t\tconst reUrl = reStandard.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n\n\t\t// Also compare against original normalized-without-padding variant\n\t\tconst originalNoPad = normalized.replace(/=+$/, '');\n\n\t\tif (reStandard.replace(/=+$/, '') === originalNoPad) return true;\n\t\tif (reUrl === originalNoPad) return true;\n\n\t\treturn false;\n\t} catch {\n\t\treturn false;\n\t}\n}\n\nexport {\n\tencodeUint8toBase64,\n\tencodeUint8toBase64Url,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeBase64ToJson,\n\tisBase64String,\n};\n","import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha2';\nimport { getKeysetIdInt } from '../common';\nimport { HDKey } from '@scure/bip32';\nimport { Bytes } from '../../utils/Bytes';\nimport { isBase64String } from '../../base64';\n\nconst STANDARD_DERIVATION_PATH = `m/129372'/0'`;\n\nenum DerivationType {\n\tSECRET = 0,\n\tBLINDING_FACTOR = 1,\n}\n\nexport const deriveSecret = (seed: Uint8Array, keysetId: string, counter: number): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.SECRET);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.SECRET);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nexport const deriveBlindingFactor = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n): Uint8Array => {\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keysetId);\n\tif (!isValidHex && isBase64String(keysetId)) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\n\tif (isValidHex && keysetId.startsWith('00')) {\n\t\treturn derive_deprecated(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t} else if (isValidHex && keysetId.startsWith('01')) {\n\t\treturn derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);\n\t}\n\tthrow new Error(`Unrecognized keyset ID version ${keysetId.slice(0, 2)}`);\n};\n\nconst derive = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tlet message = Bytes.concat(\n\t\tBytes.fromString('Cashu_KDF_HMAC_SHA256'),\n\t\tBytes.fromHex(keysetId),\n\t\tBytes.writeBigUint64BE(BigInt(counter)),\n\t);\n\n\tswitch (secretOrBlinding) {\n\t\tcase DerivationType.SECRET:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('00'));\n\t\t\tbreak;\n\t\tcase DerivationType.BLINDING_FACTOR:\n\t\t\tmessage = Bytes.concat(message, Bytes.fromHex('01'));\n\t}\n\n\t// Step 2: Compute HMAC-SHA256\n\treturn hmac(sha256, seed, message);\n};\n\nconst derive_deprecated = (\n\tseed: Uint8Array,\n\tkeysetId: string,\n\tcounter: number,\n\tsecretOrBlinding: DerivationType,\n): Uint8Array => {\n\tconst hdkey = HDKey.fromMasterSeed(seed);\n\tconst keysetIdInt = getKeysetIdInt(keysetId);\n\tconst derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;\n\tconst derived = hdkey.derive(derivationPath);\n\tif (derived.privateKey === null) {\n\t\tthrow new Error('Could not derive private key');\n\t}\n\treturn derived.privateKey;\n};\n"],"names":["encodeUint8toBase64Url","bytes","Bytes","encodeBase64toUint8","base64String","encodeJsonToBase64","jsonObj","jsonString","base64urlFromBase64","encodeBase64ToJson","base64urlToBase64","str","isBase64String","s","base64url","base64","normalized","padLength","padded","decoded","reStandard","reUrl","originalNoPad","STANDARD_DERIVATION_PATH","deriveSecret","seed","keysetId","counter","isValidHex","derive_deprecated","derive","deriveBlindingFactor","secretOrBlinding","message","hmac","sha256","hdkey","HDKey","keysetIdInt","getKeysetIdInt","derivationPath","derived"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1175, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/crypto/common/NUT11.es.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/common/NUT11.ts"],"sourcesContent":["import { type Secret } from './index';\n\nexport const parseP2PKSecret = (secret: string | Uint8Array): Secret => {\n\ttry {\n\t\tif (secret instanceof Uint8Array) {\n\t\t\tsecret = new TextDecoder().decode(secret);\n\t\t}\n\t\treturn JSON.parse(secret) as Secret;\n\t} catch {\n\t\tthrow new Error(\"can't parse secret\");\n\t}\n};\n"],"names":["parseP2PKSecret","secret"],"mappings":";;;;AAEO,MAAMA,IAAkB,CAACC,MAAwC;IACvE,IAAI;QACH,OAAIA,aAAkB,cAAA,CACrBA,IAAS,IAAI,cAAc,MAAA,CAAOA,CAAM,CAAA,GAElC,KAAK,KAAA,CAAMA,CAAM;IACzB,EAAA,OAAQ;QACP,MAAM,IAAI,MAAM,oBAAoB;IACrC;AACD","debugId":null}},
    {"offset": {"line": 1192, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT11.es.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT11.ts"],"sourcesContent":["import { type PrivKey, bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { schnorr } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { parseP2PKSecret } from '../common/NUT11';\nimport { type Secret, type Witness } from '../common/index';\nimport { type P2PKWitness, type Proof } from '../../model/types/index';\nimport { type BlindedMessage } from './index';\n\nexport const createP2PKsecret = (pubkey: string): string => {\n\tconst newSecret: Secret = [\n\t\t'P2PK',\n\t\t{\n\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\tdata: pubkey,\n\t\t},\n\t];\n\treturn JSON.stringify(newSecret);\n};\n\nexport const signP2PKSecret = (secret: string, privateKey: PrivKey): string => {\n\tconst msghash = sha256(secret);\n\tconst sig = schnorr.sign(msghash, privateKey);\n\treturn bytesToHex(sig);\n};\n\nexport const signBlindedMessage = (B_: string, privateKey: PrivKey): string => {\n\tconst msgHash = sha256(B_);\n\tconst sig = schnorr.sign(msgHash, privateKey);\n\treturn bytesToHex(sig);\n};\n\n/**\n * Verifies a Schnorr signature on a P2PK secret.\n *\n * @param signature - The Schnorr signature (hex-encoded).\n * @param secret - The Secret to verify.\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @returns {boolean} True if the signature is valid, false otherwise.\n */\nexport const verifyP2PKSecretSignature = (\n\tsignature: string,\n\tsecret: string,\n\tpubkey: string,\n): boolean => {\n\ttry {\n\t\tconst msghash = sha256(secret);\n\t\t// Use X-only pubkey: strip 02/03 prefix if pubkey is 66 hex chars (33 bytes)\n\t\tconst pubkeyX = pubkey.length === 66 ? pubkey.slice(2) : pubkey;\n\t\tif (schnorr.verify(signature, msghash, hexToBytes(pubkeyX))) {\n\t\t\treturn true;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('verifyP2PKsecret error:', e);\n\t}\n\treturn false; // no bueno\n};\n\n/**\n * Verifies a pubkey has signed a P2PK Proof.\n *\n * @param pubkey - The Cashu P2PK public key (hex-encoded, X-only or with 02/03 prefix).\n * @param proof - A Cashu proof.\n * @returns {boolean} True if one of the signatures is theirs, false otherwise.\n */\nexport const hasP2PKSignedProof = (pubkey: string, proof: Proof): boolean => {\n\tif (!proof.witness) {\n\t\treturn false;\n\t}\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\t// See if any of the signatures belong to this pubkey.\n\t// We need to do this as Schnorr signatures are non-deterministic.\n\treturn signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n};\n\n/**\n * Returns the expected witness public keys from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKExpectedKWitnessPubkeys(secretStr: string | Secret): string[] {\n\ttry {\n\t\t// Validate secret\n\t\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\t\tif (secret[0] !== 'P2PK') {\n\t\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t\t}\n\t\tconst now = Math.floor(Date.now() / 1000);\n\t\tconst locktime = getP2PKLocktime(secret);\n\t\tif (locktime > now) {\n\t\t\t// Am interpretting NUT-11 as intending pubkeys to be usable for a\n\t\t\t// 1-of-m multisig if provided, even if n_sigs is not set\n\t\t\treturn getP2PKWitnessPubkeys(secret);\n\t\t}\n\t\treturn getP2PKWitnessRefundkeys(secret);\n\t} catch {\n\t\t// do nothing\n\t}\n\treturn []; // Unlocked, malformed or expired with no refund keys\n}\n\n/**\n * Returns ALL locktime witnesses from a NUT-11 P2PK secret NB: Does not specify if they are\n * expected to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public key(s or empty array.\n */\nexport function getP2PKWitnessPubkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { data, tags } = secret[1];\n\tconst pubkeysTag = tags && tags.find((tag) => tag[0] === 'pubkeys');\n\tconst pubkeys = pubkeysTag && pubkeysTag.length > 1 ? pubkeysTag.slice(1) : [];\n\treturn [data, ...pubkeys].filter(Boolean);\n}\n\n/**\n * Returns ALL refund witnesses from a NUT-11 P2PK secret NB: Does not specify if they are expected\n * to sign - see: getP2PKExpectedKWitnessPubkeys()\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {array} With the public keys or empty array.\n */\nexport function getP2PKWitnessRefundkeys(secretStr: string | Secret): string[] {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst refundTag = tags && tags.find((tag) => tag[0] === 'refund');\n\treturn refundTag && refundTag.length > 1 ? refundTag.slice(1).filter(Boolean) : [];\n}\n\n/**\n * Returns the locktime from a NUT-11 P2PK secret or Infinity if no locktime.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The locktime unix timestamp or Infinity (permanent lock)\n */\nexport function getP2PKLocktime(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst locktimeTag = tags && tags.find((tag) => tag[0] === 'locktime');\n\treturn locktimeTag && locktimeTag.length > 1 ? parseInt(locktimeTag[1], 10) : Infinity; // Permanent lock if not set\n}\n\n/**\n * Returns the number of signatures required from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {number} The number of signatories (n_sigs / n_sigs_refund) or 0 if secret is unlocked.\n */\nexport function getP2PKNSigs(secretStr: string | Secret): number {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\t// Check for witnesses\n\tconst witness = getP2PKExpectedKWitnessPubkeys(secret);\n\tif (!witness.length) {\n\t\treturn 0; // unlocked if no witnesses needed\n\t}\n\t// Check for Lock multisig\n\tconst { tags } = secret[1];\n\tconst now = Math.floor(Date.now() / 1000);\n\tconst locktime = getP2PKLocktime(secret);\n\tif (locktime > now) {\n\t\tconst n_sigsTag = tags && tags.find((tag) => tag[0] === 'n_sigs');\n\t\treturn n_sigsTag && n_sigsTag.length > 1 ? parseInt(n_sigsTag[1], 10) : 1; // Default: 1\n\t}\n\t// Refund multisig\n\tconst n_sigs_refundTag = tags && tags.find((tag) => tag[0] === 'n_sigs_refund');\n\treturn n_sigs_refundTag && n_sigs_refundTag.length > 1 ? parseInt(n_sigs_refundTag[1], 10) : 1; // Default: 1\n}\n\n/**\n * Returns the sigflag from a NUT-11 P2PK secret.\n *\n * @param secretStr - The NUT-11 P2PK secret.\n * @returns {string} The sigflag or 'SIG_INPUTS' (default)\n */\nexport function getP2PKSigFlag(secretStr: string | Secret): string {\n\t// Validate secret\n\tconst secret: Secret = typeof secretStr === 'string' ? parseP2PKSecret(secretStr) : secretStr;\n\tif (secret[0] !== 'P2PK') {\n\t\tthrow new Error('Invalid P2PK secret: must start with \"P2PK\"');\n\t}\n\tconst { tags } = secret[1];\n\tconst sigFlagTag = tags && tags.find((tag) => tag[0] === 'sigflag');\n\treturn sigFlagTag && sigFlagTag.length > 1 ? sigFlagTag[1] : 'SIG_INPUTS';\n}\n\n/**\n * Gets witness signatures as an array.\n *\n * @type {array} of Signatures.\n */\nexport const getP2PKWitnessSignatures = (witness: string | P2PKWitness | undefined): string[] => {\n\tif (!witness) return [];\n\tif (typeof witness === 'string') {\n\t\ttry {\n\t\t\tconst parsed = JSON.parse(witness) as Witness;\n\t\t\treturn parsed.signatures || [];\n\t\t} catch (e) {\n\t\t\tconsole.error('Failed to parse witness string:', e);\n\t\t\treturn [];\n\t\t}\n\t}\n\treturn witness.signatures || [];\n};\n\n/**\n * Signs proofs with provided private key(s) if required NB: Will only sign if the proof requires a\n * signature from the key.\n *\n * @param proofs - An array of proofs to sign.\n * @param privateKey - A single private key or array of private keys.\n * @param beStrict - (Default: false) Throws Error if any signing attempt fails.\n */\nexport const signP2PKProofs = (\n\tproofs: Proof[],\n\tprivateKey: string | string[],\n\tbeStrict = false,\n): Proof[] => {\n\tconst privateKeys: string[] = Array.isArray(privateKey) ? privateKey : [privateKey];\n\treturn proofs.map((proof, index) => {\n\t\tlet signedProof = proof;\n\t\tfor (const priv of privateKeys) {\n\t\t\ttry {\n\t\t\t\tsignedProof = signP2PKProof(signedProof, priv);\n\t\t\t} catch (error: unknown) {\n\t\t\t\tconst message = error instanceof Error ? error.message : 'Unknown error';\n\t\t\t\tif (beStrict) {\n\t\t\t\t\tthrow new Error(`Failed signing proof #${index + 1}: ${message}`);\n\t\t\t\t}\n\t\t\t\tconsole.warn(`Proof #${index + 1}: ${message}`);\n\t\t\t}\n\t\t}\n\t\treturn signedProof;\n\t});\n};\n\n/**\n * Signs a single proof with the provided private key if required NB: Will only sign if the proof\n * requires a signature from the key.\n *\n * @param proof - A proof to sign.\n * @param privateKey - A single private key.\n * @throws Error if signature is not required or proof is already signed.\n */\nexport const signP2PKProof = (proof: Proof, privateKey: string): Proof => {\n\t// Check secret is P2PK\n\tconst parsed: Secret = parseP2PKSecret(proof.secret);\n\tif (parsed[0] !== 'P2PK') {\n\t\tthrow new Error('not a P2PK secret');\n\t}\n\t// Check if the private key is required to sign by checking its\n\t// X-only pubkey (no 02/03 prefix) against the expected witness pubkeys\n\t// NB: Nostr pubkeys prepend 02 by convention, ignoring actual Y-parity\n\tconst pubkey = bytesToHex(schnorr.getPublicKey(privateKey)); // x-only\n\tconst witnesses = getP2PKExpectedKWitnessPubkeys(parsed);\n\tif (!witnesses.length || !witnesses.some((w) => w.includes(pubkey))) {\n\t\tthrow new Error(`Signature not required from [02|03]${pubkey}`);\n\t}\n\t// Check if the public key has already signed\n\tconst signatures = getP2PKWitnessSignatures(proof.witness);\n\tconst alreadySigned = signatures.some((sig) => {\n\t\ttry {\n\t\t\treturn verifyP2PKSecretSignature(sig, proof.secret, pubkey);\n\t\t} catch {\n\t\t\treturn false; // Invalid signature, treat as not signed\n\t\t}\n\t});\n\tif (alreadySigned) {\n\t\tthrow new Error(`Proof already signed by [02|03]${pubkey}`);\n\t}\n\t// Add new signature\n\tconst signature = signP2PKSecret(proof.secret, privateKey);\n\tsignatures.push(signature);\n\treturn { ...proof, witness: { signatures } };\n};\n\nexport const getSignedOutput = (output: BlindedMessage, privateKey: PrivKey): BlindedMessage => {\n\tconst B_ = output.B_.toHex(true);\n\tconst signature = signBlindedMessage(B_, privateKey);\n\toutput.witness = { signatures: [signature] };\n\treturn output;\n};\n\nexport const getSignedOutputs = (\n\toutputs: BlindedMessage[],\n\tprivateKey: string,\n): BlindedMessage[] => {\n\treturn outputs.map((o) => getSignedOutput(o, privateKey));\n};\n"],"names":["createP2PKsecret","pubkey","newSecret","bytesToHex","randomBytes","signP2PKSecret","secret","privateKey","msghash","sha256","sig","schnorr","signBlindedMessage","B_","msgHash","verifyP2PKSecretSignature","signature","pubkeyX","hexToBytes","hasP2PKSignedProof","proof","getP2PKWitnessSignatures","getP2PKExpectedKWitnessPubkeys","secretStr","parseP2PKSecret","now","getP2PKLocktime","getP2PKWitnessPubkeys","getP2PKWitnessRefundkeys","data","tags","pubkeysTag","tag","pubkeys","refundTag","locktimeTag","getP2PKNSigs","n_sigsTag","n_sigs_refundTag","getP2PKSigFlag","sigFlagTag","witness","e","signP2PKProofs","proofs","beStrict","privateKeys","index","signedProof","priv","signP2PKProof","error","message","parsed","witnesses","w","signatures","getSignedOutput","output","getSignedOutputs","outputs","o"],"mappings":"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","debugId":null}},
    {"offset": {"line": 1371, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/crypto/client/NUT20.es.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/client/NUT20.ts"],"sourcesContent":["import { schnorr } from '@noble/curves/secp256k1';\nimport { type SerializedBlindedMessage } from '../../model/types';\nimport { bytesToHex, hexToBytes } from '@noble/hashes/utils';\nimport { sha256 } from '@noble/hashes/sha256';\n\nfunction constructMessage(quote: string, blindedMessages: SerializedBlindedMessage[]): Uint8Array {\n\tlet message = quote;\n\tfor (const blindedMessage of blindedMessages) {\n\t\tmessage += blindedMessage.B_;\n\t}\n\tconst msgbytes = new TextEncoder().encode(message);\n\treturn sha256(msgbytes);\n}\n\nexport function signMintQuote(\n\tprivkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n): string {\n\tconst message = constructMessage(quote, blindedMessages);\n\tconst privkeyBytes = hexToBytes(privkey);\n\tconst signature = schnorr.sign(message, privkeyBytes);\n\treturn bytesToHex(signature);\n}\n\nexport function verifyMintQuoteSignature(\n\tpubkey: string,\n\tquote: string,\n\tblindedMessages: SerializedBlindedMessage[],\n\tsignature: string,\n): boolean {\n\tconst sigbytes = hexToBytes(signature);\n\tlet pubkeyBytes = hexToBytes(pubkey);\n\tif (pubkeyBytes.length !== 33) return false;\n\tpubkeyBytes = pubkeyBytes.slice(1);\n\tconst message = constructMessage(quote, blindedMessages);\n\treturn schnorr.verify(sigbytes, message, pubkeyBytes);\n}\n"],"names":["constructMessage","quote","blindedMessages","message","blindedMessage","msgbytes","sha256","signMintQuote","privkey","privkeyBytes","hexToBytes","signature","schnorr","bytesToHex","verifyMintQuoteSignature","pubkey","sigbytes","pubkeyBytes"],"mappings":";;;;;;;;;;;;AAKA,SAASA,EAAiBC,CAAAA,EAAeC,CAAAA,EAAyD;IACjG,IAAIC,IAAUF;IACd,KAAA,MAAWG,KAAkBF,EAC5BC,KAAWC,EAAe,EAAA;IAE3B,MAAMC,IAAW,IAAI,cAAc,MAAA,CAAOF,CAAO;IACjD,WAAOG,4JAAAA,EAAOD,CAAQ;AACvB;AAEO,SAASE,EACfC,CAAAA,EACAP,CAAAA,EACAC,CAAAA,EACS;IACT,MAAMC,IAAUH,EAAiBC,GAAOC,CAAe,GACjDO,QAAeC,+JAAAA,EAAWF,CAAO,GACjCG,IAAYC,gKAAAA,CAAQ,IAAA,CAAKT,GAASM,CAAY;IACpD,WAAOI,+JAAAA,EAAWF,CAAS;AAC5B;AAEO,SAASG,EACfC,CAAAA,EACAd,CAAAA,EACAC,CAAAA,EACAS,CAAAA,EACU;IACV,MAAMK,QAAWN,+JAAAA,EAAWC,CAAS;IACrC,IAAIM,QAAcP,+JAAAA,EAAWK,CAAM;IACnC,IAAIE,EAAY,MAAA,KAAW,GAAI,CAAA,OAAO,CAAA;IACtCA,IAAcA,EAAY,KAAA,CAAM,CAAC;IACjC,MAAMd,IAAUH,EAAiBC,GAAOC,CAAe;IACvD,OAAOU,gKAAAA,CAAQ,MAAA,CAAOI,GAAUb,GAASc,CAAW;AACrD","debugId":null}},
    {"offset": {"line": 1407, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/crypto/client.es.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/crypto/client/index.ts"],"sourcesContent":["import { type ProjPointType } from '@noble/curves/abstract/weierstrass';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { bytesToNumber } from '../util/utils';\nimport {\n\ttype BlindSignature,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedProof,\n\thashToCurve,\n\tpointFromHex,\n\ttype Witness,\n} from '../common/index.js';\nimport { type PrivKey } from '@noble/curves/abstract/utils';\nimport { getSignedOutput } from './NUT11';\n\nexport type BlindedMessage = {\n\tB_: ProjPointType<bigint>;\n\tr: bigint;\n\tsecret: Uint8Array;\n\twitness?: Witness;\n};\n\nexport function createRandomBlindedMessage(privateKey?: PrivKey): BlindedMessage {\n\treturn blindMessage(\n\t\trandomBytes(32),\n\t\tbytesToNumber(secp256k1.utils.randomPrivateKey()),\n\t\tprivateKey,\n\t);\n}\n\nexport function blindMessage(secret: Uint8Array, r?: bigint, privateKey?: PrivKey): BlindedMessage {\n\tconst Y = hashToCurve(secret);\n\tif (!r) {\n\t\tr = bytesToNumber(secp256k1.utils.randomPrivateKey());\n\t}\n\tconst rG = secp256k1.ProjectivePoint.BASE.multiply(r);\n\tconst B_ = Y.add(rG);\n\tif (privateKey !== undefined) {\n\t\treturn getSignedOutput({ B_, r, secret }, privateKey);\n\t}\n\treturn { B_, r, secret };\n}\n\nexport function unblindSignature(\n\tC_: ProjPointType<bigint>,\n\tr: bigint,\n\tA: ProjPointType<bigint>,\n): ProjPointType<bigint> {\n\tconst C = C_.subtract(A.multiply(r));\n\treturn C;\n}\n\nexport function constructProofFromPromise(\n\tpromise: BlindSignature,\n\tr: bigint,\n\tsecret: Uint8Array,\n\tkey: ProjPointType<bigint>,\n): Proof {\n\tconst A = key;\n\tconst C = unblindSignature(promise.C_, r, A);\n\tconst proof = {\n\t\tid: promise.id,\n\t\tamount: promise.amount,\n\t\tsecret,\n\t\tC,\n\t};\n\treturn proof;\n}\n\nexport const serializeProof = (proof: Proof): SerializedProof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: proof.C.toHex(true),\n\t\tid: proof.id,\n\t\tsecret: new TextDecoder().decode(proof.secret),\n\t\twitness: JSON.stringify(proof.witness),\n\t};\n};\n\nexport const deserializeProof = (proof: SerializedProof): Proof => {\n\treturn {\n\t\tamount: proof.amount,\n\t\tC: pointFromHex(proof.C),\n\t\tid: proof.id,\n\t\tsecret: new TextEncoder().encode(proof.secret),\n\t\twitness: proof.witness ? (JSON.parse(proof.witness) as Witness) : undefined,\n\t};\n};\nexport const serializeBlindedMessage = (\n\tbm: BlindedMessage,\n\tamount: number,\n): SerializedBlindedMessage => {\n\treturn {\n\t\tB_: bm.B_.toHex(true),\n\t\tamount: amount,\n\t};\n};\n"],"names":["createRandomBlindedMessage","privateKey","blindMessage","randomBytes","bytesToNumber","secp256k1","secret","r","Y","hashToCurve","rG","B_","getSignedOutput","unblindSignature","C_","A","constructProofFromPromise","promise","key","C","serializeProof","proof","deserializeProof","pointFromHex","serializeBlindedMessage","bm","amount"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAuBO,SAASA,EAA2BC,CAAAA,EAAsC;IAChF,OAAOC,MACNC,gKAAAA,EAAY,EAAE,OACdC,uKAAAA,EAAcC,kKAAAA,CAAU,KAAA,CAAM,gBAAA,EAAkB,GAChDJ;AAEF;AAEO,SAASC,EAAaI,CAAAA,EAAoBC,CAAAA,EAAYN,CAAAA,EAAsC;IAClG,MAAMO,QAAIC,sLAAAA,EAAYH,CAAM;IACvBC,KAAAA,CACJA,QAAIH,uKAAAA,EAAcC,kKAAAA,CAAU,KAAA,CAAM,gBAAA,CAAA,CAAkB,CAAA;IAErD,MAAMK,IAAKL,kKAAAA,CAAU,eAAA,CAAgB,IAAA,CAAK,QAAA,CAASE,CAAC,GAC9CI,IAAKH,EAAE,GAAA,CAAIE,CAAE;IACnB,OAAIT,MAAe,KAAA,QACXW,mMAAAA,EAAgB;QAAE,IAAAD;QAAI,GAAAJ;QAAG,QAAAD;IAAA,GAAUL,CAAU,IAE9C;QAAE,IAAAU;QAAI,GAAAJ;QAAG,QAAAD;IAAA;AACjB;AAEO,SAASO,EACfC,CAAAA,EACAP,CAAAA,EACAQ,CAAAA,EACwB;IAExB,OADUD,EAAG,QAAA,CAASC,EAAE,QAAA,CAASR,CAAC,CAAC;AAEpC;AAEO,SAASS,EACfC,CAAAA,EACAV,CAAAA,EACAD,CAAAA,EACAY,CAAAA,EACQ;IACR,MAAMH,IAAIG,GACJC,IAAIN,EAAiBI,EAAQ,EAAA,EAAIV,GAAGQ,CAAC;IAO3C,OANc;QACb,IAAIE,EAAQ,EAAA;QACZ,QAAQA,EAAQ,MAAA;QAChB,QAAAX;QACA,GAAAa;IAAA;AAGF;AAEO,MAAMC,IAAiB,CAACC,IAAAA,CACvB;QACN,QAAQA,EAAM,MAAA;QACd,GAAGA,EAAM,CAAA,CAAE,KAAA,CAAM,CAAA,CAAI;QACrB,IAAIA,EAAM,EAAA;QACV,QAAQ,IAAI,YAAA,EAAc,MAAA,CAAOA,EAAM,MAAM;QAC7C,SAAS,KAAK,SAAA,CAAUA,EAAM,OAAO;IAAA,CAAA,GAI1BC,IAAmB,CAACD,IAAAA,CACzB;QACN,QAAQA,EAAM,MAAA;QACd,OAAGE,uLAAAA,EAAaF,EAAM,CAAC;QACvB,IAAIA,EAAM,EAAA;QACV,QAAQ,IAAI,YAAA,EAAc,MAAA,CAAOA,EAAM,MAAM;QAC7C,SAASA,EAAM,OAAA,GAAW,KAAK,KAAA,CAAMA,EAAM,OAAO,IAAgB,KAAA;IAAA,CAAA,GAGvDG,IAA0B,CACtCC,GACAC,IAAAA,CAEO;QACN,IAAID,EAAG,EAAA,CAAG,KAAA,CAAM,CAAA,CAAI;QACpB,QAAAC;IAAA,CAAA","debugId":null}},
    {"offset": {"line": 1484, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@cashu/cashu-ts/lib/cashu-ts.es.js","sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/cbor.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/model/PaymentRequest.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/utils/Constants.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/utils.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/ws.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/logger.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/WSConnection.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/model/types/mint/responses.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/model/types/wallet/paymentRequests.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/model/Errors.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/request.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/legacy/nut-05.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/legacy/nut-04.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/legacy/nut-06.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/model/MintInfo.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/CashuMint.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/model/BlindedMessage.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/model/OutputData.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/CashuWallet.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/auth/CashuAuthMint.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/auth/CashuAuthWallet.ts","file:///Users/mac/Desktop/CODE/SLPM-enhanced/node_modules/%40cashu/cashu-ts/src/auth/index.ts"],"sourcesContent":["type SimpleValue = boolean | null | undefined;\n\nexport type ResultObject = { [key: string]: ResultValue };\nexport type ResultValue = SimpleValue | number | string | Uint8Array | ResultValue[] | ResultObject;\n\ntype ResultKeyType = Extract<ResultValue, number | string>;\nexport type ValidDecodedType = Extract<ResultValue, ResultObject>;\n\nfunction isResultKeyType(value: ResultValue): value is ResultKeyType {\n\treturn typeof value === 'number' || typeof value === 'string';\n}\n\ntype DecodeResult<T extends ResultValue> = {\n\tvalue: T;\n\toffset: number;\n};\n\nexport function encodeCBOR(value: unknown): Uint8Array {\n\tconst buffer: number[] = [];\n\tencodeItem(value, buffer);\n\treturn new Uint8Array(buffer);\n}\n\nfunction encodeItem(value: unknown, buffer: number[]) {\n\tif (value === null) {\n\t\tbuffer.push(0xf6);\n\t} else if (value === undefined) {\n\t\tbuffer.push(0xf7);\n\t} else if (typeof value === 'boolean') {\n\t\tbuffer.push(value ? 0xf5 : 0xf4);\n\t} else if (typeof value === 'number') {\n\t\tencodeUnsigned(value, buffer);\n\t} else if (typeof value === 'string') {\n\t\tencodeString(value, buffer);\n\t} else if (Array.isArray(value)) {\n\t\tencodeArray(value, buffer);\n\t} else if (value instanceof Uint8Array) {\n\t\tencodeByteString(value, buffer);\n\t} else if (\n\t\t// Defensive: POJO only (null/array handled above)\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t!Array.isArray(value)\n\t) {\n\t\tencodeObject(value as Record<string, unknown>, buffer);\n\t} else {\n\t\tthrow new Error('Unsupported type');\n\t}\n}\n\nfunction encodeUnsigned(value: number, buffer: number[]) {\n\tif (value < 24) {\n\t\tbuffer.push(value);\n\t} else if (value < 256) {\n\t\tbuffer.push(0x18, value);\n\t} else if (value < 65536) {\n\t\tbuffer.push(0x19, value >> 8, value & 0xff);\n\t} else if (value < 4294967296) {\n\t\tbuffer.push(0x1a, value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported integer size');\n\t}\n}\n\nfunction encodeByteString(value: Uint8Array, buffer: number[]) {\n\tconst length = value.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x40 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x58, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x59, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x5a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('Byte string too long to encode');\n\t}\n\n\tfor (let i = 0; i < value.length; i++) {\n\t\tbuffer.push(value[i]);\n\t}\n}\n\nfunction encodeString(value: string, buffer: number[]) {\n\tconst utf8 = new TextEncoder().encode(value);\n\tconst length = utf8.length;\n\n\tif (length < 24) {\n\t\tbuffer.push(0x60 + length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x78, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x79, (length >> 8) & 0xff, length & 0xff);\n\t} else if (length < 4294967296) {\n\t\tbuffer.push(\n\t\t\t0x7a,\n\t\t\t(length >> 24) & 0xff,\n\t\t\t(length >> 16) & 0xff,\n\t\t\t(length >> 8) & 0xff,\n\t\t\tlength & 0xff,\n\t\t);\n\t} else {\n\t\tthrow new Error('String too long to encode');\n\t}\n\n\tfor (let i = 0; i < utf8.length; i++) {\n\t\tbuffer.push(utf8[i]);\n\t}\n}\n\nfunction encodeArray(value: unknown[], buffer: number[]) {\n\tconst length = value.length;\n\tif (length < 24) {\n\t\tbuffer.push(0x80 | length);\n\t} else if (length < 256) {\n\t\tbuffer.push(0x98, length);\n\t} else if (length < 65536) {\n\t\tbuffer.push(0x99, length >> 8, length & 0xff);\n\t} else {\n\t\tthrow new Error('Unsupported array length');\n\t}\n\n\tfor (const item of value) {\n\t\tencodeItem(item, buffer);\n\t}\n}\n\nfunction encodeObject(value: Record<string, unknown>, buffer: number[]) {\n\tconst keys = Object.keys(value);\n\tencodeUnsigned(keys.length, buffer);\n\tbuffer[buffer.length - 1] |= 0xa0;\n\tfor (const key of keys) {\n\t\tencodeString(key, buffer);\n\t\tencodeItem(value[key], buffer);\n\t}\n}\n\nexport function decodeCBOR(data: Uint8Array): ResultValue {\n\tconst view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\tconst result = decodeItem(view, 0);\n\treturn result.value;\n}\n\nfunction decodeItem(view: DataView, offset: number): DecodeResult<ResultValue> {\n\tif (offset >= view.byteLength) {\n\t\tthrow new Error('Unexpected end of data');\n\t}\n\tconst initialByte = view.getUint8(offset++);\n\tconst majorType = initialByte >> 5;\n\tconst additionalInfo = initialByte & 0x1f;\n\n\tswitch (majorType) {\n\t\tcase 0:\n\t\t\treturn decodeUnsigned(view, offset, additionalInfo);\n\t\tcase 1:\n\t\t\treturn decodeSigned(view, offset, additionalInfo);\n\t\tcase 2:\n\t\t\treturn decodeByteString(view, offset, additionalInfo);\n\t\tcase 3:\n\t\t\treturn decodeString(view, offset, additionalInfo);\n\t\tcase 4:\n\t\t\treturn decodeArray(view, offset, additionalInfo);\n\t\tcase 5:\n\t\t\treturn decodeMap(view, offset, additionalInfo);\n\t\tcase 7:\n\t\t\treturn decodeSimpleAndFloat(view, offset, additionalInfo);\n\t\tdefault:\n\t\t\tthrow new Error(`Unsupported major type: ${majorType}`);\n\t}\n}\n\nfunction decodeLength(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tif (additionalInfo < 24) return { value: additionalInfo, offset };\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = view.getUint16(offset, false);\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getUint32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst hi = view.getUint32(offset, false);\n\t\tconst lo = view.getUint32(offset + 4, false);\n\t\toffset += 8;\n\t\treturn { value: hi * 2 ** 32 + lo, offset };\n\t}\n\tthrow new Error(`Unsupported length: ${additionalInfo}`);\n}\n\nfunction decodeUnsigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value, offset: newOffset };\n}\n\nfunction decodeSigned(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<number> {\n\tconst { value, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\treturn { value: -1 - value, offset: newOffset };\n}\n\nfunction decodeByteString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Uint8Array> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('Byte string length exceeds data length');\n\t}\n\tconst value = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeString(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<string> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tif (newOffset + length > view.byteLength) {\n\t\tthrow new Error('String length exceeds data length');\n\t}\n\tconst bytes = new Uint8Array(view.buffer, view.byteOffset + newOffset, length);\n\tconst value = new TextDecoder().decode(bytes);\n\treturn { value, offset: newOffset + length };\n}\n\nfunction decodeArray(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<ResultValue[]> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst array = [];\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst result = decodeItem(view, currentOffset);\n\t\tarray.push(result.value);\n\t\tcurrentOffset = result.offset;\n\t}\n\treturn { value: array, offset: currentOffset };\n}\n\nfunction decodeMap(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<Record<string, ResultValue>> {\n\tconst { value: length, offset: newOffset } = decodeLength(view, offset, additionalInfo);\n\tconst map: { [key: string]: ResultValue } = {};\n\tlet currentOffset = newOffset;\n\tfor (let i = 0; i < length; i++) {\n\t\tconst keyResult = decodeItem(view, currentOffset);\n\t\tif (!isResultKeyType(keyResult.value)) {\n\t\t\tthrow new Error('Invalid key type');\n\t\t}\n\t\tconst valueResult = decodeItem(view, keyResult.offset);\n\t\tmap[keyResult.value] = valueResult.value;\n\t\tcurrentOffset = valueResult.offset;\n\t}\n\treturn { value: map, offset: currentOffset };\n}\n\nfunction decodeFloat16(uint16: number): number {\n\tconst exponent = (uint16 & 0x7c00) >> 10;\n\tconst fraction = uint16 & 0x03ff;\n\tconst sign = uint16 & 0x8000 ? -1 : 1;\n\n\tif (exponent === 0) {\n\t\treturn sign * 2 ** -14 * (fraction / 1024);\n\t} else if (exponent === 0x1f) {\n\t\treturn fraction ? NaN : sign * Infinity;\n\t}\n\treturn sign * 2 ** (exponent - 15) * (1 + fraction / 1024);\n}\n\nfunction decodeSimpleAndFloat(\n\tview: DataView,\n\toffset: number,\n\tadditionalInfo: number,\n): DecodeResult<SimpleValue | number> {\n\tif (additionalInfo < 24) {\n\t\tswitch (additionalInfo) {\n\t\t\tcase 20:\n\t\t\t\treturn { value: false, offset };\n\t\t\tcase 21:\n\t\t\t\treturn { value: true, offset };\n\t\t\tcase 22:\n\t\t\t\treturn { value: null, offset };\n\t\t\tcase 23:\n\t\t\t\treturn { value: undefined, offset };\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown simple value: ${additionalInfo}`);\n\t\t}\n\t}\n\tif (additionalInfo === 24) return { value: view.getUint8(offset++), offset };\n\tif (additionalInfo === 25) {\n\t\tconst value = decodeFloat16(view.getUint16(offset, false));\n\t\toffset += 2;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 26) {\n\t\tconst value = view.getFloat32(offset, false);\n\t\toffset += 4;\n\t\treturn { value, offset };\n\t}\n\tif (additionalInfo === 27) {\n\t\tconst value = view.getFloat64(offset, false);\n\t\toffset += 8;\n\t\treturn { value, offset };\n\t}\n\tthrow new Error(`Unknown simple or float value: ${additionalInfo}`);\n}\n","import { encodeBase64toUint8 } from '../base64';\nimport { decodeCBOR, encodeCBOR } from '../cbor';\nimport {\n\ttype RawPaymentRequest,\n\ttype RawTransport,\n\ttype NUT10Option,\n\ttype PaymentRequestTransport,\n\ttype PaymentRequestTransportType,\n} from './types';\nimport { Bytes } from '../utils/Bytes';\n\nexport class PaymentRequest {\n\tconstructor(\n\t\tpublic transport?: PaymentRequestTransport[],\n\t\tpublic id?: string,\n\t\tpublic amount?: number,\n\t\tpublic unit?: string,\n\t\tpublic mints?: string[],\n\t\tpublic description?: string,\n\t\tpublic singleUse: boolean = false,\n\t\tpublic nut10?: NUT10Option,\n\t) {}\n\n\ttoRawRequest() {\n\t\tconst rawRequest: RawPaymentRequest = {};\n\t\tif (this.transport) {\n\t\t\trawRequest.t = this.transport.map((t: PaymentRequestTransport) => ({\n\t\t\t\tt: t.type,\n\t\t\t\ta: t.target,\n\t\t\t\tg: t.tags,\n\t\t\t}));\n\t\t}\n\t\tif (this.id) {\n\t\t\trawRequest.i = this.id;\n\t\t}\n\t\tif (this.amount) {\n\t\t\trawRequest.a = this.amount;\n\t\t}\n\t\tif (this.unit) {\n\t\t\trawRequest.u = this.unit;\n\t\t}\n\t\tif (this.mints) {\n\t\t\trawRequest.m = this.mints;\n\t\t}\n\t\tif (this.description) {\n\t\t\trawRequest.d = this.description;\n\t\t}\n\t\tif (this.singleUse) {\n\t\t\trawRequest.s = this.singleUse;\n\t\t}\n\t\tif (this.nut10) {\n\t\t\trawRequest.nut10 = {\n\t\t\t\tk: this.nut10.kind,\n\t\t\t\td: this.nut10.data,\n\t\t\t\tt: this.nut10.tags,\n\t\t\t};\n\t\t}\n\t\treturn rawRequest;\n\t}\n\n\ttoEncodedRequest() {\n\t\tconst rawRequest: RawPaymentRequest = this.toRawRequest();\n\t\tconst data = encodeCBOR(rawRequest);\n\t\tconst encodedData = Bytes.toBase64(data);\n\t\treturn 'creq' + 'A' + encodedData;\n\t}\n\n\tgetTransport(type: PaymentRequestTransportType) {\n\t\treturn this.transport?.find((t: PaymentRequestTransport) => t.type === type);\n\t}\n\n\tstatic fromRawRequest(rawPaymentRequest: RawPaymentRequest): PaymentRequest {\n\t\tconst transports = rawPaymentRequest.t\n\t\t\t? rawPaymentRequest.t.map((t: RawTransport) => ({\n\t\t\t\t\ttype: t.t,\n\t\t\t\t\ttarget: t.a,\n\t\t\t\t\ttags: t.g,\n\t\t\t\t}))\n\t\t\t: undefined;\n\t\tconst nut10 = rawPaymentRequest.nut10\n\t\t\t? {\n\t\t\t\t\tkind: rawPaymentRequest.nut10.k,\n\t\t\t\t\tdata: rawPaymentRequest.nut10.d,\n\t\t\t\t\ttags: rawPaymentRequest.nut10.t,\n\t\t\t\t}\n\t\t\t: undefined;\n\t\treturn new PaymentRequest(\n\t\t\ttransports,\n\t\t\trawPaymentRequest.i,\n\t\t\trawPaymentRequest.a,\n\t\t\trawPaymentRequest.u,\n\t\t\trawPaymentRequest.m,\n\t\t\trawPaymentRequest.d,\n\t\t\trawPaymentRequest.s,\n\t\t\tnut10,\n\t\t);\n\t}\n\n\tstatic fromEncodedRequest(encodedRequest: string): PaymentRequest {\n\t\tif (!encodedRequest.startsWith('creq')) {\n\t\t\tthrow new Error('unsupported pr: invalid prefix');\n\t\t}\n\t\tconst version = encodedRequest[4];\n\t\tif (version !== 'A') {\n\t\t\tthrow new Error('unsupported pr version');\n\t\t}\n\t\tconst encodedData = encodedRequest.slice(5);\n\t\tconst data = encodeBase64toUint8(encodedData);\n\t\tconst decoded = decodeCBOR(data) as RawPaymentRequest;\n\t\treturn this.fromRawRequest(decoded);\n\t}\n}\n","/**\n * Per protocol definition since tokenV3 tokens have a prefix and a version number.\n */\nconst TOKEN_VERSION = 'A';\nconst TOKEN_PREFIX = 'cashu';\n\nexport { TOKEN_VERSION, TOKEN_PREFIX };\n","import { verifyDLEQProof_reblind } from './crypto/client/NUT12';\nimport { type DLEQ, pointFromHex } from './crypto/common';\nimport { bytesToHex, hexToBytes } from '@noble/curves/abstract/utils';\nimport { sha256 } from '@noble/hashes/sha2';\nimport {\n\tencodeBase64ToJson,\n\tencodeBase64toUint8,\n\tencodeJsonToBase64,\n\tencodeUint8toBase64Url,\n\tisBase64String,\n} from './base64';\nimport { decodeCBOR, encodeCBOR } from './cbor';\nimport { PaymentRequest } from './model/PaymentRequest';\nimport type {\n\tTokenMetadata,\n\tDeprecatedToken,\n\tKeys,\n\tMintKeys,\n\tMintKeyset,\n\tProof,\n\tSerializedDLEQ,\n\tToken,\n\tTokenV4Template,\n\tV4DLEQTemplate,\n\tV4InnerToken,\n\tV4ProofTemplate,\n} from './model/types';\nimport { TOKEN_PREFIX, TOKEN_VERSION } from './utils/Constants';\nimport { Bytes } from './utils/Bytes';\n\n/**\n * Splits the amount into denominations of the provided @param keyset.\n *\n * @param value Amount to split.\n * @param keyset Keys to look up split amounts.\n * @param split? Optional custom split amounts.\n * @param order? Optional order for split amounts (default: \"asc\")\n * @returns Array of split amounts.\n * @throws Error if @param split amount is greater than @param value amount.\n */\nexport function splitAmount(\n\tvalue: number,\n\tkeyset: Keys,\n\tsplit?: number[],\n\torder?: 'desc' | 'asc',\n): number[] {\n\tif (split) {\n\t\tconst totalSplitAmount = sumArray(split);\n\n\t\t// Special case: explicit \"zero-total\" outputs (restore or NUT-08 blanks)\n\t\tif (value === 0 && totalSplitAmount === 0) {\n\t\t\treturn split;\n\t\t}\n\n\t\t// Normal positive-value paths: ignore zeros for validation and totals\n\t\tconst positive = split.filter((amt) => amt > 0);\n\t\tconst totalPositive = sumArray(positive);\n\t\tif (totalPositive > value) {\n\t\t\tthrow new Error(`Split is greater than total amount: ${totalPositive} > ${value}`);\n\t\t}\n\t\tif (positive.some((amt) => !hasCorrespondingKey(amt, keyset))) {\n\t\t\tthrow new Error('Provided amount preferences do not match the amounts of the mint keyset.');\n\t\t}\n\n\t\t// if caller supplied an exact custom split, preserve their order\n\t\tif (totalPositive === value) {\n\t\t\treturn positive;\n\t\t}\n\n\t\t// Work only with validated positive amounts from here on\n\t\tsplit = positive;\n\t\tvalue -= totalPositive;\n\t} else {\n\t\tsplit = [];\n\t}\n\n\t// Denomination fill for the remaining value\n\tconst sortedKeyAmounts = getKeysetAmounts(keyset, 'desc');\n\tif (!sortedKeyAmounts || sortedKeyAmounts.length === 0) {\n\t\tthrow new Error('Cannot split amount, keyset is inactive or contains no keys');\n\t}\n\tsortedKeyAmounts.forEach((amt: number) => {\n\t\tif (value <= 0 || amt <= 0) return;\n\t\tconst q = Math.floor(value / amt);\n\t\tfor (let i = 0; i < q; ++i) split.push(amt);\n\t\tvalue %= amt;\n\t});\n\tif (value !== 0) {\n\t\tthrow new Error(`Unable to split remaining amount: ${value}`);\n\t}\n\n\t// Only sort when we performed a fill; exact custom splits returned earlier\n\treturn split.sort((a, b) => (order === 'desc' ? b - a : a - b));\n}\n\n/**\n * Creates a list of amounts to keep based on the proofs we have and the proofs we want to reach.\n *\n * @param proofsWeHave Complete set of proofs stored (from current mint)\n * @param amountToKeep Amount to keep.\n * @param keys Keys of current keyset.\n * @param targetCount The target number of proofs to reach.\n * @returns An array of amounts to keep.\n */\nexport function getKeepAmounts(\n\tproofsWeHave: Proof[],\n\tamountToKeep: number,\n\tkeys: Keys,\n\ttargetCount: number,\n): number[] {\n\t// determines amounts we need to reach the targetCount for each amount based on the amounts of the proofs we have\n\t// it tries to select amounts so that the proofs we have and the proofs we want reach the targetCount\n\tconst amountsWeWant: number[] = [];\n\tconst amountsWeHave = proofsWeHave.map((p: Proof) => p.amount);\n\tconst sortedKeyAmounts = getKeysetAmounts(keys, 'asc');\n\tsortedKeyAmounts.forEach((amt) => {\n\t\tconst countWeHave = amountsWeHave.filter((a) => a === amt).length;\n\t\tconst countWeWant = Math.max(targetCount - countWeHave, 0);\n\t\tfor (let i = 0; i < countWeWant; ++i) {\n\t\t\tif (amountsWeWant.reduce((a, b) => a + b, 0) + amt > amountToKeep) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tamountsWeWant.push(amt);\n\t\t}\n\t});\n\t// use splitAmount to fill the rest between the sum of amountsWeHave and amountToKeep\n\tconst amountDiff = amountToKeep - amountsWeWant.reduce((a, b) => a + b, 0);\n\tif (amountDiff) {\n\t\tconst remainingAmounts = splitAmount(amountDiff, keys);\n\t\tremainingAmounts.forEach((amt: number) => {\n\t\t\tamountsWeWant.push(amt);\n\t\t});\n\t}\n\treturn amountsWeWant.sort((a, b) => a - b);\n}\n/**\n * Returns the amounts in the keyset sorted by the order specified.\n *\n * @param keyset To search in.\n * @param order Order to sort the amounts in.\n * @returns The amounts in the keyset sorted by the order specified.\n */\nexport function getKeysetAmounts(keyset: Keys, order: 'asc' | 'desc' = 'desc'): number[] {\n\tif (order == 'desc') {\n\t\treturn Object.keys(keyset)\n\t\t\t.map((k: string) => parseInt(k))\n\t\t\t.sort((a: number, b: number) => b - a);\n\t}\n\treturn Object.keys(keyset)\n\t\t.map((k: string) => parseInt(k))\n\t\t.sort((a: number, b: number) => a - b);\n}\n\n/**\n * Checks if the provided amount is in the keyset.\n *\n * @param amount Amount to check.\n * @param keyset To search in.\n * @returns True if the amount is in the keyset, false otherwise.\n */\nexport function hasCorrespondingKey(amount: number, keyset: Keys): boolean {\n\treturn amount in keyset;\n}\n\n/**\n * Converts a bytes array to a number.\n *\n * @param bytes To convert to number.\n * @returns Number.\n */\nexport function bytesToNumber(bytes: Uint8Array): bigint {\n\treturn hexToNumber(bytesToHex(bytes));\n}\n\n/**\n * Converts a hex string to a number.\n *\n * @param hex To convert to number.\n * @returns Number.\n */\nexport function hexToNumber(hex: string): bigint {\n\treturn BigInt(`0x${hex}`);\n}\n\n/**\n * Converts a number to a hex string of 64 characters.\n *\n * @param number (bigint) to conver to hex.\n * @returns Hex string start-padded to 64 characters.\n */\nexport function numberToHexPadded64(number: bigint): string {\n\treturn number.toString(16).padStart(64, '0');\n}\n\nexport function isValidHex(str: string) {\n\treturn /^[a-f0-9]*$/i.test(str);\n}\n\n/**\n * Checks wether a proof or a list of proofs contains a non-hex id.\n *\n * @param p Proof or list of proofs.\n * @returns Boolean.\n */\nexport function hasNonHexId(p: Proof | Proof[]) {\n\tif (Array.isArray(p)) {\n\t\treturn p.some((proof) => !isValidHex(proof.id));\n\t}\n\treturn !isValidHex(p.id);\n}\n\n//used for json serialization\nexport function bigIntStringify<T>(_key: unknown, value: T) {\n\treturn typeof value === 'bigint' ? value.toString() : value;\n}\n\n/**\n * Helper function to encode a v3 cashu token.\n *\n * @param token To encode.\n * @returns Encoded token.\n */\nexport function getEncodedTokenV3(token: Token, removeDleq?: boolean): string {\n\tif (!hasNonHexId(token.proofs)) {\n\t\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\t}\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\tconst v3TokenObj: DeprecatedToken = { token: [{ mint: token.mint, proofs: token.proofs }] };\n\tif (token.unit) {\n\t\tv3TokenObj.unit = token.unit;\n\t}\n\tif (token.memo) {\n\t\tv3TokenObj.memo = token.memo;\n\t}\n\treturn TOKEN_PREFIX + TOKEN_VERSION + encodeJsonToBase64(v3TokenObj);\n}\n\n/*\n * Convert a keyset ID into short form\n */\nfunction convertToShortKeysetId(proofs: Proof[]) {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tnewP.id = newP.id.slice(0, 16);\n\t\treturn newP;\n\t});\n}\n\n/**\n * Helper function to encode a cashu token (defaults to v4 if keyset id allows it)\n *\n * @param token\n * @param [opts]\n */\nexport function getEncodedToken(\n\ttoken: Token,\n\topts?: { version?: 3 | 4; removeDleq?: boolean },\n): string {\n\t// Find out if it's a base64 keyset\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex || opts?.version === 3) {\n\t\tif (opts?.version === 4) {\n\t\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t\t}\n\t\treturn getEncodedTokenV3(token, opts?.removeDleq);\n\t}\n\treturn getEncodedTokenV4(token, opts?.removeDleq);\n}\n\nexport function getEncodedTokenV4(token: Token, removeDleq?: boolean): string {\n\tif (removeDleq) {\n\t\ttoken.proofs = stripDleq(token.proofs);\n\t}\n\t// Make sure each DLEQ has its blinding factor\n\ttoken.proofs.forEach((p) => {\n\t\tif (p.dleq && p.dleq.r == undefined) {\n\t\t\tthrow new Error('Missing blinding factor in included DLEQ proof');\n\t\t}\n\t});\n\tconst nonHex = hasNonHexId(token.proofs);\n\tif (nonHex) {\n\t\tthrow new Error('can not encode to v4 token if proofs contain non-hex keyset id');\n\t}\n\t// Map keyset IDs to short IDs\n\ttoken.proofs = convertToShortKeysetId(token.proofs);\n\n\tconst tokenTemplate = templateFromToken(token);\n\n\tconst encodedData = encodeCBOR(tokenTemplate);\n\tconst prefix = 'cashu';\n\tconst version = 'B';\n\tconst base64Data = encodeUint8toBase64Url(encodedData);\n\treturn prefix + version + base64Data;\n}\n\nfunction templateFromToken(token: Token): TokenV4Template {\n\tconst idMap: { [id: string]: Proof[] } = {};\n\tconst mint = token.mint;\n\tfor (let i = 0; i < token.proofs.length; i++) {\n\t\tconst proof = token.proofs[i];\n\t\tif (idMap[proof.id]) {\n\t\t\tidMap[proof.id].push(proof);\n\t\t} else {\n\t\t\tidMap[proof.id] = [proof];\n\t\t}\n\t}\n\tconst tokenTemplate: TokenV4Template = {\n\t\tm: mint,\n\t\tu: token.unit || 'sat',\n\t\tt: Object.keys(idMap).map(\n\t\t\t(id: string): V4InnerToken => ({\n\t\t\t\ti: hexToBytes(id),\n\t\t\t\tp: idMap[id].map(\n\t\t\t\t\t(p: Proof): V4ProofTemplate => ({\n\t\t\t\t\t\ta: p.amount,\n\t\t\t\t\t\ts: p.secret,\n\t\t\t\t\t\tc: hexToBytes(p.C),\n\t\t\t\t\t\t...(p.dleq && {\n\t\t\t\t\t\t\td: {\n\t\t\t\t\t\t\t\te: hexToBytes(p.dleq.e),\n\t\t\t\t\t\t\t\ts: hexToBytes(p.dleq.s),\n\t\t\t\t\t\t\t\tr: hexToBytes(p.dleq.r ?? '00'),\n\t\t\t\t\t\t\t} as V4DLEQTemplate,\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t...(p.witness && {\n\t\t\t\t\t\t\tw: JSON.stringify(p.witness),\n\t\t\t\t\t\t}),\n\t\t\t\t\t}),\n\t\t\t\t),\n\t\t\t}),\n\t\t),\n\t} as TokenV4Template;\n\tif (token.memo) {\n\t\ttokenTemplate.d = token.memo;\n\t}\n\treturn tokenTemplate;\n}\n\nfunction tokenFromTemplate(template: TokenV4Template): Token {\n\tconst proofs: Proof[] = [];\n\ttemplate.t.forEach((t) =>\n\t\tt.p.forEach((p) => {\n\t\t\tproofs.push({\n\t\t\t\tsecret: p.s,\n\t\t\t\tC: bytesToHex(p.c),\n\t\t\t\tamount: p.a,\n\t\t\t\tid: bytesToHex(t.i),\n\t\t\t\t...(p.d && {\n\t\t\t\t\tdleq: {\n\t\t\t\t\t\tr: bytesToHex(p.d.r),\n\t\t\t\t\t\ts: bytesToHex(p.d.s),\n\t\t\t\t\t\te: bytesToHex(p.d.e),\n\t\t\t\t\t} as SerializedDLEQ,\n\t\t\t\t}),\n\t\t\t\t...(p.w && {\n\t\t\t\t\twitness: p.w,\n\t\t\t\t}),\n\t\t\t});\n\t\t}),\n\t);\n\tconst decodedToken: Token = { mint: template.m, proofs, unit: template.u || 'sat' };\n\tif (template.d) {\n\t\tdecodedToken.memo = template.d;\n\t}\n\treturn decodedToken;\n}\n\n/**\n * Helper function to decode cashu tokens into object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu token object.\n */\nexport function getDecodedToken(tokenString: string, keysets?: MintKeyset[]) {\n\ttokenString = removePrefix(tokenString);\n\n\tconst token = handleTokens(tokenString);\n\ttoken.proofs = mapShortKeysetIds(token.proofs, keysets);\n\treturn token;\n}\n\n/**\n * Returns the metadata of a cashu token.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Token metadata.\n */\nexport function getTokenMetadata(token: string): TokenMetadata {\n\ttoken = removePrefix(token);\n\tconst tokenObj = handleTokens(token);\n\treturn {\n\t\tunit: tokenObj.unit || 'sat',\n\t\tmint: tokenObj.mint,\n\t\tamount: sumProofs(tokenObj.proofs),\n\t\tincompleteProofs: tokenObj.proofs.map((p) => ({\n\t\t\tsecret: p.secret,\n\t\t\tC: p.C,\n\t\t\tamount: p.amount,\n\t\t\t...(p.dleq && {\n\t\t\t\tdleq: p.dleq,\n\t\t\t}),\n\t\t})),\n\t\t...(tokenObj.memo && { memo: tokenObj.memo }),\n\t};\n}\n\n/**\n * Helper function to decode different versions of cashu tokens into an object.\n *\n * @param token An encoded cashu token (cashuAey...)\n * @returns Cashu Token object.\n */\nexport function handleTokens(token: string): Token {\n\tconst version = token.slice(0, 1);\n\tconst encodedToken = token.slice(1);\n\tif (version === 'A') {\n\t\tconst parsedV3Token = encodeBase64ToJson<DeprecatedToken>(encodedToken);\n\t\tif (parsedV3Token.token.length > 1) {\n\t\t\tthrow new Error('Multi entry token are not supported');\n\t\t}\n\t\tconst entry = parsedV3Token.token[0];\n\t\tconst tokenObj: Token = {\n\t\t\tmint: entry.mint,\n\t\t\tproofs: entry.proofs,\n\t\t\tunit: parsedV3Token.unit || 'sat',\n\t\t};\n\t\tif (parsedV3Token.memo) {\n\t\t\ttokenObj.memo = parsedV3Token.memo;\n\t\t}\n\t\treturn tokenObj;\n\t} else if (version === 'B') {\n\t\tconst uInt8Token = encodeBase64toUint8(encodedToken);\n\t\tconst tokenData = decodeCBOR(uInt8Token) as TokenV4Template;\n\t\treturn tokenFromTemplate(tokenData);\n\t}\n\tthrow new Error('Token version is not supported');\n}\n\n/**\n * Returns the keyset id of a set of keys.\n *\n * @param keys Keys object to derive keyset id from.\n * @param unit (optional) the unit of the keyset.\n * @param expiry (optional) expiry of the keyset.\n * @param versionByte (optional) version of the keyset ID. Default is 0.\n * @param isDeprecatedBase64 (optional) true if the keyset ID should be derived as a deprecated v0\n *   base64 keyset ID.\n * @returns Keyset id of the keys.\n * @throws If keyset versionByte is not valid.\n */\nexport function deriveKeysetId(\n\tkeys: Keys,\n\tunit?: string,\n\texpiry?: number,\n\tversionByte: number = 0,\n\tisDeprecatedBase64: boolean = false,\n) {\n\tif (isDeprecatedBase64) {\n\t\tconst pubkeysConcat = Object.entries(keys)\n\t\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t\t.map(([, pubKey]: [unknown, string]) => pubKey)\n\t\t\t.reduce((prev: string, curr: string) => prev + curr, '');\n\t\tconst hash = sha256(pubkeysConcat);\n\t\tconst b64 = Bytes.toBase64(hash);\n\t\treturn b64.slice(0, 12);\n\t}\n\n\tlet pubkeysConcat = Object.entries(keys)\n\t\t.sort((a: [string, string], b: [string, string]) => +a[0] - +b[0])\n\t\t.map(([, pubKey]: [unknown, string]) => hexToBytes(pubKey))\n\t\t.reduce((prev: Uint8Array, curr: Uint8Array) => mergeUInt8Arrays(prev, curr), new Uint8Array());\n\n\tlet hash;\n\tlet hashHex;\n\tswitch (versionByte) {\n\t\tcase 0:\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash).slice(0, 14);\n\t\t\treturn '00' + hashHex;\n\t\tcase 1:\n\t\t\tif (!unit) {\n\t\t\t\tthrow new Error('Cannot compute keyset ID version 01: unit is required.');\n\t\t\t}\n\t\t\tpubkeysConcat = mergeUInt8Arrays(pubkeysConcat, Bytes.fromString('unit:' + unit));\n\t\t\tif (expiry) {\n\t\t\t\tpubkeysConcat = mergeUInt8Arrays(\n\t\t\t\t\tpubkeysConcat,\n\t\t\t\t\tBytes.fromString('final_expiry:' + expiry.toString()),\n\t\t\t\t);\n\t\t\t}\n\t\t\thash = sha256(pubkeysConcat);\n\t\t\thashHex = Bytes.toHex(hash);\n\t\t\treturn '01' + hashHex;\n\t\tdefault:\n\t\t\tthrow new Error(`Unrecognized keyset ID version: ${versionByte}`);\n\t}\n}\n\nexport function mergeUInt8Arrays(a1: Uint8Array, a2: Uint8Array): Uint8Array {\n\t// sum of individual array lengths\n\tconst mergedArray = new Uint8Array(a1.length + a2.length);\n\tmergedArray.set(a1);\n\tmergedArray.set(a2, a1.length);\n\treturn mergedArray;\n}\n\nexport function sortProofsById(proofs: Proof[]) {\n\treturn proofs.sort((a: Proof, b: Proof) => a.id.localeCompare(b.id));\n}\n\nexport function isObj(v: unknown): v is object {\n\treturn typeof v === 'object';\n}\n\nexport function checkResponse(data: { error?: string; detail?: string }) {\n\tif (!isObj(data)) return;\n\tif ('error' in data && data.error) {\n\t\tthrow new Error(data.error);\n\t}\n\tif ('detail' in data && data.detail) {\n\t\tthrow new Error(data.detail);\n\t}\n}\n\nexport function joinUrls(...parts: string[]): string {\n\treturn parts.map((part: string) => part.replace(/(^\\/+|\\/+$)/g, '')).join('/');\n}\n\nexport function sanitizeUrl(url: string): string {\n\treturn url.replace(/\\/$/, '');\n}\n\nexport function sumProofs(proofs: Proof[]) {\n\treturn proofs.reduce((acc: number, proof: Proof) => acc + proof.amount, 0);\n}\n\nexport function decodePaymentRequest(paymentRequest: string) {\n\treturn PaymentRequest.fromEncodedRequest(paymentRequest);\n}\n\nexport class MessageNode {\n\tprivate _value: string;\n\tprivate _next: MessageNode | null;\n\n\tpublic get value(): string {\n\t\treturn this._value;\n\t}\n\tpublic set value(message: string) {\n\t\tthis._value = message;\n\t}\n\tpublic get next(): MessageNode | null {\n\t\treturn this._next;\n\t}\n\tpublic set next(node: MessageNode | null) {\n\t\tthis._next = node;\n\t}\n\n\tconstructor(message: string) {\n\t\tthis._value = message;\n\t\tthis._next = null;\n\t}\n}\n\nexport class MessageQueue {\n\tprivate _first: MessageNode | null;\n\tprivate _last: MessageNode | null;\n\n\tpublic get first(): MessageNode | null {\n\t\treturn this._first;\n\t}\n\tpublic set first(messageNode: MessageNode | null) {\n\t\tthis._first = messageNode;\n\t}\n\tpublic get last(): MessageNode | null {\n\t\treturn this._last;\n\t}\n\tpublic set last(messageNode: MessageNode | null) {\n\t\tthis._last = messageNode;\n\t}\n\tprivate _size: number;\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\tpublic set size(v: number) {\n\t\tthis._size = v;\n\t}\n\n\tconstructor() {\n\t\tthis._first = null;\n\t\tthis._last = null;\n\t\tthis._size = 0;\n\t}\n\tenqueue(message: string): boolean {\n\t\tconst newNode = new MessageNode(message);\n\t\tif (this._size === 0 || !this._last) {\n\t\t\tthis._first = newNode;\n\t\t\tthis._last = newNode;\n\t\t} else {\n\t\t\tthis._last.next = newNode;\n\t\t\tthis._last = newNode;\n\t\t}\n\t\tthis._size++;\n\t\treturn true;\n\t}\n\tdequeue(): string | null {\n\t\tif (this._size === 0 || !this._first) return null;\n\n\t\tconst prev = this._first;\n\t\tthis._first = prev.next;\n\t\tprev.next = null;\n\n\t\tthis._size--;\n\t\treturn prev.value;\n\t}\n}\n/**\n * Removes all traces of DLEQs from a list of proofs.\n *\n * @param proofs The list of proofs that dleq should be stripped from.\n */\nexport function stripDleq(proofs: Proof[]): Array<Omit<Proof, 'dleq'>> {\n\treturn proofs.map((p) => {\n\t\tconst newP = { ...p };\n\t\tdelete newP['dleq'];\n\t\treturn newP;\n\t});\n}\n\n/**\n * Check that the keyset hashes to the specified ID.\n *\n * @param keys The keyset to be verified.\n * @returns True if the verification was successful, false otherwise.\n * @throws Error if the keyset ID version is unrecognized.\n */\nexport function verifyKeysetId(keys: MintKeys): boolean {\n\tconst isBase64 = isBase64String(keys.id);\n\tconst isValidHex = /^[a-fA-F0-9]+$/.test(keys.id);\n\tconst versionByte = isValidHex ? hexToBytes(keys.id)[0] : 0;\n\treturn (\n\t\tderiveKeysetId(\n\t\t\tkeys.keys,\n\t\t\tkeys.unit,\n\t\t\tkeys.final_expiry,\n\t\t\tversionByte,\n\t\t\tisBase64 && !isValidHex,\n\t\t) === keys.id\n\t);\n}\n\n/**\n * Maps the short keyset IDs stored in the token to actual keyset IDs that were fetched from the\n * Mint.\n */\nfunction mapShortKeysetIds(proofs: Proof[], keysets?: MintKeyset[]): Proof[] {\n\tconst newProofs = [];\n\tfor (const proof of proofs) {\n\t\tlet idBytes;\n\t\ttry {\n\t\t\tidBytes = hexToBytes(proof.id);\n\t\t} catch {\n\t\t\t// Base64 keysets don't need conversion\n\t\t\tnewProofs.push(proof);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idBytes[0] === 0x00) {\n\t\t\tnewProofs.push(proof);\n\t\t} else if (idBytes[0] === 0x01) {\n\t\t\tif (!keysets) {\n\t\t\t\tthrow new Error('A short keyset ID v2 was encountered, but got no keysets to map it to.');\n\t\t\t}\n\t\t\t// Look for a match: prefix(keyset ID) == short ID\n\t\t\tlet found = false;\n\t\t\tfor (const keyset of keysets) {\n\t\t\t\tif (proof.id === keyset.id.slice(0, proof.id.length)) {\n\t\t\t\t\tproof.id = keyset.id;\n\t\t\t\t\tnewProofs.push(proof);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Couldn't map short keyset ID ${proof.id} to any known keysets of the current Mint`,\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error(`Unknown keyset ID version: ${idBytes[0]}`);\n\t\t}\n\t}\n\n\treturn newProofs;\n}\n\n/**\n * Checks that the proof has a valid DLEQ proof according to keyset `keys`\n *\n * @param proof The proof subject to verification.\n * @param keyset The Mint's keyset to be used for verification.\n * @returns True if verification succeeded, false otherwise.\n * @throws Error if @param proof does not match any key in @param keyset.\n */\nexport function hasValidDleq(proof: Proof, keyset: MintKeys): boolean {\n\tif (proof.dleq == undefined) {\n\t\treturn false;\n\t}\n\tconst dleq = {\n\t\te: hexToBytes(proof.dleq.e),\n\t\ts: hexToBytes(proof.dleq.s),\n\t\tr: hexToNumber(proof.dleq.r ?? '00'),\n\t} as DLEQ;\n\tif (!hasCorrespondingKey(proof.amount, keyset.keys)) {\n\t\tthrow new Error(`undefined key for amount ${proof.amount}`);\n\t}\n\tconst key = keyset.keys[proof.amount];\n\treturn verifyDLEQProof_reblind(\n\t\tnew TextEncoder().encode(proof.secret),\n\t\tdleq,\n\t\tpointFromHex(proof.C),\n\t\tpointFromHex(key),\n\t);\n}\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nfunction concatByteArrays(...arrays: Uint8Array[]): Uint8Array {\n\tconst totalLength = arrays.reduce((a, c) => a + c.length, 0);\n\tconst byteArray = new Uint8Array(totalLength);\n\tlet pointer = 0;\n\tfor (let i = 0; i < arrays.length; i++) {\n\t\tbyteArray.set(arrays[i], pointer);\n\t\tpointer = pointer + arrays[i].length;\n\t}\n\treturn byteArray;\n}\n\nexport function getEncodedTokenBinary(token: Token): Uint8Array {\n\tconst utf8Encoder = new TextEncoder();\n\tconst template = templateFromToken(token);\n\tconst binaryTemplate = encodeCBOR(template);\n\tconst prefix = utf8Encoder.encode('craw');\n\tconst version = utf8Encoder.encode('B');\n\treturn concatByteArrays(prefix, version, binaryTemplate);\n}\n\nexport function getDecodedTokenBinary(bytes: Uint8Array): Token {\n\tconst utfDecoder = new TextDecoder();\n\tconst prefix = utfDecoder.decode(bytes.slice(0, 4));\n\tconst version = utfDecoder.decode(new Uint8Array([bytes[4]]));\n\tif (prefix !== 'craw' || version !== 'B') {\n\t\tthrow new Error('not a valid binary token');\n\t}\n\tconst binaryToken = bytes.slice(5);\n\tconst decoded = decodeCBOR(binaryToken) as TokenV4Template;\n\treturn tokenFromTemplate(decoded);\n}\n\nfunction sumArray(arr: number[]) {\n\treturn arr.reduce((a, c) => a + c, 0);\n}\n\nfunction removePrefix(token: string): string {\n\tconst uriPrefixes = ['web+cashu://', 'cashu://', 'cashu:', 'cashu'];\n\turiPrefixes.forEach((prefix: string) => {\n\t\tif (!token.startsWith(prefix)) {\n\t\t\treturn;\n\t\t}\n\t\ttoken = token.slice(prefix.length);\n\t});\n\treturn token;\n}\n","let _WS: typeof WebSocket | undefined;\n\nif (typeof WebSocket !== 'undefined') {\n\t_WS = WebSocket;\n}\n\nexport function injectWebSocketImpl(ws: typeof WebSocket) {\n\t_WS = ws;\n}\n\nexport function getWebSocketImpl() {\n\tif (_WS === undefined) {\n\t\tthrow new Error('WebSocket implementation not initialized');\n\t}\n\treturn _WS;\n}\n","/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport const LogLevel = {\n\tFATAL: 'FATAL',\n\tERROR: 'ERROR',\n\tWARN: 'WARN',\n\tINFO: 'INFO',\n\tDEBUG: 'DEBUG',\n\tTRACE: 'TRACE',\n} as const;\n\n/**\n * Defines the available log levels for the logger. Log levels are ordered from most severe (FATAL)\n * to least severe (TRACE).\n */\nexport type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];\n\nexport interface Logger {\n\tfatal(message: string, context?: Record<string, unknown>): void;\n\terror(message: string, context?: Record<string, unknown>): void;\n\twarn(message: string, context?: Record<string, unknown>): void;\n\tinfo(message: string, context?: Record<string, unknown>): void;\n\tdebug(message: string, context?: Record<string, unknown>): void;\n\ttrace(message: string, context?: Record<string, unknown>): void;\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void;\n}\n\n// The default logger implementation - does nothing\n/* eslint-disable @typescript-eslint/no-empty-function */\nexport const NULL_LOGGER: Logger = {\n\tfatal() {},\n\terror() {},\n\twarn() {},\n\tinfo() {},\n\tdebug() {},\n\ttrace() {},\n\tlog() {},\n};\n/* eslint-enable @typescript-eslint/no-empty-function */\n\n/**\n * Outputs messages to the console based on the specified log level.\n *\n * Supports placeholder substitution in messages (e.g., `{key}`) using values from the optional\n * `context` object. Context keys not used in substitution are appended to the output as additional\n * data. Each log message is prefixed with the log level in square brackets (e.g., `[INFO]`).\n *\n * @example Const logger = new ConsoleLogger(LogLevel.DEBUG); logger.info('User {username} logged\n * in', { username: 'alice', ip: '127.0.0.1' }); // Output: [INFO] User alice logged in { ip:\n * \"127.0.0.1\" }\n */\nexport class ConsoleLogger implements Logger {\n\tprivate minLevel: LogLevel;\n\tpublic static readonly SEVERITY: Record<LogLevel, number> = {\n\t\t[LogLevel.FATAL]: 0,\n\t\t[LogLevel.ERROR]: 1,\n\t\t[LogLevel.WARN]: 2,\n\t\t[LogLevel.INFO]: 3,\n\t\t[LogLevel.DEBUG]: 4,\n\t\t[LogLevel.TRACE]: 5,\n\t};\n\tconstructor(minLevel: LogLevel = LogLevel.INFO) {\n\t\tthis.minLevel = minLevel;\n\t}\n\n\tprivate logToConsole(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tif (ConsoleLogger.SEVERITY[level] > ConsoleLogger.SEVERITY[this.minLevel]) return;\n\t\tconst levelPrefix = `[${level}] `;\n\t\tlet interpolatedMessage = message;\n\t\tconst usedKeys = new Set<string>();\n\t\tif (context) {\n\t\t\tconst processedContext = Object.fromEntries(\n\t\t\t\tObject.entries(context).map(([key, value]) => [\n\t\t\t\t\tkey,\n\t\t\t\t\tvalue instanceof Error ? { message: value.message, stack: value.stack } : value,\n\t\t\t\t]),\n\t\t\t);\n\t\t\tinterpolatedMessage = message.replace(/\\{(\\w+)\\}/g, (match: string, key: string) => {\n\t\t\t\tif (key in processedContext && processedContext[key] !== undefined) {\n\t\t\t\t\tusedKeys.add(key);\n\t\t\t\t\tconst value: unknown = processedContext[key];\n\t\t\t\t\tif (typeof value === 'string') return value;\n\t\t\t\t\tif (typeof value === 'number' || typeof value === 'boolean') return value.toString();\n\t\t\t\t\tif (value == null) return '';\n\t\t\t\t\treturn JSON.stringify(value);\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tconst filteredContext = Object.fromEntries(\n\t\t\t\tObject.entries(processedContext).filter(([key]) => !usedKeys.has(key)),\n\t\t\t);\n\t\t\tconst consoleMethod = this.getConsoleMethod(level);\n\t\t\tif (Object.keys(filteredContext).length > 0) {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage, filteredContext);\n\t\t\t} else {\n\t\t\t\tconsoleMethod(levelPrefix + interpolatedMessage);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.getConsoleMethod(level)(levelPrefix + interpolatedMessage);\n\t\t}\n\t}\n\t// Note: NOT static as test suite needs to spy on the output\n\tprivate getConsoleMethod(level: LogLevel): (message: string, ...args: unknown[]) => void {\n\t\tswitch (level) {\n\t\t\tcase LogLevel.FATAL:\n\t\t\tcase LogLevel.ERROR:\n\t\t\t\treturn console.error;\n\t\t\tcase LogLevel.WARN:\n\t\t\t\treturn console.warn;\n\t\t\tcase LogLevel.INFO:\n\t\t\t\treturn console.info;\n\t\t\tcase LogLevel.DEBUG:\n\t\t\t\treturn console.debug;\n\t\t\tcase LogLevel.TRACE:\n\t\t\t\treturn console.trace;\n\t\t\tdefault:\n\t\t\t\t// We could throw, but that's a bit aggressive for a logging class\n\t\t\t\t// so just use a regular console.log()\n\t\t\t\treturn console.log;\n\t\t}\n\t}\n\t// Interface methods\n\tfatal(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.FATAL, message, context);\n\t}\n\terror(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.ERROR, message, context);\n\t}\n\twarn(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.WARN, message, context);\n\t}\n\tinfo(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.INFO, message, context);\n\t}\n\tdebug(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.DEBUG, message, context);\n\t}\n\ttrace(message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(LogLevel.TRACE, message, context);\n\t}\n\tlog(level: LogLevel, message: string, context?: Record<string, unknown>): void {\n\t\tthis.logToConsole(level, message, context);\n\t}\n}\n\n/**\n * Creates a timer to measure elapsed time in milliseconds.\n *\n * @example Const timer = measureTime(); // ... some code ... const duration = timer.elapsed();\n *\n * @returns An object with an `elapsed` method to retrieve the duration since the timer started.\n */\nexport function measureTime() {\n\tconst start = Date.now();\n\treturn {\n\t\telapsed: () => {\n\t\t\treturn Date.now() - start;\n\t\t},\n\t};\n}\n","import { MessageQueue } from './utils';\nimport { type JsonRpcMessage, type JsonRpcReqParams, type RpcSubId } from './model/types';\nimport { type OnOpenError, type OnOpenSuccess } from './model/types/wallet/websocket';\nimport { getWebSocketImpl } from './ws';\nimport { type Logger, NULL_LOGGER } from './logger';\n\n// Internal interface for RPC listeners\ninterface RpcListener {\n\tcallback: () => void;\n\terrorCallback: (e: Error) => void;\n}\n\nexport class ConnectionManager {\n\tprivate static instance: ConnectionManager;\n\tprivate connectionMap: Map<string, WSConnection> = new Map();\n\n\tstatic getInstance() {\n\t\tif (!ConnectionManager.instance) {\n\t\t\tConnectionManager.instance = new ConnectionManager();\n\t\t}\n\t\treturn ConnectionManager.instance;\n\t}\n\n\tgetConnection(url: string, logger?: Logger): WSConnection {\n\t\tif (this.connectionMap.has(url)) {\n\t\t\treturn this.connectionMap.get(url) as WSConnection;\n\t\t}\n\t\tconst newConn = new WSConnection(url, logger);\n\t\tthis.connectionMap.set(url, newConn);\n\t\treturn newConn;\n\t}\n}\n\nexport class WSConnection {\n\tpublic readonly url: URL;\n\tprivate readonly _WS: typeof WebSocket;\n\tprivate ws: WebSocket | undefined;\n\tprivate connectionPromise: Promise<void> | undefined;\n\tprivate subListeners: { [subId: string]: Array<(payload: unknown) => void> } = {};\n\tprivate rpcListeners: { [rpcSubId: string]: RpcListener } = {};\n\tprivate messageQueue: MessageQueue;\n\tprivate handlingInterval?: number;\n\tprivate rpcId = 0;\n\tprivate _logger: Logger;\n\tprivate onCloseCallbacks: Array<(e: CloseEvent) => void> = [];\n\n\tconstructor(url: string, logger?: Logger) {\n\t\tthis._WS = getWebSocketImpl();\n\t\tthis.url = new URL(url);\n\t\tthis.messageQueue = new MessageQueue();\n\t\tthis._logger = logger ?? NULL_LOGGER;\n\t}\n\n\tconnect() {\n\t\tif (!this.connectionPromise) {\n\t\t\tthis.connectionPromise = new Promise((resolve: OnOpenSuccess, reject: OnOpenError) => {\n\t\t\t\ttry {\n\t\t\t\t\tthis.ws = new this._WS(this.url.toString());\n\t\t\t\t\tthis.onCloseCallbacks = [];\n\t\t\t\t} catch (err: unknown) {\n\t\t\t\t\treject(err instanceof Error ? err : new Error(String(err)));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.ws.onopen = () => {\n\t\t\t\t\tresolve();\n\t\t\t\t};\n\t\t\t\tthis.ws.onerror = () => {\n\t\t\t\t\treject(new Error('Failed to open WebSocket'));\n\t\t\t\t};\n\t\t\t\tthis.ws.onmessage = (e: MessageEvent) => {\n\t\t\t\t\tthis.messageQueue.enqueue(e.data as string);\n\t\t\t\t\tif (!this.handlingInterval) {\n\t\t\t\t\t\tthis.handlingInterval = setInterval(\n\t\t\t\t\t\t\tthis.handleNextMessage.bind(this),\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t) as unknown as number;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.ws.onclose = (e: CloseEvent) => {\n\t\t\t\t\tthis.connectionPromise = undefined;\n\t\t\t\t\tthis.onCloseCallbacks.forEach((cb) => cb(e));\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn this.connectionPromise;\n\t}\n\n\tsendRequest(method: 'subscribe', params: JsonRpcReqParams): void;\n\tsendRequest(method: 'unsubscribe', params: { subId: string }): void;\n\tsendRequest(method: 'subscribe' | 'unsubscribe', params: Partial<JsonRpcReqParams>) {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tif (method === 'unsubscribe') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._logger.error('Attempted sendRequest, but socket was not open');\n\t\t\tthrow new Error('Socket not open');\n\t\t}\n\t\tconst id = this.rpcId;\n\t\tthis.rpcId++;\n\t\tconst message = JSON.stringify({ jsonrpc: '2.0', method, params, id });\n\t\tthis.ws?.send(message);\n\t}\n\n\t/**\n\t * @deprecated Use cancelSubscription for JSONRPC compliance.\n\t */\n\tcloseSubscription(subId: string) {\n\t\tthis.ws?.send(JSON.stringify(['CLOSE', subId]));\n\t}\n\n\taddSubListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\t(this.subListeners[subId] = this.subListeners[subId] || []).push(\n\t\t\tcallback as (payload: unknown) => void,\n\t\t);\n\t}\n\n\tprivate addRpcListener(\n\t\tcallback: () => void,\n\t\terrorCallback: (e: Error) => void,\n\t\tid: Exclude<RpcSubId, null>,\n\t) {\n\t\tthis.rpcListeners[id] = { callback, errorCallback };\n\t}\n\n\tprivate removeRpcListener(id: Exclude<RpcSubId, null>) {\n\t\tdelete this.rpcListeners[id];\n\t}\n\n\tprivate removeListener<TPayload = unknown>(subId: string, callback: (payload: TPayload) => void) {\n\t\tif (!this.subListeners[subId]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.subListeners[subId].length === 1) {\n\t\t\tdelete this.subListeners[subId];\n\t\t\treturn;\n\t\t}\n\t\tthis.subListeners[subId] = this.subListeners[subId].filter(\n\t\t\t(fn) => fn !== (callback as (payload: unknown) => void),\n\t\t);\n\t}\n\n\tasync ensureConnection() {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tawait this.connect();\n\t\t}\n\t}\n\n\tprivate handleNextMessage() {\n\t\tif (this.messageQueue.size === 0) {\n\t\t\tclearInterval(this.handlingInterval);\n\t\t\tthis.handlingInterval = undefined;\n\t\t\treturn;\n\t\t}\n\t\tconst message = this.messageQueue.dequeue() as string;\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(message) as JsonRpcMessage;\n\t\t\tif ('result' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].callback();\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('error' in parsed && parsed.id != undefined) {\n\t\t\t\tif (this.rpcListeners[parsed.id]) {\n\t\t\t\t\tthis.rpcListeners[parsed.id].errorCallback(new Error(parsed.error.message));\n\t\t\t\t\tthis.removeRpcListener(parsed.id);\n\t\t\t\t}\n\t\t\t} else if ('method' in parsed) {\n\t\t\t\tif ('id' in parsed) {\n\t\t\t\t\t// Do nothing as mints should not send requests\n\t\t\t\t} else {\n\t\t\t\t\tconst subId = parsed.params?.subId;\n\t\t\t\t\tif (!subId) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (this.subListeners[subId]?.length > 0) {\n\t\t\t\t\t\tconst notification = parsed;\n\t\t\t\t\t\tthis.subListeners[subId].forEach((cb) => cb(notification.params?.payload));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tthis._logger.error('Error doing handleNextMessage', { e });\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcreateSubscription<TPayload = unknown>(\n\t\tparams: Omit<JsonRpcReqParams, 'subId'>,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): string {\n\t\tif (this.ws?.readyState !== 1) {\n\t\t\tthis._logger.error('Attempted createSubscription, but socket was not open');\n\t\t\tthrow new Error('Socket is not open');\n\t\t}\n\t\tconst subId = (Math.random() + 1).toString(36).substring(7);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis.addSubListener(subId, callback);\n\t\t\t},\n\t\t\terrorCallback,\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('subscribe', { ...params, subId });\n\t\tthis.rpcId++;\n\t\treturn subId;\n\t}\n\n\t/**\n\t * Cancels a subscription, sending an unsubscribe request and handling responses.\n\t *\n\t * @param subId The subscription ID to cancel.\n\t * @param callback The original payload callback to remove.\n\t * @param errorCallback Optional callback for unsubscribe errors (defaults to logging).\n\t */\n\tcancelSubscription<TPayload = unknown>(\n\t\tsubId: string,\n\t\tcallback: (payload: TPayload) => void,\n\t\terrorCallback?: (e: Error) => void,\n\t) {\n\t\tthis.removeListener(subId, callback);\n\t\tthis.addRpcListener(\n\t\t\t() => {\n\t\t\t\tthis._logger.info('Unsubscribed {subId}', { subId });\n\t\t\t},\n\t\t\terrorCallback || ((e: Error) => this._logger.error('Unsubscribe failed', { e })),\n\t\t\tthis.rpcId,\n\t\t);\n\t\tthis.sendRequest('unsubscribe', { subId });\n\t}\n\n\tget activeSubscriptions() {\n\t\treturn Object.keys(this.subListeners);\n\t}\n\n\tclose() {\n\t\tif (this.ws) {\n\t\t\tthis.ws?.close();\n\t\t}\n\t}\n\n\tonClose(callback: (e: CloseEvent) => void) {\n\t\tthis.onCloseCallbacks.push(callback);\n\t}\n}\n","import { type SerializedBlindedMessage } from '../wallet';\n\n/**\n * Cashu api error.\n */\nexport type ApiError = {\n\t/**\n\t * Error message.\n\t */\n\terror?: string;\n\t/**\n\t * HTTP error code.\n\t */\n\tcode?: number;\n\t/**\n\t * Detailed error message.\n\t */\n\tdetail?: string;\n};\n\n/**\n * Entries of CheckStateResponse with state of the proof.\n */\nexport type ProofState = {\n\tY: string;\n\tstate: CheckStateEnum;\n\twitness: string | null;\n};\n\n/**\n * Enum for the state of a proof.\n */\nexport const CheckStateEnum = {\n\tUNSPENT: 'UNSPENT',\n\tPENDING: 'PENDING',\n\tSPENT: 'SPENT',\n} as const;\nexport type CheckStateEnum = (typeof CheckStateEnum)[keyof typeof CheckStateEnum];\n\n/**\n * Response when checking proofs if they are spendable. Should not rely on this for receiving, since\n * it can be easily cheated.\n */\nexport type CheckStateResponse = {\n\tstates: ProofState[];\n} & ApiError;\n\n/**\n * Response from mint at /info endpoint.\n */\nexport type GetInfoResponse = {\n\tname: string;\n\tpubkey: string;\n\tversion: string;\n\tdescription?: string;\n\tdescription_long?: string;\n\ticon_url?: string;\n\tcontact: MintContactInfo[];\n\tnuts: {\n\t\t'4': {\n\t\t\t// Minting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'5': {\n\t\t\t// Melting\n\t\t\tmethods: SwapMethod[];\n\t\t\tdisabled: boolean;\n\t\t};\n\t\t'7'?: {\n\t\t\t// Token state check\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'8'?: {\n\t\t\t// Overpaid melt fees\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'9'?: {\n\t\t\t// Restore\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'10'?: {\n\t\t\t// Spending conditions\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'11'?: {\n\t\t\t// P2PK\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'12'?: {\n\t\t\t// DLEQ\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'14'?: {\n\t\t\t// HTLCs\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'15'?: {\n\t\t\t// MPP\n\t\t\tmethods: MPPMethod[];\n\t\t};\n\t\t'17'?: {\n\t\t\t// WebSockets\n\t\t\tsupported: WebSocketSupport[];\n\t\t};\n\t\t'20'?: {\n\t\t\t// Locked Mint Quote\n\t\t\tsupported: boolean;\n\t\t};\n\t\t'22'?: {\n\t\t\t// Blind Authentication\n\t\t\tbat_max_mint: number;\n\t\t\tprotected_endpoints: Array<{ method: 'GET' | 'POST'; path: string }>;\n\t\t};\n\t};\n\tmotd?: string;\n};\n\n/**\n * Response from the mint after requesting a melt quote.\n */\nexport type PartialMeltQuoteResponse = {\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * Amount to be melted.\n\t */\n\tamount: number;\n\t/**\n\t * Fee reserve to be added to the amount.\n\t */\n\tfee_reserve: number;\n\t/**\n\t * State of the melt quote.\n\t */\n\tstate: MeltQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Preimage of the paid invoice. is null if it the invoice has not been paid yet. can be null,\n\t * depending on which LN-backend the mint uses.\n\t */\n\tpayment_preimage: string | null;\n\t/**\n\t * Return/Change from overpaid fees. This happens due to Lighting fee estimation being inaccurate.\n\t */\n\tchange?: SerializedBlindedSignature[];\n\t/**\n\t * Payment request for the melt quote.\n\t */\n\trequest?: string;\n\t/**\n\t * Unit of the melt quote.\n\t */\n\tunit?: string;\n} & ApiError;\n\nexport type MeltQuoteResponse = PartialMeltQuoteResponse & { request: string; unit: string };\n\n/**\n * Response from the mint after requesting a BOLT12 melt quote. Contains payment details and state\n * for paying Lightning Network offers.\n */\nexport type Bolt12MeltQuoteResponse = MeltQuoteResponse;\n\nexport const MeltQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPENDING: 'PENDING',\n\tPAID: 'PAID',\n} as const;\nexport type MeltQuoteState = (typeof MeltQuoteState)[keyof typeof MeltQuoteState];\n\nexport type MintContactInfo = {\n\tmethod: string;\n\tinfo: string;\n};\n\nexport const MintQuoteState = {\n\tUNPAID: 'UNPAID',\n\tPAID: 'PAID',\n\tISSUED: 'ISSUED',\n} as const;\nexport type MintQuoteState = (typeof MintQuoteState)[keyof typeof MintQuoteState];\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type PartialMintQuoteResponse = {\n\t/**\n\t * Payment request.\n\t */\n\trequest: string;\n\t/**\n\t * Quote ID.\n\t */\n\tquote: string;\n\t/**\n\t * State of the mint quote.\n\t */\n\tstate: MintQuoteState;\n\t/**\n\t * Timestamp of when the quote expires.\n\t */\n\texpiry: number;\n\t/**\n\t * Public key the quote is locked to.\n\t */\n\tpubkey?: string;\n\t/**\n\t * Unit of the quote.\n\t */\n\tunit?: string;\n\t/**\n\t * Amount requested for mint quote.\n\t */\n\tamount?: number;\n} & ApiError;\n\nexport type MintQuoteResponse = PartialMintQuoteResponse & { amount: number; unit: string };\n\nexport type LockedMintQuoteResponse = MintQuoteResponse & { pubkey: string };\n\n/**\n * Response from the mint after requesting a BOLT12 mint quote. Contains a Lightning Network offer\n * and tracks payment/issuance amounts.\n */\nexport type Bolt12MintQuoteResponse = {\n\t/**\n\t * Quote identifier.\n\t */\n\tquote: string;\n\t/**\n\t * BOLT12 offer that can be paid to mint tokens.\n\t */\n\trequest: string;\n\t/**\n\t * Requested amount. This is null for amount-less offers.\n\t */\n\tamount: number | null;\n\t/**\n\t * Unit of the amount.\n\t */\n\tunit: string;\n\t/**\n\t * Unix timestamp when quote expires.\n\t */\n\texpiry: number | null;\n\t/**\n\t * Public key that locked this quote.\n\t */\n\tpubkey: string;\n\t/**\n\t * The amount that has been paid to the mint via the bolt12 offer. The difference between this and\n\t * `amount_issued` can be minted.\n\t */\n\tamount_paid: number;\n\t/**\n\t * The amount of ecash that has been issued for the given mint quote.\n\t */\n\tamount_issued: number;\n};\n\n/**\n * Response from the mint after requesting a mint.\n */\nexport type MintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * Response from mint at /v1/restore endpoint.\n */\nexport type PostRestoreResponse = {\n\toutputs: SerializedBlindedMessage[];\n\tsignatures: SerializedBlindedSignature[];\n};\n\n/*\n * Zero-Knowledge that BlindedSignature\n * was generated using a specific public key\n */\nexport type SerializedDLEQ = {\n\ts: string;\n\te: string;\n\tr?: string;\n};\n\n/**\n * Blinded signature as it is received from the mint.\n */\nexport type SerializedBlindedSignature = {\n\t/**\n\t * Keyset id for indicating which public key was used to sign the blinded message.\n\t */\n\tid: string;\n\t/**\n\t * Amount denominated in Satoshi.\n\t */\n\tamount: number;\n\t/**\n\t * Blinded signature.\n\t */\n\tC_: string;\n\t/**\n\t * DLEQ Proof.\n\t */\n\tdleq?: SerializedDLEQ;\n};\n\n/**\n * Ecash to other MoE swap method, displayed in @type {GetInfoResponse}\n */\nexport type SwapMethod = {\n\tmethod: string;\n\tunit: string;\n\tmin_amount: number;\n\tmax_amount: number;\n\toptions?: {\n\t\tdescription?: boolean;\n\t};\n};\n\n/**\n * Response from the mint after performing a split action.\n */\nexport type SwapResponse = {\n\t/**\n\t * Represents the outputs after the split.\n\t */\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n\n/**\n * MPP supported methods.\n */\nexport type MPPMethod = {\n\tmethod: string;\n\tunit: string;\n};\n\n/**\n * WebSocket supported methods.\n */\nexport type WebSocketSupport = {\n\tmethod: string;\n\tunit: string;\n\tcommands: string[];\n};\n\n/**\n * Response from the mint after blind auth minting.\n */\nexport type BlindAuthMintResponse = {\n\tsignatures: SerializedBlindedSignature[];\n} & ApiError;\n","import { type Proof } from './index';\n\nexport type RawTransport = {\n\tt: PaymentRequestTransportType; // type\n\ta: string; // target\n\tg?: string[][]; // tags\n};\n\nexport type RawNUT10Option = {\n\tk: string; // kind\n\td: string; // data\n\tt: string[][]; // tags\n};\n\nexport type RawPaymentRequest = {\n\ti?: string; // id\n\ta?: number; // amount\n\tu?: string; // unit\n\ts?: boolean; // single use\n\tm?: string[]; // mints\n\td?: string; // description\n\tt?: RawTransport[]; // transports\n\tnut10?: RawNUT10Option;\n};\n\nexport type PaymentRequestTransport = {\n\ttype: PaymentRequestTransportType;\n\ttarget: string;\n\ttags?: string[][];\n};\n\nexport enum PaymentRequestTransportType {\n\tPOST = 'post',\n\tNOSTR = 'nostr',\n}\n\nexport type PaymentRequestPayload = {\n\tid?: string;\n\tmemo?: string;\n\tunit: string;\n\tmint: string;\n\tproofs: Proof[];\n};\n\n/**\n * Used to express a spending condition that proofs should be encumbered with.\n */\nexport type NUT10Option = {\n\t/**\n\t * The kind of spending condition.\n\t */\n\tkind: string;\n\t/**\n\t * Expresses the spending condition relative to the kind.\n\t */\n\tdata: string;\n\t/**\n\t * Tags associated with the spending condition for additional data.\n\t */\n\ttags: string[][];\n};\n","/**\n * This error is thrown when a HTTP response is not 2XX nor a protocol error.\n */\nexport class HttpResponseError extends Error {\n\tstatus: number;\n\tconstructor(message: string, status: number) {\n\t\tsuper(message);\n\t\tthis.status = status;\n\t\tthis.name = 'HttpResponseError';\n\t\tObject.setPrototypeOf(this, HttpResponseError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a network request fails.\n */\nexport class NetworkError extends Error {\n\tconstructor(message: string) {\n\t\tsuper(message);\n\t\tthis.name = 'NetworkError';\n\t\tObject.setPrototypeOf(this, NetworkError.prototype);\n\t}\n}\n\n/**\n * This error is thrown when a [protocol\n * error](https://github.com/cashubtc/nuts/blob/main/00.md#errors) occurs. See error codes\n * [here](https://github.com/cashubtc/nuts/blob/main/error_codes.md).\n */\nexport class MintOperationError extends HttpResponseError {\n\tcode: number;\n\tconstructor(code: number, detail: string) {\n\t\tsuper(detail || 'Unknown mint operation error', 400);\n\t\tthis.code = code;\n\t\tthis.name = 'MintOperationError';\n\t\tObject.setPrototypeOf(this, MintOperationError.prototype);\n\t}\n}\n","import { HttpResponseError, NetworkError, MintOperationError } from './model/Errors';\nimport { type Logger, NULL_LOGGER } from './logger';\nimport { type ApiError } from './model/types/mint/responses';\n\ntype RequestArgs = {\n\tendpoint: string;\n\trequestBody?: Record<string, unknown>;\n\theaders?: Record<string, string>;\n};\n\ntype RequestOptions = RequestArgs & Omit<RequestInit, 'body' | 'headers'>;\n\nlet globalRequestOptions: Partial<RequestOptions> = {};\nlet requestLogger = NULL_LOGGER;\n\n/**\n * An object containing any custom settings that you want to apply to the global fetch method.\n *\n * @param options See possible options here:\n *   https://developer.mozilla.org/en-US/docs/Web/API/fetch#options.\n */\nexport function setGlobalRequestOptions(options: Partial<RequestOptions>): void {\n\tglobalRequestOptions = options;\n}\n\n/**\n * Allows a logger to be set.\n *\n * @param {Logger} logger The logger instance to use.\n */\nexport function setRequestLogger(logger: Logger): void {\n\trequestLogger = logger;\n}\n\nasync function _request({\n\tendpoint,\n\trequestBody,\n\theaders: requestHeaders,\n\t...options\n}: RequestOptions): Promise<unknown> {\n\tconst body = requestBody ? JSON.stringify(requestBody) : undefined;\n\tconst headers = {\n\t\t...{ Accept: 'application/json, text/plain, */*' },\n\t\t...(body ? { 'Content-Type': 'application/json' } : undefined),\n\t\t...requestHeaders,\n\t};\n\n\tlet response: Response;\n\ttry {\n\t\tresponse = await fetch(endpoint, { body, headers, ...options });\n\t} catch (err) {\n\t\t// A fetch() promise only rejects when the request fails,\n\t\t// for example, because of a badly-formed request URL or a network error.\n\t\tthrow new NetworkError(err instanceof Error ? err.message : 'Network request failed');\n\t}\n\n\tif (!response.ok) {\n\t\tlet errorData: ApiError;\n\t\ttry {\n\t\t\terrorData = (await response.json()) as ApiError;\n\t\t} catch {\n\t\t\terrorData = { error: 'bad response' };\n\t\t}\n\n\t\tif (\n\t\t\tresponse.status === 400 &&\n\t\t\t'code' in errorData &&\n\t\t\ttypeof errorData.code === 'number' &&\n\t\t\t'detail' in errorData &&\n\t\t\ttypeof errorData.detail === 'string'\n\t\t) {\n\t\t\tthrow new MintOperationError(errorData.code, errorData.detail);\n\t\t}\n\n\t\tlet errorMessage = 'HTTP request failed';\n\t\tif ('error' in errorData && typeof errorData.error === 'string') {\n\t\t\terrorMessage = errorData.error;\n\t\t} else if ('detail' in errorData && typeof errorData.detail === 'string') {\n\t\t\terrorMessage = errorData.detail;\n\t\t}\n\n\t\tthrow new HttpResponseError(errorMessage, response.status);\n\t}\n\n\ttry {\n\t\treturn await response.json();\n\t} catch (err) {\n\t\trequestLogger.error('Failed to parse HTTP response', { err });\n\t\tthrow new HttpResponseError('bad response', response.status);\n\t}\n}\n\nexport default async function request<T>(options: RequestOptions): Promise<T> {\n\tconst data = await _request({ ...options, ...globalRequestOptions });\n\treturn data as T;\n}\n","import type { PartialMeltQuoteResponse } from '../model/types/index';\nimport { MeltQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MeltQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMeltQuoteResponseDeprecated(\n\tresponse: PartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMeltQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MeltQuoteResponse. Update NUT-05 of mint: https://github.com/cashubtc/nuts/pull/136)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MeltQuoteState.PAID : MeltQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { PartialMintQuoteResponse } from '../model/types/index';\nimport { MintQuoteState } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport type MintQuoteResponsePaidDeprecated = {\n\tpaid?: boolean;\n};\n\nexport function handleMintQuoteResponseDeprecated(\n\tresponse: PartialMintQuoteResponse & MintQuoteResponsePaidDeprecated,\n\tlogger: Logger,\n): PartialMintQuoteResponse {\n\t// if the response MeltQuoteResponse has a \"paid\" flag, we monkey patch it to the state enum\n\tif (!response.state) {\n\t\tlogger.warn(\n\t\t\t\"Field 'state' not found in MintQuoteResponse. Update NUT-04 of mint: https://github.com/cashubtc/nuts/pull/141)\",\n\t\t);\n\t\tif (typeof response.paid === 'boolean') {\n\t\t\tresponse.state = response.paid ? MintQuoteState.PAID : MintQuoteState.UNPAID;\n\t\t}\n\t}\n\treturn response;\n}\n","import type { MintContactInfo, GetInfoResponse } from '../model/types/index';\nimport type { Logger } from '../logger';\n\nexport function handleMintInfoContactFieldDeprecated(data: GetInfoResponse, logger: Logger) {\n\t// Monkey patch old contact field [\"email\", \"me@mail.com\"] Array<[string, string]>; to new contact field [{method: \"email\", info: \"me@mail.com\"}] Array<MintContactInfo>\n\t// This is to maintain backwards compatibility with older versions of the mint\n\tif (Array.isArray(data?.contact) && data?.contact.length > 0) {\n\t\tdata.contact = data.contact.map((contact: MintContactInfo) => {\n\t\t\tif (\n\t\t\t\tArray.isArray(contact) &&\n\t\t\t\tcontact.length === 2 &&\n\t\t\t\ttypeof contact[0] === 'string' &&\n\t\t\t\ttypeof contact[1] === 'string'\n\t\t\t) {\n\t\t\t\tlogger.warn(\n\t\t\t\t\t`Mint returned deprecated 'contact' field: Update NUT-06: https://github.com/cashubtc/nuts/pull/117`,\n\t\t\t\t);\n\t\t\t\treturn { method: contact[0], info: contact[1] } as MintContactInfo;\n\t\t\t}\n\t\t\treturn contact;\n\t\t});\n\t}\n\treturn data;\n}\n","import {\n\ttype GetInfoResponse,\n\ttype MPPMethod,\n\ttype SwapMethod,\n\ttype WebSocketSupport,\n} from './types';\n\nexport class MintInfo {\n\tprivate readonly _mintInfo: GetInfoResponse;\n\tprivate readonly _protectedEnpoints?: {\n\t\tcache: {\n\t\t\t[url: string]: boolean;\n\t\t};\n\t\tapiReturn: Array<{ method: 'GET' | 'POST'; regex: RegExp; cachedValue?: boolean }>;\n\t};\n\n\tconstructor(info: GetInfoResponse) {\n\t\tthis._mintInfo = info;\n\t\tif (info.nuts[22]) {\n\t\t\tthis._protectedEnpoints = {\n\t\t\t\tcache: {},\n\t\t\t\tapiReturn: info.nuts[22].protected_endpoints.map((o) => ({\n\t\t\t\t\tmethod: o.method,\n\t\t\t\t\tregex: new RegExp(o.path),\n\t\t\t\t})),\n\t\t\t};\n\t\t}\n\t}\n\n\tisSupported(num: 4 | 5): { disabled: boolean; params: SwapMethod[] };\n\tisSupported(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20): { supported: boolean };\n\tisSupported(num: 17): { supported: boolean; params?: WebSocketSupport[] };\n\tisSupported(num: 15): { supported: boolean; params?: MPPMethod[] };\n\tisSupported(num: number) {\n\t\tswitch (num) {\n\t\t\tcase 4:\n\t\t\tcase 5: {\n\t\t\t\treturn this.checkMintMelt(num);\n\t\t\t}\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\tcase 14:\n\t\t\tcase 20: {\n\t\t\t\treturn this.checkGenericNut(num);\n\t\t\t}\n\t\t\tcase 17: {\n\t\t\t\treturn this.checkNut17();\n\t\t\t}\n\t\t\tcase 15: {\n\t\t\t\treturn this.checkNut15();\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('nut is not supported by cashu-ts');\n\t\t\t}\n\t\t}\n\t}\n\n\trequiresBlindAuthToken(path: string) {\n\t\tif (!this._protectedEnpoints) {\n\t\t\treturn false;\n\t\t}\n\t\tif (typeof this._protectedEnpoints.cache[path] === 'boolean') {\n\t\t\treturn this._protectedEnpoints.cache[path];\n\t\t}\n\t\tconst isProtectedEndpoint = this._protectedEnpoints.apiReturn.some((e) => e.regex.test(path));\n\t\tthis._protectedEnpoints.cache[path] = isProtectedEndpoint;\n\t\treturn isProtectedEndpoint;\n\t}\n\n\tprivate checkGenericNut(num: 7 | 8 | 9 | 10 | 11 | 12 | 14 | 20) {\n\t\tif (this._mintInfo.nuts[num]?.supported) {\n\t\t\treturn { supported: true };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkMintMelt(num: 4 | 5) {\n\t\tconst mintMeltInfo = this._mintInfo.nuts[num];\n\t\tif (mintMeltInfo && mintMeltInfo.methods.length > 0 && !mintMeltInfo.disabled) {\n\t\t\treturn { disabled: false, params: mintMeltInfo.methods };\n\t\t}\n\t\treturn { disabled: true, params: mintMeltInfo.methods };\n\t}\n\tprivate checkNut17() {\n\t\tif (this._mintInfo.nuts[17] && this._mintInfo.nuts[17].supported.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[17].supported };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\tprivate checkNut15() {\n\t\tif (this._mintInfo.nuts[15] && this._mintInfo.nuts[15].methods.length > 0) {\n\t\t\treturn { supported: true, params: this._mintInfo.nuts[15].methods };\n\t\t}\n\t\treturn { supported: false };\n\t}\n\n\tget contact() {\n\t\treturn this._mintInfo.contact;\n\t}\n\n\tget description() {\n\t\treturn this._mintInfo.description;\n\t}\n\n\tget description_long() {\n\t\treturn this._mintInfo.description_long;\n\t}\n\n\tget name() {\n\t\treturn this._mintInfo.name;\n\t}\n\n\tget pubkey() {\n\t\treturn this._mintInfo.pubkey;\n\t}\n\n\tget nuts() {\n\t\treturn this._mintInfo.nuts;\n\t}\n\n\tget version() {\n\t\treturn this._mintInfo.version;\n\t}\n\n\tget motd() {\n\t\treturn this._mintInfo.motd;\n\t}\n\n\t/**\n\t * Checks if the mint supports creating BOLT12 offers with a description.\n\t *\n\t * @returns True if the mint supports offers with a description, false otherwise.\n\t */\n\tget supportsBolt12Description() {\n\t\treturn this._mintInfo.nuts[4]?.methods.some(\n\t\t\t(method) => method.method === 'bolt12' && method.options?.description === true,\n\t\t);\n\t}\n}\n","import { ConnectionManager, type WSConnection } from './WSConnection';\nimport type {\n\tCheckStatePayload,\n\tCheckStateResponse,\n\tGetInfoResponse,\n\tMeltPayload,\n\tMintActiveKeys,\n\tMintAllKeysets,\n\tPostRestoreResponse,\n\tSerializedBlindedMessage,\n\tSwapPayload,\n\tSwapResponse,\n\tMintQuotePayload,\n\tMintPayload,\n\tMintResponse,\n\tPostRestorePayload,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tBolt12MintQuotePayload,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n} from './model/types/index';\nimport { MeltQuoteState } from './model/types/index';\nimport request, { setRequestLogger } from './request';\nimport { isObj, joinUrls, sanitizeUrl } from './utils';\nimport {\n\ttype MeltQuoteResponsePaidDeprecated,\n\thandleMeltQuoteResponseDeprecated,\n} from './legacy/nut-05';\nimport {\n\ttype MintQuoteResponsePaidDeprecated,\n\thandleMintQuoteResponseDeprecated,\n} from './legacy/nut-04';\nimport { handleMintInfoContactFieldDeprecated } from './legacy/nut-06';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER } from './logger';\n\n/**\n * Class represents Cashu Mint API. This class contains Lower level functions that are implemented\n * by CashuWallet.\n */\nclass CashuMint {\n\tprivate ws?: WSConnection;\n\tprivate _mintInfo?: MintInfo;\n\tprivate _authTokenGetter?: () => Promise<string>;\n\tprivate _checkNut22 = false;\n\tprivate _logger: Logger;\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t * @param [authTokenGetter] A function that is called by the CashuMint instance to obtain a NUT-22\n\t *   BlindedAuthToken (e.g. from a database or localstorage)\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t\tauthTokenGetter?: () => Promise<string>,\n\t\toptions?: {\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t\tif (authTokenGetter) {\n\t\t\tthis._checkNut22 = true;\n\t\t\tthis._authTokenGetter = authTokenGetter;\n\t\t}\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\t\tsetRequestLogger(this._logger);\n\t}\n\n\t//TODO: v3 - refactor CashuMint to take two or less args.\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t */\n\tpublic static async getInfo(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t\tlogger?: Logger,\n\t): Promise<GetInfoResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst response = await requestInstance<GetInfoResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/info'),\n\t\t});\n\t\tconst data = handleMintInfoContactFieldDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Fetches mints info at the /info endpoint.\n\t */\n\tasync getInfo(): Promise<GetInfoResponse> {\n\t\treturn CashuMint.getInfo(this._mintUrl, this._customRequest, this._logger);\n\t}\n\n\tasync getLazyMintInfo(): Promise<MintInfo> {\n\t\tif (this._mintInfo) {\n\t\t\treturn this._mintInfo;\n\t\t}\n\t\tconst data = await CashuMint.getInfo(this._mintUrl, this._customRequest);\n\t\tthis._mintInfo = new MintInfo(data);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param mintUrl\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @param customRequest\n\t * @returns Signed outputs.\n\t */\n\tpublic static async swap(\n\t\tmintUrl: string,\n\t\tswapPayload: SwapPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<SwapResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<SwapResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/swap'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: swapPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error(data.detail ?? 'bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Performs a swap operation with ecash inputs and outputs.\n\t *\n\t * @param swapPayload Payload containing inputs and outputs.\n\t * @returns Signed outputs.\n\t */\n\tasync swap(swapPayload: SwapPayload): Promise<SwapResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/swap');\n\t\treturn CashuMint.swap(this._mintUrl, swapPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @param customRequest\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tpublic static async createMintQuote(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: MintQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Requests a new mint quote from the mint.\n\t *\n\t * @param mintQuotePayload Payload for creating a new mint quote.\n\t * @returns The mint will create and return a new mint quote containing a payment request for the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(mintQuotePayload: MintQuotePayload): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/quote/bolt11');\n\t\treturn CashuMint.createMintQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmintQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tpublic static async createMintQuoteBolt12(\n\t\tmintUrl: string,\n\t\tmintQuotePayload: Bolt12MintQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MintQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 mint quote from the mint using Lightning Network offers.\n\t *\n\t * @param mintQuotePayload Payload containing amount, unit, optional description, and required\n\t *   pubkey.\n\t * @returns A mint quote containing a BOLT12 offer.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tmintQuotePayload: Bolt12MintQuotePayload,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/quote/bolt12');\n\t\treturn CashuMint.createMintQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tmintQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @param customRequest\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tpublic static async checkMintQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMintQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMintQuoteResponse & MintQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMintQuoteResponseDeprecated(response, mintLogger);\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/mint/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMintQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tpublic static async checkMintQuoteBolt12(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MintQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/quote/bolt12', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID to check.\n\t * @returns Updated quote with current payment and issuance amounts.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/mint/quote/bolt12/${quote}`);\n\t\treturn CashuMint.checkMintQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tquote,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: MintPayload) {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/bolt11');\n\t\treturn CashuMint.mint(this._mintUrl, mintPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tpublic static async mintBolt12(\n\t\tmintUrl: string,\n\t\tmintPayload: MintPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<MintResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<MintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/mint/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Mints new tokens using a BOLT12 quote by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the quote ID and outputs to get blind signatures on.\n\t * @returns Serialized blinded signatures for the requested outputs.\n\t */\n\tasync mintBolt12(mintPayload: MintPayload): Promise<MintResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/mint/bolt12');\n\t\treturn CashuMint.mintBolt12(this._mintUrl, mintPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param mintUrl\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tpublic static async createMeltQuote(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<\n\t\t\tPartialMeltQuoteResponse & MeltQuoteResponsePaidDeprecated\n\t\t>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string'\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests a new melt quote from the mint.\n\t *\n\t * @param MeltQuotePayload\n\t * @returns\n\t */\n\tasync createMeltQuote(meltQuotePayload: MeltQuotePayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/quote/bolt11');\n\t\treturn CashuMint.createMeltQuote(\n\t\t\tthis._mintUrl,\n\t\t\tmeltQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tpublic static async createMeltQuoteBolt12(\n\t\tmintUrl: string,\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MeltQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltQuotePayload,\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Requests a new BOLT12 melt quote from the mint for paying a Lightning Network offer. For\n\t * amount-less offers, specify the amount in options.amountless.amount_msat.\n\t *\n\t * @param meltQuotePayload Payload containing the BOLT12 offer to pay and unit.\n\t * @returns Melt quote with amount, fee reserve, and payment state.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\tmeltQuotePayload: MeltQuotePayload,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/quote/bolt12');\n\t\treturn CashuMint.createMeltQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tmeltQuotePayload,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param mintUrl\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tpublic static async checkMeltQuote(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt11', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.amount !== 'number' ||\n\t\t\ttypeof data?.fee_reserve !== 'number' ||\n\t\t\ttypeof data?.quote !== 'string' ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Gets an existing melt quote.\n\t *\n\t * @param quote Quote ID.\n\t * @returns\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/melt/quote/bolt11/${quote}`);\n\t\treturn CashuMint.checkMeltQuote(this._mintUrl, quote, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param quote Quote ID to check.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tpublic static async checkMeltQuoteBolt12(\n\t\tmintUrl: string,\n\t\tquote: string,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<Bolt12MeltQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/quote/bolt12', quote),\n\t\t\tmethod: 'GET',\n\t\t\theaders,\n\t\t});\n\t\treturn response;\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 melt quote from the mint. Returns current payment state (UNPAID,\n\t * PENDING, or PAID) and payment preimage if paid.\n\t *\n\t * @param quote Quote ID to check.\n\t * @returns Updated quote with current payment state and preimage if available.\n\t */\n\tasync checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth(`/v1/melt/quote/bolt12/${quote}`);\n\t\treturn CashuMint.checkMeltQuoteBolt12(\n\t\t\tthis._mintUrl,\n\t\t\tquote,\n\t\t\tthis._customRequest,\n\t\t\tblindAuthToken,\n\t\t);\n\t}\n\n\t/**\n\t * Requests the mint to pay for a Bolt11 payment request by providing ecash as inputs to be spent.\n\t * The inputs contain the amount and the fee_reserves for a Lightning payment. The payload can\n\t * also contain blank outputs in order to receive back overpaid Lightning fees.\n\t *\n\t * @param mintUrl\n\t * @param meltPayload\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async melt(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t\tlogger?: Logger,\n\t): Promise<PartialMeltQuoteResponse> {\n\t\tconst mintLogger = logger ?? NULL_LOGGER;\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst response = await requestInstance<MeltQuoteResponse & MeltQuoteResponsePaidDeprecated>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt11'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tconst data = handleMeltQuoteResponseDeprecated(response, mintLogger);\n\n\t\tif (\n\t\t\t!isObj(data) ||\n\t\t\ttypeof data?.state !== 'string' ||\n\t\t\t!Object.values(MeltQuoteState).includes(data.state)\n\t\t) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Ask mint to perform a melt operation. This pays a lightning invoice and destroys tokens\n\t * matching its amount + fees.\n\t *\n\t * @param meltPayload\n\t * @returns\n\t */\n\tasync melt(meltPayload: MeltPayload): Promise<PartialMeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/bolt11');\n\t\treturn CashuMint.melt(this._mintUrl, meltPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param mintUrl The mint's base URL.\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @param customRequest Optional custom request implementation.\n\t * @param blindAuthToken Optional authentication token for NUT-22.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tpublic static async meltBolt12(\n\t\tmintUrl: string,\n\t\tmeltPayload: MeltPayload,\n\t\tcustomRequest?: typeof request,\n\t\tblindAuthToken?: string,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers: Record<string, string> = blindAuthToken ? { 'Blind-auth': blindAuthToken } : {};\n\t\tconst data = await requestInstance<Bolt12MeltQuoteResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/melt/bolt12'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: meltPayload,\n\t\t\theaders,\n\t\t});\n\t\treturn data;\n\t}\n\n\t/**\n\t * Requests the mint to pay a BOLT12 offer by providing ecash inputs to be spent. The inputs must\n\t * cover the amount plus fee reserves. Optional outputs can be included to receive change for\n\t * overpaid Lightning fees.\n\t *\n\t * @param meltPayload Payload containing quote ID, inputs, and optional outputs for change.\n\t * @returns Payment result with state and optional change signatures.\n\t */\n\tasync meltBolt12(meltPayload: MeltPayload): Promise<Bolt12MeltQuoteResponse> {\n\t\tconst blindAuthToken = await this.handleBlindAuth('/v1/melt/bolt12');\n\t\treturn CashuMint.meltBolt12(this._mintUrl, meltPayload, this._customRequest, blindAuthToken);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param mintUrl\n\t * @param checkPayload\n\t * @param customRequest\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tpublic static async check(\n\t\tmintUrl: string,\n\t\tcheckPayload: CheckStatePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<CheckStateResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<CheckStateResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/checkstate'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: checkPayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.states)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\t// backwards compatibility for base64 encoded keyset ids\n\t\tif (keysetId) {\n\t\t\t// make the keysetId url safe\n\t\t\tkeysetId = keysetId.replace(/\\//g, '_').replace(/\\+/g, '-');\n\t\t}\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId ? joinUrls(mintUrl, '/v1/keys', keysetId) : joinUrls(mintUrl, '/v1/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({ endpoint: joinUrls(mintUrl, '/v1/keysets') });\n\t}\n\n\t/**\n\t * Get the mints keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n\n\t/**\n\t * Checks if specific proofs have already been redeemed.\n\t *\n\t * @param checkPayload\n\t * @returns Redeemed and unredeemed ordered list of booleans.\n\t */\n\tasync check(checkPayload: CheckStatePayload): Promise<CheckStateResponse> {\n\t\treturn CashuMint.check(this._mintUrl, checkPayload, this._customRequest);\n\t}\n\n\tpublic static async restore(\n\t\tmintUrl: string,\n\t\trestorePayload: PostRestorePayload,\n\t\tcustomRequest?: typeof request,\n\t): Promise<PostRestoreResponse> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<PostRestoreResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/restore'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: restorePayload,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.outputs) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tasync restore(restorePayload: {\n\t\toutputs: SerializedBlindedMessage[];\n\t}): Promise<PostRestoreResponse> {\n\t\treturn CashuMint.restore(this._mintUrl, restorePayload, this._customRequest);\n\t}\n\n\t/**\n\t * Tries to establish a websocket connection with the websocket mint url according to NUT-17.\n\t */\n\tasync connectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tawait this.ws.ensureConnection();\n\t\t} else {\n\t\t\tconst mintUrl = new URL(this._mintUrl);\n\t\t\tconst wsSegment = 'v1/ws';\n\t\t\tif (mintUrl.pathname) {\n\t\t\t\tif (mintUrl.pathname.endsWith('/')) {\n\t\t\t\t\tmintUrl.pathname += wsSegment;\n\t\t\t\t} else {\n\t\t\t\t\tmintUrl.pathname += '/' + wsSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.ws = ConnectionManager.getInstance().getConnection(\n\t\t\t\t`${mintUrl.protocol === 'https:' ? 'wss' : 'ws'}://${mintUrl.host}${mintUrl.pathname}`,\n\t\t\t);\n\t\t\ttry {\n\t\t\t\tawait this.ws.connect();\n\t\t\t} catch (e) {\n\t\t\t\tthis._logger.error('Failed to connect to WebSocket...', { e });\n\t\t\t\tthrow new Error('Failed to connect to WebSocket...');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Closes a websocket connection.\n\t */\n\tdisconnectWebSocket() {\n\t\tif (this.ws) {\n\t\t\tthis.ws.close();\n\t\t}\n\t}\n\n\tget webSocketConnection() {\n\t\treturn this.ws;\n\t}\n\n\tasync handleBlindAuth(path: string) {\n\t\tif (!this._checkNut22) {\n\t\t\treturn;\n\t\t}\n\t\tconst info = await this.getLazyMintInfo();\n\t\tif (info.requiresBlindAuthToken(path)) {\n\t\t\tif (!this._authTokenGetter) {\n\t\t\t\tthrow new Error('Can not call a protected endpoint without authProofGetter');\n\t\t\t}\n\t\t\treturn this._authTokenGetter();\n\t\t}\n\t\treturn undefined;\n\t}\n}\n\nexport { CashuMint };\n","import { type SerializedBlindedMessage } from './types/index';\nimport { type ProjPointType } from '@noble/curves/abstract/weierstrass';\n\nclass BlindedMessage {\n\tamount: number;\n\tB_: ProjPointType<bigint>;\n\tid: string;\n\tconstructor(amount: number, B_: ProjPointType<bigint>, id: string) {\n\t\tthis.amount = amount;\n\t\tthis.B_ = B_;\n\t\tthis.id = id;\n\t}\n\tgetSerializedBlindedMessage(): SerializedBlindedMessage {\n\t\treturn { amount: this.amount, B_: this.B_.toHex(true), id: this.id };\n\t}\n}\nexport { BlindedMessage };\n","import {\n\ttype MintKeys,\n\ttype Proof,\n\ttype SerializedBlindedMessage,\n\ttype SerializedBlindedSignature,\n\ttype SerializedDLEQ,\n} from './types';\nimport { blindMessage, constructProofFromPromise, serializeProof } from '../crypto/client/index';\nimport { BlindedMessage } from './BlindedMessage';\nimport { bytesToHex, hexToBytes, randomBytes } from '@noble/hashes/utils';\nimport { type DLEQ, pointFromHex } from '../crypto/common/index';\nimport { bytesToNumber, numberToHexPadded64, splitAmount } from '../utils';\nimport { deriveBlindingFactor, deriveSecret } from '../crypto/client/NUT09';\n\nexport interface OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\ttoProof: (signature: SerializedBlindedSignature, keyset: MintKeys) => Proof;\n}\n\nexport type OutputDataFactory = (amount: number, keys: MintKeys) => OutputDataLike;\n\nexport function isOutputDataFactory(\n\tvalue: OutputData[] | OutputDataFactory,\n): value is OutputDataFactory {\n\treturn typeof value === 'function';\n}\n\nconst RESERVED_P2PK_TAGS = new Set(['locktime', 'pubkeys', 'n_sigs', 'refund', 'n_sigs_refund']);\nconst MAX_SECRET_LENGTH = 1024;\n\nexport class OutputData implements OutputDataLike {\n\tblindedMessage: SerializedBlindedMessage;\n\tblindingFactor: bigint;\n\tsecret: Uint8Array;\n\n\tconstructor(blindedMessage: SerializedBlindedMessage, blidingFactor: bigint, secret: Uint8Array) {\n\t\tthis.secret = secret;\n\t\tthis.blindingFactor = blidingFactor;\n\t\tthis.blindedMessage = blindedMessage;\n\t}\n\n\ttoProof(sig: SerializedBlindedSignature, keyset: MintKeys) {\n\t\tlet dleq: DLEQ | undefined;\n\t\tif (sig.dleq) {\n\t\t\tdleq = {\n\t\t\t\ts: hexToBytes(sig.dleq.s),\n\t\t\t\te: hexToBytes(sig.dleq.e),\n\t\t\t\tr: this.blindingFactor,\n\t\t\t};\n\t\t}\n\t\tconst blindSignature = {\n\t\t\tid: sig.id,\n\t\t\tamount: sig.amount,\n\t\t\tC_: pointFromHex(sig.C_),\n\t\t\tdleq: dleq,\n\t\t};\n\t\tconst A = pointFromHex(keyset.keys[sig.amount]);\n\t\tconst proof = constructProofFromPromise(blindSignature, this.blindingFactor, this.secret, A);\n\t\tconst serializedProof = {\n\t\t\t...serializeProof(proof),\n\t\t\t...(dleq && {\n\t\t\t\tdleq: {\n\t\t\t\t\ts: bytesToHex(dleq.s),\n\t\t\t\t\te: bytesToHex(dleq.e),\n\t\t\t\t\tr: numberToHexPadded64(dleq.r ?? BigInt(0)),\n\t\t\t\t} as SerializedDLEQ,\n\t\t\t}),\n\t\t} as Proof;\n\t\treturn serializedProof;\n\t}\n\n\tstatic createP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleP2PKData(p2pk, a, keyset.id));\n\t}\n\n\tstatic createSingleP2PKData(\n\t\tp2pk: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t\tamount: number,\n\t\tkeysetId: string,\n\t) {\n\t\t// normalise keys and clamp required signature counts to available keys\n\t\tconst lockKeys: string[] = Array.isArray(p2pk.pubkey) ? p2pk.pubkey : [p2pk.pubkey];\n\t\tconst refundKeys: string[] = p2pk.refundKeys ?? [];\n\t\tconst reqLock = Math.max(1, Math.min(p2pk.requiredSignatures ?? 1, lockKeys.length));\n\t\tconst reqRefund = Math.max(\n\t\t\t1,\n\t\t\tMath.min(p2pk.requiredRefundSignatures ?? 1, refundKeys.length || 1),\n\t\t);\n\n\t\t// Init vars\n\t\tconst data = lockKeys[0];\n\t\tconst pubkeys = lockKeys.slice(1);\n\t\tconst refund = refundKeys;\n\n\t\t// build P2PK Tags (NUT-11)\n\t\tconst tags: string[][] = [];\n\n\t\tconst ts = p2pk.locktime ?? NaN;\n\t\tif (Number.isSafeInteger(ts) && ts >= 0) {\n\t\t\ttags.push(['locktime', String(ts)]);\n\t\t}\n\n\t\tif (pubkeys.length > 0) {\n\t\t\ttags.push(['pubkeys', ...pubkeys]);\n\t\t\tif (reqLock > 1) {\n\t\t\t\ttags.push(['n_sigs', String(reqLock)]);\n\t\t\t}\n\t\t}\n\n\t\tif (refund.length > 0) {\n\t\t\ttags.push(['refund', ...refund]);\n\t\t\tif (reqRefund > 1) {\n\t\t\t\ttags.push(['n_sigs_refund', String(reqRefund)]);\n\t\t\t}\n\t\t}\n\n\t\t// Append additional tags if any\n\t\tif (p2pk.additionalTags?.length) {\n\t\t\tconst normalized = p2pk.additionalTags.map(([k, ...vals], i) => {\n\t\t\t\tif (typeof k !== 'string' || !k) {\n\t\t\t\t\tthrow new Error(`additionalTags[${i}][0] must be a non empty string`);\n\t\t\t\t}\n\t\t\t\tif (RESERVED_P2PK_TAGS.has(k)) {\n\t\t\t\t\tthrow new Error(`additionalTags must not use reserved key \"${k}\"`);\n\t\t\t\t}\n\t\t\t\treturn [k, ...vals.map(String)]; // all to strings\n\t\t\t});\n\t\t\ttags.push(...normalized);\n\t\t}\n\n\t\t// Construct secret\n\t\tconst newSecret: [string, { nonce: string; data: string; tags: string[][] }] = [\n\t\t\t'P2PK',\n\t\t\t{\n\t\t\t\tnonce: bytesToHex(randomBytes(32)),\n\t\t\t\tdata: data,\n\t\t\t\ttags,\n\t\t\t},\n\t\t];\n\t\tconst parsed = JSON.stringify(newSecret);\n\n\t\t// Check secret length, counting Unicode code points\n\t\t// Same semantics as Nutshell python: len(str)\n\t\tconst charCount = [...parsed].length;\n\t\tif (charCount > MAX_SECRET_LENGTH) {\n\t\t\tthrow new Error(`Secret too long (${charCount} characters), maximum is ${MAX_SECRET_LENGTH}`);\n\t\t}\n\t\t// blind the message\n\t\tconst secretBytes = new TextEncoder().encode(parsed);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\n\t\t// create OutputData\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createRandomData(amount: number, keyset: MintKeys, customSplit?: number[]) {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a) => this.createSingleRandomData(a, keyset.id));\n\t}\n\n\tstatic createSingleRandomData(amount: number, keysetId: string) {\n\t\tconst randomHex = bytesToHex(randomBytes(32));\n\t\tconst secretBytes = new TextEncoder().encode(randomHex);\n\t\tconst { r, B_ } = blindMessage(secretBytes);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tsecretBytes,\n\t\t);\n\t}\n\n\tstatic createDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeyset: MintKeys,\n\t\tcustomSplit?: number[],\n\t): OutputData[] {\n\t\tconst amounts = splitAmount(amount, keyset.keys, customSplit);\n\t\treturn amounts.map((a, i) =>\n\t\t\tthis.createSingleDeterministicData(a, seed, counter + i, keyset.id),\n\t\t);\n\t}\n\n\tstatic createSingleDeterministicData(\n\t\tamount: number,\n\t\tseed: Uint8Array,\n\t\tcounter: number,\n\t\tkeysetId: string,\n\t) {\n\t\tconst secretBytes = deriveSecret(seed, keysetId, counter);\n\t\tconst secretBytesAsHex = bytesToHex(secretBytes);\n\t\tconst utf8SecretBytes = new TextEncoder().encode(secretBytesAsHex);\n\t\tconst deterministicR = bytesToNumber(deriveBlindingFactor(seed, keysetId, counter));\n\t\tconst { r, B_ } = blindMessage(utf8SecretBytes, deterministicR);\n\t\treturn new OutputData(\n\t\t\tnew BlindedMessage(amount, B_, keysetId).getSerializedBlindedMessage(),\n\t\t\tr,\n\t\t\tutf8SecretBytes,\n\t\t);\n\t}\n}\n","import { signP2PKProofs } from './crypto/client/NUT11';\nimport { hashToCurve } from './crypto/common/index';\nimport { type CashuMint } from './CashuMint';\nimport { MintInfo } from './model/MintInfo';\nimport { type Logger, NULL_LOGGER, measureTime } from './logger';\nimport type {\n\tGetInfoResponse,\n\tMeltProofOptions,\n\tMintProofOptions,\n\tMintQuoteResponse,\n\tOutputAmounts,\n\tProofState,\n\tReceiveOptions,\n\tRestoreOptions,\n\tSendOptions,\n\tSerializedBlindedSignature,\n\tSwapOptions,\n\tMeltPayload,\n\tMeltProofsResponse,\n\tMeltQuotePayload,\n\tMeltQuoteResponse,\n\tMintKeys,\n\tMintKeyset,\n\tMintPayload,\n\tMintQuotePayload,\n\tProof,\n\tSendResponse,\n\tToken,\n\tMPPOption,\n\tMeltQuoteOptions,\n\tSwapTransaction,\n\tLockedMintQuoteResponse,\n\tPartialMintQuoteResponse,\n\tPartialMeltQuoteResponse,\n\tBolt12MintQuotePayload,\n\tBolt12MintQuoteResponse,\n\tBolt12MeltQuoteResponse,\n} from './model/types/index';\nimport { MintQuoteState, MeltQuoteState } from './model/types/index';\nimport { type SubscriptionCanceller } from './model/types/wallet/websocket';\nimport {\n\tgetDecodedToken,\n\tgetKeepAmounts,\n\thasValidDleq,\n\tisValidHex,\n\tsplitAmount,\n\tstripDleq,\n\tsumProofs,\n\tverifyKeysetId,\n} from './utils';\nimport { signMintQuote } from './crypto/client/NUT20';\nimport {\n\tOutputData,\n\ttype OutputDataFactory,\n\ttype OutputDataLike,\n\tisOutputDataFactory,\n} from './model/OutputData';\n\n/**\n * The default number of proofs per denomination to keep in a wallet.\n */\nconst DEFAULT_DENOMINATION_TARGET = 3;\n\n/**\n * The default unit for the wallet, if not specified in constructor.\n */\nconst DEFAULT_UNIT = 'sat';\n\n/**\n * Class that represents a Cashu wallet. This class should act as the entry point for this library.\n */\nclass CashuWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _seed: Uint8Array | undefined = undefined;\n\tprivate _unit = DEFAULT_UNIT;\n\tprivate _mintInfo: MintInfo | undefined = undefined;\n\tprivate _denominationTarget = DEFAULT_DENOMINATION_TARGET;\n\tprivate _keepFactory: OutputDataFactory | undefined;\n\tprivate _logger: Logger;\n\n\tmint: CashuMint;\n\n\t/**\n\t * @param mint Cashu mint instance is used to make api calls.\n\t * @param options.unit Optionally set unit (default is 'sat')\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t * @param options.mintInfo Mint info from the mint (will be fetched from mint if not provided)\n\t * @param options.denominationTarget Target number proofs per denomination (default: see @constant\n\t *   DEFAULT_DENOMINATION_TARGET)\n\t * @param options.bip39seed BIP39 seed for deterministic secrets.\n\t * @param options.keepFactory A function that will be used by all parts of the library that\n\t *   produce proofs to be kept (change, etc.). This can lead to poor performance, in which case\n\t *   the seed should be directly provided.\n\t */\n\tconstructor(\n\t\tmint: CashuMint,\n\t\toptions?: {\n\t\t\tunit?: string;\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t\tmintInfo?: GetInfoResponse;\n\t\t\tbip39seed?: Uint8Array;\n\t\t\tdenominationTarget?: number;\n\t\t\tkeepFactory?: OutputDataFactory;\n\t\t\tlogger?: Logger;\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tthis._logger = options?.logger ?? NULL_LOGGER;\n\n\t\t// When we decide to stop v2 support we should push the warming to console.\n\t\t// Inform consumers that there is a new v3 and they should upgrade.\n\t\t// Keep this log lightweight and safe to run in browser and node environments\n\t\t// if (typeof console !== 'undefined' && typeof console.warn === 'function') {\n\t\t// \tconsole.warn(\n\t\t// \t\t'cashu-ts v3 has been released. Please upgrade to access the latest features. v2 is now in minimal maintenance mode.',\n\t\t// \t);\n\t\t// }\n\t\tthis._logger.warn(\n\t\t\t'cashu-ts v3 has been released. Please upgrade to access the latest features. v2 is now in minimal maintenance mode.',\n\t\t);\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.unit) this._unit = options?.unit;\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t\tif (options?.mintInfo) this._mintInfo = new MintInfo(options.mintInfo);\n\t\tif (options?.denominationTarget) {\n\t\t\tthis._denominationTarget = options.denominationTarget;\n\t\t}\n\n\t\tif (options?.bip39seed) {\n\t\t\tif (options.bip39seed instanceof Uint8Array) {\n\t\t\t\tthis._seed = options.bip39seed;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('bip39seed must be a valid UInt8Array');\n\t\t}\n\t\tif (options?.keepFactory) {\n\t\t\tthis._keepFactory = options.keepFactory;\n\t\t}\n\t}\n\n\tget unit(): string {\n\t\treturn this._unit;\n\t}\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\tget mintInfo(): MintInfo {\n\t\tif (!this._mintInfo) {\n\t\t\tthrow new Error('Mint info not loaded');\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get information about the mint.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync getMintInfo(): Promise<MintInfo> {\n\t\tconst infoRes = await this.mint.getInfo();\n\t\tthis._mintInfo = new MintInfo(infoRes);\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Get stored information about the mint or request it if not loaded.\n\t *\n\t * @returns Mint info.\n\t */\n\tasync lazyGetMintInfo(): Promise<MintInfo> {\n\t\tif (!this._mintInfo) {\n\t\t\treturn await this.getMintInfo();\n\t\t}\n\t\treturn this._mintInfo;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait Promise.all([\n\t\t\tthis.getMintInfo(),\n\t\t\tthis.getKeys(), // NB: also runs getKeySets()\n\t\t]);\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active && k.unit === this._unit);\n\n\t\t// Only consider keysets that are hex\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => isValidHex(k.id));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tkeysets.keysets.forEach((k) => {\n\t\t\tif (!verifyKeysetId(k)) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${k.id}`);\n\t\t\t}\n\t\t});\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tif (!verifyKeysetId(keys.keysets[0])) {\n\t\t\t\tthrow new Error(`Couldn't verify keyset ID ${keys.keysets[0].id}`);\n\t\t\t}\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the\n\t * first token in the token array)\n\t *\n\t * @param {string | Token} token - Cashu token, either as string or decoded.\n\t * @param {ReceiveOptions} [options] - Optional configuration for token processing.\n\t * @returns New token with newly created proofs, token entries that had errors.\n\t */\n\tasync receive(token: string | Token, options?: ReceiveOptions): Promise<Proof[]> {\n\t\tconst { requireDleq, keysetId, outputAmounts, counter, pubkey, privkey, outputData, p2pk } =\n\t\t\toptions || {};\n\n\t\t// Fetch the keysets if we don't have them\n\t\tif (this._keysets.length === 0) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\tif (typeof token === 'string') {\n\t\t\ttoken = getDecodedToken(token, this._keysets);\n\t\t}\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (requireDleq) {\n\t\t\tif (token.proofs.some((p: Proof) => !hasValidDleq(p, keys))) {\n\t\t\t\tthrow new Error('Token contains proofs with invalid DLEQ');\n\t\t\t}\n\t\t}\n\t\tconst amount = sumProofs(token.proofs) - this.getFeesForProofs(token.proofs);\n\t\tlet newOutputData: { send: OutputDataLike[] | OutputDataFactory } | undefined = undefined;\n\t\tif (outputData) {\n\t\t\tnewOutputData = { send: outputData };\n\t\t} else if (this._keepFactory) {\n\t\t\tnewOutputData = { send: this._keepFactory };\n\t\t}\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamount,\n\t\t\ttoken.proofs,\n\t\t\tkeys,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\tnewOutputData,\n\t\t\tp2pk,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst proofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keys));\n\t\tconst orderedProofs: Proof[] = [];\n\t\tswapTransaction.sortedIndices.forEach((s, o) => {\n\t\t\torderedProofs[s] = proofs[o];\n\t\t});\n\t\treturn orderedProofs;\n\t}\n\n\t/**\n\t * Send proofs of a given amount, by providing at least the required amount of proofs.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofs Array of proofs (accumulated amount of proofs must be >= than amount)\n\t * @param {SendOptions} [options] - Optional parameters for configuring the send operation.\n\t * @returns {SendResponse}\n\t */\n\tasync send(amount: number, proofs: Proof[], options?: SendOptions): Promise<SendResponse> {\n\t\tconst {\n\t\t\toffline,\n\t\t\tincludeFees,\n\t\t\tincludeDleq,\n\t\t\tkeysetId,\n\t\t\toutputAmounts,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\toutputData,\n\t\t} = options || {};\n\t\tif (includeDleq) {\n\t\t\tproofs = proofs.filter((p: Proof) => p.dleq != undefined);\n\t\t}\n\t\tif (sumProofs(proofs) < amount) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\t\tconst { keep: keepProofsOffline, send: sendProofOffline } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamount,\n\t\t\toptions?.includeFees,\n\t\t);\n\t\tconst expectedFee = includeFees ? this.getFeesForProofs(sendProofOffline) : 0;\n\t\tif (\n\t\t\t!offline &&\n\t\t\t(sumProofs(sendProofOffline) != amount + expectedFee || // if the exact amount cannot be selected\n\t\t\t\toutputAmounts ||\n\t\t\t\tpubkey ||\n\t\t\t\tprivkey ||\n\t\t\t\tkeysetId ||\n\t\t\t\toutputData) // these options require a swap\n\t\t) {\n\t\t\tconst sendRes = await this.swap(amount, proofs, options);\n\t\t\tconst { keep, send } = sendRes;\n\t\t\tconst serialized = sendRes.serialized;\n\n\t\t\treturn { keep, send, serialized };\n\t\t}\n\n\t\tif (sumProofs(sendProofOffline) < amount + expectedFee) {\n\t\t\tthrow new Error('Not enough funds available to send');\n\t\t}\n\n\t\treturn { keep: keepProofsOffline, send: sendProofOffline };\n\t}\n\n\t/**\n\t * Selects proofs to send based on amount and fee inclusion.\n\t *\n\t * @remarks\n\t * Uses an adapted Randomized Greedy with Local Improvement (RGLI) algorithm, which has a time\n\t * complexity O(n log n) and space complexity O(n).\n\t * @param proofs Array of Proof objects available to select from.\n\t * @param amountToSend The target amount to send.\n\t * @param includeFees Optional boolean to include fees; Default: false.\n\t * @returns SendResponse containing proofs to keep and proofs to send.\n\t * @see https://crypto.ethz.ch/publications/files/Przyda02.pdf\n\t */\n\tselectProofsToSend(proofs: Proof[], amountToSend: number, includeFees = false): SendResponse {\n\t\t// Init vars\n\t\tconst MAX_TRIALS = 60; // 40-80 is optimal (per RGLI paper)\n\t\tconst MAX_OVRPCT = 0; // Acceptable close match overage (percent)\n\t\tconst MAX_OVRAMT = 0; // Acceptable close match overage (absolute)\n\t\tconst MAX_TIMEMS = 1000; // Halt new trials if over time (in ms)\n\t\tconst MAX_P2SWAP = 5000; // Max number of Phase 2 improvement swaps\n\t\tconst exactMatch = false; // Allows close match (> amountToSend + fee)\n\t\tconst timer = measureTime(); // start the clock\n\t\tlet bestSubset: ProofWithFee[] | null = null;\n\t\tlet bestDelta = Infinity;\n\t\tlet bestAmount = 0;\n\t\tlet bestFeePPK = 0;\n\n\t\t/**\n\t\t * Helper Functions.\n\t\t */\n\t\tinterface ProofWithFee {\n\t\t\tproof: Proof;\n\t\t\texFee: number;\n\t\t\tppkfee: number;\n\t\t}\n\t\t// Calculate net amount after fees\n\t\tconst sumExFees = (amount: number, feePPK: number): number => {\n\t\t\treturn amount - (includeFees ? Math.ceil(feePPK / 1000) : 0);\n\t\t};\n\t\t// Shuffle array for randomization\n\t\tconst shuffleArray = <T>(array: T[]): T[] => {\n\t\t\tconst shuffled = [...array];\n\t\t\tfor (let i = shuffled.length - 1; i > 0; i--) {\n\t\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t\t[shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n\t\t\t}\n\t\t\treturn shuffled;\n\t\t};\n\t\t// Performs a binary search on a sorted (ascending) array of ProofWithFee objects by exFee.\n\t\t// If lessOrEqual=true, returns the rightmost index where exFee <= value\n\t\t// If lessOrEqual=false, returns the leftmost index where exFee >= value\n\t\tconst binarySearchIndex = (\n\t\t\tarr: ProofWithFee[],\n\t\t\tvalue: number,\n\t\t\tlessOrEqual: boolean,\n\t\t): number | null => {\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length - 1,\n\t\t\t\tresult: number | null = null;\n\t\t\twhile (left <= right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tconst midValue = arr[mid].exFee;\n\t\t\t\tif (lessOrEqual ? midValue <= value : midValue >= value) {\n\t\t\t\t\tresult = mid;\n\t\t\t\t\tif (lessOrEqual) left = mid + 1;\n\t\t\t\t\telse right = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (lessOrEqual) right = mid - 1;\n\t\t\t\t\telse left = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lessOrEqual ? result : left < arr.length ? left : null;\n\t\t};\n\t\t// Insert into array of ProofWithFee objects sorted by exFee\n\t\tconst insertSorted = (arr: ProofWithFee[], obj: ProofWithFee): void => {\n\t\t\tconst value = obj.exFee;\n\t\t\tlet left = 0,\n\t\t\t\tright = arr.length;\n\t\t\twhile (left < right) {\n\t\t\t\tconst mid = Math.floor((left + right) / 2);\n\t\t\t\tif (arr[mid].exFee < value) left = mid + 1;\n\t\t\t\telse right = mid;\n\t\t\t}\n\t\t\tarr.splice(left, 0, obj);\n\t\t};\n\t\t// \"Delta\" is the excess over amountToSend including fees\n\t\t// plus a tiebreaker to favour lower PPK keysets\n\t\t// NB: Solutions under amountToSend are invalid (delta: Infinity)\n\t\tconst calculateDelta = (amount: number, feePPK: number): number => {\n\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\tif (netSum < amountToSend) return Infinity; // no good\n\t\t\treturn amount + feePPK / 1000 - amountToSend;\n\t\t};\n\n\t\t/**\n\t\t * Pre-processing.\n\t\t */\n\t\tlet totalAmount = 0;\n\t\tlet totalFeePPK = 0;\n\t\tconst proofWithFees = proofs.map((p) => {\n\t\t\tconst ppkfee = this.getProofFeePPK(p);\n\t\t\tconst exFee = includeFees ? p.amount - ppkfee / 1000 : p.amount;\n\t\t\tconst obj = { proof: p, exFee, ppkfee };\n\t\t\t// Sum all economical proofs (filtered below)\n\t\t\tif (!includeFees || exFee > 0) {\n\t\t\t\ttotalAmount += p.amount;\n\t\t\t\ttotalFeePPK += ppkfee;\n\t\t\t}\n\t\t\treturn obj;\n\t\t});\n\n\t\t// Filter uneconomical proofs (totals computed above)\n\t\tlet spendableProofs = includeFees\n\t\t\t? proofWithFees.filter((obj) => obj.exFee > 0)\n\t\t\t: proofWithFees;\n\n\t\t// Sort by exFee ascending\n\t\tspendableProofs.sort((a, b) => a.exFee - b.exFee);\n\n\t\t// Remove proofs too large to be useful and adjust totals\n\t\t// Exact Match: Keep proofs where exFee <= amountToSend\n\t\t// Close Match: Keep proofs where exFee <= nextBiggerExFee\n\t\tif (spendableProofs.length > 0) {\n\t\t\tlet endIndex;\n\t\t\tif (exactMatch) {\n\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, amountToSend, true);\n\t\t\t\tendIndex = rightIndex !== null ? rightIndex + 1 : 0;\n\t\t\t} else {\n\t\t\t\tconst biggerIndex = binarySearchIndex(spendableProofs, amountToSend, false);\n\t\t\t\tif (biggerIndex !== null) {\n\t\t\t\t\tconst nextBiggerExFee = spendableProofs[biggerIndex].exFee;\n\t\t\t\t\tconst rightIndex = binarySearchIndex(spendableProofs, nextBiggerExFee, true);\n\t\t\t\t\tif (rightIndex === null) {\n\t\t\t\t\t\tthrow new Error('Unexpected null rightIndex in binary search');\n\t\t\t\t\t}\n\t\t\t\t\tendIndex = rightIndex + 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Keep all proofs if all exFee < amountToSend\n\t\t\t\t\tendIndex = spendableProofs.length;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Adjust totals for removed proofs\n\t\t\tfor (let i = endIndex; i < spendableProofs.length; i++) {\n\t\t\t\ttotalAmount -= spendableProofs[i].proof.amount;\n\t\t\t\ttotalFeePPK -= spendableProofs[i].ppkfee;\n\t\t\t}\n\t\t\tspendableProofs = spendableProofs.slice(0, endIndex);\n\t\t}\n\n\t\t// Validate using precomputed totals\n\t\tconst totalNetSum = sumExFees(totalAmount, totalFeePPK);\n\t\tif (amountToSend <= 0 || amountToSend > totalNetSum) {\n\t\t\treturn { keep: proofs, send: [] };\n\t\t}\n\n\t\t// Max acceptable amount for non-exact matches\n\t\tconst maxOverAmount = Math.min(\n\t\t\tMath.ceil(amountToSend * (1 + MAX_OVRPCT / 100)),\n\t\t\tamountToSend + MAX_OVRAMT,\n\t\t\ttotalNetSum,\n\t\t);\n\n\t\t/**\n\t\t * RGLI algorithm: Runs multiple trials (up to MAX_TRIALS) Each trial starts with randomized\n\t\t * greedy subset (S) and then tries to improve that subset to get a valid solution. NOTE: Fees\n\t\t * are dynamic, based on number of proofs (PPK), so we perform all calculations based on net\n\t\t * amounts.\n\t\t */\n\t\tfor (let trial = 0; trial < MAX_TRIALS; trial++) {\n\t\t\t// PHASE 1: Randomized Greedy Selection\n\t\t\t// Add proofs up to amountToSend (after adjusting for fees)\n\t\t\t// for exact match or the first amount over target otherwise\n\t\t\tconst S: ProofWithFee[] = [];\n\t\t\tlet amount = 0;\n\t\t\tlet feePPK = 0;\n\t\t\tfor (const obj of shuffleArray(spendableProofs)) {\n\t\t\t\tconst newAmount = amount + obj.proof.amount;\n\t\t\t\tconst newFeePPK = feePPK + obj.ppkfee;\n\t\t\t\tconst netSum = sumExFees(newAmount, newFeePPK);\n\t\t\t\tif (exactMatch && netSum > amountToSend) break;\n\t\t\t\tS.push(obj);\n\t\t\t\tamount = newAmount;\n\t\t\t\tfeePPK = newFeePPK;\n\t\t\t\tif (netSum >= amountToSend) break;\n\t\t\t}\n\n\t\t\t// PHASE 2: Local Improvement\n\t\t\t// Examine all the amounts found in the first phase, and find the\n\t\t\t// amount not in the current solution (others), which would get us\n\t\t\t// closest to the amountToSend.\n\n\t\t\t// Calculate the \"others\" array (note: spendableProofs is sorted ASC)\n\t\t\t// Using set.has() for filtering gives faster lookups: O(n+m)\n\t\t\t// Using array.includes() would be way slower: O(n*m)\n\t\t\tconst SSet = new Set(S);\n\t\t\tconst others = spendableProofs.filter((obj) => !SSet.has(obj));\n\t\t\t// Generate a random order for accessing the trial subset ('S')\n\t\t\tconst indices = shuffleArray(Array.from({ length: S.length }, (_, i) => i)).slice(\n\t\t\t\t0,\n\t\t\t\tMAX_P2SWAP,\n\t\t\t);\n\t\t\tfor (const i of indices) {\n\t\t\t\t// Exact or acceptable close match solution found?\n\t\t\t\tconst netSum = sumExFees(amount, feePPK);\n\t\t\t\tif (\n\t\t\t\t\tnetSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && netSum >= amountToSend && netSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Get details for proof being replaced (objP), and temporarily\n\t\t\t\t// calculate the subset amount/fee with that proof removed.\n\t\t\t\tconst objP = S[i];\n\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\tconst tempNetSum = sumExFees(tempAmount, tempFeePPK);\n\t\t\t\tconst target = amountToSend - tempNetSum;\n\n\t\t\t\t// Find a better replacement proof (objQ) and swap it in\n\t\t\t\t// Exact match can only replace larger to close on the target\n\t\t\t\t// Close match can replace larger or smaller as needed, but will\n\t\t\t\t// not replace larger unless it closes on the target\n\t\t\t\tconst qIndex = binarySearchIndex(others, target, exactMatch);\n\t\t\t\tif (qIndex !== null) {\n\t\t\t\t\tconst objQ = others[qIndex];\n\t\t\t\t\tif (!exactMatch || objQ.exFee > objP.exFee) {\n\t\t\t\t\t\tif (target >= 0 || objQ.exFee <= objP.exFee) {\n\t\t\t\t\t\t\tS[i] = objQ;\n\t\t\t\t\t\t\tamount = tempAmount + objQ.proof.amount;\n\t\t\t\t\t\t\tfeePPK = tempFeePPK + objQ.ppkfee;\n\t\t\t\t\t\t\tothers.splice(qIndex, 1);\n\t\t\t\t\t\t\tinsertSorted(others, objP);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update best solution\n\t\t\tconst delta = calculateDelta(amount, feePPK);\n\t\t\tif (delta < bestDelta) {\n\t\t\t\tthis._logger.debug(\n\t\t\t\t\t'selectProofsToSend: best solution found in trial #{trial} - amount: {amount}, delta: {delta}',\n\t\t\t\t\t{ trial, amount, delta },\n\t\t\t\t);\n\t\t\t\tbestSubset = [...S].sort((a, b) => b.exFee - a.exFee); // copy & sort\n\t\t\t\tbestDelta = delta;\n\t\t\t\tbestAmount = amount;\n\t\t\t\tbestFeePPK = feePPK;\n\n\t\t\t\t// \"PHASE 3\": Final check to make sure we haven't overpaid fees\n\t\t\t\t// and see if we can improve the solution. This is an adaptation\n\t\t\t\t// to the original RGLI, which helps us identify close match and\n\t\t\t\t// optimal fee solutions more consistently\n\t\t\t\tconst tempS = [...bestSubset]; // copy\n\t\t\t\twhile (tempS.length > 1 && bestDelta > 0) {\n\t\t\t\t\tconst objP = tempS.pop() as ProofWithFee;\n\t\t\t\t\tconst tempAmount = amount - objP.proof.amount;\n\t\t\t\t\tconst tempFeePPK = feePPK - objP.ppkfee;\n\t\t\t\t\tconst tempDelta = calculateDelta(tempAmount, tempFeePPK);\n\t\t\t\t\tif (tempDelta == Infinity) break;\n\t\t\t\t\tif (tempDelta < bestDelta) {\n\t\t\t\t\t\tbestSubset = [...tempS];\n\t\t\t\t\t\tbestDelta = tempDelta;\n\t\t\t\t\t\tbestAmount = tempAmount;\n\t\t\t\t\t\tbestFeePPK = tempFeePPK;\n\t\t\t\t\t\tamount = tempAmount;\n\t\t\t\t\t\tfeePPK = tempFeePPK;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Check if solution is acceptable\n\t\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\t\tconst bestSum = sumExFees(bestAmount, bestFeePPK);\n\t\t\t\tif (\n\t\t\t\t\tbestSum === amountToSend ||\n\t\t\t\t\t(!exactMatch && bestSum >= amountToSend && bestSum <= maxOverAmount)\n\t\t\t\t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Time limit reached?\n\t\t\tif (timer.elapsed() > MAX_TIMEMS) {\n\t\t\t\tif (exactMatch) {\n\t\t\t\t\tthrow new Error('Proof selection took too long. Try again with a smaller proof set.');\n\t\t\t\t} else {\n\t\t\t\t\tthis._logger.warn('Proof selection took too long. Returning best selection so far.');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Return Result\n\t\tif (bestSubset && bestDelta < Infinity) {\n\t\t\tconst bestProofs = bestSubset.map((obj) => obj.proof);\n\t\t\tconst bestSubsetSet = new Set(bestProofs);\n\t\t\tconst keep = proofs.filter((p) => !bestSubsetSet.has(p));\n\t\t\tthis._logger.info('Proof selection took {time}ms', { time: timer.elapsed() });\n\t\t\treturn { keep, send: bestProofs };\n\t\t}\n\t\treturn { keep: proofs, send: [] };\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs (proofs)\n\t *\n\t * @param proofs Input proofs to calculate fees for.\n\t * @returns Fee amount.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tgetFeesForProofs(proofs: Proof[]): number {\n\t\tconst sumPPK = proofs.reduce((a, c) => a + this.getProofFeePPK(c), 0);\n\t\treturn Math.ceil(sumPPK / 1000);\n\t}\n\n\t/**\n\t * Returns the current fee PPK for a proof according to the cached keyset.\n\t *\n\t * @param proof {Proof} A single proof.\n\t * @returns FeePPK {number} The feePPK for the selected proof.\n\t * @throws Throws an error if the proofs keyset is unknown.\n\t */\n\tprivate getProofFeePPK(proof: Proof) {\n\t\tconst keyset = this._keysets.find((k) => k.id === proof.id);\n\t\tif (!keyset) {\n\t\t\tthrow new Error(`Could not get fee. No keyset found for keyset id: ${proof.id}`);\n\t\t}\n\t\treturn keyset?.input_fee_ppk || 0;\n\t}\n\n\t/**\n\t * Calculates the fees based on inputs for a given keyset.\n\t *\n\t * @param nInputs Number of inputs.\n\t * @param keysetId KeysetId used to lookup `input_fee_ppk`\n\t * @returns Fee amount.\n\t */\n\tgetFeesForKeyset(nInputs: number, keysetId: string): number {\n\t\tconst fees = Math.floor(\n\t\t\tMath.max(\n\t\t\t\t(nInputs * (this._keysets.find((k: MintKeyset) => k.id === keysetId)?.input_fee_ppk || 0) +\n\t\t\t\t\t999) /\n\t\t\t\t\t1000,\n\t\t\t\t0,\n\t\t\t),\n\t\t);\n\t\treturn fees;\n\t}\n\n\t/**\n\t * Splits and creates sendable tokens if no amount is specified, the amount is implied by the\n\t * cumulative amount of all proofs if both amount and preference are set, but the preference\n\t * cannot fulfill the amount, then we use the default split.\n\t *\n\t * @param {SwapOptions} [options] - Optional parameters for configuring the swap operation.\n\t * @returns Promise of the change- and send-proofs.\n\t */\n\tasync swap(amount: number, proofs: Proof[], options?: SwapOptions): Promise<SendResponse> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { includeFees, keysetId, counter, pubkey, privkey, proofsWeHave, outputData, p2pk } =\n\t\t\toptions || {};\n\t\tconst keyset = await this.getKeys(keysetId);\n\n\t\tlet amountToSend = amount;\n\t\tconst amountAvailable = sumProofs(proofs);\n\t\t// send output selection\n\t\tlet sendAmounts = outputAmounts?.sendAmounts || splitAmount(amountToSend, keyset.keys);\n\n\t\tif (includeFees) {\n\t\t\tlet outputFee = this.getFeesForKeyset(sendAmounts.length, keyset.id);\n\t\t\tlet sendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\twhile (\n\t\t\t\tthis.getFeesForKeyset(sendAmounts.concat(sendAmountsFee).length, keyset.id) > outputFee\n\t\t\t) {\n\t\t\t\toutputFee++;\n\t\t\t\tsendAmountsFee = splitAmount(outputFee, keyset.keys);\n\t\t\t}\n\t\t\tsendAmounts = sendAmounts.concat(sendAmountsFee);\n\t\t\tamountToSend += outputFee;\n\t\t}\n\n\t\t// include the fees to spend the the outputs of the swap\n\t\t// input selection, needs fees because of the swap\n\t\tconst { keep: keepProofs, send: sendProofs } = this.selectProofsToSend(\n\t\t\tproofs,\n\t\t\tamountToSend,\n\t\t\ttrue, // inc. fees\n\t\t);\n\n\t\tconst amountToKeep = sumProofs(sendProofs) - this.getFeesForProofs(sendProofs) - amountToSend;\n\n\t\tif (amountToKeep < 0) {\n\t\t\tthrow new Error('Not enough balance to send');\n\t\t}\n\n\t\t// keep output selection\n\t\tlet keepAmounts;\n\t\tif (!outputAmounts?.keepAmounts && !proofsWeHave) {\n\t\t\tkeepAmounts = splitAmount(amountToKeep, keyset.keys);\n\t\t} else if (!outputAmounts?.keepAmounts && proofsWeHave) {\n\t\t\tkeepAmounts = getKeepAmounts(\n\t\t\t\tproofsWeHave,\n\t\t\t\tamountToKeep,\n\t\t\t\tkeyset.keys,\n\t\t\t\tthis._denominationTarget,\n\t\t\t);\n\t\t} else if (outputAmounts) {\n\t\t\tif (outputAmounts.keepAmounts?.reduce((a: number, b: number) => a + b, 0) != amountToKeep) {\n\t\t\t\tthrow new Error('Keep amounts do not match amount to keep');\n\t\t\t}\n\t\t\tkeepAmounts = outputAmounts.keepAmounts;\n\t\t}\n\n\t\tif (amountToSend + this.getFeesForProofs(sendProofs) > amountAvailable) {\n\t\t\tthis._logger.error(\n\t\t\t\t`Not enough funds available (${amountAvailable}) for swap amountToSend: ${amountToSend} + fee: ${this.getFeesForProofs(\n\t\t\t\t\tsendProofs,\n\t\t\t\t)} | length: ${sendProofs.length}`,\n\t\t\t);\n\t\t\tthrow new Error(`Not enough funds available for swap`);\n\t\t}\n\n\t\toutputAmounts = {\n\t\t\tkeepAmounts: keepAmounts,\n\t\t\tsendAmounts: sendAmounts,\n\t\t};\n\n\t\tconst keepOutputData = outputData?.keep || this._keepFactory;\n\t\tconst sendOutputData = outputData?.send;\n\n\t\tconst swapTransaction = this.createSwapPayload(\n\t\t\tamountToSend,\n\t\t\tsendProofs,\n\t\t\tkeyset,\n\t\t\toutputAmounts,\n\t\t\tcounter,\n\t\t\tpubkey,\n\t\t\tprivkey,\n\t\t\t{ keep: keepOutputData, send: sendOutputData },\n\t\t\tp2pk,\n\t\t);\n\t\tconst { signatures } = await this.mint.swap(swapTransaction.payload);\n\t\tconst swapProofs = swapTransaction.outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tconst splitProofsToKeep: Proof[] = [];\n\t\tconst splitProofsToSend: Proof[] = [];\n\t\tconst reorderedKeepVector = Array(swapTransaction.keepVector.length);\n\t\tconst reorderedProofs = Array(swapProofs.length);\n\t\tswapTransaction.sortedIndices.forEach((s, i) => {\n\t\t\treorderedKeepVector[s] = swapTransaction.keepVector[i];\n\t\t\treorderedProofs[s] = swapProofs[i];\n\t\t});\n\t\treorderedProofs.forEach((p: Proof, i) => {\n\t\t\tif (reorderedKeepVector[i]) {\n\t\t\t\tsplitProofsToKeep.push(p);\n\t\t\t} else {\n\t\t\t\tsplitProofsToSend.push(p);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\tkeep: [...splitProofsToKeep, ...keepProofs],\n\t\t\tsend: splitProofsToSend,\n\t\t};\n\t}\n\n\t/**\n\t * Restores batches of deterministic proofs until no more signatures are returned from the mint.\n\t *\n\t * @param [gapLimit=300] The amount of empty counters that should be returned before restoring\n\t *   ends (defaults to 300). Default is `300`\n\t * @param [batchSize=100] The amount of proofs that should be restored at a time (defaults to\n\t *   100). Default is `100`\n\t * @param [counter=0] The counter that should be used as a starting point (defaults to 0). Default\n\t *   is `0`\n\t * @param [keysetId] Which keysetId to use for the restoration. If none is passed the instance's\n\t *   default one will be used.\n\t */\n\tasync batchRestore(\n\t\tgapLimit = 300,\n\t\tbatchSize = 100,\n\t\tcounter = 0,\n\t\tkeysetId?: string,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst requiredEmptyBatches = Math.ceil(gapLimit / batchSize);\n\t\tconst restoredProofs: Proof[] = [];\n\n\t\tlet lastCounterWithSignature: undefined | number;\n\t\tlet emptyBatchesFound = 0;\n\n\t\twhile (emptyBatchesFound < requiredEmptyBatches) {\n\t\t\tconst restoreRes = await this.restore(counter, batchSize, { keysetId });\n\t\t\tif (restoreRes.proofs.length > 0) {\n\t\t\t\temptyBatchesFound = 0;\n\t\t\t\trestoredProofs.push(...restoreRes.proofs);\n\t\t\t\tlastCounterWithSignature = restoreRes.lastCounterWithSignature;\n\t\t\t} else {\n\t\t\t\temptyBatchesFound++;\n\t\t\t}\n\t\t\tcounter += batchSize;\n\t\t}\n\t\treturn { proofs: restoredProofs, lastCounterWithSignature };\n\t}\n\n\t/**\n\t * Regenerates.\n\t *\n\t * @param start Set starting point for count (first cycle for each keyset should usually be 0)\n\t * @param count Set number of blinded messages that should be generated.\n\t * @param options.keysetId Set a custom keysetId to restore from. keysetIds can be loaded with\n\t *   `CashuMint.getKeySets()`\n\t */\n\tasync restore(\n\t\tstart: number,\n\t\tcount: number,\n\t\toptions?: RestoreOptions,\n\t): Promise<{ proofs: Proof[]; lastCounterWithSignature?: number }> {\n\t\tconst { keysetId } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tif (!this._seed) {\n\t\t\tthrow new Error('CashuWallet must be initialized with a seed to use restore');\n\t\t}\n\t\t// create deterministic blank outputs for unknown restore amounts\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = Array(count).fill(0);\n\t\tconst outputData = OutputData.createDeterministicData(0, this._seed, start, keys, zeros);\n\n\t\tconst { outputs, signatures } = await this.mint.restore({\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t});\n\n\t\tconst signatureMap: { [sig: string]: SerializedBlindedSignature } = {};\n\t\toutputs.forEach((o, i) => (signatureMap[o.B_] = signatures[i]));\n\n\t\tconst restoredProofs: Proof[] = [];\n\t\tlet lastCounterWithSignature: number | undefined;\n\n\t\tfor (let i = 0; i < outputData.length; i++) {\n\t\t\tconst matchingSig = signatureMap[outputData[i].blindedMessage.B_];\n\t\t\tif (matchingSig) {\n\t\t\t\tlastCounterWithSignature = start + i;\n\t\t\t\toutputData[i].blindedMessage.amount = matchingSig.amount;\n\t\t\t\trestoredProofs.push(outputData[i].toProof(matchingSig, keys));\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tproofs: restoredProofs,\n\t\t\tlastCounterWithSignature,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning payment request for the\n\t * requested given amount and unit.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param description Optional description for the mint quote.\n\t * @param pubkey Optional public key to lock the quote to.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuote(amount: number, description?: string): Promise<MintQuoteResponse> {\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\treturn { ...res, amount: res.amount || amount, unit: res.unit || this.unit };\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint that is locked to a public key.\n\t *\n\t * @param amount Amount requesting for mint.\n\t * @param pubkey Public key to lock the quote to.\n\t * @param description Optional description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit. The quote will be locked to the specified `pubkey`.\n\t */\n\tasync createLockedMintQuote(\n\t\tamount: number,\n\t\tpubkey: string,\n\t\tdescription?: string,\n\t): Promise<LockedMintQuoteResponse> {\n\t\tconst { supported } = (await this.lazyGetMintInfo()).isSupported(20);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-20');\n\t\t}\n\t\tconst mintQuotePayload: MintQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\tamount: amount,\n\t\t\tdescription: description,\n\t\t\tpubkey: pubkey,\n\t\t};\n\t\tconst res = await this.mint.createMintQuote(mintQuotePayload);\n\t\tif (typeof res.pubkey !== 'string') {\n\t\t\tthrow new Error('Mint returned unlocked mint quote');\n\t\t} else {\n\t\t\tconst pubkey = res.pubkey;\n\t\t\treturn { ...res, pubkey, amount: res.amount || amount, unit: res.unit || this.unit };\n\t\t}\n\t}\n\n\t/**\n\t * Requests a mint quote from the mint. Response returns a Lightning BOLT12 offer for the\n\t * requested given amount and unit.\n\t *\n\t * @param pubkey Public key to lock the quote to.\n\t * @param options.amount BOLT12 offer amount requesting for mint. If not specified, the offer will\n\t *   be amountless.\n\t * @param options.description Description for the mint quote.\n\t * @returns The mint will return a mint quote with a Lightning invoice for minting tokens of the\n\t *   specified amount and unit.\n\t */\n\tasync createMintQuoteBolt12(\n\t\tpubkey: string,\n\t\toptions?: {\n\t\t\tamount?: number;\n\t\t\tdescription?: string;\n\t\t},\n\t): Promise<Bolt12MintQuoteResponse> {\n\t\t// Check if mint supports description for bolt12\n\t\tconst mintInfo = await this.lazyGetMintInfo();\n\t\tif (options?.description && !mintInfo.supportsBolt12Description) {\n\t\t\tthrow new Error('Mint does not support description for bolt12');\n\t\t}\n\n\t\tconst mintQuotePayload: Bolt12MintQuotePayload = {\n\t\t\tpubkey: pubkey,\n\t\t\tunit: this._unit,\n\t\t\tamount: options?.amount,\n\t\t\tdescription: options?.description,\n\t\t};\n\n\t\treturn this.mint.createMintQuoteBolt12(mintQuotePayload);\n\t}\n\n\t/**\n\t * Gets an existing mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The mint will create and return a Lightning invoice for the specified amount.\n\t */\n\tasync checkMintQuote(quote: MintQuoteResponse): Promise<MintQuoteResponse>;\n\tasync checkMintQuote(quote: string): Promise<PartialMintQuoteResponse>;\n\tasync checkMintQuote(\n\t\tquote: string | MintQuoteResponse,\n\t): Promise<MintQuoteResponse | PartialMintQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst baseRes = await this.mint.checkMintQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn baseRes;\n\t\t}\n\t\treturn { ...baseRes, amount: baseRes.amount || quote.amount, unit: baseRes.unit || quote.unit };\n\t}\n\n\t/**\n\t * Gets an existing BOLT12 mint quote from the mint.\n\t *\n\t * @param quote Quote ID.\n\t * @returns The latest mint quote for the given quote ID.\n\t */\n\tasync checkMintQuoteBolt12(quote: string): Promise<Bolt12MintQuoteResponse> {\n\t\treturn this.mint.checkMintQuoteBolt12(quote);\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param {string} quote - ID of mint quote (when quote is a string)\n\t * @param {LockedMintQuote} quote - Containing the quote ID and unlocking private key (when quote\n\t *   is a LockedMintQuote)\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof\n\t *   operation.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: MintQuoteResponse,\n\t\toptions: MintProofOptions & { privateKey: string },\n\t): Promise<Proof[]>;\n\tasync mintProofs(amount: number, quote: string, options?: MintProofOptions): Promise<Proof[]>;\n\tasync mintProofs(\n\t\tamount: number,\n\t\tquote: string | MintQuoteResponse,\n\t\toptions?: MintProofOptions & { privateKey?: string },\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt11', amount, quote, options);\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request. This must be less than or equal to the `quote.amountPaid -\n\t *   quote.amountIssued`\n\t * @param {string} quote - ID of mint quote.\n\t * @param {string} privateKey - Private key to unlock the quote.\n\t * @param {MintProofOptions} [options] - Optional parameters for configuring the Mint Proof\n\t *   operation.\n\t * @returns Proofs.\n\t */\n\tasync mintProofsBolt12(\n\t\tamount: number,\n\t\tquote: Bolt12MintQuoteResponse,\n\t\tprivateKey: string,\n\t\toptions?: MintProofOptions,\n\t): Promise<Proof[]> {\n\t\treturn this._mintProofs('bolt12', amount, quote, { ...options, privateKey });\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a Lightning invoice.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuote(invoice: string): Promise<MeltQuoteResponse> {\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn {\n\t\t\t...meltQuote,\n\t\t\tunit: meltQuote.unit || this.unit,\n\t\t\trequest: meltQuote.request || invoice,\n\t\t};\n\t}\n\n\t/**\n\t * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order\n\t * to pay a BOLT12 offer.\n\t *\n\t * @param offer BOLT12 offer that needs to get a fee estimate.\n\t * @param amountMsat Amount in millisatoshis for amount-less offers. If this is defined and the\n\t *   offer has an amount, they **MUST** be equal.\n\t * @returns The mint will create and return a melt quote for the offer with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMeltQuoteBolt12(\n\t\toffer: string,\n\t\tamountMsat?: number,\n\t): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.createMeltQuoteBolt12({\n\t\t\tunit: this._unit,\n\t\t\trequest: offer,\n\t\t\toptions: amountMsat\n\t\t\t\t? {\n\t\t\t\t\t\tamountless: {\n\t\t\t\t\t\t\tamount_msat: amountMsat,\n\t\t\t\t\t\t},\n\t\t\t\t\t}\n\t\t\t\t: undefined,\n\t\t});\n\t}\n\n\t/**\n\t * Requests a multi path melt quote from the mint.\n\t *\n\t * @param invoice LN invoice that needs to get a fee estimate.\n\t * @param partialAmount The partial amount of the invoice's total to be paid by this instance.\n\t * @returns The mint will create and return a melt quote for the invoice with an amount and fee\n\t *   reserve.\n\t */\n\tasync createMultiPathMeltQuote(\n\t\tinvoice: string,\n\t\tmillisatPartialAmount: number,\n\t): Promise<MeltQuoteResponse> {\n\t\tconst { supported, params } = (await this.lazyGetMintInfo()).isSupported(15);\n\t\tif (!supported) {\n\t\t\tthrow new Error('Mint does not support NUT-15');\n\t\t}\n\t\tif (!params?.some((p) => p.method === 'bolt11' && p.unit === this.unit)) {\n\t\t\tthrow new Error(`Mint does not support MPP for bolt11 and ${this.unit}`);\n\t\t}\n\t\tconst mppOption: MPPOption = {\n\t\t\tamount: millisatPartialAmount,\n\t\t};\n\t\tconst meltOptions: MeltQuoteOptions = {\n\t\t\tmpp: mppOption,\n\t\t};\n\t\tconst meltQuotePayload: MeltQuotePayload = {\n\t\t\tunit: this._unit,\n\t\t\trequest: invoice,\n\t\t\toptions: meltOptions,\n\t\t};\n\t\tconst meltQuote = await this.mint.createMeltQuote(meltQuotePayload);\n\t\treturn { ...meltQuote, request: invoice, unit: this._unit };\n\t}\n\n\t/**\n\t * Return an existing melt quote from the mint.\n\t *\n\t * @param quote ID of the melt quote.\n\t * @returns The mint will return an existing melt quote.\n\t */\n\tasync checkMeltQuote(quote: string): Promise<PartialMeltQuoteResponse>;\n\tasync checkMeltQuote(quote: MeltQuoteResponse): Promise<MeltQuoteResponse>;\n\tasync checkMeltQuote(\n\t\tquote: string | MeltQuoteResponse,\n\t): Promise<MeltQuoteResponse | PartialMeltQuoteResponse> {\n\t\tconst quoteId = typeof quote === 'string' ? quote : quote.quote;\n\t\tconst meltQuote = await this.mint.checkMeltQuote(quoteId);\n\t\tif (typeof quote === 'string') {\n\t\t\treturn meltQuote;\n\t\t}\n\t\treturn { ...meltQuote, request: quote.request, unit: quote.unit };\n\t}\n\n\tasync checkMeltQuoteBolt12(quote: string): Promise<Bolt12MeltQuoteResponse> {\n\t\treturn this.mint.checkMeltQuoteBolt12(quote);\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt\n\t * quote. This function does not perform coin selection!. Returns melt quote and change proofs.\n\t *\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof\n\t *   operation.\n\t * @returns\n\t */\n\tasync meltProofs(\n\t\tmeltQuote: MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<MeltProofsResponse> {\n\t\treturn this._meltProofs('bolt11', meltQuote, proofsToSend, options);\n\t}\n\n\t/**\n\t * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt\n\t * quote. This function does not perform coin selection!. Returns melt quote and change proofs.\n\t *\n\t * @param meltQuote ID of the melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param {MeltProofOptions} [options] - Optional parameters for configuring the Melting Proof\n\t *   operation.\n\t * @returns\n\t */\n\tasync meltProofsBolt12(\n\t\tmeltQuote: Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<{\n\t\tquote: Bolt12MeltQuoteResponse;\n\t\tchange: Proof[];\n\t}> {\n\t\treturn this._meltProofs('bolt12', meltQuote, proofsToSend, options);\n\t}\n\n\t/**\n\t * Creates a split payload.\n\t *\n\t * @param amount Amount to send.\n\t * @param proofsToSend Proofs to split*\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param privkey? Will create a signature on the @param proofsToSend secrets if set.\n\t * @param customOutputData? Optionally specify your own OutputData (blinded messages)\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @returns\n\t */\n\tprivate createSwapPayload(\n\t\tamount: number,\n\t\tproofsToSend: Proof[],\n\t\tkeyset: MintKeys,\n\t\toutputAmounts?: OutputAmounts,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\tprivkey?: string,\n\t\tcustomOutputData?: {\n\t\t\tkeep?: OutputDataLike[] | OutputDataFactory;\n\t\t\tsend?: OutputDataLike[] | OutputDataFactory;\n\t\t},\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t): SwapTransaction {\n\t\tconst totalAmount = proofsToSend.reduce((total: number, curr: Proof) => total + curr.amount, 0);\n\t\tif (outputAmounts && outputAmounts.sendAmounts && !outputAmounts.keepAmounts) {\n\t\t\toutputAmounts.keepAmounts = splitAmount(\n\t\t\t\ttotalAmount - amount - this.getFeesForProofs(proofsToSend),\n\t\t\t\tkeyset.keys,\n\t\t\t);\n\t\t}\n\t\tconst keepAmount = totalAmount - amount - this.getFeesForProofs(proofsToSend);\n\t\tlet keepOutputData: OutputDataLike[] = [];\n\t\tlet sendOutputData: OutputDataLike[] = [];\n\n\t\tif (customOutputData?.keep) {\n\t\t\tif (isOutputDataFactory(customOutputData.keep)) {\n\t\t\t\tconst factory = customOutputData.keep;\n\t\t\t\tconst amounts = splitAmount(keepAmount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tkeepOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tkeepOutputData = customOutputData.keep;\n\t\t\t}\n\t\t} else {\n\t\t\tkeepOutputData = this.createOutputData(\n\t\t\t\tkeepAmount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tundefined,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tundefined,\n\t\t\t\tthis._keepFactory,\n\t\t\t);\n\t\t}\n\n\t\tif (customOutputData?.send) {\n\t\t\tif (isOutputDataFactory(customOutputData.send)) {\n\t\t\t\tconst factory = customOutputData.send;\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\t\tamounts.forEach((a) => {\n\t\t\t\t\tsendOutputData.push(factory(a, keyset));\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tsendOutputData = customOutputData.send;\n\t\t\t}\n\t\t} else {\n\t\t\tsendOutputData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter ? counter + keepOutputData.length : undefined,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.sendAmounts,\n\t\t\t\tp2pk,\n\t\t\t);\n\t\t}\n\n\t\tif (privkey) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst mergedBlindingData = [...keepOutputData, ...sendOutputData];\n\t\tconst indices = mergedBlindingData\n\t\t\t.map((_, i) => i)\n\t\t\t.sort(\n\t\t\t\t(a, b) =>\n\t\t\t\t\tmergedBlindingData[a].blindedMessage.amount - mergedBlindingData[b].blindedMessage.amount,\n\t\t\t);\n\t\tconst keepVector: boolean[] = [\n\t\t\t...Array.from({ length: keepOutputData.length }, () => true),\n\t\t\t...Array.from({ length: sendOutputData.length }, () => false),\n\t\t];\n\n\t\tconst sortedOutputData: OutputDataLike[] = indices.map((i) => mergedBlindingData[i]);\n\t\tconst sortedKeepVector: boolean[] = indices.map((i) => keepVector[i]);\n\n\t\treturn {\n\t\t\tpayload: {\n\t\t\t\tinputs: proofsToSend,\n\t\t\t\toutputs: sortedOutputData.map((d) => d.blindedMessage),\n\t\t\t},\n\t\t\toutputData: sortedOutputData,\n\t\t\tkeepVector: sortedKeepVector,\n\t\t\tsortedIndices: indices,\n\t\t};\n\t}\n\n\t/**\n\t * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)\n\t *\n\t * @param proofs (only the `secret` field is required)\n\t * @returns\n\t */\n\tasync checkProofsStates(proofs: Proof[]): Promise<ProofState[]> {\n\t\tconst enc = new TextEncoder();\n\t\tconst Ys = proofs.map((p: Proof) => hashToCurve(enc.encode(p.secret)).toHex(true));\n\t\t// TODO: Replace this with a value from the info endpoint of the mint eventually\n\t\tconst BATCH_SIZE = 100;\n\t\tconst states: ProofState[] = [];\n\t\tfor (let i = 0; i < Ys.length; i += BATCH_SIZE) {\n\t\t\tconst YsSlice = Ys.slice(i, i + BATCH_SIZE);\n\t\t\tconst { states: batchStates } = await this.mint.check({\n\t\t\t\tYs: YsSlice,\n\t\t\t});\n\t\t\tconst stateMap: { [y: string]: ProofState } = {};\n\t\t\tbatchStates.forEach((s) => {\n\t\t\t\tstateMap[s.Y] = s;\n\t\t\t});\n\t\t\tfor (let j = 0; j < YsSlice.length; j++) {\n\t\t\t\tconst state = stateMap[YsSlice[j]];\n\t\t\t\tif (!state) {\n\t\t\t\t\tthrow new Error('Could not find state for proof with Y: ' + YsSlice[j]);\n\t\t\t\t}\n\t\t\t\tstates.push(state);\n\t\t\t}\n\t\t}\n\t\treturn states;\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a mint quote's state changes.\n\t *\n\t * @param quoteIds List of mint quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a mint quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_mint_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a melt quote's state changes.\n\t *\n\t * @param quoteIds List of melt quote IDs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a melt quote state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMeltQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MeltQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single mint quote gets paid.\n\t *\n\t * @param quoteId Mint quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this mint quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMintQuotePaid(\n\t\tquoteId: string,\n\t\tcallback: (payload: MintQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\treturn this.onMintQuoteUpdates(\n\t\t\t[quoteId],\n\t\t\t(p) => {\n\t\t\t\tif (p.state === MintQuoteState.PAID) {\n\t\t\t\t\tcallback(p);\n\t\t\t\t}\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t}\n\n\t/**\n\t * Register a callback to be called when a single melt quote gets paid.\n\t *\n\t * @param quoteId Melt quote id that should be subscribed to.\n\t * @param callback Callback function that will be called when this melt quote gets paid.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onMeltQuoteUpdates(\n\t\tquoteIds: string[],\n\t\tcallback: (payload: MeltQuoteResponse) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'bolt11_melt_quote', filters: quoteIds },\n\t\t\tcallback,\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Register a callback to be called whenever a subscribed proof state changes.\n\t *\n\t * @param proofs List of proofs that should be subscribed to.\n\t * @param callback Callback function that will be called whenever a proof's state changes.\n\t * @param errorCallback\n\t * @returns\n\t */\n\tasync onProofStateUpdates(\n\t\tproofs: Proof[],\n\t\tcallback: (payload: ProofState & { proof: Proof }) => void,\n\t\terrorCallback: (e: Error) => void,\n\t): Promise<SubscriptionCanceller> {\n\t\tawait this.mint.connectWebSocket();\n\t\tif (!this.mint.webSocketConnection) {\n\t\t\tthrow new Error('failed to establish WebSocket connection.');\n\t\t}\n\t\tconst enc = new TextEncoder();\n\t\tconst proofMap: { [y: string]: Proof } = {};\n\t\tfor (let i = 0; i < proofs.length; i++) {\n\t\t\tconst y = hashToCurve(enc.encode(proofs[i].secret)).toHex(true);\n\t\t\tproofMap[y] = proofs[i];\n\t\t}\n\t\tconst ys = Object.keys(proofMap);\n\t\tconst subId = this.mint.webSocketConnection.createSubscription(\n\t\t\t{ kind: 'proof_state', filters: ys },\n\t\t\t(p: ProofState) => {\n\t\t\t\tcallback({ ...p, proof: proofMap[p.Y] });\n\t\t\t},\n\t\t\terrorCallback,\n\t\t);\n\t\treturn () => {\n\t\t\tthis.mint.webSocketConnection?.cancelSubscription(subId, callback);\n\t\t};\n\t}\n\n\t/**\n\t * Creates blinded messages for a according to @param amounts.\n\t *\n\t * @param amount Array of amounts to create blinded messages for.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @param pubkey? Optionally locks ecash to pubkey. Will not be deterministic, even if counter is\n\t *   set!\n\t * @param outputAmounts? Optionally specify the output's amounts to keep and to send.\n\t * @param p2pk? Optionally specify options to lock the proofs according to NUT-11.\n\t * @param factory? Optionally specify a custom function that produces OutputData (blinded\n\t *   messages)\n\t * @returns Blinded messages, secrets, rs, and amounts.\n\t */\n\tprivate createOutputData(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tpubkey?: string,\n\t\toutputAmounts?: number[],\n\t\tp2pk?: {\n\t\t\tpubkey: string | string[];\n\t\t\tlocktime?: number;\n\t\t\trefundKeys?: string[];\n\t\t\trequiredSignatures?: number;\n\t\t\trequiredRefundSignatures?: number;\n\t\t\tadditionalTags?: Array<[key: string, ...values: string[]]>;\n\t\t},\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet outputData: OutputDataLike[];\n\t\tif (pubkey) {\n\t\t\toutputData = OutputData.createP2PKData(\n\t\t\t\t{ pubkey, additionalTags: p2pk?.additionalTags },\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts,\n\t\t\t);\n\t\t} else if (counter || counter === 0) {\n\t\t\tif (!this._seed) {\n\t\t\t\tthrow new Error('cannot create deterministic messages without seed');\n\t\t\t}\n\t\t\toutputData = OutputData.createDeterministicData(\n\t\t\t\tamount,\n\t\t\t\tthis._seed,\n\t\t\t\tcounter,\n\t\t\t\tkeyset,\n\t\t\t\toutputAmounts,\n\t\t\t);\n\t\t} else if (p2pk) {\n\t\t\toutputData = OutputData.createP2PKData(p2pk, amount, keyset, outputAmounts);\n\t\t} else if (factory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys);\n\t\t\toutputData = amounts.map((a) => factory(a, keyset));\n\t\t} else {\n\t\t\toutputData = OutputData.createRandomData(amount, keyset, outputAmounts);\n\t\t}\n\t\treturn outputData;\n\t}\n\n\t/**\n\t * Creates NUT-08 blank outputs (fee returns) for a given fee reserve See:\n\t * https://github.com/cashubtc/nuts/blob/main/08.md.\n\t *\n\t * @param amount Amount to cover with blank outputs.\n\t * @param keysetId Mint keysetId.\n\t * @param counter? Optionally set counter to derive secret deterministically. CashuWallet class\n\t *   must be initialized with seed phrase to take effect.\n\t * @returns Blinded messages, secrets, and rs.\n\t */\n\tprivate createBlankOutputs(\n\t\tamount: number,\n\t\tkeyset: MintKeys,\n\t\tcounter?: number,\n\t\tfactory?: OutputDataFactory,\n\t): OutputDataLike[] {\n\t\tlet count = Math.ceil(Math.log2(amount)) || 1;\n\t\t//Prevent count from being -Infinity\n\t\tif (count < 0) {\n\t\t\tcount = 0;\n\t\t}\n\t\t// Note: zero amount + zero denomination passes splitAmount validation\n\t\tconst zeros = count ? Array(count).fill(0) : [];\n\t\treturn this.createOutputData(0, keyset, counter, undefined, zeros, undefined, factory);\n\t}\n\n\t/**\n\t * Mints proofs for a given mint quote created with the bolt11 or bolt12 method.\n\t *\n\t * @param method Payment method of the quote.\n\t * @param amount Amount to mint.\n\t * @param quote The bolt11 or bolt12 mint quote.\n\t * @param options Optional parameters for configuring the Mint Proof operation.\n\t * @returns Proofs.\n\t */\n\tprivate async _mintProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tamount: number,\n\t\tquote: string | (T extends 'bolt11' ? MintQuoteResponse : Bolt12MintQuoteResponse),\n\t\toptions?: MintProofOptions & { privateKey?: string },\n\t): Promise<Proof[]> {\n\t\tlet { outputAmounts } = options || {};\n\t\tconst { counter, pubkey, p2pk, keysetId, proofsWeHave, outputData, privateKey } = options || {};\n\n\t\tconst keyset = await this.getKeys(keysetId);\n\t\tif (!outputAmounts && proofsWeHave) {\n\t\t\toutputAmounts = {\n\t\t\t\tkeepAmounts: getKeepAmounts(proofsWeHave, amount, keyset.keys, this._denominationTarget),\n\t\t\t\tsendAmounts: [],\n\t\t\t};\n\t\t}\n\t\tlet newBlindingData: OutputData[] = [];\n\t\tif (outputData) {\n\t\t\tif (isOutputDataFactory(outputData)) {\n\t\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\t\tnewBlindingData.push(outputData(amounts[i], keyset));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewBlindingData = outputData;\n\t\t\t}\n\t\t} else if (this._keepFactory) {\n\t\t\tconst amounts = splitAmount(amount, keyset.keys, outputAmounts?.keepAmounts);\n\t\t\tfor (let i = 0; i < amounts.length; i++) {\n\t\t\t\tnewBlindingData.push(this._keepFactory(amounts[i], keyset));\n\t\t\t}\n\t\t} else {\n\t\t\tnewBlindingData = this.createOutputData(\n\t\t\t\tamount,\n\t\t\t\tkeyset,\n\t\t\t\tcounter,\n\t\t\t\tpubkey,\n\t\t\t\toutputAmounts?.keepAmounts,\n\t\t\t\tp2pk,\n\t\t\t);\n\t\t}\n\t\tconst blindedMessages = newBlindingData.map((d) => d.blindedMessage);\n\t\tconst mintPayload: MintPayload = {\n\t\t\toutputs: blindedMessages,\n\t\t\tquote: typeof quote === 'string' ? quote : quote.quote,\n\t\t};\n\t\tif (typeof quote !== 'string' && quote.pubkey) {\n\t\t\tif (!privateKey) {\n\t\t\t\tthrow new Error('Can not sign locked quote without private key');\n\t\t\t}\n\t\t\tmintPayload.signature = signMintQuote(privateKey, quote.quote, blindedMessages);\n\t\t}\n\t\tif (method === 'bolt12') {\n\t\t\tconst { signatures } = await this.mint.mintBolt12(mintPayload);\n\t\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\t}\n\t\tconst { signatures } = await this.mint.mint(mintPayload);\n\t\treturn newBlindingData.map((d, i) => d.toProof(signatures[i], keyset));\n\t}\n\n\t/**\n\t * Melt proofs for a given melt quote created with the bolt11 or bolt12 method.\n\t *\n\t * @param method Payment method of the quote.\n\t * @param meltQuote The bolt11 or bolt12 melt quote.\n\t * @param proofsToSend Proofs to melt.\n\t * @param options Optional parameters for configuring the Melting Proof operation.\n\t * @returns Melt quote and change proofs.\n\t */\n\tprivate async _meltProofs<T extends 'bolt11' | 'bolt12'>(\n\t\tmethod: T,\n\t\tmeltQuote: T extends 'bolt11' ? MeltQuoteResponse : Bolt12MeltQuoteResponse,\n\t\tproofsToSend: Proof[],\n\t\toptions?: MeltProofOptions,\n\t): Promise<MeltProofsResponse> {\n\t\tconst { keysetId, counter, privkey } = options || {};\n\t\tconst keys = await this.getKeys(keysetId);\n\t\tconst outputData = this.createBlankOutputs(\n\t\t\tsumProofs(proofsToSend) - meltQuote.amount,\n\t\t\tkeys,\n\t\t\tcounter,\n\t\t\tthis._keepFactory,\n\t\t);\n\t\tif (privkey != undefined) {\n\t\t\tproofsToSend = signP2PKProofs(proofsToSend, privkey);\n\t\t}\n\n\t\tproofsToSend = stripDleq(proofsToSend);\n\n\t\t// Ensure witnesses are serialized before sending to mint\n\t\tproofsToSend = proofsToSend.map((p: Proof) => {\n\t\t\tconst witness =\n\t\t\t\tp.witness && typeof p.witness !== 'string' ? JSON.stringify(p.witness) : p.witness;\n\t\t\treturn { ...p, witness };\n\t\t});\n\n\t\tconst meltPayload: MeltPayload = {\n\t\t\tquote: meltQuote.quote,\n\t\t\tinputs: proofsToSend,\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tif (method === 'bolt12') {\n\t\t\tconst meltResponse = await this.mint.meltBolt12(meltPayload);\n\t\t\treturn {\n\t\t\t\tquote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request },\n\t\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? [],\n\t\t\t};\n\t\t}\n\t\tconst meltResponse = await this.mint.melt(meltPayload);\n\t\treturn {\n\t\t\tquote: { ...meltResponse, unit: meltQuote.unit, request: meltQuote.request },\n\t\t\tchange: meltResponse.change?.map((s, i) => outputData[i].toProof(s, keys)) ?? [],\n\t\t};\n\t}\n}\n\nexport { CashuWallet };\n","import {\n\ttype BlindAuthMintPayload,\n\ttype BlindAuthMintResponse,\n\ttype MintActiveKeys,\n\ttype MintAllKeysets,\n} from '../model/types';\nimport request from '../request';\nimport { isObj, joinUrls, sanitizeUrl } from '../utils';\n\n/**\n * Class represents Cashu Auth Mint API. This class contains Lower level functions that are\n * implemented by CashuAuthWallet.\n */\nclass CashuAuthMint {\n\t/**\n\t * @param _mintUrl Requires mint URL to create this object.\n\t * @param _customRequest If passed, use custom request implementation for network communication\n\t *   with the mint.\n\t */\n\tconstructor(\n\t\tprivate _mintUrl: string,\n\t\tprivate _customRequest?: typeof request,\n\t) {\n\t\tthis._mintUrl = sanitizeUrl(_mintUrl);\n\t\tthis._customRequest = _customRequest;\n\t}\n\n\tget mintUrl() {\n\t\treturn this._mintUrl;\n\t}\n\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintUrl\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @param customRequest\n\t * @returns Serialized blinded signatures.\n\t */\n\tpublic static async mint(\n\t\tmintUrl: string,\n\t\tmintPayload: BlindAuthMintPayload,\n\t\tclearAuthToken: string,\n\t\tcustomRequest?: typeof request,\n\t) {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst headers = {\n\t\t\t'Clear-auth': `${clearAuthToken}`,\n\t\t};\n\t\tconst data = await requestInstance<BlindAuthMintResponse>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/mint'),\n\t\t\tmethod: 'POST',\n\t\t\trequestBody: mintPayload,\n\t\t\theaders,\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data?.signatures)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Mints new Blinded Authentication tokens by requesting blind signatures on the provided outputs.\n\t *\n\t * @param mintPayload Payload containing the outputs to get blind signatures on.\n\t * @param clearAuthToken A NUT-21 clear auth token.\n\t * @returns Serialized blinded signatures.\n\t */\n\tasync mint(mintPayload: BlindAuthMintPayload, clearAuthToken: string) {\n\t\treturn CashuAuthMint.mint(this._mintUrl, mintPayload, clearAuthToken, this._customRequest);\n\t}\n\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param mintUrl\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @param customRequest\n\t * @returns\n\t */\n\tpublic static async getKeys(\n\t\tmintUrl: string,\n\t\tkeysetId?: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintActiveKeys> {\n\t\tconst requestInstance = customRequest || request;\n\t\tconst data = await requestInstance<MintActiveKeys>({\n\t\t\tendpoint: keysetId\n\t\t\t\t? joinUrls(mintUrl, '/v1/auth/blind/keys', keysetId)\n\t\t\t\t: joinUrls(mintUrl, '/v1/auth/blind/keys'),\n\t\t});\n\n\t\tif (!isObj(data) || !Array.isArray(data.keysets)) {\n\t\t\tthrow new Error('bad response');\n\t\t}\n\n\t\treturn data;\n\t}\n\t/**\n\t * Get the mints public NUT-22 keys.\n\t *\n\t * @param keysetId Optional param to get the keys for a specific keyset. If not specified, the\n\t *   keys from all active keysets are fetched.\n\t * @returns The mints public keys.\n\t */\n\tasync getKeys(keysetId?: string, mintUrl?: string): Promise<MintActiveKeys> {\n\t\tconst allKeys = await CashuAuthMint.getKeys(\n\t\t\tmintUrl || this._mintUrl,\n\t\t\tkeysetId,\n\t\t\tthis._customRequest,\n\t\t);\n\t\treturn allKeys;\n\t}\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @param mintUrl\n\t * @param customRequest\n\t * @returns All the mints past and current keysets.\n\t */\n\tpublic static async getKeySets(\n\t\tmintUrl: string,\n\t\tcustomRequest?: typeof request,\n\t): Promise<MintAllKeysets> {\n\t\tconst requestInstance = customRequest || request;\n\t\treturn requestInstance<MintAllKeysets>({\n\t\t\tendpoint: joinUrls(mintUrl, '/v1/auth/blind/keysets'),\n\t\t});\n\t}\n\n\t/**\n\t * Get the mints NUT-22 keysets in no specific order.\n\t *\n\t * @returns All the mints past and current keysets.\n\t */\n\tasync getKeySets(): Promise<MintAllKeysets> {\n\t\treturn CashuAuthMint.getKeySets(this._mintUrl, this._customRequest);\n\t}\n}\n\nexport { CashuAuthMint };\n","import { OutputData } from '../model/OutputData';\nimport {\n\ttype BlindAuthMintPayload,\n\ttype MintKeys,\n\ttype MintKeyset,\n\ttype Proof,\n} from '../model/types';\nimport { hasValidDleq } from '../utils';\nimport { type CashuAuthMint } from './CashuAuthMint';\n\n/**\n * Class that represents a Cashu NUT-22 wallet.\n */\nclass CashuAuthWallet {\n\tprivate _keys: Map<string, MintKeys> = new Map();\n\tprivate _keysetId: string | undefined;\n\tprivate _keysets: MintKeyset[] = [];\n\tprivate _unit = 'auth';\n\n\tmint: CashuAuthMint;\n\n\t/**\n\t * @param mint NUT-22 auth mint instance.\n\t * @param options.keys Public keys from the mint (will be fetched from mint if not provided)\n\t * @param options.keysets Keysets from the mint (will be fetched from mint if not provided)\n\t */\n\tconstructor(\n\t\tmint: CashuAuthMint,\n\t\toptions?: {\n\t\t\tkeys?: MintKeys[] | MintKeys;\n\t\t\tkeysets?: MintKeyset[];\n\t\t},\n\t) {\n\t\tthis.mint = mint;\n\t\tlet keys: MintKeys[] = [];\n\t\tif (options?.keys && !Array.isArray(options.keys)) {\n\t\t\tkeys = [options.keys];\n\t\t} else if (options?.keys && Array.isArray(options?.keys)) {\n\t\t\tkeys = options?.keys;\n\t\t}\n\t\tif (keys) keys.forEach((key: MintKeys) => this._keys.set(key.id, key));\n\t\tif (options?.keysets) this._keysets = options.keysets;\n\t}\n\n\tget keys(): Map<string, MintKeys> {\n\t\treturn this._keys;\n\t}\n\tget keysetId(): string {\n\t\tif (!this._keysetId) {\n\t\t\tthrow new Error('No keysetId set');\n\t\t}\n\t\treturn this._keysetId;\n\t}\n\tset keysetId(keysetId: string) {\n\t\tthis._keysetId = keysetId;\n\t}\n\tget keysets(): MintKeyset[] {\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Load mint information, keysets and keys. This function can be called if no keysets are passed\n\t * in the constructor.\n\t */\n\tasync loadMint() {\n\t\tawait this.getKeySets();\n\t\tawait this.getKeys();\n\t}\n\n\t/**\n\t * Choose a keyset to activate based on the lowest input fee.\n\t *\n\t * Note: this function will filter out deprecated base64 keysets.\n\t *\n\t * @param keysets Keysets to choose from.\n\t * @returns Active keyset.\n\t */\n\tgetActiveKeyset(keysets: MintKeyset[]): MintKeyset {\n\t\tlet activeKeysets = keysets.filter((k: MintKeyset) => k.active);\n\n\t\t// we only consider keyset IDs that start with \"00\"\n\t\tactiveKeysets = activeKeysets.filter((k: MintKeyset) => k.id.startsWith('00'));\n\n\t\tconst activeKeyset = activeKeysets.sort(\n\t\t\t(a: MintKeyset, b: MintKeyset) => (a.input_fee_ppk ?? 0) - (b.input_fee_ppk ?? 0),\n\t\t)[0];\n\t\tif (!activeKeyset) {\n\t\t\tthrow new Error('No active keyset found');\n\t\t}\n\t\treturn activeKeyset;\n\t}\n\n\t/**\n\t * Get keysets from the mint with the unit of the wallet.\n\t *\n\t * @returns Keysets with wallet's unit.\n\t */\n\tasync getKeySets(): Promise<MintKeyset[]> {\n\t\tconst allKeysets = await this.mint.getKeySets();\n\t\tconst unitKeysets = allKeysets.keysets.filter((k: MintKeyset) => k.unit === this._unit);\n\t\tthis._keysets = unitKeysets;\n\t\treturn this._keysets;\n\t}\n\n\t/**\n\t * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet\n\t * keyset.\n\t *\n\t * @returns Keyset.\n\t */\n\tasync getAllKeys(): Promise<MintKeys[]> {\n\t\tconst keysets = await this.mint.getKeys();\n\t\tthis._keys = new Map(keysets.keysets.map((k: MintKeys) => [k.id, k]));\n\t\tthis.keysetId = this.getActiveKeyset(this._keysets).id;\n\t\treturn keysets.keysets;\n\t}\n\n\t/**\n\t * Get public keys from the mint. If keys were already fetched, it will return those.\n\t *\n\t * If `keysetId` is set, it will fetch and return that specific keyset. Otherwise, we select an\n\t * active keyset with the unit of the wallet.\n\t *\n\t * @param keysetId Optional keysetId to get keys for.\n\t * @param forceRefresh? If set to true, it will force refresh the keyset from the mint.\n\t * @returns Keyset.\n\t */\n\tasync getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys> {\n\t\tif (!(this._keysets.length > 0) || forceRefresh) {\n\t\t\tawait this.getKeySets();\n\t\t}\n\t\t// no keyset id is chosen, let's choose one\n\t\tif (!keysetId) {\n\t\t\tconst localKeyset = this.getActiveKeyset(this._keysets);\n\t\t\tkeysetId = localKeyset.id;\n\t\t}\n\t\t// make sure we have keyset for this id\n\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\tawait this.getKeySets();\n\t\t\tif (!this._keysets.find((k: MintKeyset) => k.id === keysetId)) {\n\t\t\t\tthrow new Error(`could not initialize keys. No keyset with id '${keysetId}' found`);\n\t\t\t}\n\t\t}\n\n\t\t// make sure we have keys for this id\n\t\tif (!this._keys.get(keysetId)) {\n\t\t\tconst keys = await this.mint.getKeys(keysetId);\n\t\t\tthis._keys.set(keysetId, keys.keysets[0]);\n\t\t}\n\n\t\t// set and return\n\t\tthis.keysetId = keysetId;\n\t\treturn this._keys.get(keysetId) as MintKeys;\n\t}\n\n\t/**\n\t * Mint proofs for a given mint quote.\n\t *\n\t * @param amount Amount to request.\n\t * @param clearAuthToken ClearAuthToken to mint.\n\t * @param options.keysetId? Optionally set keysetId for blank outputs for returned change.\n\t * @returns Proofs.\n\t */\n\tasync mintProofs(\n\t\tamount: number,\n\t\tclearAuthToken: string,\n\t\toptions?: {\n\t\t\tkeysetId?: string;\n\t\t},\n\t): Promise<Proof[]> {\n\t\tconst keyset = await this.getKeys(options?.keysetId);\n\t\tconst outputData = OutputData.createRandomData(amount, keyset);\n\n\t\tconst mintPayload: BlindAuthMintPayload = {\n\t\t\toutputs: outputData.map((d) => d.blindedMessage),\n\t\t};\n\t\tconst { signatures } = await this.mint.mint(mintPayload, clearAuthToken);\n\t\tconst authProofs = outputData.map((d, i) => d.toProof(signatures[i], keyset));\n\t\tif (authProofs.some((p) => !hasValidDleq(p, keyset))) {\n\t\t\tthrow new Error('Mint returned auth proofs with invalid DLEQ');\n\t\t}\n\t\treturn authProofs;\n\t}\n}\n\nexport { CashuAuthWallet };\n","import { CashuAuthMint } from './CashuAuthMint';\nimport { CashuAuthWallet } from './CashuAuthWallet';\nimport { encodeJsonToBase64 } from '../base64';\nimport { type Proof } from '../model/types';\n\n/**\n * Helper function to encode a cashu auth token authA.\n *\n * @param proof\n */\nexport function getEncodedAuthToken(proof: Proof): string {\n\tconst token = {\n\t\tid: proof.id,\n\t\tsecret: proof.secret,\n\t\tC: proof.C,\n\t};\n\tconst base64Data = encodeJsonToBase64(token);\n\tconst prefix = 'auth';\n\tconst version = 'A';\n\treturn prefix + version + base64Data;\n}\n\nexport async function getBlindedAuthToken(amount: number, url: string, clearAuthToken: string) {\n\tconst authMint = new CashuAuthMint(url);\n\tconst authWallet = new CashuAuthWallet(authMint);\n\tconst authProofs = await authWallet.mintProofs(amount, clearAuthToken);\n\treturn authProofs.map((p) => getEncodedAuthToken(p));\n}\n\nexport { CashuAuthMint, CashuAuthWallet };\n"],"names":["isResultKeyType","value","encodeCBOR","buffer","encodeItem","encodeUnsigned","encodeString","encodeArray","encodeByteString","encodeObject","length","i","utf8","item","keys","key","decodeCBOR","data","view","decodeItem","offset","initialByte","majorType","additionalInfo","decodeUnsigned","decodeSigned","decodeByteString","decodeString","decodeArray","decodeMap","decodeSimpleAndFloat","decodeLength","hi","lo","newOffset","bytes","array","currentOffset","result","map","keyResult","valueResult","decodeFloat16","uint16","exponent","fraction","sign","PaymentRequest","transport","id","amount","unit","mints","description","singleUse","nut10","rawRequest","t","Bytes","type","rawPaymentRequest","transports","encodedRequest","encodedData","encodeBase64toUint8","decoded","TOKEN_VERSION","TOKEN_PREFIX","splitAmount","keyset","split","order","totalSplitAmount","sumArray","positive","amt","totalPositive","hasCorrespondingKey","sortedKeyAmounts","getKeysetAmounts","q","a","b","getKeepAmounts","proofsWeHave","amountToKeep","targetCount","amountsWeWant","amountsWeHave","p","countWeHave","countWeWant","amountDiff","k","bytesToNumber","hexToNumber","bytesToHex","hex","numberToHexPadded64","number","isValidHex","str","hasNonHexId","proof","getEncodedTokenV3","token","removeDleq","convertToShortKeysetId","stripDleq","v3TokenObj","encodeJsonToBase64","proofs","newP","getEncodedToken","opts","getEncodedTokenV4","tokenTemplate","templateFromToken","prefix","version","base64Data","encodeUint8toBase64Url","idMap","mint","hexToBytes","tokenFromTemplate","template","decodedToken","getDecodedToken","tokenString","keysets","removePrefix","handleTokens","mapShortKeysetIds","getTokenMetadata","tokenObj","sumProofs","encodedToken","parsedV3Token","encodeBase64ToJson","entry","uInt8Token","tokenData","deriveKeysetId","expiry","versionByte","isDeprecatedBase64","pubkeysConcat","pubKey","prev","curr","hash","sha256","mergeUInt8Arrays","hashHex","a1","a2","mergedArray","isObj","v","joinUrls","parts","part","sanitizeUrl","url","acc","decodePaymentRequest","paymentRequest","MessageNode","message","node","MessageQueue","messageNode","newNode","verifyKeysetId","isBase64","isBase64String","newProofs","idBytes","found","hasValidDleq","dleq","verifyDLEQProof_reblind","pointFromHex","concatByteArrays","arrays","totalLength","c","byteArray","pointer","getEncodedTokenBinary","utf8Encoder","binaryTemplate","getDecodedTokenBinary","utfDecoder","binaryToken","arr","_WS","injectWebSocketImpl","ws","getWebSocketImpl","LogLevel","NULL_LOGGER","_ConsoleLogger","minLevel","level","context","levelPrefix","interpolatedMessage","usedKeys","processedContext","match","filteredContext","consoleMethod","ConsoleLogger","measureTime","start","ConnectionManager","logger","newConn","WSConnection","resolve","reject","err","e","cb","method","params","subId","callback","errorCallback","fn","parsed","notification","CheckStateEnum","MeltQuoteState","MintQuoteState","PaymentRequestTransportType","HttpResponseError","status","NetworkError","MintOperationError","code","detail","globalRequestOptions","requestLogger","setGlobalRequestOptions","options","setRequestLogger","_request","endpoint","requestBody","requestHeaders","body","headers","response","errorData","errorMessage","request","handleMeltQuoteResponseDeprecated","handleMintQuoteResponseDeprecated","handleMintInfoContactFieldDeprecated","contact","MintInfo","info","o","num","path","isProtectedEndpoint","mintMeltInfo","CashuMint","_mintUrl","_customRequest","authTokenGetter","mintUrl","customRequest","mintLogger","swapPayload","blindAuthToken","requestInstance","mintQuotePayload","quote","mintPayload","meltQuotePayload","meltPayload","checkPayload","keysetId","restorePayload","wsSegment","BlindedMessage","B_","isOutputDataFactory","RESERVED_P2PK_TAGS","MAX_SECRET_LENGTH","OutputData","blindedMessage","blidingFactor","secret","sig","blindSignature","A","constructProofFromPromise","serializeProof","p2pk","customSplit","lockKeys","refundKeys","reqLock","reqRefund","pubkeys","refund","tags","ts","normalized","vals","newSecret","randomBytes","charCount","secretBytes","r","blindMessage","randomHex","seed","counter","deriveSecret","secretBytesAsHex","utf8SecretBytes","deterministicR","deriveBlindingFactor","DEFAULT_DENOMINATION_TARGET","DEFAULT_UNIT","CashuWallet","infoRes","activeKeysets","activeKeyset","unitKeysets","forceRefresh","requireDleq","outputAmounts","pubkey","privkey","outputData","newOutputData","swapTransaction","signatures","d","orderedProofs","s","offline","includeFees","includeDleq","keepProofsOffline","sendProofOffline","expectedFee","sendRes","keep","send","serialized","amountToSend","timer","bestSubset","bestDelta","bestAmount","bestFeePPK","sumExFees","feePPK","shuffleArray","shuffled","j","binarySearchIndex","lessOrEqual","left","right","mid","midValue","insertSorted","obj","calculateDelta","totalAmount","totalFeePPK","proofWithFees","ppkfee","exFee","spendableProofs","endIndex","biggerIndex","nextBiggerExFee","rightIndex","totalNetSum","maxOverAmount","trial","S","newAmount","newFeePPK","netSum","SSet","others","indices","_","objP","tempAmount","tempFeePPK","tempNetSum","target","qIndex","objQ","delta","tempS","tempDelta","bestSum","bestProofs","bestSubsetSet","sumPPK","nInputs","amountAvailable","sendAmounts","outputFee","sendAmountsFee","keepProofs","sendProofs","keepAmounts","keepOutputData","sendOutputData","swapProofs","splitProofsToKeep","splitProofsToSend","reorderedKeepVector","reorderedProofs","gapLimit","batchSize","requiredEmptyBatches","restoredProofs","lastCounterWithSignature","emptyBatchesFound","restoreRes","count","zeros","outputs","signatureMap","matchingSig","res","supported","mintInfo","quoteId","baseRes","privateKey","invoice","meltQuote","offer","amountMsat","millisatPartialAmount","meltOptions","proofsToSend","customOutputData","total","keepAmount","factory","signP2PKProofs","witness","mergedBlindingData","keepVector","sortedOutputData","sortedKeepVector","enc","Ys","hashToCurve","BATCH_SIZE","states","YsSlice","batchStates","stateMap","state","quoteIds","proofMap","y","ys","newBlindingData","amounts","blindedMessages","signMintQuote","meltResponse","CashuAuthMint","clearAuthToken","CashuAuthWallet","authProofs","getEncodedAuthToken","getBlindedAuthToken","authMint"],"mappings":"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","debugId":null}}]
}