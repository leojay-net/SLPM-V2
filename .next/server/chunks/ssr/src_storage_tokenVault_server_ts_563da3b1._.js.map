{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mac/Desktop/CODE/SLPM-enhanced/src/storage/tokenVault.server.ts"],"sourcesContent":["// Server-only token vault for persisting Cashu tokens by quoteId\n// Storage backend: JSON file under .data/cashu-tokens.json\n\nimport { promises as fs } from 'fs';\nimport path from 'path';\n\nexport interface StoredTokenRecord {\n    quote: string;\n    token: string;\n    mintUrl: string;\n    amountSats: number;\n    proofsCount?: number;\n    createdAt: number; // epoch ms\n}\n\ninterface VaultFileShape {\n    version: number;\n    records: Record<string, StoredTokenRecord>; // keyed by quote\n}\n\nconst DATA_DIR = path.join(process.cwd(), '.data');\nconst VAULT_FILE = path.join(DATA_DIR, 'cashu-tokens.json');\n\nasync function ensureDir(): Promise<void> {\n    try {\n        await fs.mkdir(DATA_DIR, { recursive: true });\n    } catch (_) {\n        // ignore\n    }\n}\n\nasync function loadFile(): Promise<VaultFileShape> {\n    await ensureDir();\n    try {\n        const raw = await fs.readFile(VAULT_FILE, 'utf8');\n        const parsed = JSON.parse(raw);\n        if (parsed && typeof parsed === 'object' && parsed.records) {\n            return { version: parsed.version || 1, records: parsed.records };\n        }\n    } catch (_) { }\n    return { version: 1, records: {} };\n}\n\nasync function saveFile(data: VaultFileShape): Promise<void> {\n    const content = JSON.stringify(data, null, 2);\n    await fs.writeFile(VAULT_FILE, content, 'utf8');\n}\n\nconst TokenVault = {\n    async get(quote: string): Promise<StoredTokenRecord | null> {\n        const data = await loadFile();\n        return data.records[quote] || null;\n    },\n\n    async set(record: StoredTokenRecord): Promise<void> {\n        const data = await loadFile();\n        data.records[record.quote] = record;\n        await saveFile(data);\n    },\n\n    async has(quote: string): Promise<boolean> {\n        const rec = await this.get(quote);\n        return !!rec;\n    },\n\n    async list(limit = 100): Promise<StoredTokenRecord[]> {\n        const data = await loadFile();\n        const all = Object.values(data.records);\n        all.sort((a, b) => b.createdAt - a.createdAt);\n        return all.slice(0, limit);\n    }\n};\n\nexport default TokenVault;\n"],"names":[],"mappings":"AAAA,iEAAiE;AACjE,2DAA2D;;;;;AAE3D;AACA;;;AAgBA,MAAM,WAAW,4GAAI,CAAC,IAAI,CAAC,QAAQ,GAAG,IAAI;AAC1C,MAAM,aAAa,4GAAI,CAAC,IAAI,CAAC,UAAU;AAEvC,eAAe;IACX,IAAI;QACA,MAAM,yGAAE,CAAC,KAAK,CAAC,UAAU;YAAE,WAAW;QAAK;IAC/C,EAAE,OAAO,GAAG;IACR,SAAS;IACb;AACJ;AAEA,eAAe;IACX,MAAM;IACN,IAAI;QACA,MAAM,MAAM,MAAM,yGAAE,CAAC,QAAQ,CAAC,YAAY;QAC1C,MAAM,SAAS,KAAK,KAAK,CAAC;QAC1B,IAAI,UAAU,OAAO,WAAW,YAAY,OAAO,OAAO,EAAE;YACxD,OAAO;gBAAE,SAAS,OAAO,OAAO,IAAI;gBAAG,SAAS,OAAO,OAAO;YAAC;QACnE;IACJ,EAAE,OAAO,GAAG,CAAE;IACd,OAAO;QAAE,SAAS;QAAG,SAAS,CAAC;IAAE;AACrC;AAEA,eAAe,SAAS,IAAoB;IACxC,MAAM,UAAU,KAAK,SAAS,CAAC,MAAM,MAAM;IAC3C,MAAM,yGAAE,CAAC,SAAS,CAAC,YAAY,SAAS;AAC5C;AAEA,MAAM,aAAa;IACf,MAAM,KAAI,KAAa;QACnB,MAAM,OAAO,MAAM;QACnB,OAAO,KAAK,OAAO,CAAC,MAAM,IAAI;IAClC;IAEA,MAAM,KAAI,MAAyB;QAC/B,MAAM,OAAO,MAAM;QACnB,KAAK,OAAO,CAAC,OAAO,KAAK,CAAC,GAAG;QAC7B,MAAM,SAAS;IACnB;IAEA,MAAM,KAAI,KAAa;QACnB,MAAM,MAAM,MAAM,IAAI,CAAC,GAAG,CAAC;QAC3B,OAAO,CAAC,CAAC;IACb;IAEA,MAAM,MAAK,QAAQ,GAAG;QAClB,MAAM,OAAO,MAAM;QACnB,MAAM,MAAM,OAAO,MAAM,CAAC,KAAK,OAAO;QACtC,IAAI,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,SAAS,GAAG,EAAE,SAAS;QAC5C,OAAO,IAAI,KAAK,CAAC,GAAG;IACxB;AACJ;uCAEe","debugId":null}}]
}