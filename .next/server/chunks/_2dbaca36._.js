module.exports=[742396,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.OutOfBoundsError=r.RequestError=void 0;class i extends Error{constructor(t,e){try{let e=JSON.parse(t);null!=e.msg&&(t=e.msg)}catch(t){}super(t),Object.setPrototypeOf(this,i.prototype),this.httpCode=e}static parse(t,e){try{let r=JSON.parse(t);if(t=r.msg,20003===r.code||20004===r.code)return new n(r.msg,e,BigInt(r.data.min),BigInt(r.data.max))}catch(t){}return new i(t,e)}}r.RequestError=i;class n extends i{constructor(t,e,r,i){super(t,e),this.max=i,this.min=r,Object.setPrototypeOf(this,n.prototype)}}r.OutOfBoundsError=n},389215,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.randomBytes=r.toCoinselectAddressType=r.toOutputScript=r.bigIntCompare=r.bigIntMax=r.bigIntMin=r.timeoutSignal=r.timeoutPromise=r.httpPost=r.httpGet=r.fetchWithTimeout=r.tryWithRetries=r.extendAbortController=r.mapToArray=r.objectMap=r.promiseAny=r.getLogger=void 0;let i=t.r(742396),n=t.r(500874),a=t.r(839596),s=t.r(697858);function o(t){return"function"==typeof t&&null!=t.prototype&&t.prototype.constructor===t}function l(e){return{debug:(r,...i)=>t.g.atomiqLogLevel>=3&&console.debug(e+r,...i),info:(r,...i)=>t.g.atomiqLogLevel>=2&&console.info(e+r,...i),warn:(r,...i)=>(null==t.g.atomiqLogLevel||t.g.atomiqLogLevel>=1)&&console.warn(e+r,...i),error:(r,...i)=>(null==t.g.atomiqLogLevel||t.g.atomiqLogLevel>=0)&&console.error(e+r,...i)}}r.getLogger=l;let u=l("Utils: ");function c(t,e){return null==e&&(e={}),null!=e.timeout&&(e.signal=p(e.timeout,Error("Network request timed out"),e.signal)),fetch(t,e).catch(t=>{if("AbortError"===t.name)throw e.signal.reason;throw t})}function h(t,e){return new Promise((r,i)=>{let n;if(null!=e&&e.aborted)return void i(e.reason);let a=setTimeout(()=>{null!=n&&e.removeEventListener("abort",n),r()},t);null!=e&&e.addEventListener("abort",n=()=>{null!=a&&clearTimeout(a),a=null,i(e.reason)})})}function p(t,e,r){if(null==t)return r;let i=new AbortController,n=setTimeout(()=>i.abort(e||Error("Timed out")),t);return null!=r&&r.addEventListener("abort",()=>{clearTimeout(n),i.abort(r.reason)}),i.signal}r.promiseAny=function(t){return new Promise((e,r)=>{let i=0,n=Array(t.length);t.forEach((a,s)=>{a.then(t=>{null!=e&&e(t),e=null}).catch(e=>{n[s]=e,++i===t.length&&r(n)})})})},r.objectMap=function(t,e){let r={};for(let i in t)r[i]=e(t[i],i);return r},r.mapToArray=function(t,e){let r=Array(t.size),i=0;for(let n of t.entries())r[i++]=e(n[0],n[1]);return r},r.extendAbortController=function(t){let e=new AbortController;return null!=t&&(t.throwIfAborted(),t.onabort=()=>e.abort(t.reason)),e},r.tryWithRetries=async function(t,e,r,i){(e=e||{}).maxRetries=e.maxRetries||5,e.delay=e.delay||500,e.exponential=null==e.exponential||e.exponential;let n=null;for(let a=0;a<e.maxRetries;a++){try{return await t(a)}catch(t){if(null!=r&&function(t,e){return Array.isArray(e)&&e.every(o)?null!=e.find(e=>t instanceof e):o(e)?t instanceof e:e(t)}(t,r))throw t;n=t,u.warn("tryWithRetries(): Error on try number: "+a,t)}if(null!=i&&i.aborted)throw i.reason||Error("Aborted");a!==e.maxRetries-1&&await h(e.exponential?e.delay*Math.pow(2,a):e.delay,i)}throw n},r.fetchWithTimeout=c,r.httpGet=async function(t,e,r,n=!1){let a=await c(t,{method:"GET",timeout:e,signal:r});if(200!==a.status){let t;try{t=await a.text()}catch(t){throw new i.RequestError(a.statusText,a.status)}if(n)try{return JSON.parse(t)}catch(t){}throw i.RequestError.parse(t,a.status)}return await a.json()},r.httpPost=async function(t,e,r,n){let a={method:"POST",timeout:r,body:JSON.stringify(e),headers:{"Content-Type":"application/json"},signal:n},s=null==r?await fetch(t,a):await c(t,a);if(200!==s.status){let t;try{t=await s.text()}catch(t){throw new i.RequestError(s.statusText,s.status)}throw i.RequestError.parse(t,s.status)}return await s.json()},r.timeoutPromise=h,r.timeoutSignal=p,r.bigIntMin=function(t,e){return t>e?e:t},r.bigIntMax=function(t,e){return e>t?e:t},r.bigIntCompare=function(t,e){return t>e?1:t===e?0:-1},r.toOutputScript=function(t,e){let r=(0,a.Address)(t).decode(e);switch(r.type){case"pkh":case"sh":case"wpkh":case"wsh":return n.Buffer.from(a.OutScript.encode({type:r.type,hash:r.hash}));case"tr":return n.Buffer.from(a.OutScript.encode({type:"tr",pubkey:r.pubkey}))}},r.toCoinselectAddressType=function(t){switch(a.OutScript.decode(t).type){case"pkh":return"p2pkh";case"sh":return"p2sh-p2wpkh";case"wpkh":return"p2wpkh";case"wsh":return"p2wsh";case"tr":return"p2tr"}throw Error("Unrecognized address type!")},r.randomBytes=function(t){return n.Buffer.from((0,s.randomBytes)(t))}},873547,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.MempoolBtcRelaySynchronizer=void 0;let i=t.r(389215),n=(0,i.getLogger)("MempoolBtcRelaySynchronizer: ");r.MempoolBtcRelaySynchronizer=class{constructor(t,e){this.btcRelay=t,this.bitcoinRpc=e}async syncToLatestTxs(t,e){let r=await this.btcRelay.getTipData(),a={forkId:0,lastStoredHeader:null,tx:null,computedCommitedHeaders:null},{resultStoredHeader:s,resultBitcoinHeader:o}=await this.btcRelay.retrieveLatestKnownBlockLog();a.lastStoredHeader=s,s.getBlockheight()<r.blockheight&&(a.forkId=-1),o.getHash(),n.debug("Retrieved stored header with commitment: ",a.lastStoredHeader),n.debug("SPV tip bitcoin RPC block header: ",o);let l=o.height,u=[],c={[o.getHeight()]:o},h={[s.getBlockheight()]:s},p=null,d=e,f=e,m=async e=>{for(let i of(-1===a.forkId?(null==f&&(f=await this.btcRelay.getMainFeeRate(t)),a=await this.btcRelay.saveNewForkHeaders(t,e,a.lastStoredHeader,r.chainWork,f)):0===a.forkId?(null==f&&(f=await this.btcRelay.getMainFeeRate(t)),a=await this.btcRelay.saveMainHeaders(t,e,a.lastStoredHeader,f)):(null==d&&(d=await this.btcRelay.getForkFeeRate(t,a.forkId)),a=await this.btcRelay.saveForkHeaders(t,e,a.lastStoredHeader,a.forkId,r.chainWork,d)),-1!==a.forkId&&0!==a.forkId&&(p=a.forkId),u.push(a.tx),a.computedCommitedHeaders))h[i.getBlockheight()]=i},g=null,w=[];for(;null==g||g.length>0;){let t=(g=await this.bitcoinRpc.getPast15Blocks(l+15)).findIndex(t=>t.height===l);-1===t&&(t=g.length);for(let e=t-1;e>=0;e--){let t=g[e];c[t.height]=t,w.push(t),(0===a.forkId?w.length>=this.btcRelay.maxHeadersPerTx:w.length>=this.btcRelay.maxForkHeadersPerTx)&&(await m(w),w=[])}if(g.length>0){if(l===g[0].height)break;l=g[0].height,await (0,i.timeoutPromise)(1e3)}}if(w.length>0&&await m(w),0!==a.forkId)throw Error("Unable to synchronize on-chain bitcoin light client! Not enough chainwork at connected RPC.");return{txs:u,targetCommitedHeader:a.lastStoredHeader,blockHeaderMap:c,computedHeaderMap:h,btcRelayTipCommitedHeader:s,btcRelayTipBlockHeader:o,latestBlockHeader:o,startForkId:p}}}},358716,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.MempoolApi=void 0;let i=t.r(500874),n=t.r(389215),a=t.r(742396);r.MempoolApi=class{getOperationalApi(){return this.backends.find(t=>!0===t.operational)}getMaybeOperationalApis(){let t=this.backends.filter(t=>!0===t.operational||null===t.operational);return 0===t.length&&(this.backends.forEach(t=>t.operational=null),t=this.backends),t}async _request(t,e,r,i="GET",s){let o=await (0,n.fetchWithTimeout)(t+e,{method:i,timeout:this.timeout,body:"string"==typeof s?s:JSON.stringify(s)});if(200!==o.status){let t;try{t=await o.text()}catch(t){throw new a.RequestError(o.statusText,o.status)}throw a.RequestError.parse(t,o.status)}return"str"===r?await o.text():await o.json()}async requestFromMaybeOperationalUrls(t,e,r="GET",i){try{return await (0,n.promiseAny)(this.getMaybeOperationalApis().map(n=>(async()=>{try{let a=await this._request(n.url,t,e,r,i);return n.operational=!0,a}catch(t){if(t instanceof a.RequestError&&5!==Math.floor(t.httpCode/100))throw n.operational=!0,t;throw n.operational=!1,t}})()))}catch(t){throw t.find(t=>t instanceof a.RequestError&&5!==Math.floor(t.httpCode/100))||t[0]}}async request(t,e,r="GET",i){return(0,n.tryWithRetries)(()=>{let n=this.getOperationalApi();return null!=n?this._request(n.url,t,e,r,i).catch(s=>{if(s instanceof a.RequestError&&5!==Math.floor(s.httpCode/100))throw s;return n.operational=!1,this.requestFromMaybeOperationalUrls(t,e,r,i)}):this.requestFromMaybeOperationalUrls(t,e,r,i)},null,t=>t instanceof a.RequestError&&5!==Math.floor(t.httpCode/100))}constructor(t,e){Array.isArray(t=t??"https://mempool.space/testnet/api/")?this.backends=t.map(t=>({url:t,operational:null})):this.backends=[{url:t,operational:null}],this.timeout=e}getLNNodeInfo(t){return this.request("v1/lightning/nodes/"+t,"obj").catch(t=>{if("This node does not exist, or our node is not seeing it yet"===t.message)return null;throw t})}getTransaction(t){return this.request("tx/"+t,"obj").catch(t=>{if("Transaction not found"===t.message)return null;throw t})}async getRawTransaction(t){let e=await this.request("tx/"+t+"/hex","str").catch(t=>{if("Transaction not found"===t.message)return null;throw t});return null==e?null:i.Buffer.from(e,"hex")}async getAddressBalances(t){let e=await this.request("address/"+t,"obj"),r=BigInt(e.chain_stats.funded_txo_sum),i=BigInt(e.chain_stats.spent_txo_sum);return{confirmedBalance:r-i,unconfirmedBalance:BigInt(e.mempool_stats.funded_txo_sum)-BigInt(e.mempool_stats.spent_txo_sum)}}getCPFPData(t){return this.request("v1/cpfp/"+t,"obj")}async getAddressUTXOs(t){let e=await this.request("address/"+t+"/utxo","obj");return e.forEach(t=>t.value=BigInt(t.value)),e}getFees(){return this.request("v1/fees/recommended","obj")}getAddressTransactions(t){return this.request("address/"+t+"/txs","obj")}getPendingBlocks(){return this.request("v1/fees/mempool-blocks","obj")}async getTipBlockHeight(){return parseInt(await this.request("blocks/tip/height","str"))}getBlockHeader(t){return this.request("block/"+t,"obj")}getBlockStatus(t){return this.request("block/"+t+"/status","obj")}getTransactionProof(t){return this.request("tx/"+t+"/merkle-proof","obj")}getOutspends(t){return this.request("tx/"+t+"/outspends","obj")}getBlockHash(t){return this.request("block-height/"+t,"str")}getPast15BlockHeaders(t){return this.request("v1/blocks/"+t,"obj")}sendTransaction(t){return this.request("tx","str","POST",t)}}},908332,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.MempoolBitcoinBlock=void 0,r.MempoolBitcoinBlock=class{constructor(t){this.id=t.id,this.height=t.height,this.version=t.version,this.timestamp=t.timestamp,this.tx_count=t.tx_count,this.size=t.size,this.weight=t.weight,this.merkle_root=t.merkle_root,this.previousblockhash=t.previousblockhash,this.mediantime=t.mediantime,this.nonce=t.nonce,this.bits=t.bits,this.difficulty=t.difficulty}getHeight(){return this.height}getHash(){return this.id}getMerkleRoot(){return this.merkle_root}getNbits(){return this.bits}getNonce(){return this.nonce}getPrevBlockhash(){return this.previousblockhash}getTimestamp(){return this.timestamp}getVersion(){return this.version}getChainWork(){throw Error("Unsupported")}}},915293,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.MempoolBitcoinRpc=void 0;let i=t.r(154585),n=t.r(908332),a=t.r(358716),s=t.r(500874),o=t.r(389215),l=t.r(839596),u=t.r(1083);class c{constructor(t){this.api=t instanceof a.MempoolApi?t:new a.MempoolApi(t)}static getTxoHash(t){return s.Buffer.from((0,u.sha256)(s.Buffer.concat([i.BigIntBufferUtils.toBuffer(BigInt(t.value),"le",8),s.Buffer.from(t.scriptpubkey,"hex")])))}async getTimeTillConfirmation(t){let e=await this.api.getPendingBlocks(),r=e.findIndex(e=>e.feeRange[0]<=t);return -1===r||r+1===e.length&&e[e.length-1].blockVSize>1048576?-1:(r+1)*6e5}async getConfirmationDelay(t,e){if(t.confirmations>e)return 0;if(0===t.confirmations){let r=await this.api.getCPFPData(t.txid);if(null==r.effectiveFeePerVsize)return null;let i=await this.getTimeTillConfirmation(r.effectiveFeePerVsize);return -1!==i&&(i+=(e-1)*6e5),i}return(e-t.confirmations)*6e5}async toBtcTx(t,e=!0){let r,i=e?await this.api.getRawTransaction(t.txid):null,n=0;if(null!=t.status&&t.status.confirmed&&(n=await this.api.getTipBlockHeight()-t.status.block_height+1),null!=i){let t=l.Transaction.fromRaw(i,{allowLegacyWitnessUtxo:!0,allowUnknownInputs:!0,allowUnknownOutputs:!0,disableScriptCheck:!0});r=s.Buffer.from(t.toBytes(!0,!1)).toString("hex")}return{locktime:t.locktime,version:t.version,blockheight:t.status?.block_height,blockhash:t.status?.block_hash,confirmations:n,txid:t.txid,vsize:t.weight/4,hex:r,raw:null==i?null:i.toString("hex"),outs:t.vout.map((t,e)=>({value:t.value,n:e,scriptPubKey:{hex:t.scriptpubkey,asm:t.scriptpubkey_asm}})),ins:t.vin.map(t=>({txid:t.txid,vout:t.vout,scriptSig:{hex:t.scriptsig,asm:t.scriptsig_asm},sequence:t.sequence,txinwitness:t.witness}))}}getTipHeight(){return this.api.getTipBlockHeight()}async getBlockHeader(t){return new n.MempoolBitcoinBlock(await this.api.getBlockHeader(t))}async getMerkleProof(t,e){let r=await this.api.getTransactionProof(t);return{reversedTxId:s.Buffer.from(t,"hex").reverse(),pos:r.pos,merkle:r.merkle.map(t=>s.Buffer.from(t,"hex").reverse()),blockheight:r.block_height}}async getTransaction(t){let e=await this.api.getTransaction(t);return null==e?null:await this.toBtcTx(e)}async isInMainChain(t){return(await this.api.getBlockStatus(t)).in_best_chain}getBlockhash(t){return this.api.getBlockHash(t)}getBlockWithTransactions(t){throw Error("Unsupported.")}async getSyncInfo(){let t=await this.api.getTipBlockHeight();return{verificationProgress:1,blocks:t,headers:t,ibd:!1}}async getPast15Blocks(t){return(await this.api.getPast15BlockHeaders(t)).map(t=>new n.MempoolBitcoinBlock(t))}async checkAddressTxos(t,e){let r=(await this.api.getAddressTransactions(t)).map(t=>({tx:t,vout:t.vout.findIndex(t=>c.getTxoHash(t).equals(e))})).filter(t=>t.vout>=0).sort((t,e)=>t.tx.status.confirmed&&!e.tx.status.confirmed?-1:!t.tx.status.confirmed&&e.tx.status.confirmed?1:t.tx.status.confirmed&&e.tx.status.confirmed?t.tx.status.block_height-e.tx.status.block_height:0);return 0===r.length?null:{tx:await this.toBtcTx(r[0].tx,!1),vout:r[0].vout}}async waitForAddressTxo(t,e,r,i,n,a){for(null!=n&&n.throwIfAborted();null==n||!n.aborted;){await (0,o.timeoutPromise)(1e3*(a||5),n);let s=await this.checkAddressTxos(t,e);if(null==s){i(null,null,null,null);continue}let l=await this.getConfirmationDelay(s.tx,r);if(null!=l&&(null!=i&&i(s.tx.confirmations,s.tx.txid,s.vout,l),0===l))return s}n.throwIfAborted()}async waitForTransaction(t,e,r,i,n){for(null!=i&&i.throwIfAborted();null==i||!i.aborted;){await (0,o.timeoutPromise)(1e3*(n||5),i);let a=await this.getTransaction(t);if(null==a){r(null,null,null);continue}let s=await this.getConfirmationDelay(a,e);if(null!=s&&(null!=r&&r(a.confirmations,a.txid,s),0===s))return a}i.throwIfAborted()}async getLNNodeLiquidity(t){let e=await this.api.getLNNodeInfo(t);return{publicKey:e.public_key,capacity:BigInt(e.capacity),numChannels:e.active_channel_count}}sendRawTransaction(t){return this.api.sendTransaction(t)}sendRawPackage(t){throw Error("Unsupported")}async isSpent(t,e){let[r,i]=t.split(":"),n=parseInt(i),a=await this.api.getOutspends(r);return null==a[n]||(e?a[n].spent&&a[n].status.confirmed:a[n].spent)}parseTransaction(t){var e;return Promise.resolve({locktime:(e=l.Transaction.fromRaw(s.Buffer.from(t,"hex"),{allowLegacyWitnessUtxo:!0,allowUnknownInputs:!0,allowUnknownOutputs:!0,disableScriptCheck:!0})).lockTime,version:e.version,blockhash:null,confirmations:0,txid:s.Buffer.from((0,u.sha256)((0,u.sha256)(e.toBytes(!0,!1)))).reverse().toString("hex"),hex:s.Buffer.from(e.toBytes(!0,!1)).toString("hex"),raw:s.Buffer.from(e.toBytes(!0,!0)).toString("hex"),vsize:e.isFinal?e.vsize:null,outs:Array.from({length:e.outputsLength},(t,e)=>e).map(t=>{let r=e.getOutput(t);return{value:Number(r.amount),n:t,scriptPubKey:{asm:l.Script.decode(r.script).map(t=>"object"==typeof t?s.Buffer.from(t).toString("hex"):t.toString()).join(" "),hex:s.Buffer.from(r.script).toString("hex")}}}),ins:Array.from({length:e.inputsLength},(t,e)=>e).map(t=>{let r=e.getInput(t);return{txid:s.Buffer.from(r.txid).toString("hex"),vout:r.index,scriptSig:{asm:l.Script.decode(r.finalScriptSig).map(t=>"object"==typeof t?s.Buffer.from(t).toString("hex"):t.toString()).join(" "),hex:s.Buffer.from(r.finalScriptSig).toString("hex")},sequence:r.sequence,txinwitness:null==r.finalScriptWitness?[]:r.finalScriptWitness.map(t=>s.Buffer.from(t).toString("hex"))}})})}getEffectiveFeeRate(t){throw Error("Unsupported.")}async getFeeRate(){return(await this.api.getFees()).fastestFee}getAddressBalances(t){return this.api.getAddressBalances(t)}async getAddressUTXOs(t){return(await this.api.getAddressUTXOs(t)).map(t=>({txid:t.txid,vout:t.vout,confirmed:t.status.confirmed,block_height:t.status.block_height,block_hash:t.status.block_hash,block_time:t.status.block_time,value:t.value}))}getCPFPData(t){return this.api.getCPFPData(t)}}r.MempoolBitcoinRpc=c},460458,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0})},457854,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0})},824341,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.isIBitcoinWallet=void 0,r.isIBitcoinWallet=function(t){return null!==t&&"function"==typeof t.sendTransaction&&"function"==typeof t.fundPsbt&&"function"==typeof t.signPsbt&&"function"==typeof t.getFeeRate&&"function"==typeof t.getTransactionFee&&"function"==typeof t.getFundedPsbtFee&&"function"==typeof t.getReceiveAddress&&"function"==typeof t.getBalance&&"function"==typeof t.getSpendableBalance}},24228,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.utils=r.DUST_THRESHOLDS=void 0;let i=(0,t.r(389215).getLogger)("CoinSelect: "),n={"p2sh-p2wpkh":51,p2wpkh:27,p2tr:16.75,p2pkh:107,p2wsh:16.5};function a(t){return 41+(t.script?t.script.length:n[t.type])}let s={"p2sh-p2wpkh":23,p2wpkh:22,p2tr:34,p2pkh:25,p2wsh:34};function o(t){return 9+(t.script?t.script.length:s[t.type])}function l(t){return r.DUST_THRESHOLDS[t.type]}function u(t,e,r){let i=10,n=!1;for(let e of("p2pkh"!==r&&(i+=.5),t))n||"p2pkh"===e.type||(n=!0,i+=.5),i+=a(e);for(let t of e)i+=o(t);return Math.ceil(i)}function c(t){return"number"!=typeof t||!isFinite(t)||Math.floor(t)!==t||t<0?NaN:t}function h(t){return t.reduce((t,e)=>t+c(e.value),0)}r.DUST_THRESHOLDS={"p2sh-p2wpkh":540,p2wpkh:294,p2tr:330,p2pkh:546,p2wsh:330},r.utils={dustThreshold:l,finalize:function(t,e,r,n,a=0){let s=u(t,e,n);i.debug("finalize(): Transaction bytes: ",s);let c=r*(s+o({type:n}))+a;i.debug("finalize(): TX fee after adding change output: ",c);let p=Math.floor(h(t)-(h(e)+c));i.debug("finalize(): Leaves change (changeType="+n+") value: ",p),p>=l({type:n})&&(e=e.concat({value:p,type:n}));let d=h(t)-h(e);return(i.debug("finalize(): Re-calculated total fee: ",d),isFinite(d))?{inputs:t,outputs:e,fee:d}:{fee:r*s+a}},inputBytes:a,outputBytes:o,sumOrNaN:h,sumForgiving:function(t){return t.reduce((t,e)=>t+(isFinite(e.value)?e.value:0),0)},transactionBytes:u,uintOrNaN:c}},154667,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.accumulative=void 0;let i=t.r(24228),n=(0,t.r(389215).getLogger)("CoinSelect: ");r.accumulative=function(t,e,r,a,s){if(!isFinite(i.utils.uintOrNaN(r)))return null;let o=null==s?[]:[...s],l=i.utils.transactionBytes(o,e,a),u=r*l,c=0,h=i.utils.sumOrNaN(o),p=i.utils.sumOrNaN(e);n.debug("accumulative(): total output: ",p);for(let s=0;s<t.length;++s){let d=t[s],f=i.utils.inputBytes(d),m=r*f,g=i.utils.uintOrNaN(d.value),w=0;if(null!=d.cpfp&&d.cpfp.txEffectiveFeeRate<r&&(w=Math.ceil(d.cpfp.txVsize*(r-d.cpfp.txEffectiveFeeRate))),m+w>d.value){if(n.debug("accumulative("+s+"): Skipping detrimental output, cpfpFee: "+w+" utxoFee: "+m+" value: "+d.value),s===t.length-1)return{fee:r*(l+f)+c+w};continue}if(l+=f,h+=g,c+=w,o.push(d),u=Math.ceil(r*l+c),n.debug("accumulative("+s+"): total fee: ",u),n.debug("accumulative("+s+"): input value: ",h),n.debug("accumulative("+s+"): cpfpAddFee: ",c),!(h<p+u))return n.debug("accumulative("+s+"): Finalizing transaction, inputs: ",o),n.debug("accumulative("+s+"): Finalizing transaction, outputs: ",e),n.debug("accumulative("+s+"): Finalizing transaction, feeRate: ",r),i.utils.finalize(o,e,r,a,c)}return{fee:u}}},114501,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.blackjack=void 0;let i=t.r(24228);r.blackjack=function(t,e,r,n,a){if(!isFinite(i.utils.uintOrNaN(r)))return null;let s=null==a?[]:[...a],o=i.utils.transactionBytes(s,e,n),l=i.utils.sumOrNaN(s),u=0,c=i.utils.sumOrNaN(e),h=i.utils.dustThreshold({type:n});for(let a=0;a<t.length;++a){let p=t[a],d=i.utils.inputBytes(p),f=0;null!=p.cpfp&&p.cpfp.txEffectiveFeeRate<r&&(f=Math.ceil(p.cpfp.txVsize*(r-p.cpfp.txEffectiveFeeRate)));let m=Math.ceil(r*(o+d)+u+f),g=i.utils.uintOrNaN(p.value);if(!(l+g>c+m+h)&&(o+=d,l+=g,u+=f,s.push(p),!(l<c+m)))return i.utils.finalize(s,e,r,n,u)}return{fee:r*o+u}}},863316,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.maxSendable=r.coinSelect=r.DUST_THRESHOLDS=void 0;let i=t.r(154667),n=t.r(114501),a=t.r(24228);function s(t,e){let r=t.value-e*a.utils.inputBytes(t);return null!=t.cpfp&&t.cpfp.txEffectiveFeeRate<e&&(r-=t.cpfp.txVsize*(e-t.cpfp.txEffectiveFeeRate)),r}Object.defineProperty(r,"DUST_THRESHOLDS",{enumerable:!0,get:function(){return a.DUST_THRESHOLDS}}),r.coinSelect=function(t,e,r,a,o){t=t.sort((t,e)=>s(e,r)-s(t,r));let l=(0,n.blackjack)(t,e,r,a,o);return l.inputs?l:(0,i.accumulative)(t,e,r,a,o)},r.maxSendable=function(t,e,r,i,n){if(!isFinite(a.utils.uintOrNaN(r)))return null;let s=n??[],o=i??[],l=a.utils.transactionBytes(o,s.concat([e]),null),u=0,c=a.utils.sumOrNaN(o),h=a.utils.sumOrNaN(s);for(let e=0;e<t.length;++e){let i=t[e],n=a.utils.inputBytes(i),s=r*n,h=0;null!=i.cpfp&&i.cpfp.txEffectiveFeeRate<r&&(h=i.cpfp.txVsize*(r-i.cpfp.txEffectiveFeeRate));let p=a.utils.uintOrNaN(i.value);s+h>i.value||(l+=n,c+=p,u+=h,o.push(i))}let p=r*l+u,d=c-p-h;return d<a.DUST_THRESHOLDS[e.type]?{fee:p,value:0}:{fee:p,value:d}}},614350,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.BitcoinWallet=r.identifyAddressType=void 0;let i=t.r(863316),n=t.r(839596),a=t.r(500874),s=t.r(389215);r.identifyAddressType=function(t,e){switch((0,n.Address)(e).decode(t).type){case"pkh":return"p2pkh";case"wpkh":return"p2wpkh";case"tr":return"p2tr";case"sh":return"p2sh-p2wpkh";case"wsh":return"p2wsh";default:return null}};let o=(0,s.getLogger)("BitcoinWallet: ");r.BitcoinWallet=class{constructor(t,e,r=1.25,i){this.rpc=t,this.network=e,this.feeMultiplier=r,this.feeOverride=i}async getFeeRate(){return null!=this.feeOverride?this.feeOverride:Math.floor(await this.rpc.getFeeRate()*this.feeMultiplier)}_sendTransaction(t){return this.rpc.sendRawTransaction(t)}_getBalance(t){return this.rpc.getAddressBalances(t)}async _getUtxoPool(t,e){let r=await this.rpc.getAddressUTXOs(t),i=0,n=(0,s.toOutputScript)(this.network,t),a=[];for(let s of r){let r=Number(s.value);i+=r,a.push({vout:s.vout,txId:s.txid,value:r,type:e,outputScript:n,address:t,cpfp:s.confirmed?null:await this.rpc.getCPFPData(s.txid).then(t=>null==t.effectiveFeePerVsize?null:{txVsize:t.adjustedVsize,txEffectiveFeeRate:t.effectiveFeePerVsize}),confirmed:s.confirmed})}return o.debug("_getUtxoPool(): Total spendable value: "+i+" num utxos: "+a.length),a}async _getPsbt(t,e,r,i){let a=new n.Transaction({PSBTVersion:0});return a.addOutput({amount:BigInt(r),script:(0,s.toOutputScript)(this.network,e)}),this._fundPsbt(t,a,i)}async _fundPsbt(t,e,r){null==r&&(r=await this.getFeeRate());let l=(await Promise.all(t.map(t=>this._getUtxoPool(t.address,t.addressType)))).flat();o.debug("_fundPsbt(): fee rate: "+r+" utxo pool: ",l);let u={};t.forEach(t=>u[t.address]=t.pubkey);let c=[];for(let t=0;t<e.inputsLength;t++){let r=e.getInput(t),i=null!=r.witnessUtxo?r.witnessUtxo.amount:r.nonWitnessUtxo.outputs[r.index].amount,n=null!=r.witnessUtxo?r.witnessUtxo.script:r.nonWitnessUtxo.outputs[r.index].script;c.push({txId:a.Buffer.from(r.txid).toString("hex"),vout:r.index,value:Number(i),type:(0,s.toCoinselectAddressType)(n)})}let h=[];for(let t=0;t<e.outputsLength;t++){let r=e.getOutput(t);h.push({value:Number(r.amount),script:a.Buffer.from(r.script)})}o.debug("_fundPsbt(): Coinselect targets: ",h);let p=(0,i.coinSelect)(l,h,r,t[0].addressType,c);if(o.debug("_fundPsbt(): Coinselect result: ",p),null==p.inputs||null==p.outputs)return{psbt:null,fee:p.fee,inputAddressIndexes:null};p.inputs.splice(0,e.inputsLength),p.outputs.splice(0,e.outputsLength);let d={};return p.inputs.forEach((t,e)=>{d[t.address]??=[],d[t.address].push(e)}),(await Promise.all(p.inputs.map(async t=>{switch(t.type){case"p2tr":let e=(0,n.p2tr)(a.Buffer.from(u[t.address],"hex"));return{txid:t.txId,index:t.vout,witnessUtxo:{script:t.outputScript,amount:BigInt(t.value)},tapInternalKey:e.tapInternalKey,tapMerkleRoot:e.tapMerkleRoot,tapLeafScript:e.tapLeafScript};case"p2wpkh":return{txid:t.txId,index:t.vout,witnessUtxo:{script:t.outputScript,amount:BigInt(t.value)},sighashType:1};case"p2sh-p2wpkh":return{txid:t.txId,index:t.vout,witnessUtxo:{script:t.outputScript,amount:BigInt(t.value)},redeemScript:(0,n.p2wpkh)(a.Buffer.from(u[t.address],"hex"),this.network).script,sighashType:1};case"p2pkh":return{txid:t.txId,index:t.vout,nonWitnessUtxo:(await this.rpc.getTransaction(t.txId)).raw,sighashType:1}}}))).forEach(t=>e.addInput(t)),p.outputs.forEach(r=>{null==r.script&&null==r.address?e.addOutput({script:(0,s.toOutputScript)(this.network,t[0].address),amount:BigInt(Math.floor(r.value))}):e.addOutput({script:r.script??(0,s.toOutputScript)(this.network,r.address),amount:BigInt(r.value)})}),{psbt:e,fee:p.fee,inputAddressIndexes:d}}async _getSpendableBalance(t,e,r){r??=await this.getFeeRate();let l=(await Promise.all(t.map(t=>this._getUtxoPool(t.address,t.addressType)))).flat(),u=[];if(null!=e)for(let t=0;t<e.inputsLength;t++){let r=e.getInput(t),i=null!=r.witnessUtxo?r.witnessUtxo.amount:r.nonWitnessUtxo.outputs[r.index].amount,n=null!=r.witnessUtxo?r.witnessUtxo.script:r.nonWitnessUtxo.outputs[r.index].script;u.push({txId:a.Buffer.from(r.txid).toString("hex"),vout:r.index,value:Number(i),type:(0,s.toCoinselectAddressType)(n)})}let c=[];if(null!=e)for(let t=0;t<e.outputsLength;t++){let r=e.getOutput(t);c.push({value:Number(r.amount),script:a.Buffer.from(r.script)})}let h=n.OutScript.encode({type:"wsh",hash:(0,s.randomBytes)(32)}),p=(0,i.maxSendable)(l,{script:a.Buffer.from(h),type:"p2wsh"},r,u,c);return o.debug("_getSpendableBalance(): Max spendable result: ",p),{feeRate:r,balance:BigInt(Math.floor(p.value)),totalFee:p.fee}}}},199974,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SingleAddressBitcoinWallet=void 0;let i=t.r(196225),n=t.r(839596),a=t.r(500874),s=t.r(614350);class o extends s.BitcoinWallet{constructor(t,e,r,o=1.25,l){if(super(t,e,o,l),"string"==typeof r){try{this.privKey=(0,n.WIF)(e).decode(r)}catch(t){this.privKey=(0,n.WIF)().decode(r)}this.pubkey=(0,i.pubECDSA)(this.privKey),this.address=(0,n.getAddress)("wpkh",this.privKey,e)}else this.address=r.address,this.pubkey=a.Buffer.from(r.publicKey,"hex");this.addressType=(0,s.identifyAddressType)(this.address,e)}toBitcoinWalletAccounts(){return[{pubkey:a.Buffer.from(this.pubkey).toString("hex"),address:this.address,addressType:this.addressType}]}async sendTransaction(t,e,r){if(!this.privKey)throw Error("Not supported.");let{psbt:i}=await super._getPsbt(this.toBitcoinWalletAccounts(),t,Number(e),r);i.sign(this.privKey),i.finalize();let n=a.Buffer.from(i.extract()).toString("hex");return await super._sendTransaction(n)}async fundPsbt(t,e){let{psbt:r}=await super._fundPsbt(this.toBitcoinWalletAccounts(),t,e);if(null==r)throw Error("Not enough balance!");return r}async signPsbt(t,e){if(!this.privKey)throw Error("Not supported.");for(let r of e)t.signIdx(this.privKey,r);return t}async getTransactionFee(t,e,r){let{psbt:i,fee:n}=await super._getPsbt(this.toBitcoinWalletAccounts(),t,Number(e),r);return null==i?null:n}async getFundedPsbtFee(t,e){let{psbt:r,fee:i}=await super._fundPsbt(this.toBitcoinWalletAccounts(),t,e);return null==r?null:i}getReceiveAddress(){return this.address}getBalance(){return this._getBalance(this.address)}getSpendableBalance(t,e){return this._getSpendableBalance([{address:this.address,addressType:this.addressType}],t,e)}static generateRandomPrivateKey(t){return(0,n.WIF)(t).encode((0,i.randomPrivateKeyBytes)())}}r.SingleAddressBitcoinWallet=o},46575,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IntermediaryError=void 0;class i extends Error{constructor(t){super(t),Object.setPrototypeOf(this,i.prototype)}}r.IntermediaryError=i},894705,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.PaymentAuthError=void 0;class i extends Error{constructor(t,e,r){super(t),this.data=r,this.code=e,Object.setPrototypeOf(this,i.prototype)}getCode(){return this.code}getData(){return this.data}}r.PaymentAuthError=i},223682,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.UserError=void 0;class i extends Error{constructor(t){super(t),Object.setPrototypeOf(this,i.prototype)}}r.UserError=i},853312,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SwapType=void 0,function(t){t[t.FROM_BTC=0]="FROM_BTC",t[t.FROM_BTCLN=1]="FROM_BTCLN",t[t.TO_BTC=2]="TO_BTC",t[t.TO_BTCLN=3]="TO_BTCLN",t[t.TRUSTED_FROM_BTC=4]="TRUSTED_FROM_BTC",t[t.TRUSTED_FROM_BTCLN=5]="TRUSTED_FROM_BTCLN",t[t.SPV_VAULT_FROM_BTC=6]="SPV_VAULT_FROM_BTC"}(r.SwapType||(r.SwapType={}))},544086,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.Intermediary=void 0;let i=t.r(853312),n=t.r(389215);r.Intermediary=class{constructor(t,e,r,n={}){for(let a in this.reputation={},this.liquidity={},this.url=t,this.addresses=e,this.services=r,this.reputation=n,this.swapBounds={},this.services){let t=parseInt(a),e=this.services[a],r={min:BigInt(e.min),max:BigInt(e.max)},n=t===i.SwapType.TO_BTC||t===i.SwapType.TO_BTCLN;for(let i in this.swapBounds[t]={},e.chainTokens)for(let a of(this.swapBounds[t][i]={},e.chainTokens[i]))this.swapBounds[t][i][a]={input:n?{min:null,max:null}:r,output:n?r:{min:null,max:null}}}}getSwapLimits(t,e,r){return this.swapBounds[t]?.[e]?.[r]}getSupportedTokens(t,e=[i.SwapType.TO_BTC,i.SwapType.TO_BTCLN,i.SwapType.FROM_BTC,i.SwapType.FROM_BTCLN,i.SwapType.SPV_VAULT_FROM_BTC]){let r=new Set(e),n=new Set;return r.forEach(e=>{null!=this.services[e]&&null!=this.services[e].chainTokens&&null!=this.services[e].chainTokens[t]&&this.services[e].chainTokens[t].forEach(t=>n.add(t))}),n}async getReputation(t,e,r,a){let s=null==r?this.getSupportedTokens(t,[i.SwapType.TO_BTC,i.SwapType.TO_BTCLN]):new Set(r),o=[],l={};for(let r of s)o.push((0,n.tryWithRetries)(()=>e.getIntermediaryReputation(this.getAddress(t),r),null,null,a).then(t=>{l[r]=t}));for(let e in await Promise.all(o),this.reputation??={},this.reputation[t]??={},l)this.reputation[t][e]=l[e];return l}async getLiquidity(t,e,r,i){let a=await (0,n.tryWithRetries)(()=>e.getBalance(this.getAddress(t),r,!0),null,null,i);return this.liquidity??={},this.liquidity[t]??={},this.liquidity[t][r]=a,a}supportsChain(t){return null!=this.addresses[t]&&0!==this.getSupportedTokens(t).size}getAddress(t){return this.addresses[t]}}},187433,(t,e,r)=>{"use strict";var i;function n(t){if(null==t||"string"!=typeof t&&"number"!=typeof t)return null;try{return BigInt(t)}catch(t){return null}}function a(t){if("function"==typeof t)return null!=t(void 0);if("object"==typeof t){for(let e in t)if(!a(t[e]))return!1;return!0}return t>=100}function s(t,e){if(null==t)return null;let r={};for(let o in e){let l=t[o],u=e[o];if("function"==typeof u){let t=u(l);if(null==t)return null;r[o]=t;continue}if(null==l&&a(u)){r[o]=null;continue}if(u===i.Any||u===i.AnyOptional)r[o]=l;else if(u===i.Boolean||u===i.BooleanOptional){if("boolean"!=typeof l)return null;r[o]=l}else if(u===i.Number||u===i.NumberOptional){if("number"!=typeof l||isNaN(l))return null;r[o]=l}else if(u===i.BigInt||u===i.BigIntOptional){let t=n(l);if(null==t)return null;r[o]=t}else if(u===i.String||u===i.StringOptional){if("string"!=typeof l)return null;r[o]=l}else{let t=s(l,u);if(null==t)return null;r[o]=t}}return r}Object.defineProperty(r,"__esModule",{value:!0}),r.verifySchema=r.verifyField=r.isOptionalField=r.FieldTypeEnum=r.parseBigInt=void 0,r.parseBigInt=n,function(t){t[t.String=0]="String",t[t.Boolean=1]="Boolean",t[t.Number=2]="Number",t[t.BigInt=3]="BigInt",t[t.Any=4]="Any",t[t.StringOptional=100]="StringOptional",t[t.BooleanOptional=101]="BooleanOptional",t[t.NumberOptional=102]="NumberOptional",t[t.BigIntOptional=103]="BigIntOptional",t[t.AnyOptional=104]="AnyOptional"}(i=r.FieldTypeEnum||(r.FieldTypeEnum={})),r.isOptionalField=a,r.verifyField=function(t,e){if("function"==typeof t){let r=t(e);if(null==r)return;return r}if(null==e&&a(t))return null;if(t===i.Any||t===i.AnyOptional)return e;if(t===i.Boolean||t===i.BooleanOptional){if("boolean"!=typeof e)return;return e}if(t===i.Number||t===i.NumberOptional){if("number"!=typeof e||isNaN(e))return;return e}if(t===i.BigInt||t===i.BigIntOptional){let t=n(e);if(null==t)return;return t}if(t===i.String||t===i.StringOptional){if("string"!=typeof e)return;return e}else{let r=s(e,t);if(null==r)return;return r}},r.verifySchema=s},695160,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ParamEncoder=void 0;let i=t.r(500874);r.ParamEncoder=class{constructor(t,e){this.writeFN=t,this.endFN=e}writeParams(t){let e=i.Buffer.from(JSON.stringify(t)),r=i.Buffer.alloc(4);return r.writeUint32LE(e.length),this.writeFN(i.Buffer.concat([r,e]))}end(){return this.endFN()}}},911877,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.StreamParamEncoder=void 0;let i=t.r(695160);class n extends i.ParamEncoder{constructor(){let t=new TransformStream,e=t.writable.getWriter();e.closed.then(()=>this.closed=!0),super(e.write.bind(e),()=>this.closed?Promise.resolve():(this.closed=!0,e.close())),this.closed=!1,this.stream=t}getReadableStream(){return this.stream.readable}}r.StreamParamEncoder=n},379445,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ParamDecoder=void 0;let i=t.r(500874);r.ParamDecoder=class{constructor(){this.frameHeader=null,this.frameData=[],this.frameDataLength=0,this.closed=!1,this.params={}}onFrameRead(t){let e=JSON.parse(t.toString());for(let t in e)null==this.params[t]?this.params[t]={promise:Promise.resolve(e[t]),resolve:null,reject:null}:null!=this.params[t].resolve&&(this.params[t].resolve(e[t]),this.params[t].resolve=null,this.params[t].reject=null)}onData(t){let e=t;for(;null!=e&&e.length>0;){if(null==this.frameHeader)e.length<=4?(this.frameHeader=e,e=null):(this.frameHeader=e.subarray(0,4),e=e.subarray(4));else if(this.frameHeader.length<4){let t=4-this.frameHeader.length;e.length<=t?(this.frameHeader=i.Buffer.concat([this.frameHeader,e]),e=null):(this.frameHeader=i.Buffer.concat([this.frameHeader,e.subarray(0,t)]),e=e.subarray(t))}if(null==e||null==this.frameHeader||this.frameHeader.length<4)continue;let t=this.frameHeader.readUint32LE(),r=t-this.frameDataLength;e.length<=r?(this.frameData.push(e),this.frameDataLength+=e.length,e=null):(this.frameData.push(e.subarray(0,r)),this.frameDataLength+=r,e=e.subarray(r)),t===this.frameDataLength&&(this.onFrameRead(i.Buffer.concat(this.frameData)),this.frameHeader=null,this.frameData=[],this.frameDataLength=0)}}onEnd(){for(let t in this.params)null!=this.params[t].reject&&this.params[t].reject(Error("EOF before field seen!"));this.closed=!0}onError(t){for(let e in this.params)null!=this.params[e].reject&&this.params[e].reject(t);this.closed=!0}getParam(t){if(null==this.params[t]){let e,r;if(this.closed)return Promise.reject(Error("Stream already closed without param received!"));let i=new Promise((t,i)=>{e=t,r=i});this.params[t]={resolve:e,reject:r,promise:i}}return this.params[t].promise}}},86030,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ResponseParamDecoder=void 0;let i=t.r(379445),n=t.r(500874),a=(0,t.r(389215).getLogger)("ResponseParamDecoder: ");class s extends i.ParamDecoder{constructor(t,e){super(),this.abortSignal=e;try{this.reader=t.body.getReader(),this.readResponse()}catch(e){t.arrayBuffer().then(t=>{super.onData(n.Buffer.from(t)),super.onEnd()}).catch(t=>{super.onError(t)})}null!=e&&e.addEventListener("abort",()=>{super.onError(e.reason),this.reader.closed||this.reader.cancel(e.reason)})}async readResponse(){for(;;){let t=await this.reader.read().catch(t=>(a.error("readResponse(): Error reading response: ",t),null));if(null!=this.abortSignal&&this.abortSignal.aborted)return;if(null==t||t.done)return void super.onEnd();super.onData(n.Buffer.from(t.value))}}}r.ResponseParamDecoder=s},816660,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.streamingFetchPromise=void 0;let i=t.r(187433),n=t.r(742396),a=t.r(389215),s=t.r(911877),o=t.r(86030),l=(0,a.getLogger)("StreamingFetch: "),u=(()=>{try{let t=!1,e=new Request("https://example.com/",{body:new ReadableStream,method:"POST",get duplex(){return t=!0,"half"}}).headers.has("Content-Type");return t&&!e}catch(t){return l.error("supportsRequestStreams: Error checking environment support for HTTP request stream",t),!1}})();l.info("Environment supports request stream: "+u),r.streamingFetchPromise=async function(t,e,r,c,h,p){null==p&&(p=u),null!=c&&(h=(0,a.timeoutSignal)(c,Error("Network request timed out"),h));let d={method:"POST",headers:{}},f=Date.now(),m={},g=[];if(p){let r=new s.StreamParamEncoder,i=!1;for(let n in e)e[n]instanceof Promise?(g.push(e[n].then(e=>(l.debug(t+": Send param ("+(Date.now()-f)+"ms) (streaming): ",{[n]:e}),r.writeParams({[n]:e})))),i=!0):m[n]=e[n];if(i){d.body=r.getReadableStream(),d.headers["content-type"]="application/x-multiple-json",d.duplex="half",l.debug(t+": Sending request ("+(Date.now()-f)+"ms) (streaming): ",m),g.push(r.writeParams(m));let e=(0,a.extendAbortController)(h);h=e.signal,Promise.all(g).then(()=>r.end()).catch(t=>{t._inputPromiseError=!0,e.abort(t)}),h.addEventListener("abort",()=>r.end())}else l.debug(t+": Sending request ("+(Date.now()-f)+"ms) (non-streaming): ",m),d.body=JSON.stringify(m),d.headers["content-type"]="application/json"}else{for(let t in e)e[t]instanceof Promise?g.push(e[t].then(e=>{m[t]=e})):m[t]=e[t];try{await Promise.all(g)}catch(t){throw t._inputPromiseError=!0,t}null!=h&&h.throwIfAborted(),l.debug(t+": Sending request ("+(Date.now()-f)+"ms) (non-streaming): ",m),d.body=JSON.stringify(m),d.headers["content-type"]="application/json"}null!=h&&(d.signal=h),d.headers.accept="application/x-multiple-json";let w=await fetch(t,d).catch(t=>{if(null!=d.signal&&"AbortError"===t.name)throw d.signal.reason;throw null!=t.message&&(t.message+=p?" (streaming req)":" (non streaming req)"),t});if(l.debug(t+": Response status ("+(Date.now()-f)+"ms) "+(p?"(streaming req)":"(non streaming req)")+": ",w.status),200!==w.status){let t;try{t=await w.text()}catch(t){throw new n.RequestError(w.statusText,w.status)}throw new n.RequestError(t,w.status)}if("application/x-multiple-json"!==w.headers.get("content-type")){let e=await w.json();return l.debug(t+": Response read ("+(Date.now()-f)+"ms) (non streaming resp): ",e),(0,a.objectMap)(r,(t,r)=>{let n=e[r],a=(0,i.verifyField)(t,n);return void 0===a?Promise.reject(Error("Invalid field value")):Promise.resolve(a)})}{let e=new o.ResponseParamDecoder(w,d.signal);return(0,a.objectMap)(r,(r,n)=>e.getParam(n).catch(t=>{if(!(0,i.isOptionalField)(r))throw t}).then(e=>{l.debug(t+": Response frame read ("+(Date.now()-f)+"ms) (streaming resp): ",{[n]:e});let a=(0,i.verifyField)(r,e);return void 0===a?Promise.reject(Error("Invalid field value")):a}))}}},302071,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IntermediaryAPI=r.PaymentAuthorizationResponseCodes=r.RefundAuthorizationResponseCodes=void 0;let i=t.r(742396),n=t.r(187433),a=t.r(816660),s=t.r(389215);!function(t){t[t.EXPIRED=20010]="EXPIRED",t[t.REFUND_DATA=2e4]="REFUND_DATA",t[t.NOT_FOUND=20007]="NOT_FOUND",t[t.PENDING=20008]="PENDING",t[t.PAID=20006]="PAID"}(r.RefundAuthorizationResponseCodes||(r.RefundAuthorizationResponseCodes={})),function(t){t[t.AUTH_DATA=1e4]="AUTH_DATA",t[t.EXPIRED=10001]="EXPIRED",t[t.PAID=10002]="PAID",t[t.PENDING=10003]="PENDING",t[t.ALREADY_COMMITTED=10004]="ALREADY_COMMITTED"}(r.PaymentAuthorizationResponseCodes||(r.PaymentAuthorizationResponseCodes={}));let o={data:n.FieldTypeEnum.Any,prefix:n.FieldTypeEnum.String,timeout:n.FieldTypeEnum.String,signature:n.FieldTypeEnum.String},l={amount:n.FieldTypeEnum.BigInt,address:n.FieldTypeEnum.String,satsPervByte:n.FieldTypeEnum.BigInt,networkFee:n.FieldTypeEnum.BigInt,swapFee:n.FieldTypeEnum.BigInt,totalFee:n.FieldTypeEnum.BigInt,total:n.FieldTypeEnum.BigInt,minRequiredExpiry:n.FieldTypeEnum.BigInt,...o},u={maxFee:n.FieldTypeEnum.BigInt,swapFee:n.FieldTypeEnum.BigInt,total:n.FieldTypeEnum.BigInt,confidence:n.FieldTypeEnum.Number,address:n.FieldTypeEnum.String,routingFeeSats:n.FieldTypeEnum.BigInt,...o},c={amount:n.FieldTypeEnum.BigInt,reqId:n.FieldTypeEnum.String},h={amount:n.FieldTypeEnum.BigInt,btcAddress:n.FieldTypeEnum.String,address:n.FieldTypeEnum.String,swapFee:n.FieldTypeEnum.BigInt,total:n.FieldTypeEnum.BigInt,confirmations:n.FieldTypeEnum.NumberOptional,...o},p={pr:n.FieldTypeEnum.String,swapFee:n.FieldTypeEnum.BigInt,total:n.FieldTypeEnum.BigInt,intermediaryKey:n.FieldTypeEnum.String,securityDeposit:n.FieldTypeEnum.BigInt},d={quoteId:n.FieldTypeEnum.String,expiry:n.FieldTypeEnum.Number,address:n.FieldTypeEnum.String,vaultId:n.FieldTypeEnum.BigInt,vaultBtcAddress:n.FieldTypeEnum.String,btcAddress:n.FieldTypeEnum.String,btcUtxo:n.FieldTypeEnum.String,btcFeeRate:n.FieldTypeEnum.Number,btcAmount:n.FieldTypeEnum.BigInt,btcAmountSwap:n.FieldTypeEnum.BigInt,btcAmountGas:n.FieldTypeEnum.BigInt,total:n.FieldTypeEnum.BigInt,totalGas:n.FieldTypeEnum.BigInt,totalFeeBtc:n.FieldTypeEnum.BigInt,swapFeeBtc:n.FieldTypeEnum.BigInt,swapFee:n.FieldTypeEnum.BigInt,gasSwapFeeBtc:n.FieldTypeEnum.BigInt,gasSwapFee:n.FieldTypeEnum.BigInt,callerFeeShare:n.FieldTypeEnum.BigInt,frontingFeeShare:n.FieldTypeEnum.BigInt,executionFeeShare:n.FieldTypeEnum.BigInt},f={txId:n.FieldTypeEnum.String};r.IntermediaryAPI=class{static async getIntermediaryInfo(t,e,r){let i=(0,s.randomBytes)(32).toString("hex"),n=await (0,s.httpPost)(t+"/info",{nonce:i},e,r);if(i!==JSON.parse(n.envelope).nonce)throw Error("Invalid response - nonce");return n}static async getRefundAuthorization(t,e,r,n,a){return(0,s.tryWithRetries)(()=>(0,s.httpGet)(t+"/getRefundAuthorization?paymentHash="+encodeURIComponent(e)+"&sequence="+encodeURIComponent(r.toString(10)),n,a),null,i.RequestError,a)}static async getPaymentAuthorization(t,e,r,n){return(0,s.tryWithRetries)(()=>(0,s.httpGet)(t+"/getInvoicePaymentAuth?paymentHash="+encodeURIComponent(e),r,n),null,i.RequestError,n)}static initToBTC(t,e,r,s,o,u){let c=(0,a.streamingFetchPromise)(e+"/tobtc/payInvoice?chain="+encodeURIComponent(t),{...r.additionalParams,address:r.btcAddress,amount:r.amount.toString(10),exactIn:r.exactIn,confirmationTarget:r.confirmationTarget,confirmations:r.confirmations,nonce:r.nonce.toString(10),token:r.token,offerer:r.offerer,feeRate:r.feeRate},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional,signDataPrefetch:n.FieldTypeEnum.AnyOptional},s,o,u);return{signDataPrefetch:c.then(t=>t.signDataPrefetch),response:c.then(t=>Promise.all([t.code,t.msg,t.data])).then(([t,e,r])=>{if(2e4!==t)throw i.RequestError.parse(JSON.stringify({code:t,msg:e,data:r}),400);return(0,n.verifySchema)(r,l)})}}static initFromBTC(t,e,r,s,o,l,u){let c=(0,a.streamingFetchPromise)(e+"/frombtc/getAddress?chain="+encodeURIComponent(t)+"&depositToken="+encodeURIComponent(r),{...s.additionalParams,address:s.claimer,amount:s.amount.toString(10),token:s.token,exactOut:s.exactOut,sequence:s.sequence.toString(10),claimerBounty:s.claimerBounty.then(t=>({feePerBlock:t.feePerBlock.toString(10),safetyFactor:t.safetyFactor,startTimestamp:t.startTimestamp.toString(10),addBlock:t.addBlock,addFee:t.addFee.toString(10)})),feeRate:s.feeRate},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional,signDataPrefetch:n.FieldTypeEnum.AnyOptional},o,l,u);return{signDataPrefetch:c.then(t=>t.signDataPrefetch),response:c.then(t=>Promise.all([t.code,t.msg,t.data])).then(([t,e,r])=>{if(2e4!==t)throw i.RequestError.parse(JSON.stringify({code:t,msg:e,data:r}),400);return(0,n.verifySchema)(r,h)})}}static initFromBTCLN(t,e,r,s,o,l,u){let c=(0,a.streamingFetchPromise)(e+"/frombtcln/createInvoice?chain="+encodeURIComponent(t)+"&depositToken="+encodeURIComponent(r),{...s.additionalParams,paymentHash:s.paymentHash.toString("hex"),amount:s.amount.toString(),address:s.claimer,token:s.token,descriptionHash:null==s.descriptionHash?null:s.descriptionHash.toString("hex"),exactOut:s.exactOut,feeRate:s.feeRate},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional,lnPublicKey:n.FieldTypeEnum.StringOptional},o,l,u);return{lnPublicKey:c.then(t=>t.lnPublicKey),response:c.then(t=>Promise.all([t.code,t.msg,t.data])).then(([t,e,r])=>{if(2e4!==t)throw i.RequestError.parse(JSON.stringify({code:t,msg:e,data:r}),400);return(0,n.verifySchema)(r,p)})}}static initToBTCLN(t,e,r,s,o,l){let c=(0,a.streamingFetchPromise)(e+"/tobtcln/payInvoice?chain="+encodeURIComponent(t),{exactIn:!1,...r.additionalParams,pr:r.pr,maxFee:r.maxFee.toString(10),expiryTimestamp:r.expiryTimestamp.toString(10),token:r.token,offerer:r.offerer,feeRate:r.feeRate,amount:null},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional,signDataPrefetch:n.FieldTypeEnum.AnyOptional},s,o,l);return{signDataPrefetch:c.then(t=>t.signDataPrefetch),response:c.then(t=>Promise.all([t.code,t.msg,t.data])).then(([t,e,r])=>{if(2e4!==t)throw i.RequestError.parse(JSON.stringify({code:t,msg:e,data:r}),400);return(0,n.verifySchema)(r,u)})}}static async initToBTCLNExactIn(t,e,r,s,o){let l=await (0,a.streamingFetchPromise)(t+"/tobtcln/payInvoiceExactIn",{...e.additionalParams,pr:e.pr,reqId:e.reqId,feeRate:e.feeRate},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional},r,s,o),[c,h,p]=await Promise.all([l.code,l.msg,l.data]);if(2e4!==c)throw i.RequestError.parse(JSON.stringify({code:c,msg:h,data:p}),400);return(0,n.verifySchema)(p,u)}static prepareToBTCLNExactIn(t,e,r,s,o,l){let u=(0,a.streamingFetchPromise)(e+"/tobtcln/payInvoice?chain="+encodeURIComponent(t),{exactIn:!0,...r.additionalParams,pr:r.pr,maxFee:r.maxFee.toString(10),expiryTimestamp:r.expiryTimestamp.toString(10),token:r.token,offerer:r.offerer,amount:r.amount.toString(10)},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional,signDataPrefetch:n.FieldTypeEnum.AnyOptional},s,o,l);return{signDataPrefetch:u.then(t=>t.signDataPrefetch),response:u.then(t=>Promise.all([t.code,t.msg,t.data])).then(([t,e,r])=>{if(2e4!==t)throw i.RequestError.parse(JSON.stringify({code:t,msg:e,data:r}),400);return(0,n.verifySchema)(r,c)})}}static prepareSpvFromBTC(t,e,r,s,o,l){return(0,a.streamingFetchPromise)(e+"/frombtc_spv/getQuote?chain="+encodeURIComponent(t),{exactOut:r.exactOut,...r.additionalParams,address:r.address,amount:r.amount.toString(10),token:r.token,gasAmount:r.gasAmount.toString(10),gasToken:r.gasToken,frontingFeeRate:r.frontingFeeRate.toString(10),callerFeeRate:r.callerFeeRate.then(t=>t.toString(10))},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional},s,o,l).then(t=>Promise.all([t.code,t.msg,t.data])).then(([t,e,r])=>{if(2e4!==t)throw i.RequestError.parse(JSON.stringify({code:t,msg:e,data:r}),400);return(0,n.verifySchema)(r,d)})}static initSpvFromBTC(t,e,r,s,o,l){return(0,a.streamingFetchPromise)(e+"/postQuote?chain="+encodeURIComponent(t),{quoteId:r.quoteId,psbtHex:r.psbtHex},{code:n.FieldTypeEnum.Number,msg:n.FieldTypeEnum.String,data:n.FieldTypeEnum.AnyOptional},s,o,l).then(t=>Promise.all([t.code,t.msg,t.data])).then(([t,e,r])=>{if(2e4!==t)throw i.RequestError.parse(JSON.stringify({code:t,msg:e,data:r}),400);return(0,n.verifySchema)(r,f)})}}},483930,(t,e,r)=>{"use strict";var i;Object.defineProperty(r,"__esModule",{value:!0}),r.IntermediaryDiscovery=r.SwapHandlerType=void 0;let n=t.r(544086),a=t.r(853312),s=t.r(154585),o=t.r(427699),l=t.r(500874),u=t.r(389215),c=t.r(302071);!function(t){t.TO_BTC="TO_BTC",t.FROM_BTC="FROM_BTC",t.TO_BTCLN="TO_BTCLN",t.FROM_BTCLN="FROM_BTCLN",t.FROM_BTC_TRUSTED="FROM_BTC_TRUSTED",t.FROM_BTCLN_TRUSTED="FROM_BTCLN_TRUSTED",t.FROM_BTC_SPV="FROM_BTC_SPV"}(i=r.SwapHandlerType||(r.SwapHandlerType={}));let h=(0,u.getLogger)("IntermediaryDiscovery: ");class p extends o.EventEmitter{constructor(t,e="https://api.github.com/repos/adambor/SolLightning-registry/contents/registry.json?ref=main",r,i){super(),this.intermediaries=[],this.swapContracts=t,this.registryUrl=e,this.overrideNodeUrls=r,this.httpRequestTimeout=i}async getIntermediaryUrls(t){if(null!=this.overrideNodeUrls&&this.overrideNodeUrls.length>0)return this.overrideNodeUrls;let e=(await (0,u.httpGet)(this.registryUrl,this.httpRequestTimeout,t)).content.replace(RegExp("\\n","g"),"");return JSON.parse(l.Buffer.from(e,"base64").toString())}async getNodeInfo(t,e){let r=await (0,u.tryWithRetries)(()=>c.IntermediaryAPI.getIntermediaryInfo(t,this.httpRequestTimeout,e),{maxRetries:3,delay:100,exponential:!0},void 0,e),i={};for(let n in r.chains)if(null!=this.swapContracts[n]){let{signature:a,address:o}=r.chains[n];try{await (0,u.tryWithRetries)(()=>this.swapContracts[n].isValidDataSignature(l.Buffer.from(r.envelope),a,o),{maxRetries:3,delay:100,exponential:!0},s.SignatureVerificationError,e),i[n]=o}catch(e){h.warn("Failed to verify "+n+" signature for intermediary: "+t)}}null!=e&&e.throwIfAborted();let n=JSON.parse(r.envelope);for(let t in n.services){let e=n.services[t];for(let t in null==e.chainTokens&&(e.chainTokens={SOLANA:e.tokens}),e.chainTokens)null==i[t]&&delete e.chainTokens[t]}return{addresses:i,info:n}}async loadIntermediary(t,e){try{let r=await this.getNodeInfo(t,e),s={};for(let t in r.info.services)s[function(t){switch(t){case i.FROM_BTC:return a.SwapType.FROM_BTC;case i.TO_BTC:return a.SwapType.TO_BTC;case i.FROM_BTCLN:return a.SwapType.FROM_BTCLN;case i.TO_BTCLN:return a.SwapType.TO_BTCLN;case i.FROM_BTC_TRUSTED:return a.SwapType.TRUSTED_FROM_BTC;case i.FROM_BTCLN_TRUSTED:return a.SwapType.TRUSTED_FROM_BTCLN;case i.FROM_BTC_SPV:return a.SwapType.SPV_VAULT_FROM_BTC}}(t)]=r.info.services[t];return new n.Intermediary(t,r.addresses,s)}catch(e){return h.warn("fetchIntermediaries(): Error contacting intermediary "+t+": ",e),null}}async fetchIntermediaries(t){let e=await this.getIntermediaryUrls(t);h.debug("fetchIntermediaries(): Pinging intermediaries: ",e.join());let r=e.map(e=>this.loadIntermediary(e,t)),i=(await Promise.all(r)).filter(t=>null!=t);if(0===i.length)throw Error("No online intermediary found!");return i}getIntermediary(t){let e=this.intermediaries.find(e=>e.url===t);return null!=e?Promise.resolve(e):this.loadIntermediary(t)}async reloadIntermediaries(t){let e=await (0,u.tryWithRetries)(()=>this.fetchIntermediaries(t),null,null,t);this.intermediaries=e,this.emit("added",e),h.info("reloadIntermediaries(): Using active intermediaries: ",e.map(t=>t.url).join())}init(t){return h.info("init(): Initializing with registryUrl: "+this.registryUrl+" intermediary array: "+(this.overrideNodeUrls||[]).join()),this.reloadIntermediaries(t)}getMultichainSwapBounds(){let t={};return this.intermediaries.forEach(e=>{for(let r in e.services){let i=e.services[r];t[r]??={};let n=t[r];for(let t in i.chainTokens){n[t]??={};let e=n[t];for(let r of i.chainTokens[t]){let t=e[r];null==t?e[r]={min:BigInt(i.min),max:BigInt(i.max)}:(t.min=(0,u.bigIntMin)(t.min,BigInt(i.min)),t.max=(0,u.bigIntMax)(t.max,BigInt(i.max)))}}}}),t}getSwapBounds(t){let e={};return this.intermediaries.forEach(r=>{for(let i in r.services){let n=r.services[i];null==e[i]&&(e[i]={});let a=e[i];if(null!=n.chainTokens&&null!=n.chainTokens[t])for(let e of n.chainTokens[t]){let t=a[e];null==t?a[e]={min:BigInt(n.min),max:BigInt(n.max)}:(t.min=(0,u.bigIntMin)(t.min,BigInt(n.min)),t.max=(0,u.bigIntMax)(t.max,BigInt(n.max)))}}}),e}getSwapMinimum(t,e,r){let i=r.toString();return this.intermediaries.reduce((r,n)=>{let a=n.services[e];return null!=a&&null!=a.chainTokens&&null!=a.chainTokens[t]&&a.chainTokens[t].includes(i)?null==r?a.min:Math.min(r,a.min):r},null)}getSwapMaximum(t,e,r){let i=r.toString();return this.intermediaries.reduce((r,n)=>{let a=n.services[e];return null!=a&&null!=a.chainTokens&&null!=a.chainTokens[t]&&a.chainTokens[t].includes(i)?null==r?a.max:Math.max(r,a.max):r},null)}getSwapCandidates(t,e,r,i,n){let s=this.intermediaries.filter(n=>{let a=n.services[e];return!(null==a||null!=i&&i<BigInt(a.min)||null!=i&&i>BigInt(a.max))&&null!=a.chainTokens&&null!=a.chainTokens[t]&&!!a.chainTokens[t].includes(r.toString())});return(s.sort((a.SwapType.TO_BTC,(t,r)=>{if(null==i)return t.services[e].swapFeePPM-r.services[e].swapFeePPM;{let n=BigInt(t.services[e].swapBaseFee)+i*BigInt(t.services[e].swapFeePPM)/1000000n,a=BigInt(r.services[e].swapBaseFee)+i*BigInt(r.services[e].swapFeePPM)/1000000n;return n-a>0n?1:n===a?0:-1}})),null==n)?s:s.slice(0,n)}removeIntermediary(t){let e=this.intermediaries.indexOf(t);return e>=0&&(h.info("removeIntermediary(): Removing intermediary: "+t.url),this.intermediaries.splice(e,1),this.emit("removed",[t]),!0)}}r.IntermediaryDiscovery=p},179576,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ISwapPrice=r.isPriceInfoType=void 0,r.isPriceInfoType=function(t){return null!=t&&"boolean"==typeof t.isValid&&"bigint"==typeof t.differencePPM&&"bigint"==typeof t.satsBaseFee&&"bigint"==typeof t.feePPM&&"bigint"==typeof t.realPriceUSatPerToken&&"bigint"==typeof t.swapPriceUSatPerToken},r.ISwapPrice=class{constructor(t){this.maxAllowedFeeDifferencePPM=t}recomputePriceInfoSend(t,e,r,i,n,a){let s=1000000n*(e*(1000000n+i)/1000000n+r)*10n**BigInt(this.getDecimals(t,a))/n;return{isValid:!0,differencePPM:0n,satsBaseFee:r,feePPM:i,realPriceUSatPerToken:this.shouldIgnore(t,a)?null:s,swapPriceUSatPerToken:s}}async isValidAmountSend(t,e,r,i,n,a,s,o){let l=e*(1000000n+i)/1000000n+r,u=1000000n*l,c=u*10n**BigInt(this.getDecimals(t,a))/n;if(this.shouldIgnore(t,a))return{isValid:!0,differencePPM:0n,satsBaseFee:r,feePPM:i,realPriceUSatPerToken:null,swapPriceUSatPerToken:c};let h=await this.getFromBtcSwapAmount(t,l,a,s,o),p=u*10n**BigInt(this.getDecimals(t,a))/h,d=1000000n*(n-h)/h;return{isValid:d<=this.maxAllowedFeeDifferencePPM,differencePPM:d,satsBaseFee:r,feePPM:i,realPriceUSatPerToken:p,swapPriceUSatPerToken:c}}recomputePriceInfoReceive(t,e,r,i,n,a){let s=1000000n*(e*(1000000n-i)/1000000n-r)*10n**BigInt(this.getDecimals(t,a))/n;return{isValid:!0,differencePPM:0n,satsBaseFee:r,feePPM:i,realPriceUSatPerToken:this.shouldIgnore(t,a)?null:s,swapPriceUSatPerToken:s}}async isValidAmountReceive(t,e,r,i,n,a,s,o){let l=e*(1000000n-i)/1000000n-r,u=1000000n*l,c=u*10n**BigInt(this.getDecimals(t,a))/n;if(this.shouldIgnore(t,a))return{isValid:!0,differencePPM:0n,satsBaseFee:r,feePPM:i,realPriceUSatPerToken:null,swapPriceUSatPerToken:c};let h=await this.getFromBtcSwapAmount(t,l,a,s,o),p=u*10n**BigInt(this.getDecimals(t,a))/h,d=100000n*(h-n)/h;return{isValid:d<=this.maxAllowedFeeDifferencePPM,differencePPM:d,satsBaseFee:r,feePPM:i,realPriceUSatPerToken:p,swapPriceUSatPerToken:c}}preFetchPrice(t,e,r){return this.getPrice(t,e,r)}preFetchUsdPrice(t){return this.getUsdPrice(t)}async getFromBtcSwapAmount(t,e,r,i,n){if(null==this.getDecimals(t,r.toString()))throw Error("Token not found!");let a=n||await this.getPrice(t,r,i);return e*10n**BigInt(this.getDecimals(t,r.toString()))*1000000n/a}async getToBtcSwapAmount(t,e,r,i,n){if(null==this.getDecimals(t,r.toString()))throw Error("Token not found");return e*(n||await this.getPrice(t,r,i))/1000000n/10n**BigInt(this.getDecimals(t,r.toString()))}shouldIgnore(t,e){let r=this.getDecimals(t,e.toString());if(null==r)throw Error("Token not found");return -1===r}async getBtcUsdValue(t,e,r){return Number(t)*(r||await this.getUsdPrice(e))}async getTokenUsdValue(t,e,r,i,n){let[a,s]=await Promise.all([this.getToBtcSwapAmount(t,e,r,i),null==n?this.preFetchUsdPrice(i):Promise.resolve(n)]);return Number(a)*s}getUsdValue(t,e,r,i){return"BTC"===e.chain?this.getBtcUsdValue(t,r,i):this.getTokenUsdValue(e.chainId,t,e.address,r,i)}}},449503,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ICachedSwapPrice=void 0;let i=t.r(179576);class n extends i.ISwapPrice{constructor(t,e){super(t),this.cache={},this.cacheTimeout=e||1e4}getPrice(t,e,r){let i=e.toString(),n=this.cache[t];if(null!=n){let e=n[i];if(null!=e&&e.expiry>Date.now())return e.price.catch(e=>this.fetchPrice(t,i,r))}let a=this.fetchPrice(t,i);return this.cache[t]??={},this.cache[t][i]={price:a,expiry:Date.now()+this.cacheTimeout},a.catch(e=>{throw null!=this.cache[t]&&null!=this.cache[t][i]&&this.cache[t][i].price===a&&delete this.cache[i],e}),a}getUsdPrice(t){if(null!=this.usdCache&&this.usdCache.expiry>Date.now())return this.usdCache.price.catch(e=>this.fetchUsdPrice(t));let e=this.fetchUsdPrice();return this.usdCache={price:e,expiry:Date.now()+this.cacheTimeout},e.catch(t=>{throw null!=this.usdCache&&this.usdCache.price===e&&delete this.usdCache,t}),e}}r.ICachedSwapPrice=n},847923,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IPriceProvider=void 0,r.IPriceProvider=class{constructor(t){for(let e of(this.coinsMap={},t))if(null!=e.coinId)for(let t in e.chains){let{address:r,decimals:i}=e.chains[t];this.coinsMap[t]??={},this.coinsMap[t][r.toString()]={coinId:e.coinId,decimals:i}}}getPrice(t,e,r){let i=e.toString(),n=this.coinsMap[t];if(null==n)throw Error("Chain not found");let a=n[i];if(null==a)throw Error("Token not found");return a.coinId.startsWith("$fixed-")?Promise.resolve(BigInt(Math.floor(1e6*parseFloat(a.coinId.substring(7))).toString(10))):this.fetchPrice(a,r)}getUsdPrice(t){return this.fetchUsdPrice(t)}getDecimals(t,e){let r=this.coinsMap[t];if(null==r)throw Error("Chain not found");let i=r[e.toString()];if(null==i)throw Error("Token not found");return"$ignore"===i.coinId?-1:i.decimals}}},712099,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.HttpPriceProvider=void 0;let i=t.r(847923);class n extends i.IPriceProvider{constructor(t,e,r){super(t),this.url=e,this.httpRequestTimeout=r}}r.HttpPriceProvider=n},31857,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ExchangePriceProvider=void 0;let i=t.r(712099);class n extends i.HttpPriceProvider{async fetchPrice(t,e){let r=t.coinId.split(";");return BigInt(Math.floor(1e14*(await Promise.all(r.map(t=>{let r=t.startsWith("!");return r&&(t=t.substring(1)),this.fetchPair(t,e).then(t=>r?1/t:t)}))).reduce((t,e)=>t*e,1)))}}r.ExchangePriceProvider=n},977789,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.BinancePriceProvider=void 0;let i=t.r(31857),n=t.r(389215);class a extends i.ExchangePriceProvider{constructor(t,e="https://api.binance.com/api/v3",r){super(t,e,r)}async fetchPair(t,e){return parseFloat((await (0,n.httpGet)(this.url+"/ticker/price?symbol="+t,this.httpRequestTimeout,e)).price)}async fetchUsdPrice(t){return parseFloat((await (0,n.httpGet)(this.url+"/ticker/price?symbol=BTCUSDC",this.httpRequestTimeout,t)).price)/1e8}}r.BinancePriceProvider=a},196840,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.CoinGeckoPriceProvider=void 0;let i=t.r(712099),n=t.r(389215);class a extends i.HttpPriceProvider{constructor(t,e="https://api.coingecko.com/api/v3",r){super(t,e,r)}async fetchPrice(t,e){return BigInt(1e6*(await (0,n.httpGet)(this.url+"/simple/price?ids="+t.coinId+"&vs_currencies=sats&precision=6",this.httpRequestTimeout,e))[t.coinId].sats)}async fetchUsdPrice(t){return(await (0,n.httpGet)(this.url+"/simple/price?ids=bitcoin&vs_currencies=usd&precision=9",this.httpRequestTimeout,t)).bitcoin.usd/1e8}}r.CoinGeckoPriceProvider=a},70350,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.CoinPaprikaPriceProvider=void 0;let i=t.r(712099),n=t.r(389215);class a extends i.HttpPriceProvider{constructor(t,e="https://api.coinpaprika.com/v1",r){super(t,e,r)}async fetchPrice(t,e){return BigInt(Math.floor(1e14*(await (0,n.httpGet)(this.url+"/tickers/"+t.coinId+"?quotes=BTC",this.httpRequestTimeout,e)).quotes.BTC.price))}async fetchUsdPrice(t){return(await (0,n.httpGet)(this.url+"/tickers/btc-bitcoin?quotes=USD",this.httpRequestTimeout,t)).quotes.USD.price/1e8}}r.CoinPaprikaPriceProvider=a},999660,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.OKXPriceProvider=void 0;let i=t.r(31857),n=t.r(389215);class a extends i.ExchangePriceProvider{constructor(t,e="https://www.okx.com/api/v5",r){super(t,e,r)}async fetchPair(t,e){return parseFloat((await (0,n.httpGet)(this.url+"/market/index-tickers?instId="+t,this.httpRequestTimeout,e)).data[0].idxPx)}async fetchUsdPrice(t){return parseFloat((await (0,n.httpGet)(this.url+"/market/index-tickers?instId=BTC-USD",this.httpRequestTimeout,t)).data[0].idxPx)/1e8}}r.OKXPriceProvider=a},147087,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.CustomPriceProvider=void 0;let i=t.r(847923);class n extends i.IPriceProvider{constructor(t,e){super(t),this.getUsdPriceFn=e}async fetchPrice(t,e){let[r,i]=await this.getUsdPriceFn(["BTC",t.coinId],e);return BigInt(Math.floor(i/r*1e14))}async fetchUsdPrice(t){let[e]=await this.getUsdPriceFn(["BTC"],t);return e/1e8}}r.CustomPriceProvider=n},562331,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.KrakenPriceProvider=void 0;let i=t.r(31857),n=t.r(389215);class a extends i.ExchangePriceProvider{constructor(t,e="https://api.kraken.com/0",r){super(t,e,r)}async fetchPair(t,e){return parseFloat((await (0,n.httpGet)(this.url+"/public/Ticker?pair="+t,this.httpRequestTimeout,e)).result[t].c[0])}async fetchUsdPrice(t){return parseFloat((await (0,n.httpGet)(this.url+"/public/Ticker?pair=XBTUSDC",this.httpRequestTimeout,t)).result.XBTUSDC.c[0])/1e8}async fetchPrice(t,e){let r=t.coinId.split(";"),i=await (0,n.httpGet)(this.url+"/public/Ticker?pair="+r.map(t=>t.startsWith("!")?t.substring(1):t).join(","),this.httpRequestTimeout,e);return BigInt(Math.floor(1e14*r.map(t=>{let e=t.startsWith("!");e&&(t=t.substring(1));let r=parseFloat(i.result[t].c[0]);return e?1/r:r}).reduce((t,e)=>t*e,1)))}}r.KrakenPriceProvider=a},239536,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.RedundantSwapPrice=void 0;let i=t.r(977789),n=t.r(999660),a=t.r(196840),s=t.r(70350),o=t.r(389215),l=t.r(449503),u=t.r(742396),c=t.r(562331),h=(0,o.getLogger)("RedundantSwapPrice: ");class p extends l.ICachedSwapPrice{static createFromTokenMap(t,e,r){let o=[new i.BinancePriceProvider(e.map(t=>({coinId:t.binancePair,chains:t.chains}))),new n.OKXPriceProvider(e.map(t=>({coinId:t.okxPair,chains:t.chains}))),new a.CoinGeckoPriceProvider(e.map(t=>({coinId:t.coinGeckoCoinId,chains:t.chains}))),new s.CoinPaprikaPriceProvider(e.map(t=>({coinId:t.coinPaprikaCoinId,chains:t.chains}))),new c.KrakenPriceProvider(e.map(t=>({coinId:t.krakenPair,chains:t.chains})))];return new p(t,e,o,r)}constructor(t,e,r,i){for(let r of(super(t,i),this.coinsDecimals={},e))for(let t in r.chains){let{address:e,decimals:i}=r.chains[t];this.coinsDecimals[t]??={},this.coinsDecimals[t][e.toString()]=i}this.priceApis=r.map(t=>({priceApi:t,operational:null}))}getOperationalPriceApi(){return this.priceApis.find(t=>!0===t.operational)}getMaybeOperationalPriceApis(){let t=this.priceApis.filter(t=>!0===t.operational||null===t.operational);return 0===t.length&&(this.priceApis.forEach(t=>t.operational=null),t=this.priceApis),t}async fetchPriceFromMaybeOperationalPriceApis(t,e,r){try{return await (0,o.promiseAny)(this.getMaybeOperationalPriceApis().map(i=>(async()=>{try{let n=await i.priceApi.getPrice(t,e,r);return h.debug("fetchPrice(): Price from "+i.priceApi.constructor.name+": ",n.toString(10)),i.operational=!0,n}catch(t){throw null!=r&&r.throwIfAborted(),i.operational=!1,t}})()))}catch(t){throw null!=r&&r.throwIfAborted(),t.find(t=>!(t instanceof u.RequestError))||t[0]}}fetchPrice(t,e,r){return(0,o.tryWithRetries)(async()=>{let i=this.getOperationalPriceApi();if(null!=i)try{return await i.priceApi.getPrice(t,e,r)}catch(t){null!=r&&r.throwIfAborted(),i.operational=!1}return await this.fetchPriceFromMaybeOperationalPriceApis(t,e,r)},null,u.RequestError,r)}getDecimals(t,e){return null==this.coinsDecimals[t]?null:this.coinsDecimals[t][e.toString()]}async fetchUsdPriceFromMaybeOperationalPriceApis(t){try{return await (0,o.promiseAny)(this.getMaybeOperationalPriceApis().map(e=>(async()=>{try{let r=await e.priceApi.getUsdPrice(t);return h.debug("fetchPrice(): USD price from "+e.priceApi.constructor.name+": ",r.toString(10)),e.operational=!0,r}catch(r){throw null!=t&&t.throwIfAborted(),e.operational=!1,r}})()))}catch(e){throw null!=t&&t.throwIfAborted(),e.find(t=>!(t instanceof u.RequestError))||e[0]}}fetchUsdPrice(t){return(0,o.tryWithRetries)(()=>{let e=this.getOperationalPriceApi();return null!=e?e.priceApi.getUsdPrice(t).catch(r=>(null!=t&&t.throwIfAborted(),e.operational=!1,this.fetchUsdPriceFromMaybeOperationalPriceApis(t))):this.fetchUsdPriceFromMaybeOperationalPriceApis(t)},null,u.RequestError,t)}}r.RedundantSwapPrice=p},266854,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SingleSwapPrice=void 0;let i=t.r(449503);class n extends i.ICachedSwapPrice{constructor(t,e,r){super(t,r),this.priceProvider=e}fetchPrice(t,e,r){return this.priceProvider.getPrice(t,e,r)}getDecimals(t,e){return this.priceProvider.getDecimals(t,e.toString())}fetchUsdPrice(t){return this.priceProvider.getUsdPrice(t)}}r.SingleSwapPrice=n},228252,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SwapPriceWithChain=void 0,r.SwapPriceWithChain=class{constructor(t,e){this.swapPrice=t,this.chainIdentifier=e}async isValidAmountSend(t,e,r,i,n,a,s){return this.swapPrice.isValidAmountSend(this.chainIdentifier,t,e,r,i,n,a,s)}async isValidAmountReceive(t,e,r,i,n,a,s){return this.swapPrice.isValidAmountReceive(this.chainIdentifier,t,e,r,i,n,a,s)}preFetchPrice(t,e){return this.swapPrice.preFetchPrice(this.chainIdentifier,t,e)}preFetchUsdPrice(t){return this.swapPrice.preFetchUsdPrice(t)}async getFromBtcSwapAmount(t,e,r,i){return this.swapPrice.getFromBtcSwapAmount(this.chainIdentifier,t,e,r,i)}async getToBtcSwapAmount(t,e,r,i){return this.swapPrice.getToBtcSwapAmount(this.chainIdentifier,t,e,r,i)}shouldIgnore(t){return this.swapPrice.shouldIgnore(this.chainIdentifier,t)}async getBtcUsdValue(t,e,r){return this.swapPrice.getBtcUsdValue(t,e,r)}async getTokenUsdValue(t,e,r,i){return this.swapPrice.getTokenUsdValue(this.chainIdentifier,t,e,r,i)}getUsdValue(t,e,r,i){return this.swapPrice.getUsdValue(t,e,r,i)}}},844485,(t,e,r)=>{"use strict";function i(t){return"object"==typeof t&&"BTC"===t.chain&&"boolean"==typeof t.lightning&&"string"==typeof t.ticker&&"number"==typeof t.decimals&&"string"==typeof t.name}function n(t){return"object"==typeof t&&"SC"===t.chain&&"string"==typeof t.chainId&&"string"==typeof t.address&&"string"==typeof t.ticker&&"number"==typeof t.decimals&&"string"==typeof t.name}function a(t,e,r,i){if(e<=0)return t.toString(10)+"0".repeat(-e);let n=t.toString(10).padStart(e+1,"0"),a=n.length-e,s=n.substring(a,n.length),o=s.length;if(r&&o>0){for(let t=s.length-1;t--;)if("0"===s.charAt(t))o=t;else break;0===o&&(o=1)}return 0===i?n.substring(0,a):(null!=i&&o>i&&(o=i),n.substring(0,a)+"."+s.substring(0,o))}Object.defineProperty(r,"__esModule",{value:!0}),r.toTokenAmount=r.toDecimal=r.fromDecimal=r.isToken=r.isSCToken=r.BitcoinTokens=r.isBtcToken=void 0,r.isBtcToken=i,r.BitcoinTokens={BTC:{chain:"BTC",lightning:!1,ticker:"BTC",decimals:8,name:"Bitcoin (on-chain L1)"},BTCLN:{chain:"BTC",lightning:!0,ticker:"BTC",decimals:8,name:"Bitcoin (lightning L2)"}},r.isSCToken=n,r.isToken=function(t){return i(t)||n(t)},r.fromDecimal=function(t,e){if(t.includes(".")){let[r,i]=t.split(".");return e<0?BigInt(r.substring(0,r.length+e)):i.length>e?BigInt(("0"===r?"":r)+i.substring(0,e)):BigInt(("0"===r?"":r)+i.padEnd(e,"0"))}return e<0?BigInt(t.substring(0,t.length+e)):BigInt(t+"0".repeat(e))},r.toDecimal=a,r.toTokenAmount=function(t,e,r){if(null==t)return null;let i=a(t,e.decimals,void 0,e.displayDecimals);return{rawAmount:t,amount:i,_amount:parseFloat(i),token:e,usdValue:(i,n)=>r.getUsdValue(t,e,i,n),toString:()=>i+" "+e.ticker}}},377691,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SwapDirection=void 0,function(t){t[t.FROM_BTC=0]="FROM_BTC",t[t.TO_BTC=1]="TO_BTC"}(r.SwapDirection||(r.SwapDirection={}))},185670,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ISwap=r.ppmToPercentage=r.isISwapInit=void 0;let i=t.r(853312),n=t.r(427699),a=t.r(179576),s=t.r(389215),o=t.r(377691);function l(t){return"object"==typeof t&&null!=t&&(0,a.isPriceInfoType)(t.pricingInfo)&&"string"==typeof t.url&&"number"==typeof t.expiry&&"bigint"==typeof t.swapFee&&(null==t.swapFeeBtc||"bigint"==typeof t.swapFeeBtc)&&"boolean"==typeof t.exactIn}function u(t){if(null==t)return null;let e=Number(t)/1e4;return{ppm:t,decimal:Number(t)/1e6,percentage:e,toString:t=>(null!=t?e.toFixed(t):e)+"%"}}r.isISwapInit=l,r.ppmToPercentage=u,r.ISwap=class{constructor(t,e){this.currentVersion=1,this.initiated=!1,this.events=new n.EventEmitter,this.chainIdentifier=t.chainIdentifier,this.wrapper=t,l(e)?(Object.assign(this,e),this.version=this.currentVersion,this.createdAt=Date.now(),this.randomNonce=(0,s.randomBytes)(16).toString("hex")):(this.expiry=e.expiry,this.url=e.url,this.state=e.state,this.pricingInfo={isValid:e._isValid,differencePPM:null==e._differencePPM?null:BigInt(e._differencePPM),satsBaseFee:null==e._satsBaseFee?null:BigInt(e._satsBaseFee),feePPM:null==e._feePPM?null:BigInt(e._feePPM),realPriceUSatPerToken:null==e._realPriceUSatPerToken?null:BigInt(e._realPriceUSatPerToken),swapPriceUSatPerToken:null==e._swapPriceUSatPerToken?null:BigInt(e._swapPriceUSatPerToken)},this.swapFee=null==e.swapFee?null:BigInt(e.swapFee),this.swapFeeBtc=null==e.swapFeeBtc?null:BigInt(e.swapFeeBtc),this.version=e.version,this.initiated=e.initiated,this.exactIn=e.exactIn,this.createdAt=e.createdAt??e.expiry,this.randomNonce=e.randomNonce),this.version!==this.currentVersion&&this.upgradeVersion(),null==this.initiated&&(this.initiated=!0)}waitTillState(t,e="eq",r){return new Promise((i,n)=>{let a;a=r=>{("eq"===e?r.state===t:"gte"===e?r.state>=t:r.state!=t)&&(i(),this.events.removeListener("swapState",a))},this.events.on("swapState",a),null!=r&&r.addEventListener("abort",()=>{this.events.removeListener("swapState",a),n(r.reason)})})}tryRecomputeSwapPrice(){if(null==this.pricingInfo.swapPriceUSatPerToken)if(this.getDirection()===o.SwapDirection.TO_BTC){let t=this.getInput();this.pricingInfo=this.wrapper.prices.recomputePriceInfoSend(this.chainIdentifier,this.getOutput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,t.rawAmount,t.token.address)}else{let t=this.getOutput();this.pricingInfo=this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier,this.getInput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,t.rawAmount,t.token.address)}}async refreshPriceData(){if(null==this.pricingInfo)return null;if(this.getDirection()===o.SwapDirection.TO_BTC){let t=this.getInput();this.pricingInfo=await this.wrapper.prices.isValidAmountSend(this.chainIdentifier,this.getOutput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,t.rawAmount,t.token.address)}else{let t=this.getOutput();this.pricingInfo=await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier,this.getInput().rawAmount,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,t.rawAmount,t.token.address)}}hasValidPrice(){return null==this.pricingInfo?null:this.pricingInfo.isValid}getPriceInfo(){let t=this.getDirection()===o.SwapDirection.TO_BTC?1e14/Number(this.pricingInfo.swapPriceUSatPerToken):Number(this.pricingInfo.swapPriceUSatPerToken)/1e14;return{marketPrice:this.getDirection()===o.SwapDirection.TO_BTC?1e14/Number(this.pricingInfo.realPriceUSatPerToken):Number(this.pricingInfo.swapPriceUSatPerToken)/1e14,swapPrice:t,difference:u(this.pricingInfo.differencePPM)}}checkSigner(t){if(("string"==typeof t?t:t.getAddress())!==this._getInitiator())throw Error("Invalid signer provided!")}isInitiated(){return this.initiated}_setInitiated(){this.initiated=!0}getQuoteExpiry(){return this.expiry}getType(){return this.TYPE}getDirection(){return this.TYPE===i.SwapType.TO_BTC||this.TYPE===i.SwapType.TO_BTCLN?o.SwapDirection.TO_BTC:o.SwapDirection.FROM_BTC}getState(){return this.state}serialize(){return null==this.pricingInfo?{}:{id:this.getId(),type:this.getType(),escrowHash:this._getEscrowHash(),initiator:this._getInitiator(),_isValid:this.pricingInfo.isValid,_differencePPM:null==this.pricingInfo.differencePPM?null:this.pricingInfo.differencePPM.toString(10),_satsBaseFee:null==this.pricingInfo.satsBaseFee?null:this.pricingInfo.satsBaseFee.toString(10),_feePPM:null==this.pricingInfo.feePPM?null:this.pricingInfo.feePPM.toString(10),_realPriceUSatPerToken:null==this.pricingInfo.realPriceUSatPerToken?null:this.pricingInfo.realPriceUSatPerToken.toString(10),_swapPriceUSatPerToken:null==this.pricingInfo.swapPriceUSatPerToken?null:this.pricingInfo.swapPriceUSatPerToken.toString(10),state:this.state,url:this.url,swapFee:null==this.swapFee?null:this.swapFee.toString(10),swapFeeBtc:null==this.swapFeeBtc?null:this.swapFeeBtc.toString(10),expiry:this.expiry,version:this.version,initiated:this.initiated,exactIn:this.exactIn,createdAt:this.createdAt,randomNonce:this.randomNonce}}_save(){return this.isQuoteExpired()?this.wrapper.removeSwapData(this):this.wrapper.saveSwapData(this)}async _saveAndEmit(t){null!=t&&(this.state=t),await this._save(),this._emitEvent()}_emitEvent(){this.wrapper.events.emit("swapState",this),this.events.emit("swapState",this)}}},525059,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0})},934867,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ISwapWrapper=void 0;let i=t.r(427699),n=t.r(46575),a=t.r(389215);r.ISwapWrapper=class{constructor(t,e,r,n,s,o,l,u){for(let c of(this.logger=(0,a.getLogger)(this.constructor.name+": "),this.pendingSwaps=new Map,this.isInitialized=!1,this.tickInterval=null,this.unifiedStorage=e,this.unifiedChainEvents=r,this.chainIdentifier=t,this.chain=n,this.prices=s,this.events=u||new i.EventEmitter,this.options=l,this.tokens={},o)){let e=c.chains[t];null!=e&&(this.tokens[e.address]={chain:"SC",chainId:this.chainIdentifier,address:e.address,decimals:e.decimals,ticker:c.ticker,name:c.name,displayDecimals:e.displayDecimals})}}preFetchPrice(t,e){return this.prices.preFetchPrice(this.chainIdentifier,t.token,e).catch(t=>(this.logger.error("preFetchPrice(): Error: ",t),null))}async verifyReturnedPrice(t,e,r,i,a,s,o=Promise.resolve(null),l){let u=BigInt(t.swapBaseFee),c=BigInt(t.swapFeePPM);e&&(i-=s.networkFee);let h=await (e?this.prices.isValidAmountSend(this.chainIdentifier,r,u,c,i,a,l,await o):this.prices.isValidAmountReceive(this.chainIdentifier,r,u,c,i,a,l,await o));if(!h.isValid)throw new n.IntermediaryError("Fee too high");return h}async init(t=!1,e=!1){if(this.isInitialized)return;let r=null!=this.processEvent,i=[];if(r&&this.unifiedChainEvents.registerListener(this.TYPE,(t,e)=>(i.push({event:t,swap:e}),Promise.resolve()),this.swapDeserializer.bind(null,this)),e||await this.checkPastSwaps(),r){for(let t of i)await this.processEvent(t.event,t.swap);this.unifiedChainEvents.unregisterListener(this.TYPE),this.unifiedChainEvents.registerListener(this.TYPE,this.processEvent.bind(this),this.swapDeserializer.bind(null,this))}t||this.startTickInterval(),this.isInitialized=!0}startTickInterval(){null!=this.tickSwapState&&0!==this.tickSwapState.length&&(this.tickInterval=setInterval(()=>{this.tick()},1e3))}async checkPastSwaps(t){null==t&&(t=await this.unifiedStorage.query([[{key:"type",value:this.TYPE},{key:"state",value:this.pendingSwapStates}]],t=>new this.swapDeserializer(this,t)));let e=[],r=[];await Promise.all(t.map(t=>t._sync(!1).then(i=>{t.isQuoteExpired()?(r.push(t),this.logger.debug("init(): Removing expired swap: "+t.getId())):i&&e.push(t)}).catch(e=>this.logger.error("init(): Error when checking swap "+t.getId()+": ",e)))),await this.unifiedStorage.removeAll(r),await this.unifiedStorage.saveAll(e)}async tick(t){for(let e of(null==t&&(t=await this.unifiedStorage.query([[{key:"type",value:this.TYPE},{key:"state",value:this.tickSwapState}]],t=>new this.swapDeserializer(this,t))),this.pendingSwaps.values())){let t=e.deref();null!=t&&t._tick(!0)}t.forEach(t=>{t._tick(!0)})}saveSwapData(t){return t.isInitiated()?(this.pendingSwaps.delete(t.getId()),this.unifiedStorage.save(t)):(this.logger.debug("saveSwapData(): Swap "+t.getId()+" not initiated, saving to pending swaps"),this.pendingSwaps.set(t.getId(),new WeakRef(t)),Promise.resolve())}removeSwapData(t){return(this.pendingSwaps.delete(t.getId()),t.isInitiated())?this.unifiedStorage.remove(t):Promise.resolve()}async stop(){this.isInitialized=!1,this.unifiedChainEvents.unregisterListener(this.TYPE),this.logger.info("stop(): Swap wrapper stopped"),null!=this.tickInterval&&clearInterval(this.tickInterval)}getNativeToken(){return this.tokens[this.chain.getNativeCurrencyAddress()]}}},959455,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.hmac=r.HMAC=void 0;let i=t.r(697858);class n extends i.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,(0,i.ahash)(t);let r=(0,i.toBytes)(e);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let n=this.blockLen,a=new Uint8Array(n);a.set(r.length>n?t.create().update(r).digest():r);for(let t=0;t<a.length;t++)a[t]^=54;this.iHash.update(a),this.oHash=t.create();for(let t=0;t<a.length;t++)a[t]^=106;this.oHash.update(a),(0,i.clean)(a)}update(t){return(0,i.aexists)(this),this.iHash.update(t),this}digestInto(t){(0,i.aexists)(this),(0,i.abytes)(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){let t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));let{oHash:e,iHash:r,finished:i,destroyed:n,blockLen:a,outputLen:s}=this;return t.finished=i,t.destroyed=n,t.blockLen=a,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}r.HMAC=n,r.hmac=(t,e,r)=>new n(t,e).update(r).digest(),r.hmac.create=(t,e)=>new n(t,e)},374752,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.notImplemented=r.bitMask=r.utf8ToBytes=r.randomBytes=r.isBytes=r.hexToBytes=r.concatBytes=r.bytesToUtf8=r.bytesToHex=r.anumber=r.abytes=void 0,r.abool=function(t,e){if("boolean"!=typeof e)throw Error(t+" boolean expected, got "+e)},r._abool2=function(t,e=""){if("boolean"!=typeof t)throw Error((e&&`"${e}"`)+"expected boolean, got type="+typeof t);return t},r._abytes2=function(t,e,r=""){let n=(0,i.isBytes)(t),a=t?.length,s=void 0!==e;if(!n||s&&a!==e)throw Error((r&&`"${r}" `)+"expected Uint8Array"+(s?` of length ${e}`:"")+", got "+(n?`length=${a}`:`type=${typeof t}`));return t},r.numberToHexUnpadded=o,r.hexToNumber=l,r.bytesToNumberBE=function(t){return l((0,i.bytesToHex)(t))},r.bytesToNumberLE=function(t){return(0,i.abytes)(t),l((0,i.bytesToHex)(Uint8Array.from(t).reverse()))},r.numberToBytesBE=u,r.numberToBytesLE=function(t,e){return u(t,e).reverse()},r.numberToVarBytesBE=function(t){return(0,i.hexToBytes)(o(t))},r.ensureBytes=function(t,e,r){let n;if("string"==typeof e)try{n=(0,i.hexToBytes)(e)}catch(e){throw Error(t+" must be hex string or Uint8Array, cause: "+e)}else if((0,i.isBytes)(e))n=Uint8Array.from(e);else throw Error(t+" must be hex string or Uint8Array");let a=n.length;if("number"==typeof r&&a!==r)throw Error(t+" of length "+r+" expected, got "+a);return n},r.equalBytes=function(t,e){if(t.length!==e.length)return!1;let r=0;for(let i=0;i<t.length;i++)r|=t[i]^e[i];return 0===r},r.copyBytes=function(t){return Uint8Array.from(t)},r.asciiToBytes=function(t){return Uint8Array.from(t,(e,r)=>{let i=e.charCodeAt(0);if(1!==e.length||i>127)throw Error(`string contains non-ASCII character "${t[r]}" with code ${i} at position ${r}`);return i})},r.inRange=h,r.aInRange=function(t,e,r,i){if(!h(e,r,i))throw Error("expected valid "+t+": "+r+" <= n < "+i+", got "+e)},r.bitLen=function(t){let e;for(e=0;t>a;t>>=s,e+=1);return e},r.bitGet=function(t,e){return t>>BigInt(e)&s},r.bitSet=function(t,e,r){return t|(r?s:a)<<BigInt(e)},r.createHmacDrbg=function(t,e,r){if("number"!=typeof t||t<2)throw Error("hashLen must be a number");if("number"!=typeof e||e<2)throw Error("qByteLen must be a number");if("function"!=typeof r)throw Error("hmacFn must be a function");let n=t=>new Uint8Array(t),a=t=>Uint8Array.of(t),s=n(t),o=n(t),l=0,u=()=>{s.fill(1),o.fill(0),l=0},c=(...t)=>r(o,s,...t),h=(t=n(0))=>{o=c(a(0),t),s=c(),0!==t.length&&(o=c(a(1),t),s=c())},p=()=>{if(l++>=1e3)throw Error("drbg: tried 1000 values");let t=0,r=[];for(;t<e;){let e=(s=c()).slice();r.push(e),t+=s.length}return(0,i.concatBytes)(...r)};return(t,e)=>{let r;for(u(),h(t);!(r=e(p()));)h();return u(),r}},r.validateObject=function(t,e,r={}){let i=(e,r,i)=>{let n=p[r];if("function"!=typeof n)throw Error("invalid validator function");let a=t[e];if((!i||void 0!==a)&&!n(a,t))throw Error("param "+String(e)+" is invalid. Expected "+r+", got "+a)};for(let[t,r]of Object.entries(e))i(t,r,!1);for(let[t,e]of Object.entries(r))i(t,e,!0);return t},r.isHash=function(t){return"function"==typeof t&&Number.isSafeInteger(t.outputLen)},r._validateObject=function(t,e,r={}){if(!t||"object"!=typeof t)throw Error("expected valid options object");function i(e,r,i){let n=t[e];if(i&&void 0===n)return;let a=typeof n;if(a!==r||null===n)throw Error(`param "${e}" is invalid: expected ${r}, got ${a}`)}Object.entries(e).forEach(([t,e])=>i(t,e,!1)),Object.entries(r).forEach(([t,e])=>i(t,e,!0))},r.memoized=function(t){let e=new WeakMap;return(r,...i)=>{let n=e.get(r);if(void 0!==n)return n;let a=t(r,...i);return e.set(r,a),a}};let i=t.r(697858);var n=t.r(697858);Object.defineProperty(r,"abytes",{enumerable:!0,get:function(){return n.abytes}}),Object.defineProperty(r,"anumber",{enumerable:!0,get:function(){return n.anumber}}),Object.defineProperty(r,"bytesToHex",{enumerable:!0,get:function(){return n.bytesToHex}}),Object.defineProperty(r,"bytesToUtf8",{enumerable:!0,get:function(){return n.bytesToUtf8}}),Object.defineProperty(r,"concatBytes",{enumerable:!0,get:function(){return n.concatBytes}}),Object.defineProperty(r,"hexToBytes",{enumerable:!0,get:function(){return n.hexToBytes}}),Object.defineProperty(r,"isBytes",{enumerable:!0,get:function(){return n.isBytes}}),Object.defineProperty(r,"randomBytes",{enumerable:!0,get:function(){return n.randomBytes}}),Object.defineProperty(r,"utf8ToBytes",{enumerable:!0,get:function(){return n.utf8ToBytes}});let a=BigInt(0),s=BigInt(1);function o(t){let e=t.toString(16);return 1&e.length?"0"+e:e}function l(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return""===t?a:BigInt("0x"+t)}function u(t,e){return(0,i.hexToBytes)(t.toString(16).padStart(2*e,"0"))}let c=t=>"bigint"==typeof t&&a<=t;function h(t,e,r){return c(t)&&c(e)&&c(r)&&e<=t&&t<r}r.bitMask=t=>(s<<BigInt(t))-s;let p={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||(0,i.isBytes)(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};r.notImplemented=()=>{throw Error("not implemented")}},113157,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.isNegativeLE=void 0,r.mod=f,r.pow=function(t,e,r){return I(A(r),t,e)},r.pow2=function(t,e,r){let i=t;for(;e-- >n;)i*=i,i%=r;return i},r.invert=m,r.tonelliShanks=T,r.FpSqrt=S,r.validateField=function(t){let e=E.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"});return(0,i._validateObject)(t,e),t},r.FpPow=I,r.FpInvertBatch=b,r.FpDiv=function(t,e,r){return t.mul(e,"bigint"==typeof r?m(r,t.ORDER):t.inv(r))},r.FpLegendre=v,r.FpIsSquare=function(t,e){return 1===v(t,e)},r.nLength=B,r.Field=A,r.FpSqrtOdd=function(t,e){if(!t.isOdd)throw Error("Field doesn't have isOdd");let r=t.sqrt(e);return t.isOdd(r)?r:t.neg(r)},r.FpSqrtEven=function(t,e){if(!t.isOdd)throw Error("Field doesn't have isOdd");let r=t.sqrt(e);return t.isOdd(r)?t.neg(r):r},r.hashToPrivateScalar=function(t,e,r=!1){let n=(t=(0,i.ensureBytes)("privateHash",t)).length,s=B(e).nByteLength+8;if(s<24||n<s||n>1024)throw Error("hashToPrivateScalar: expected "+s+"-1024 bytes of input, got "+n);return f(r?(0,i.bytesToNumberLE)(t):(0,i.bytesToNumberBE)(t),e-a)+a},r.getFieldBytesLength=R,r.getMinHashLength=C,r.mapHashToField=function(t,e,r=!1){let n=t.length,s=R(e),o=C(e);if(n<16||n<o||n>1024)throw Error("expected "+o+"-1024 bytes of input, got "+n);let l=f(r?(0,i.bytesToNumberLE)(t):(0,i.bytesToNumberBE)(t),e-a)+a;return r?(0,i.numberToBytesLE)(l,s):(0,i.numberToBytesBE)(l,s)};let i=t.r(374752),n=BigInt(0),a=BigInt(1),s=BigInt(2),o=BigInt(3),l=BigInt(4),u=BigInt(5),c=BigInt(7),h=BigInt(8),p=BigInt(9),d=BigInt(16);function f(t,e){let r=t%e;return r>=n?r:e+r}function m(t,e){if(t===n)throw Error("invert: expected non-zero number");if(e<=n)throw Error("invert: expected positive modulus, got "+e);let r=f(t,e),i=e,s=n,o=a,l=a,u=n;for(;r!==n;){let t=i/r,e=i%r,n=s-l*t,a=o-u*t;i=r,r=e,s=l,o=u,l=n,u=a}if(i!==a)throw Error("invert: does not exist");return f(s,e)}function g(t,e,r){if(!t.eql(t.sqr(e),r))throw Error("Cannot find square root")}function w(t,e){let r=(t.ORDER+a)/l,i=t.pow(e,r);return g(t,i,e),i}function y(t,e){let r=(t.ORDER-u)/h,i=t.mul(e,s),n=t.pow(i,r),a=t.mul(e,n),o=t.mul(t.mul(a,s),n),l=t.mul(a,t.sub(o,t.ONE));return g(t,l,e),l}function T(t){if(t<o)throw Error("sqrt is not defined for small field");let e=t-a,r=0;for(;e%s===n;)e/=s,r++;let i=s,l=A(t);for(;1===v(l,i);)if(i++>1e3)throw Error("Cannot find square root: probably non-prime P");if(1===r)return w;let u=l.pow(i,e),c=(e+a)/s;return function(t,i){if(t.is0(i))return i;if(1!==v(t,i))throw Error("Cannot find square root");let n=r,s=t.mul(t.ONE,u),o=t.pow(i,e),l=t.pow(i,c);for(;!t.eql(o,t.ONE);){if(t.is0(o))return t.ZERO;let e=1,r=t.sqr(o);for(;!t.eql(r,t.ONE);)if(e++,r=t.sqr(r),e===n)throw Error("Cannot find square root");let i=a<<BigInt(n-e-1),u=t.pow(s,i);n=e,s=t.sqr(u),o=t.mul(o,s),l=t.mul(l,u)}return l}}function S(t){return t%l===o?w:t%h===u?y:t%d===p?function(t){let e=A(t),r=T(t),i=r(e,e.neg(e.ONE)),n=r(e,i),a=r(e,e.neg(i)),s=(t+c)/d;return(t,e)=>{let r=t.pow(e,s),o=t.mul(r,i),l=t.mul(r,n),u=t.mul(r,a),c=t.eql(t.sqr(o),e),h=t.eql(t.sqr(l),e);r=t.cmov(r,o,c),o=t.cmov(u,l,h);let p=t.eql(t.sqr(o),e),d=t.cmov(r,o,p);return g(t,d,e),d}}(t):T(t)}r.isNegativeLE=(t,e)=>(f(t,e)&a)===a;let E=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function I(t,e,r){if(r<n)throw Error("invalid exponent, negatives unsupported");if(r===n)return t.ONE;if(r===a)return e;let i=t.ONE,s=e;for(;r>n;)r&a&&(i=t.mul(i,s)),s=t.sqr(s),r>>=a;return i}function b(t,e,r=!1){let i=Array(e.length).fill(r?t.ZERO:void 0),n=e.reduce((e,r,n)=>t.is0(r)?e:(i[n]=e,t.mul(e,r)),t.ONE),a=t.inv(n);return e.reduceRight((e,r,n)=>t.is0(r)?e:(i[n]=t.mul(e,i[n]),t.mul(e,r)),a),i}function v(t,e){let r=(t.ORDER-a)/s,i=t.pow(e,r),n=t.eql(i,t.ONE),o=t.eql(i,t.ZERO),l=t.eql(i,t.neg(t.ONE));if(!n&&!o&&!l)throw Error("invalid Legendre symbol result");return n?1:o?0:-1}function B(t,e){void 0!==e&&(0,i.anumber)(e);let r=void 0!==e?e:t.toString(2).length,n=Math.ceil(r/8);return{nBitLength:r,nByteLength:n}}function A(t,e,r=!1,s={}){let o,l,u,c;if(t<=n)throw Error("invalid field: expected ORDER > 0, got "+t);let h=!1;if("object"==typeof e&&null!=e){if(s.sqrt||r)throw Error("cannot specify opts in two arguments");e.BITS&&(l=e.BITS),e.sqrt&&(u=e.sqrt),"boolean"==typeof e.isLE&&(r=e.isLE),"boolean"==typeof e.modFromBytes&&(h=e.modFromBytes),c=e.allowedLengths}else"number"==typeof e&&(l=e),s.sqrt&&(u=s.sqrt);let{nBitLength:p,nByteLength:d}=B(t,l);if(d>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let g=Object.freeze({ORDER:t,isLE:r,BITS:p,BYTES:d,MASK:(0,i.bitMask)(p),ZERO:n,ONE:a,allowedLengths:c,create:e=>f(e,t),isValid:e=>{if("bigint"!=typeof e)throw Error("invalid field element: expected bigint, got "+typeof e);return n<=e&&e<t},is0:t=>t===n,isValidNot0:t=>!g.is0(t)&&g.isValid(t),isOdd:t=>(t&a)===a,neg:e=>f(-e,t),eql:(t,e)=>t===e,sqr:e=>f(e*e,t),add:(e,r)=>f(e+r,t),sub:(e,r)=>f(e-r,t),mul:(e,r)=>f(e*r,t),pow:(t,e)=>I(g,t,e),div:(e,r)=>f(e*m(r,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>m(e,t),sqrt:u||(e=>(o||(o=S(t)),o(g,e))),toBytes:t=>r?(0,i.numberToBytesLE)(t,d):(0,i.numberToBytesBE)(t,d),fromBytes:(e,n=!0)=>{if(c){if(!c.includes(e.length)||e.length>d)throw Error("Field.fromBytes: expected "+c+" bytes, got "+e.length);let t=new Uint8Array(d);t.set(e,r?0:t.length-e.length),e=t}if(e.length!==d)throw Error("Field.fromBytes: expected "+d+" bytes, got "+e.length);let a=r?(0,i.bytesToNumberLE)(e):(0,i.bytesToNumberBE)(e);if(h&&(a=f(a,t)),!n&&!g.isValid(a))throw Error("invalid field element: outside of range 0..ORDER");return a},invertBatch:t=>b(g,t),cmov:(t,e,r)=>r?e:t});return Object.freeze(g)}function R(t){if("bigint"!=typeof t)throw Error("field order must be bigint");return Math.ceil(t.toString(2).length/8)}function C(t){let e=R(t);return e+Math.ceil(e/2)}},643282,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.wNAF=void 0,r.negateCt=o,r.normalizeZ=function(t,e){let r=(0,n.FpInvertBatch)(t.Fp,e.map(t=>t.Z));return e.map((e,i)=>t.fromAffine(e.toAffine(r[i])))},r.mulEndoUnsafe=function(t,e,r,i){let n=e,o=t.ZERO,l=t.ZERO;for(;r>a||i>a;)r&s&&(o=o.add(n)),i&s&&(l=l.add(n)),n=n.double(),r>>=s,i>>=s;return{p1:o,p2:l}},r.pippenger=function(t,e,r,n){h(r,t),p(n,e);let a=r.length,s=n.length;if(a!==s)throw Error("arrays of points and scalars must have equal length");let o=t.ZERO,l=(0,i.bitLen)(BigInt(a)),u=1;l>12?u=l-3:l>4?u=l-2:l>0&&(u=2);let c=(0,i.bitMask)(u),d=Array(Number(c)+1).fill(o),f=Math.floor((e.BITS-1)/u)*u,m=o;for(let t=f;t>=0;t-=u){d.fill(o);for(let e=0;e<s;e++){let i=Number(n[e]>>BigInt(t)&c);d[i]=d[i].add(r[e])}let e=o;for(let t=d.length-1,r=o;t>0;t--)r=r.add(d[t]),e=e.add(r);if(m=m.add(e),0!==t)for(let t=0;t<u;t++)m=m.double()}return m},r.precomputeMSMUnsafe=function(t,e,r,n){l(n,e.BITS),h(r,t);let a=t.ZERO,s=2**n-1,o=Math.ceil(e.BITS/n),u=(0,i.bitMask)(n),c=r.map(t=>{let e=[];for(let r=0,i=t;r<s;r++)e.push(i),i=i.add(t);return e});return t=>{if(p(t,e),t.length>r.length)throw Error("array of scalars must be smaller than array of points");let i=a;for(let e=0;e<o;e++){if(i!==a)for(let t=0;t<n;t++)i=i.double();let r=BigInt(o*n-(e+1)*n);for(let e=0;e<t.length;e++){let n=Number(t[e]>>r&u);n&&(i=i.add(c[e][n-1]))}}return i}},r.validateBasic=function(t){return(0,n.validateField)(t.Fp),(0,i.validateObject)(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,n.nLength)(t.n,t.nBitLength),...t,...{p:t.Fp.ORDER}})},r._createCurveFields=function(t,e,r={},i){if(void 0===i&&(i="edwards"===t),!e||"object"!=typeof e)throw Error(`expected valid ${t} CURVE object`);for(let t of["p","n","h"]){let r=e[t];if(!("bigint"==typeof r&&r>a))throw Error(`CURVE.${t} must be positive bigint`)}let n=w(e.p,r.Fp,i),s=w(e.n,r.Fn,i);for(let r of["Gx","Gy","a","weierstrass"===t?"b":"d"])if(!n.isValid(e[r]))throw Error(`CURVE.${r} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:n,Fn:s}};let i=t.r(374752),n=t.r(113157),a=BigInt(0),s=BigInt(1);function o(t,e){let r=e.negate();return t?r:e}function l(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw Error("invalid window size, expected [1.."+e+"], got W="+t)}function u(t,e){l(t,e);let r=Math.ceil(e/t)+1,n=2**(t-1),a=2**t;return{windows:r,windowSize:n,mask:(0,i.bitMask)(t),maxNumber:a,shiftBy:BigInt(t)}}function c(t,e,r){let{windowSize:i,mask:n,maxNumber:a,shiftBy:o}=r,l=Number(t&n),u=t>>o;l>i&&(l-=a,u+=s);let c=e*i,h=c+Math.abs(l)-1,p=0===l;return{nextN:u,offset:h,isZero:p,isNeg:l<0,isNegF:e%2!=0,offsetF:c}}function h(t,e){if(!Array.isArray(t))throw Error("array expected");t.forEach((t,r)=>{if(!(t instanceof e))throw Error("invalid point at index "+r)})}function p(t,e){if(!Array.isArray(t))throw Error("array of scalars expected");t.forEach((t,r)=>{if(!e.isValid(t))throw Error("invalid scalar at index "+r)})}let d=new WeakMap,f=new WeakMap;function m(t){return f.get(t)||1}function g(t){if(t!==a)throw Error("invalid wNAF")}function w(t,e,r){if(!e)return(0,n.Field)(t,{isLE:r});if(e.ORDER!==t)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return(0,n.validateField)(e),e}r.wNAF=class{constructor(t,e){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=e}_unsafeLadder(t,e,r=this.ZERO){let i=t;for(;e>a;)e&s&&(r=r.add(i)),i=i.double(),e>>=s;return r}precomputeWindow(t,e){let{windows:r,windowSize:i}=u(e,this.bits),n=[],a=t,s=a;for(let t=0;t<r;t++){s=a,n.push(s);for(let t=1;t<i;t++)s=s.add(a),n.push(s);a=s.double()}return n}wNAF(t,e,r){if(!this.Fn.isValid(r))throw Error("invalid scalar");let i=this.ZERO,n=this.BASE,a=u(t,this.bits);for(let t=0;t<a.windows;t++){let{nextN:s,offset:l,isZero:u,isNeg:h,isNegF:p,offsetF:d}=c(r,t,a);r=s,u?n=n.add(o(p,e[d])):i=i.add(o(h,e[l]))}return g(r),{p:i,f:n}}wNAFUnsafe(t,e,r,i=this.ZERO){let n=u(t,this.bits);for(let t=0;t<n.windows&&r!==a;t++){let{nextN:a,offset:s,isZero:o,isNeg:l}=c(r,t,n);if(r=a,!o){let t=e[s];i=i.add(l?t.negate():t)}}return g(r),i}getPrecomputes(t,e,r){let i=d.get(e);return i||(i=this.precomputeWindow(e,t),1!==t&&("function"==typeof r&&(i=r(i)),d.set(e,i))),i}cached(t,e,r){let i=m(t);return this.wNAF(i,this.getPrecomputes(i,t,r),e)}unsafe(t,e,r,i){let n=m(t);return 1===n?this._unsafeLadder(t,e,i):this.wNAFUnsafe(n,this.getPrecomputes(n,t,r),e,i)}createCache(t,e){l(e,this.bits),f.set(t,e),d.delete(t)}hasCache(t){return 1!==m(t)}}},855311,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.DER=r.DERErr=void 0,r._splitEndoScalar=u,r._normFnElement=y,r.weierstrassN=T,r.SWUFpSqrtRatio=E,r.mapToCurveSimpleSWU=function(t,e){(0,o.validateField)(t);let{A:r,B:i,Z:n}=e;if(!t.isValid(r)||!t.isValid(i)||!t.isValid(n))throw Error("mapToCurveSimpleSWU: invalid opts");let a=E(t,n);if(!t.isOdd)throw Error("Field does not have .isOdd()");return e=>{let s,l,u,c,h,p,d,f;s=t.sqr(e),s=t.mul(s,n),l=t.sqr(s),l=t.add(l,s),u=t.add(l,t.ONE),u=t.mul(u,i),c=t.cmov(n,t.neg(l),!t.eql(l,t.ZERO)),c=t.mul(c,r),l=t.sqr(u),p=t.sqr(c),h=t.mul(p,r),l=t.add(l,h),l=t.mul(l,u),p=t.mul(p,c),h=t.mul(p,i),l=t.add(l,h),d=t.mul(s,u);let{isValid:m,value:g}=a(l,p);f=t.mul(s,e),f=t.mul(f,g),d=t.cmov(d,u,m),f=t.cmov(f,g,m);let w=t.isOdd(e)===t.isOdd(f);f=t.cmov(t.neg(f),f,w);let y=(0,o.FpInvertBatch)(t,[c],!0)[0];return{x:d=t.mul(d,y),y:f}}},r.ecdh=b,r.ecdsa=v,r.weierstrassPoints=function(t){let{CURVE:e,curveOpts:r}=B(t);var i=t,n=T(e,r);let{Fp:s,Fn:o}=n,l=A(s,i.a,i.b);return Object.assign({},{CURVE:i,Point:n,ProjectivePoint:n,normPrivateKeyToScalar:t=>y(o,t),weierstrassEquation:l,isWithinCurveOrder:function(t){return(0,a.inRange)(t,f,o.ORDER)}})},r._legacyHelperEquat=A,r.weierstrass=function(t){let{CURVE:e,curveOpts:r,hash:i,ecdsaOpts:n}=function(t){let{CURVE:e,curveOpts:r}=B(t),i={hmac:t.hmac,randomBytes:t.randomBytes,lowS:t.lowS,bits2int:t.bits2int,bits2int_modN:t.bits2int_modN};return{CURVE:e,curveOpts:r,hash:t.hash,ecdsaOpts:i}}(t),a=v(T(e,r),i,n),s=a.Point;return Object.assign({},a,{ProjectivePoint:s,CURVE:Object.assign({},t,(0,o.nLength)(s.Fn.ORDER,s.Fn.BITS))})};let i=t.r(959455),n=t.r(697858),a=t.r(374752),s=t.r(643282),o=t.r(113157),l=(t,e)=>(t+(t>=0?e:-e)/m)/e;function u(t,e,r){let[[i,n],[s,o]]=e,u=l(o*t,r),c=l(-n*t,r),h=t-u*i-c*s,p=-u*n-c*o,m=h<d,g=p<d;m&&(h=-h),g&&(p=-p);let w=(0,a.bitMask)(Math.ceil((0,a.bitLen)(r)/2))+f;if(h<d||h>=w||p<d||p>=w)throw Error("splitScalar (endomorphism): failed, k="+t);return{k1neg:m,k1:h,k2neg:g,k2:p}}function c(t){if(!["compact","recovered","der"].includes(t))throw Error('Signature format must be "compact", "recovered", or "der"');return t}function h(t,e){let r={};for(let i of Object.keys(e))r[i]=void 0===t[i]?e[i]:t[i];return(0,a._abool2)(r.lowS,"lowS"),(0,a._abool2)(r.prehash,"prehash"),void 0!==r.format&&c(r.format),r}class p extends Error{constructor(t=""){super(t)}}r.DERErr=p,r.DER={Err:p,_tlv:{encode:(t,e)=>{let{Err:i}=r.DER;if(t<0||t>256)throw new i("tlv.encode: wrong tag");if(1&e.length)throw new i("tlv.encode: unpadded data");let n=e.length/2,s=(0,a.numberToHexUnpadded)(n);if(s.length/2&128)throw new i("tlv.encode: long form length too big");let o=n>127?(0,a.numberToHexUnpadded)(s.length/2|128):"";return(0,a.numberToHexUnpadded)(t)+o+s+e},decode(t,e){let{Err:i}=r.DER,n=0;if(t<0||t>256)throw new i("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new i("tlv.decode: wrong tlv");let a=e[n++],s=0;if(128&a){let t=127&a;if(!t)throw new i("tlv.decode(long): indefinite length not supported");if(t>4)throw new i("tlv.decode(long): byte length is too big");let r=e.subarray(n,n+t);if(r.length!==t)throw new i("tlv.decode: length bytes not complete");if(0===r[0])throw new i("tlv.decode(long): zero leftmost byte");for(let t of r)s=s<<8|t;if(n+=t,s<128)throw new i("tlv.decode(long): not minimal encoding")}else s=a;let o=e.subarray(n,n+s);if(o.length!==s)throw new i("tlv.decode: wrong value length");return{v:o,l:e.subarray(n+s)}}},_int:{encode(t){let{Err:e}=r.DER;if(t<d)throw new e("integer: negative integers are not allowed");let i=(0,a.numberToHexUnpadded)(t);if(8&Number.parseInt(i[0],16)&&(i="00"+i),1&i.length)throw new e("unexpected DER parsing assertion: unpadded hex");return i},decode(t){let{Err:e}=r.DER;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return(0,a.bytesToNumberBE)(t)}},toSig(t){let{Err:e,_int:i,_tlv:n}=r.DER,s=(0,a.ensureBytes)("signature",t),{v:o,l:l}=n.decode(48,s);if(l.length)throw new e("invalid signature: left bytes after parsing");let{v:u,l:c}=n.decode(2,o),{v:h,l:p}=n.decode(2,c);if(p.length)throw new e("invalid signature: left bytes after parsing");return{r:i.decode(u),s:i.decode(h)}},hexFromSig(t){let{_tlv:e,_int:i}=r.DER,n=e.encode(2,i.encode(t.r)),a=e.encode(2,i.encode(t.s));return e.encode(48,n+a)}};let d=BigInt(0),f=BigInt(1),m=BigInt(2),g=BigInt(3),w=BigInt(4);function y(t,e){let r,{BYTES:i}=t;if("bigint"==typeof e)r=e;else{let n=(0,a.ensureBytes)("private key",e);try{r=t.fromBytes(n)}catch(t){throw Error(`invalid private key: expected ui8a of size ${i}, got ${typeof e}`)}}if(!t.isValidNot0(r))throw Error("invalid private key: out of range [1..N-1]");return r}function T(t,e={}){let r=(0,s._createCurveFields)("weierstrass",t,e),{Fp:i,Fn:n}=r,o=r.CURVE,{h:l,n:c}=o;(0,a._validateObject)(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});let{endo:h}=e;if(h&&(!i.is0(o.a)||"bigint"!=typeof h.beta||!Array.isArray(h.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');let p=I(i,n);function m(){if(!i.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}let E=e.toBytes||function(t,e,r){let{x:n,y:s}=e.toAffine(),o=i.toBytes(n);if((0,a._abool2)(r,"isCompressed"),!r)return(0,a.concatBytes)(Uint8Array.of(4),o,i.toBytes(s));{m();let t=!i.isOdd(s);return(0,a.concatBytes)(S(t),o)}},b=e.fromBytes||function(t){(0,a._abytes2)(t,void 0,"Point");let{publicKey:e,publicKeyUncompressed:r}=p,n=t.length,s=t[0],o=t.subarray(1);if(n===e&&(2===s||3===s)){let t,e=i.fromBytes(o);if(!i.isValid(e))throw Error("bad point: is not on curve, wrong x");let r=v(e);try{t=i.sqrt(r)}catch(t){throw Error("bad point: is not on curve, sqrt error"+(t instanceof Error?": "+t.message:""))}return m(),(1&s)==1!==i.isOdd(t)&&(t=i.neg(t)),{x:e,y:t}}if(n===r&&4===s){let t=i.BYTES,e=i.fromBytes(o.subarray(0,t)),r=i.fromBytes(o.subarray(t,2*t));if(!B(e,r))throw Error("bad point: is not on curve");return{x:e,y:r}}throw Error(`bad point: got length ${n}, expected compressed=${e} or uncompressed=${r}`)};function v(t){let e=i.sqr(t),r=i.mul(e,t);return i.add(i.add(r,i.mul(t,o.a)),o.b)}function B(t,e){let r=i.sqr(e),n=v(t);return i.eql(r,n)}if(!B(o.Gx,o.Gy))throw Error("bad curve params: generator point");let A=i.mul(i.pow(o.a,g),w),R=i.mul(i.sqr(o.b),BigInt(27));if(i.is0(i.add(A,R)))throw Error("bad curve params: a or b");function C(t,e,r=!1){if(!i.isValid(e)||r&&i.is0(e))throw Error(`bad point coordinate ${t}`);return e}function _(t){if(!(t instanceof k))throw Error("ProjectivePoint expected")}function F(t){if(!h||!h.basises)throw Error("no endo");return u(t,h.basises,n.ORDER)}let P=(0,a.memoized)((t,e)=>{let{X:r,Y:n,Z:a}=t;if(i.eql(a,i.ONE))return{x:r,y:n};let s=t.is0();null==e&&(e=s?i.ONE:i.inv(a));let o=i.mul(r,e),l=i.mul(n,e),u=i.mul(a,e);if(s)return{x:i.ZERO,y:i.ZERO};if(!i.eql(u,i.ONE))throw Error("invZ was invalid");return{x:o,y:l}}),x=(0,a.memoized)(t=>{if(t.is0()){if(e.allowInfinityPoint&&!i.is0(t.Y))return;throw Error("bad point: ZERO")}let{x:r,y:n}=t.toAffine();if(!i.isValid(r)||!i.isValid(n))throw Error("bad point: x or y not field elements");if(!B(r,n))throw Error("bad point: equation left != right");if(!t.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});function D(t,e,r,n,a){return r=new k(i.mul(r.X,t),r.Y,r.Z),e=(0,s.negateCt)(n,e),r=(0,s.negateCt)(a,r),e.add(r)}class k{constructor(t,e,r){this.X=C("x",t),this.Y=C("y",e,!0),this.Z=C("z",r),Object.freeze(this)}static CURVE(){return o}static fromAffine(t){let{x:e,y:r}=t||{};if(!t||!i.isValid(e)||!i.isValid(r))throw Error("invalid affine point");if(t instanceof k)throw Error("projective point not allowed");return i.is0(e)&&i.is0(r)?k.ZERO:new k(e,r,i.ONE)}static fromBytes(t){let e=k.fromAffine(b((0,a._abytes2)(t,void 0,"point")));return e.assertValidity(),e}static fromHex(t){return k.fromBytes((0,a.ensureBytes)("pointHex",t))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(t=8,e=!0){return L.createCache(this,t),e||this.multiply(g),this}assertValidity(){x(this)}hasEvenY(){let{y:t}=this.toAffine();if(!i.isOdd)throw Error("Field doesn't support isOdd");return!i.isOdd(t)}equals(t){_(t);let{X:e,Y:r,Z:n}=this,{X:a,Y:s,Z:o}=t,l=i.eql(i.mul(e,o),i.mul(a,n)),u=i.eql(i.mul(r,o),i.mul(s,n));return l&&u}negate(){return new k(this.X,i.neg(this.Y),this.Z)}double(){let{a:t,b:e}=o,r=i.mul(e,g),{X:n,Y:a,Z:s}=this,l=i.ZERO,u=i.ZERO,c=i.ZERO,h=i.mul(n,n),p=i.mul(a,a),d=i.mul(s,s),f=i.mul(n,a);return f=i.add(f,f),c=i.mul(n,s),c=i.add(c,c),l=i.mul(t,c),u=i.mul(r,d),u=i.add(l,u),l=i.sub(p,u),u=i.add(p,u),u=i.mul(l,u),l=i.mul(f,l),c=i.mul(r,c),d=i.mul(t,d),f=i.sub(h,d),f=i.mul(t,f),f=i.add(f,c),c=i.add(h,h),h=i.add(c,h),h=i.add(h,d),h=i.mul(h,f),u=i.add(u,h),d=i.mul(a,s),d=i.add(d,d),h=i.mul(d,f),l=i.sub(l,h),c=i.mul(d,p),c=i.add(c,c),new k(l,u,c=i.add(c,c))}add(t){_(t);let{X:e,Y:r,Z:n}=this,{X:a,Y:s,Z:l}=t,u=i.ZERO,c=i.ZERO,h=i.ZERO,p=o.a,d=i.mul(o.b,g),f=i.mul(e,a),m=i.mul(r,s),w=i.mul(n,l),y=i.add(e,r),T=i.add(a,s);y=i.mul(y,T),T=i.add(f,m),y=i.sub(y,T),T=i.add(e,n);let S=i.add(a,l);return T=i.mul(T,S),S=i.add(f,w),T=i.sub(T,S),S=i.add(r,n),u=i.add(s,l),S=i.mul(S,u),u=i.add(m,w),S=i.sub(S,u),h=i.mul(p,T),u=i.mul(d,w),h=i.add(u,h),u=i.sub(m,h),h=i.add(m,h),c=i.mul(u,h),m=i.add(f,f),m=i.add(m,f),w=i.mul(p,w),T=i.mul(d,T),m=i.add(m,w),w=i.sub(f,w),w=i.mul(p,w),T=i.add(T,w),f=i.mul(m,T),c=i.add(c,f),f=i.mul(S,T),u=i.mul(y,u),u=i.sub(u,f),f=i.mul(y,m),h=i.mul(S,h),new k(u,c,h=i.add(h,f))}subtract(t){return this.add(t.negate())}is0(){return this.equals(k.ZERO)}multiply(t){let r,i,{endo:a}=e;if(!n.isValidNot0(t))throw Error("invalid scalar: out of range");let o=t=>L.cached(this,t,t=>(0,s.normalizeZ)(k,t));if(a){let{k1neg:e,k1:n,k2neg:s,k2:l}=F(t),{p:u,f:c}=o(n),{p:h,f:p}=o(l);i=c.add(p),r=D(a.beta,u,h,e,s)}else{let{p:e,f:n}=o(t);r=e,i=n}return(0,s.normalizeZ)(k,[r,i])[0]}multiplyUnsafe(t){let{endo:r}=e;if(!n.isValid(t))throw Error("invalid scalar: out of range");if(t===d||this.is0())return k.ZERO;if(t===f)return this;if(L.hasCache(this))return this.multiply(t);if(!r)return L.unsafe(this,t);{let{k1neg:e,k1:i,k2neg:n,k2:a}=F(t),{p1:o,p2:l}=(0,s.mulEndoUnsafe)(k,this,i,a);return D(r.beta,o,l,e,n)}}multiplyAndAddUnsafe(t,e,r){let i=this.multiplyUnsafe(e).add(t.multiplyUnsafe(r));return i.is0()?void 0:i}toAffine(t){return P(this,t)}isTorsionFree(){let{isTorsionFree:t}=e;return l===f||(t?t(k,this):L.unsafe(this,c).is0())}clearCofactor(){let{clearCofactor:t}=e;return l===f?this:t?t(k,this):this.multiplyUnsafe(l)}isSmallOrder(){return this.multiplyUnsafe(l).is0()}toBytes(t=!0){return(0,a._abool2)(t,"isCompressed"),this.assertValidity(),E(k,this,t)}toHex(t=!0){return(0,a.bytesToHex)(this.toBytes(t))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(t=!0){return this.toBytes(t)}_setWindowSize(t){this.precompute(t)}static normalizeZ(t){return(0,s.normalizeZ)(k,t)}static msm(t,e){return(0,s.pippenger)(k,n,t,e)}static fromPrivateKey(t){return k.BASE.multiply(y(n,t))}}k.BASE=new k(o.Gx,o.Gy,i.ONE),k.ZERO=new k(i.ZERO,i.ONE,i.ZERO),k.Fp=i,k.Fn=n;let O=n.BITS,L=new s.wNAF(k,e.endo?Math.ceil(O/2):O);return k.BASE.precompute(8),k}function S(t){return Uint8Array.of(t?2:3)}function E(t,e){let r=t.ORDER,i=d;for(let t=r-f;t%m===d;t/=m)i+=f;let n=i,a=m<<n-f-f,s=a*m,o=(r-f)/s,l=(o-f)/m,u=s-f,c=t.pow(e,o),h=t.pow(e,(o+f)/m),p=(e,r)=>{let i=c,s=t.pow(r,u),o=t.sqr(s);o=t.mul(o,r);let p=t.mul(e,o);p=t.pow(p,l),p=t.mul(p,s),s=t.mul(p,r),o=t.mul(p,e);let d=t.mul(o,s);p=t.pow(d,a);let g=t.eql(p,t.ONE);s=t.mul(o,h),p=t.mul(d,i),o=t.cmov(s,o,g),d=t.cmov(p,d,g);for(let e=n;e>f;e--){let r=e-m;r=m<<r-f;let n=t.pow(d,r),a=t.eql(n,t.ONE);s=t.mul(o,i),i=t.mul(i,i),n=t.mul(d,i),o=t.cmov(s,o,a),d=t.cmov(n,d,a)}return{isValid:g,value:o}};if(t.ORDER%w===g){let r=(t.ORDER-g)/w,i=t.sqrt(t.neg(e));p=(e,n)=>{let a=t.sqr(n),s=t.mul(e,n);a=t.mul(a,s);let o=t.pow(a,r);o=t.mul(o,s);let l=t.mul(o,i),u=t.mul(t.sqr(o),n),c=t.eql(u,e),h=t.cmov(l,o,c);return{isValid:c,value:h}}}return p}function I(t,e){return{secretKey:e.BYTES,publicKey:1+t.BYTES,publicKeyUncompressed:1+2*t.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function b(t,e={}){let{Fn:r}=t,i=e.randomBytes||a.randomBytes,n=Object.assign(I(t.Fp,r),{seed:(0,o.getMinHashLength)(r.ORDER)});function s(t){try{return!!y(r,t)}catch(t){return!1}}function l(t=i(n.seed)){return(0,o.mapHashToField)((0,a._abytes2)(t,n.seed,"seed"),r.ORDER)}function u(e,i=!0){return t.BASE.multiply(y(r,e)).toBytes(i)}function c(e){if("bigint"==typeof e)return!1;if(e instanceof t)return!0;let{secretKey:i,publicKey:s,publicKeyUncompressed:o}=n;if(r.allowedLengths||i===s)return;let l=(0,a.ensureBytes)("key",e).length;return l===s||l===o}return Object.freeze({getPublicKey:u,getSharedSecret:function(e,i,n=!0){if(!0===c(e))throw Error("first arg must be private key");if(!1===c(i))throw Error("second arg must be public key");let a=y(r,e);return t.fromHex(i).multiply(a).toBytes(n)},keygen:function(t){let e=l(t);return{secretKey:e,publicKey:u(e)}},Point:t,utils:{isValidSecretKey:s,isValidPublicKey:function(e,r){let{publicKey:i,publicKeyUncompressed:a}=n;try{let n=e.length;if(!0===r&&n!==i||!1===r&&n!==a)return!1;return!!t.fromBytes(e)}catch(t){return!1}},randomSecretKey:l,isValidPrivateKey:s,randomPrivateKey:l,normPrivateKeyToScalar:t=>y(r,t),precompute:(e=8,r=t.BASE)=>r.precompute(e,!1)},lengths:n})}function v(t,e,s={}){(0,n.ahash)(e),(0,a._validateObject)(s,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});let o=s.randomBytes||a.randomBytes,l=s.hmac||((t,...r)=>(0,i.hmac)(e,t,(0,a.concatBytes)(...r))),{Fp:u,Fn:p}=t,{ORDER:g,BITS:w}=p,{keygen:T,getPublicKey:E,getSharedSecret:I,utils:B,lengths:A}=b(t,s),R={prehash:!1,lowS:"boolean"==typeof s.lowS&&s.lowS,format:void 0,extraEntropy:!1},C="compact";function _(t,e){if(!p.isValidNot0(e))throw Error(`invalid signature ${t}: out of range 1..Point.Fn.ORDER`);return e}class F{constructor(t,e,r){this.r=_("r",t),this.s=_("s",e),null!=r&&(this.recovery=r),Object.freeze(this)}static fromBytes(t,e=C){let i;if(!function(t,e){c(e);let r=A.signature;(0,a._abytes2)(t,"compact"===e?r:"recovered"===e?r+1:void 0,`${e} signature`)}(t,e),"der"===e){let{r:e,s:i}=r.DER.toSig((0,a._abytes2)(t));return new F(e,i)}"recovered"===e&&(i=t[0],e="compact",t=t.subarray(1));let n=p.BYTES,s=t.subarray(0,n),o=t.subarray(n,2*n);return new F(p.fromBytes(s),p.fromBytes(o),i)}static fromHex(t,e){return this.fromBytes((0,a.hexToBytes)(t),e)}addRecoveryBit(t){return new F(this.r,this.s,t)}recoverPublicKey(e){let r=u.ORDER,{r:i,s:n,recovery:s}=this;if(null==s||![0,1,2,3].includes(s))throw Error("recovery id invalid");if(g*m<r&&s>1)throw Error("recovery id is ambiguous for h>1 curve");let o=2===s||3===s?i+g:i;if(!u.isValid(o))throw Error("recovery id 2 or 3 invalid");let l=u.toBytes(o),c=t.fromBytes((0,a.concatBytes)(S((1&s)==0),l)),h=p.inv(o),d=x((0,a.ensureBytes)("msgHash",e)),f=p.create(-d*h),w=p.create(n*h),y=t.BASE.multiplyUnsafe(f).add(c.multiplyUnsafe(w));if(y.is0())throw Error("point at infinify");return y.assertValidity(),y}hasHighS(){return this.s>g>>f}toBytes(t=C){if(c(t),"der"===t)return(0,a.hexToBytes)(r.DER.hexFromSig(this));let e=p.toBytes(this.r),i=p.toBytes(this.s);if("recovered"===t){if(null==this.recovery)throw Error("recovery bit must be present");return(0,a.concatBytes)(Uint8Array.of(this.recovery),e,i)}return(0,a.concatBytes)(e,i)}toHex(t){return(0,a.bytesToHex)(this.toBytes(t))}assertValidity(){}static fromCompact(t){return F.fromBytes((0,a.ensureBytes)("sig",t),"compact")}static fromDER(t){return F.fromBytes((0,a.ensureBytes)("sig",t),"der")}normalizeS(){return this.hasHighS()?new F(this.r,p.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return(0,a.bytesToHex)(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return(0,a.bytesToHex)(this.toBytes("compact"))}}let P=s.bits2int||function(t){if(t.length>8192)throw Error("input is too large");let e=(0,a.bytesToNumberBE)(t),r=8*t.length-w;return r>0?e>>BigInt(r):e},x=s.bits2int_modN||function(t){return p.create(P(t))},D=(0,a.bitMask)(w);function k(t){return(0,a.aInRange)("num < 2^"+w,t,d,D),p.toBytes(t)}function O(t,r){return(0,a._abytes2)(t,void 0,"message"),r?(0,a._abytes2)(e(t),void 0,"prehashed message"):t}return Object.freeze({keygen:T,getPublicKey:E,getSharedSecret:I,utils:B,lengths:A,Point:t,sign:function(r,i,n={}){let{seed:s,k2sig:u}=function(e,r,i){if(["recovered","canonical"].some(t=>t in i))throw Error("sign() legacy options not supported");let{lowS:n,prehash:s,extraEntropy:l}=h(i,R),u=x(e=O(e,s)),c=y(p,r),m=[k(c),k(u)];if(null!=l&&!1!==l){let t=!0===l?o(A.secretKey):l;m.push((0,a.ensureBytes)("extraEntropy",t))}return{seed:(0,a.concatBytes)(...m),k2sig:function(e){let r=P(e);if(!p.isValidNot0(r))return;let i=p.inv(r),a=t.BASE.multiply(r).toAffine(),s=p.create(a.x);if(s===d)return;let o=p.create(i*p.create(u+s*c));if(o===d)return;let l=2*(a.x!==s)|Number(a.y&f),h=o;return n&&o>g>>f&&(h=p.neg(o),l^=1),new F(s,h,l)}}}(r=(0,a.ensureBytes)("message",r),i,n);return(0,a.createHmacDrbg)(e.outputLen,p.BYTES,l)(s,u)},verify:function(e,i,n,s={}){let{lowS:o,prehash:l,format:u}=h(s,R);if(n=(0,a.ensureBytes)("publicKey",n),i=O((0,a.ensureBytes)("message",i),l),"strict"in s)throw Error("options.strict was renamed to lowS");let c=void 0===u?function(t){let e,i="string"==typeof t||(0,a.isBytes)(t),n=!i&&null!==t&&"object"==typeof t&&"bigint"==typeof t.r&&"bigint"==typeof t.s;if(!i&&!n)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(n)e=new F(t.r,t.s);else if(i){try{e=F.fromBytes((0,a.ensureBytes)("sig",t),"der")}catch(t){if(!(t instanceof r.DER.Err))throw t}if(!e)try{e=F.fromBytes((0,a.ensureBytes)("sig",t),"compact")}catch(t){return!1}}return!!e&&e}(e):F.fromBytes((0,a.ensureBytes)("sig",e),u);if(!1===c)return!1;try{let e=t.fromBytes(n);if(o&&c.hasHighS())return!1;let{r,s:a}=c,s=x(i),l=p.inv(a),u=p.create(s*l),h=p.create(r*l),d=t.BASE.multiplyUnsafe(u).add(e.multiplyUnsafe(h));if(d.is0())return!1;return p.create(d.x)===r}catch(t){return!1}},recoverPublicKey:function(t,e,r={}){let{prehash:i}=h(r,R);return e=O(e,i),F.fromBytes(t,"recovered").recoverPublicKey(e).toBytes()},Signature:F,hash:e})}function B(t){let e={a:t.a,b:t.b,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},r=t.Fp,i=t.allowedPrivateKeyLengths?Array.from(new Set(t.allowedPrivateKeyLengths.map(t=>Math.ceil(t/2)))):void 0,n={Fp:r,Fn:(0,o.Field)(e.n,{BITS:t.nBitLength,allowedLengths:i,modFromBytes:t.wrapPrivateKey}),allowInfinityPoint:t.allowInfinityPoint,endo:t.endo,isTorsionFree:t.isTorsionFree,clearCofactor:t.clearCofactor,fromBytes:t.fromBytes,toBytes:t.toBytes};return{CURVE:e,curveOpts:n}}function A(t,e,r){return function(i){let n=t.sqr(i),a=t.mul(n,i);return t.add(t.add(a,t.mul(i,e)),r)}}},54895,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.getHash=function(t){return{hash:t}},r.createCurve=function(t,e){let r=e=>(0,i.weierstrass)({...t,hash:e});return{...r(e),create:r}};let i=t.r(855311)},538175,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r._DST_scalar=void 0,r.expand_message_xmd=u,r.expand_message_xof=c,r.hash_to_field=h,r.isogenyMap=function(t,e){let r=e.map(t=>Array.from(t).reverse());return(e,i)=>{let[a,s,o,l]=r.map(r=>r.reduce((r,i)=>t.add(t.mul(r,e),i))),[u,c]=(0,n.FpInvertBatch)(t,[s,l],!0);return e=t.mul(a,u),i=t.mul(i,t.mul(o,c)),{x:e,y:i}}},r.createHasher=function(t,e,i){if("function"!=typeof e)throw Error("mapToCurve() must be defined");function n(r){return t.fromAffine(e(r))}function a(e){let r=e.clearCofactor();return r.equals(t.ZERO)?t.ZERO:(r.assertValidity(),r)}return{defaults:i,hashToCurve(t,e){let r=h(t,2,Object.assign({},i,e)),s=n(r[0]),o=n(r[1]);return a(s.add(o))},encodeToCurve(t,e){let r=i.encodeDST?{DST:i.encodeDST}:{};return a(n(h(t,1,Object.assign({},i,r,e))[0]))},mapToCurve(t){if(!Array.isArray(t))throw Error("expected array of bigints");for(let e of t)if("bigint"!=typeof e)throw Error("expected array of bigints");return a(n(t))},hashToScalar:(e,n)=>h(e,1,Object.assign({},i,{p:t.Fn.ORDER,m:1,DST:r._DST_scalar},n))[0][0]}};let i=t.r(374752),n=t.r(113157),a=i.bytesToNumberBE;function s(t,e){if(o(t),o(e),t<0||t>=1<<8*e)throw Error("invalid I2OSP input: "+t);let r=Array.from({length:e}).fill(0);for(let i=e-1;i>=0;i--)r[i]=255&t,t>>>=8;return new Uint8Array(r)}function o(t){if(!Number.isSafeInteger(t))throw Error("number expected")}function l(t){if(!(0,i.isBytes)(t)&&"string"!=typeof t)throw Error("DST must be Uint8Array or string");return"string"==typeof t?(0,i.utf8ToBytes)(t):t}function u(t,e,r,n){(0,i.abytes)(t),o(r),(e=l(e)).length>255&&(e=n((0,i.concatBytes)((0,i.utf8ToBytes)("H2C-OVERSIZE-DST-"),e)));let{outputLen:a,blockLen:u}=n,c=Math.ceil(r/a);if(r>65535||c>255)throw Error("expand_message_xmd: invalid lenInBytes");let h=(0,i.concatBytes)(e,s(e.length,1)),p=s(0,u),d=s(r,2),f=Array(c),m=n((0,i.concatBytes)(p,t,d,s(0,1),h));f[0]=n((0,i.concatBytes)(m,s(1,1),h));for(let t=1;t<=c;t++){let e=[function(t,e){let r=new Uint8Array(t.length);for(let i=0;i<t.length;i++)r[i]=t[i]^e[i];return r}(m,f[t-1]),s(t+1,1),h];f[t]=n((0,i.concatBytes)(...e))}return(0,i.concatBytes)(...f).slice(0,r)}function c(t,e,r,n,a){if((0,i.abytes)(t),o(r),(e=l(e)).length>255){let t=Math.ceil(2*n/8);e=a.create({dkLen:t}).update((0,i.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()}if(r>65535||e.length>255)throw Error("expand_message_xof: invalid lenInBytes");return a.create({dkLen:r}).update(t).update(s(r,2)).update(e).update(s(e.length,1)).digest()}function h(t,e,r){let s;(0,i._validateObject)(r,{p:"bigint",m:"number",k:"number",hash:"function"});let{p:l,k:h,m:p,hash:d,expand:f,DST:m}=r;if(!(0,i.isHash)(r.hash))throw Error("expected valid hash");(0,i.abytes)(t),o(e);let g=Math.ceil((l.toString(2).length+h)/8),w=e*p*g;if("xmd"===f)s=u(t,m,w,d);else if("xof"===f)s=c(t,m,w,h,d);else if("_internal_pass"===f)s=t;else throw Error('expand must be "xmd" or "xof"');let y=Array(e);for(let t=0;t<e;t++){let e=Array(p);for(let r=0;r<p;r++){let i=g*(r+t*p),o=s.subarray(i,i+g);e[r]=(0,n.mod)(a(o),l)}y[t]=e}return y}r._DST_scalar=(0,i.utf8ToBytes)("HashToScalar-")},891476,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.encodeToCurve=r.hashToCurve=r.secp256k1_hasher=r.schnorr=r.secp256k1=void 0;let i=t.r(1083),n=t.r(697858),a=t.r(54895),s=t.r(538175),o=t.r(113157),l=t.r(855311),u=t.r(374752),c={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},h={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},p=BigInt(0),d=BigInt(1),f=BigInt(2),m=(0,o.Field)(c.p,{sqrt:function(t){let e=c.p,r=BigInt(3),i=BigInt(6),n=BigInt(11),a=BigInt(22),s=BigInt(23),l=BigInt(44),u=BigInt(88),h=t*t*t%e,p=h*h*t%e,d=(0,o.pow2)(p,r,e)*p%e,g=(0,o.pow2)(d,r,e)*p%e,w=(0,o.pow2)(g,f,e)*h%e,y=(0,o.pow2)(w,n,e)*w%e,T=(0,o.pow2)(y,a,e)*y%e,S=(0,o.pow2)(T,l,e)*T%e,E=(0,o.pow2)(S,u,e)*S%e,I=(0,o.pow2)(E,l,e)*T%e,b=(0,o.pow2)(I,r,e)*p%e,v=(0,o.pow2)(b,s,e)*y%e,B=(0,o.pow2)(v,i,e)*h%e,A=(0,o.pow2)(B,f,e);if(!m.eql(m.sqr(A),t))throw Error("Cannot find square root");return A}});r.secp256k1=(0,a.createCurve)({...c,Fp:m,lowS:!0,endo:h},i.sha256);let g={};function w(t,...e){let r=g[t];if(void 0===r){let e=(0,i.sha256)((0,u.utf8ToBytes)(t));r=(0,u.concatBytes)(e,e),g[t]=r}return(0,i.sha256)((0,u.concatBytes)(r,...e))}let y=t=>t.toBytes(!0).slice(1),T=r.secp256k1.Point;function S(t){let{Fn:e,BASE:r}=T,i=(0,l._normFnElement)(e,t),n=r.multiply(i);return{scalar:n.y%f===p?i:e.neg(i),bytes:y(n)}}function E(t){if(!m.isValidNot0(t))throw Error("invalid x: Fail if x  p");let e=m.create(t*t),r=m.create(e*t+BigInt(7)),i=m.sqrt(r);i%f!==p&&(i=m.neg(i));let n=T.fromAffine({x:t,y:i});return n.assertValidity(),n}let I=u.bytesToNumberBE;function b(...t){return T.Fn.create(I(w("BIP0340/challenge",...t)))}function v(t){return S(t).bytes}function B(t,e,r=(0,n.randomBytes)(32)){let{Fn:i}=T,a=(0,u.ensureBytes)("message",t),{bytes:s,scalar:o}=S(e),l=(0,u.ensureBytes)("auxRand",r,32),c=i.toBytes(o^I(w("BIP0340/aux",l))),{bytes:h,scalar:p}=S(w("BIP0340/nonce",c,s,a)),d=b(h,s,a),f=new Uint8Array(64);if(f.set(h,0),f.set(i.toBytes(i.create(p+d*o)),32),!A(f,a,s))throw Error("sign: Invalid signature produced");return f}function A(t,e,r){let{Fn:i,BASE:n}=T,a=(0,u.ensureBytes)("signature",t,64),s=(0,u.ensureBytes)("message",e),o=(0,u.ensureBytes)("publicKey",r,32);try{let t=E(I(o)),e=I(a.subarray(0,32));if(!(0,u.inRange)(e,d,c.p))return!1;let r=I(a.subarray(32,64));if(!(0,u.inRange)(r,d,c.n))return!1;let l=b(i.toBytes(e),y(t),s),h=n.multiplyUnsafe(r).add(t.multiplyUnsafe(i.neg(l))),{x:m,y:g}=h.toAffine();if(h.is0()||g%f!==p||m!==e)return!1;return!0}catch(t){return!1}}r.schnorr=(()=>{let t=48,e=(e=(0,n.randomBytes)(t))=>(0,o.mapHashToField)(e,c.n);return r.secp256k1.utils.randomSecretKey,{keygen:function(t){let r=e(t);return{secretKey:r,publicKey:v(r)}},getPublicKey:v,sign:B,verify:A,Point:T,utils:{randomSecretKey:e,randomPrivateKey:e,taggedHash:w,lift_x:E,pointToBytes:y,numberToBytesBE:u.numberToBytesBE,bytesToNumberBE:u.bytesToNumberBE,mod:o.mod},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:t}}})();let R=(0,s.isogenyMap)(m,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(t=>BigInt(t)))),C=(0,l.mapToCurveSimpleSWU)(m,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:m.create(BigInt("-11"))});r.secp256k1_hasher=(0,s.createHasher)(r.secp256k1.Point,t=>{let{x:e,y:r}=C(m.create(t[0]));return R(e,r)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:m.ORDER,m:1,k:128,expand:"xmd",hash:i.sha256}),r.hashToCurve=r.secp256k1_hasher.hashToCurve,r.encodeToCurve=r.secp256k1_hasher.encodeToCurve},368555,(t,e,r)=>{var i="__lodash_hash_undefined__",n="[object Arguments]",a="[object Boolean]",s="[object Date]",o="[object Function]",l="[object GeneratorFunction]",u="[object Map]",c="[object Number]",h="[object Object]",p="[object Promise]",d="[object RegExp]",f="[object Set]",m="[object String]",g="[object Symbol]",w="[object WeakMap]",y="[object ArrayBuffer]",T="[object DataView]",S="[object Float32Array]",E="[object Float64Array]",I="[object Int8Array]",b="[object Int16Array]",v="[object Int32Array]",B="[object Uint8Array]",A="[object Uint8ClampedArray]",R="[object Uint16Array]",C="[object Uint32Array]",_=/\w*$/,F=/^\[object .+?Constructor\]$/,P=/^(?:0|[1-9]\d*)$/,x={};x[n]=x["[object Array]"]=x[y]=x[T]=x[a]=x[s]=x[S]=x[E]=x[I]=x[b]=x[v]=x[u]=x[c]=x[h]=x[d]=x[f]=x[m]=x[g]=x[B]=x[A]=x[R]=x[C]=!0,x["[object Error]"]=x[o]=x[w]=!1;var D=t.g&&t.g.Object===Object&&t.g,k="object"==typeof self&&self&&self.Object===Object&&self,O=D||k||Function("return this")(),L=r&&!r.nodeType&&r,N=L&&e&&!e.nodeType&&e,M=N&&N.exports===L;function U(t,e){return t.set(e[0],e[1]),t}function q(t,e){return t.add(e),t}function W(t,e,r,i){var n=-1,a=t?t.length:0;for(i&&a&&(r=t[++n]);++n<a;)r=e(r,t[n],n,t);return r}function j(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function H(t){var e=-1,r=Array(t.size);return t.forEach(function(t,i){r[++e]=[i,t]}),r}function V(t,e){return function(r){return t(e(r))}}function z(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}var X=Array.prototype,K=Function.prototype,G=Object.prototype,Q=O["__core-js_shared__"],$=function(){var t=/[^.]+$/.exec(Q&&Q.keys&&Q.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),Z=K.toString,Y=G.hasOwnProperty,J=G.toString,tt=RegExp("^"+Z.call(Y).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),te=M?O.Buffer:void 0,tr=O.Symbol,ti=O.Uint8Array,tn=V(Object.getPrototypeOf,Object),ta=Object.create,ts=G.propertyIsEnumerable,to=X.splice,tl=Object.getOwnPropertySymbols,tu=te?te.isBuffer:void 0,tc=V(Object.keys,Object),th=tD(O,"DataView"),tp=tD(O,"Map"),td=tD(O,"Promise"),tf=tD(O,"Set"),tm=tD(O,"WeakMap"),tg=tD(Object,"create"),tw=tN(th),ty=tN(tp),tT=tN(td),tS=tN(tf),tE=tN(tm),tI=tr?tr.prototype:void 0,tb=tI?tI.valueOf:void 0;function tv(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var i=t[e];this.set(i[0],i[1])}}function tB(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var i=t[e];this.set(i[0],i[1])}}function tA(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var i=t[e];this.set(i[0],i[1])}}function tR(t){this.__data__=new tB(t)}function tC(t,e,r){var i=t[e];Y.call(t,e)&&tM(i,r)&&(void 0!==r||e in t)||(t[e]=r)}function t_(t,e){for(var r=t.length;r--;)if(tM(t[r][0],e))return r;return -1}function tF(t){var e=new t.constructor(t.byteLength);return new ti(e).set(new ti(t)),e}function tP(t,e,r,i){r||(r={});for(var n=-1,a=e.length;++n<a;){var s=e[n],o=i?i(r[s],t[s],s,r,t):void 0;tC(r,s,void 0===o?t[s]:o)}return r}function tx(t,e){var r,i,n=t.__data__;return("string"==(i=typeof(r=e))||"number"==i||"symbol"==i||"boolean"==i?"__proto__"!==r:null===r)?n["string"==typeof e?"string":"hash"]:n.map}function tD(t,e){var r,i=null==t?void 0:t[e];return!(!tH(i)||(r=i,$&&$ in r))&&(tj(i)||j(i)?tt:F).test(tN(i))?i:void 0}tv.prototype.clear=function(){this.__data__=tg?tg(null):{}},tv.prototype.delete=function(t){return this.has(t)&&delete this.__data__[t]},tv.prototype.get=function(t){var e=this.__data__;if(tg){var r=e[t];return r===i?void 0:r}return Y.call(e,t)?e[t]:void 0},tv.prototype.has=function(t){var e=this.__data__;return tg?void 0!==e[t]:Y.call(e,t)},tv.prototype.set=function(t,e){return this.__data__[t]=tg&&void 0===e?i:e,this},tB.prototype.clear=function(){this.__data__=[]},tB.prototype.delete=function(t){var e=this.__data__,r=t_(e,t);return!(r<0)&&(r==e.length-1?e.pop():to.call(e,r,1),!0)},tB.prototype.get=function(t){var e=this.__data__,r=t_(e,t);return r<0?void 0:e[r][1]},tB.prototype.has=function(t){return t_(this.__data__,t)>-1},tB.prototype.set=function(t,e){var r=this.__data__,i=t_(r,t);return i<0?r.push([t,e]):r[i][1]=e,this},tA.prototype.clear=function(){this.__data__={hash:new tv,map:new(tp||tB),string:new tv}},tA.prototype.delete=function(t){return tx(this,t).delete(t)},tA.prototype.get=function(t){return tx(this,t).get(t)},tA.prototype.has=function(t){return tx(this,t).has(t)},tA.prototype.set=function(t,e){return tx(this,t).set(t,e),this},tR.prototype.clear=function(){this.__data__=new tB},tR.prototype.delete=function(t){return this.__data__.delete(t)},tR.prototype.get=function(t){return this.__data__.get(t)},tR.prototype.has=function(t){return this.__data__.has(t)},tR.prototype.set=function(t,e){var r=this.__data__;if(r instanceof tB){var i=r.__data__;if(!tp||i.length<199)return i.push([t,e]),this;r=this.__data__=new tA(i)}return r.set(t,e),this};var tk=tl?V(tl,Object):function(){return[]},tO=function(t){return J.call(t)};function tL(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||G)}function tN(t){if(null!=t){try{return Z.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function tM(t,e){return t===e||t!=t&&e!=e}(th&&tO(new th(new ArrayBuffer(1)))!=T||tp&&tO(new tp)!=u||td&&tO(td.resolve())!=p||tf&&tO(new tf)!=f||tm&&tO(new tm)!=w)&&(tO=function(t){var e=J.call(t),r=e==h?t.constructor:void 0,i=r?tN(r):void 0;if(i)switch(i){case tw:return T;case ty:return u;case tT:return p;case tS:return f;case tE:return w}return e});var tU=Array.isArray;function tq(t){var e;return null!=t&&"number"==typeof(e=t.length)&&e>-1&&e%1==0&&e<=0x1fffffffffffff&&!tj(t)}var tW=tu||function(){return!1};function tj(t){var e=tH(t)?J.call(t):"";return e==o||e==l}function tH(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function tV(t){return tq(t)?function(t,e){var r,i,a,s,o,l=tU(t)||(a=i=r=t)&&"object"==typeof a&&tq(i)&&Y.call(r,"callee")&&(!ts.call(r,"callee")||J.call(r)==n)?function(t,e){for(var r=-1,i=Array(t);++r<t;)i[r]=e(r);return i}(t.length,String):[],u=l.length,c=!!u;for(var h in t){Y.call(t,h)&&!(c&&("length"==h||(s=h,(o=null==(o=u)?0x1fffffffffffff:o)&&("number"==typeof s||P.test(s))&&s>-1&&s%1==0&&s<o)))&&l.push(h)}return l}(t):function(t){if(!tL(t))return tc(t);var e=[];for(var r in Object(t))Y.call(t,r)&&"constructor"!=r&&e.push(r);return e}(t)}e.exports=function(t){return function t(e,r,i,p,w,F,P){if(p&&(D=F?p(e,w,F,P):p(e)),void 0!==D)return D;if(!tH(e))return e;var D,k=tU(e);if(k){if(L=(O=e).length,N=O.constructor(L),L&&"string"==typeof O[0]&&Y.call(O,"index")&&(N.index=O.index,N.input=O.input),D=N,!r){var O,L,N,M=e,V=D,X=-1,K=M.length;for(V||(V=Array(K));++X<K;)V[X]=M[X];return V}}else{var G,Q,$,Z,J,tt=tO(e),te=tt==o||tt==l;if(tW(e)){var tr=e,ti=r;if(ti)return tr.slice();var ts=new tr.constructor(tr.length);return tr.copy(ts),ts}if(tt==h||tt==n||te&&!F){if(j(e))return F?e:{};if(D="function"!=typeof(G=te?{}:e).constructor||tL(G)?{}:tH(Q=tn(G))?ta(Q):{},!r){return $=e,Z=(J=D)&&tP(e,tV(e),J),tP($,tk($),Z)}}else{if(!x[tt])return F?e:{};D=function(t,e,r,i){var n,o,l,h=t.constructor;switch(e){case y:return tF(t);case a:case s:return new h(+t);case T:return n=i?tF(t.buffer):t.buffer,new t.constructor(n,t.byteOffset,t.byteLength);case S:case E:case I:case b:case v:case B:case A:case R:case C:return o=i?tF(t.buffer):t.buffer,new t.constructor(o,t.byteOffset,t.length);case u:return W(i?r(H(t),!0):H(t),U,new t.constructor);case c:case m:return new h(t);case d:return(l=new t.constructor(t.source,_.exec(t))).lastIndex=t.lastIndex,l;case f:return W(i?r(z(t),!0):z(t),q,new t.constructor);case g:return tb?Object(tb.call(t)):{}}}(e,tt,t,r)}}P||(P=new tR);var to=P.get(e);if(to)return to;if(P.set(e,D),!k)var tl=i?function(t){var e;return e=tV(t),tU(t)?e:function(t,e){for(var r=-1,i=e.length,n=t.length;++r<i;)t[n+r]=e[r];return t}(e,tk(t))}(e):tV(e);return!function(t,e){for(var r=-1,i=t?t.length:0;++r<i&&!1!==e(t[r],r,t););}(tl||e,function(n,a){tl&&(n=e[a=n]),tC(D,a,t(n,r,i,p,a,e,P))}),D}(t,!0,!0)}},916232,(t,e,r)=>{"use strict";let i=t.r(935547).sha256,n=t.r(706910),a=t.r(223469).Buffer,s=t.r(818601),o=t.r(891476).secp256k1,l=t.r(368555),u={bech32:"bc",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0,1],wif:128},c={bech32:"tb",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0,1],wif:239},h={bech32:"bcrt",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0,1],wif:239},p={bech32:"sb",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0,1],wif:239},d={word_length:4,var_onion_optin:{required:!1,supported:!0},payment_secret:{required:!1,supported:!0}},f=["option_data_loss_protect","initial_routing_sync","option_upfront_shutdown_script","gossip_queries","var_onion_optin","gossip_queries_ex","option_static_remotekey","payment_secret","basic_mpp","option_support_large_channel"],m={m:1000n,u:1000000n,n:1000000000n,p:1000000000000n},g={payment_hash:1,payment_secret:16,description:13,payee_node_key:19,purpose_commit_hash:23,expire_time:6,min_final_cltv_expiry:24,fallback_address:9,routing_info:3,feature_bits:5,blinded_payinfo:20},w={};for(let t=0,e=Object.keys(g);t<e.length;t++){let r=e[t];w[g[e[t]].toString()]=r}let y={payment_hash:R,payment_secret:R,description:function(t){let e=a.from(t,"utf8");return n.toWords(e)},payee_node_key:R,purpose_commit_hash:function(t){let e;if(void 0!==t&&("string"==typeof t||t instanceof String))e=t.match(/^([a-zA-Z0-9]{2})*$/)?a.from(t,"hex"):b(a.from(t,"utf8"));else throw Error("purpose or purpose commit must be a string or hex string");return n.toWords(e)},expire_time:I,min_final_cltv_expiry:I,fallback_address:function(t,e){return[t.code].concat(R(t.addressHash))},routing_info:function(t){let e=a.from([]);return t.forEach(t=>{e=a.concat([e,A(t.pubkey)]),e=a.concat([e,A(t.short_channel_id)]),e=a.concat([e,a.from([0,0,0].concat(I(t.fee_base_msat,8)).slice(-4))]),e=a.concat([e,a.from([0,0,0].concat(I(t.fee_proportional_millionths,8)).slice(-4))]),e=a.concat([e,a.from([0].concat(I(t.cltv_expiry_delta,8)).slice(-2))])}),R(e)},feature_bits:function(t){let e=t.word_length,r=[];for(f.forEach(e=>{r.push(!!(t[e]||{}).required),r.push(!!(t[e]||{}).supported)});!1===r[r.length-1];)r.pop();for(;r.length%5!=0;)r.push(!1);if(t.extra_bits&&Array.isArray(t.extra_bits.bits)&&t.extra_bits.bits.length>0){for(;r.length<t.extra_bits.start_bit;)r.push(!1);r=r.concat(t.extra_bits.bits)}if(void 0!==e&&r.length/5>e)throw Error("word_length is too small to contain all featureBits");return void 0===e&&(e=Math.ceil(r.length/5)),Array(e).fill(0).map((t,e)=>r[5*e+4]<<4|r[5*e+3]<<3|r[5*e+2]<<2|r[5*e+1]<<1|(0|r[5*e])).reverse()}},T={1:t=>B(t,!0).toString("hex"),16:t=>B(t,!0).toString("hex"),13:t=>B(t,!0).toString("utf8"),19:t=>B(t,!0).toString("hex"),23:t=>B(t,!0).toString("hex"),6:E,24:E,9:function(t,e){let r=t[0],i=B(t=t.slice(1),!0),n=null;switch(r){case 17:n=s.Address(e).encode({type:"pkh",hash:i});break;case 18:n=s.Address(e).encode({type:"sh",hash:i});break;case 0:n=20===i.length?s.Address(e).encode({type:"wpkh",hash:i}):s.Address(e).encode({type:"wsh",hash:i});break;case 1:n=s.Address(e).encode({type:"tr",pubkey:i})}return{code:r,address:n,addressHash:i.toString("hex")}},3:function(t){let e,r,i,n,a,s=[],o=B(t,!0);for(;o.length>0;)e=o.slice(0,33).toString("hex"),r=o.slice(33,41).toString("hex"),i=parseInt(o.slice(41,45).toString("hex"),16),n=parseInt(o.slice(45,49).toString("hex"),16),a=parseInt(o.slice(49,51).toString("hex"),16),o=o.slice(51),s.push({pubkey:e,short_channel_id:r,fee_base_msat:i,fee_proportional_millionths:n,cltv_expiry_delta:a});return s},5:function(t){let e=t.slice().reverse().map(t=>[!!(1&t),!!(2&t),!!(4&t),!!(8&t),!!(16&t)]).reduce((t,e)=>t.concat(e),[]);for(;e.length<2*f.length;)e.push(!1);let r={word_length:t.length};if(f.forEach((t,i)=>{r[t]={required:e[2*i],supported:e[2*i+1]}}),e.length>2*f.length){let t=e.slice(2*f.length);r.extra_bits={start_bit:2*f.length,bits:t,has_required:t.reduce((t,e,r)=>r%2!=0?t||!1:t||e,!1)}}else r.extra_bits={start_bit:2*f.length,bits:[],has_required:!1};return r},20:function(t){let e=B(t,!0),r=e.readUInt32BE(0),i=e.readUInt32BE(4),n=e.readUInt16BE(8),a=BigInt("0x"+e.slice(10,18).toString("hex")),s=BigInt("0x"+e.slice(18,26).toString("hex")),o=e.readUInt16BE(26),l=28,u=[...e.slice(l,l+o)];l+=o;let c=e.slice(l,l+33).toString("hex");l+=33;let h=e.readUInt8(l);l++;let p=[];for(let t=0;t<h;t++){let[t,r]=function(t,e){let r=t.slice(e,e+33),[i,n]=function(t,e){let r=t.readUInt8(e);switch(e++,r){case 253:return[t.readUInt16BE(e),e+2];case 254:return[t.readUInt32BE(e),e+4];case 255:return[parseInt(t.slice(e,e+8).toString("hex"),16),e+8];default:return[r,e]}}(t,e+=33);e=n;let a=t.slice(e,e+i);return e+=i,[{blinded_node_pubkey:r.toString("hex"),cipher_text:a.toString("hex")},e]}(e,l);l=r,p.push(t)}return{fee_base_msat:r,fee_proportional_millionths:i,cltv_expiry_delta:n,htlc_minimum_msat:a,htlc_maximum_msat:s,features:u,first_ephemeral_blinding_point:c,blinded_hops:p,introduction_node:p[0].blinded_node_pubkey}}},S="unknownTag";function E(t){return t.reverse().reduce((t,e,r)=>t+e*Math.pow(32,r),0)}function I(t,e){let r=[];if(void 0===e&&(e=5),0===(t=Math.floor(t)))return[0];for(;t>0;)r.push(t&Math.pow(2,e)-1),t=Math.floor(t/Math.pow(2,e));return r.reverse()}function b(t){return a.from(i(t))}function v(t,e,r){let i=0,n=0,a=(1<<r)-1,s=[];for(let o=0;o<t.length;++o)for(i=i<<e|t[o],n+=e;n>=r;)s.push(i>>(n-=r)&a);return n>0&&s.push(i<<r-n&a),s}function B(t,e){let r=a.from(v(t,5,8,!0));return e&&5*t.length%8!=0&&(r=r.slice(0,-1)),r}function A(t){return void 0!==t&&("string"==typeof t||t instanceof String)&&t.match(/^([a-zA-Z0-9]{2})*$/)?a.from(t,"hex"):t}function R(t){let e=A(t);return n.toWords(e)}function C(t,e){let r=t.filter(t=>t.tagName===e);return r.length>0?r[0].data:null}function _(t,e){return null!==C(t,e)}function F(t,e){let r={};if(Object.keys(t).sort().forEach(e=>{r[e]=t[e]}),!0===e){let t="__tagsObject_cache";Object.defineProperty(r,"tagsObject",{get(){return this[t]||Object.defineProperty(this,t,{value:function(t){let e={};return t.forEach(t=>{t.tagName===S?(e.unknownTags||(e.unknownTags=[]),e.unknownTags.push(t.data)):"blinded_payinfo"===t.tagName?(null==e[t.tagName]&&(e[t.tagName]=[]),e[t.tagName].push(t.data)):e[t.tagName]=t.data}),e}(this.tags)}),this[t]}})}return r}function P(t){if(!t.toString().match(/^\d+$/))throw Error("satoshis must be an integer");return x(1000n*BigInt(t))}function x(t){let e,r;if(!t.toString().match(/^\d+$/))throw Error("millisatoshis must be an integer");let i=BigInt(t),n=i.toString(10),a=n.length;return a>11&&/0{11}$/.test(n)?(e="",r=(i/100000000000n).toString(10)):a>8&&/0{8}$/.test(n)?(e="m",r=(i/100000000n).toString(10)):a>5&&/0{5}$/.test(n)?(e="u",r=(i/100000n).toString(10)):a>2&&/0{2}$/.test(n)?(e="n",r=(i/100n).toString(10)):(e="p",r=(10n*i).toString(10)),r+e}function D(t,e){let r=k(t,!1);if(r%1000n!==0n)throw Error("Amount is outside of valid range");let i=r/1000n;return e?i.toString(10):i}function k(t,e){let r,i;if(t.slice(-1).match(/^[munp]$/))r=t.slice(-1),i=t.slice(0,-1);else if(t.slice(-1).match(/^[^munp0-9]$/))throw Error("Not a valid multiplier for the amount");else i=t;if(!i.match(/^\d+$/))throw Error("Not a valid human readable amount");let n=BigInt(i),a=r?100000000000n*n/m[r]:100000000000n*n;if("p"===r&&n%10n!==0n||a>0x1d24b2dfac520000n)throw Error("Amount is outside of valid range");return e?a.toString(10):a}e.exports={encode:function(t,e){let r,i,c,h,p,f,m,T,E=l(t);void 0===e&&(e=!0);let B=void 0!==E.signature&&void 0!==E.recoveryFlag;if(void 0!==E.network||B)if(void 0===E.network&&B)throw Error("Need network for proper payment request reconstruction");else{if(!E.network.bech32||void 0===E.network.pubKeyHash||void 0===E.network.scriptHash||!Array.isArray(E.network.validWitnessVersions)||void 0===E.network.wif)throw Error("Invalid network");r=E.network}else E.network=u,r=u;if(void 0!==E.timestamp||B){if(void 0===E.timestamp&&B)throw Error("Need timestamp for proper payment request reconstruction")}else E.timestamp=Math.floor(new Date().getTime()/1e3);if(void 0===E.tags)throw Error("Payment Requests need tags array");if(!_(E.tags,w["1"]))throw Error("Lightning Payment Request needs a payment hash");if(_(E.tags,w["16"]))if(_(E.tags,w["5"])){let t=C(E.tags,w["5"]);if(!t.payment_secret||!t.payment_secret.supported&&!t.payment_secret.required)throw Error("Payment request requires feature bits with at least payment secret support flagged if payment secret is included")}else if(e)E.tags.push({tagName:w["5"],data:d});else throw Error("Payment request requires feature bits with at least payment secret support flagged if payment secret is included");if(!_(E.tags,w["13"])&&!_(E.tags,w["23"]))if(e)E.tags.push({tagName:w["13"],data:""});else throw Error("Payment request requires description or purpose commit hash");if(_(E.tags,w["13"])&&a.from(C(E.tags,w["13"]),"utf8").length>639)throw Error("Description is too long: Max length 639 bytes");if(_(E.tags,w["6"])||B||!e||E.tags.push({tagName:w["6"],data:3600}),_(E.tags,w["24"])||B||!e||E.tags.push({tagName:w["24"],data:9}),_(E.tags,w["19"])&&(c=A(C(E.tags,w["19"]))),E.payeeNodeKey&&(i=A(E.payeeNodeKey)),i&&c&&!c.equals(i))throw Error("payeeNodeKey and tag payee node key do not match");if((i=i||c)&&(E.payeeNodeKey=i.toString("hex")),_(E.tags,w["9"])){let t=C(E.tags,w["9"]);if(f=t.address,p=t.addressHash,h=t.code,void 0===p||void 0===h){let e;try{e=s.Address(r).decode(f)}catch(t){throw Error("Fallback address invalid format")}switch(e.type){case"pkh":p=e.hash,h=17;break;case"sh":p=e.hash,h=18;break;case"wsh":case"wpkh":p=e.hash,h=0;break;case"tr":p=e.pubkey,h=1;break;default:throw Error("Fallback address format is unknown")}t.addressHash=a.from(p).toString("hex"),t.code=h}}_(E.tags,w["3"])&&C(E.tags,w["3"]).forEach(t=>{if(void 0===t.pubkey||void 0===t.short_channel_id||void 0===t.fee_base_msat||void 0===t.fee_proportional_millionths||void 0===t.cltv_expiry_delta)throw Error("Routing info is incomplete");try{o.ProjectivePoint.fromHex(A(t.pubkey))}catch(t){throw Error("Routing info pubkey is not a valid pubkey")}let e=A(t.short_channel_id);if(!(e instanceof a)||8!==e.length)throw Error("Routing info short channel id must be 8 bytes");if("number"!=typeof t.fee_base_msat||Math.floor(t.fee_base_msat)!==t.fee_base_msat)throw Error("Routing info fee base msat is not an integer");if("number"!=typeof t.fee_proportional_millionths||Math.floor(t.fee_proportional_millionths)!==t.fee_proportional_millionths)throw Error("Routing info fee proportional millionths is not an integer");if("number"!=typeof t.cltv_expiry_delta||Math.floor(t.cltv_expiry_delta)!==t.cltv_expiry_delta)throw Error("Routing info cltv expiry delta is not an integer")});let D="ln";if(D+=r.bech32,E.millisatoshis&&E.satoshis){if(m=x(BigInt(E.millisatoshis)),P(BigInt(E.satoshis))!==m)throw Error("satoshis and millisatoshis do not match")}else m=E.millisatoshis?x(BigInt(E.millisatoshis)):E.satoshis?P(BigInt(E.satoshis)):"";D+=m;let k=I(E.timestamp);for(;k.length<7;)k.unshift(0);let O=E.tags,L=[];O.forEach(t=>{let e,r=Object.keys(y);if(B&&r.push(S),-1===r.indexOf(t.tagName))throw Error("Unknown tag key: "+t.tagName);if(t.tagName!==S)L.push(g[t.tagName]),e=(0,y[t.tagName])(t.data);else{var i;let r=((i=t.data).words=n.decode(i.words,Number.MAX_SAFE_INTEGER).words,i);L.push(r.tagCode),e=r.words}L=(L=L.concat([0].concat(I(e.length)).slice(-2))).concat(e)});let N=k.concat(L),M=b(a.concat([a.from(D,"utf8"),a.from(v(N,5,8))]));if(B)if(i){let t=o.Signature.fromCompact(a.from(E.signature,"hex")).addRecoveryBit(E.recoveryFlag),e=a.from(t.recoverPublicKey(M).toRawBytes(!0));if(i&&!i.equals(e))throw Error("Signature, message, and recoveryID did not produce the same pubkey as payeeNodeKey");T=R(E.signature+"0"+E.recoveryFlag)}else throw Error("Reconstruction with signature and recoveryID requires payeeNodeKey to verify correctness of input data.");return T&&(N=N.concat(T)),_(E.tags,w["6"])&&(E.timeExpireDate=E.timestamp+C(E.tags,w["6"]),E.timeExpireDateString=new Date(1e3*E.timeExpireDate).toISOString()),E.timestampString=new Date(1e3*E.timestamp).toISOString(),E.complete=!!T,E.paymentRequest=E.complete?n.encode(D,N,Number.MAX_SAFE_INTEGER):"",E.prefix=D,E.wordsTemp=n.encode("temp",N,Number.MAX_SAFE_INTEGER),F(E)},decode:function(t,e){let r,i,s,l,d,f,m,g,y,I;if("string"!=typeof t)throw Error("Lightning Payment Request must be string");if("ln"!==t.slice(0,2).toLowerCase())throw Error("Not a proper lightning payment request");let A=n.decode(t,Number.MAX_SAFE_INTEGER);t=t.toLowerCase();let R=A.prefix,P=A.words,x=P.slice(-104),O=P.slice(0,-104);P=P.slice(0,-104);let L=B(x,!0),N=L.slice(-1)[0];if(L=L.slice(0,-1),!(N in[0,1,2,3])||64!==L.length)throw Error("Signature is missing or incorrect");let M=R.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);if(M&&!M[2]&&(M=R.match(/^ln(\S+)$/)),!M)throw Error("Not a proper lightning payment request");let U=M[1];if(e){if(void 0===e.bech32||void 0===e.pubKeyHash||void 0===e.scriptHash||!Array.isArray(e.validWitnessVersions)||void 0===e.wif)throw Error("Invalid network");r=e}else switch(U){case u.bech32:r=u;break;case c.bech32:r=c;break;case h.bech32:r=h;break;case p.bech32:r=p}if(!r||r.bech32!==U)throw Error("Unknown coin bech32 prefix");let q=M[2];if(q){let t=M[3];try{i=parseInt(D(q+t,!0))}catch(t){i=null,l=!0}s=k(q+t,!0)}else i=null,s=null;let W=E(P.slice(0,7)),j=new Date(1e3*W).toISOString();P=P.slice(7);let H=[];for(;P.length>0;){let t=P[0].toString();d=w[t]||S,f=T[t]||function(t){return e=>({tagCode:parseInt(t),words:n.encode("unknown",e,Number.MAX_SAFE_INTEGER)})}(t),m=E((P=P.slice(1)).slice(0,2)),g=(P=P.slice(2)).slice(0,m),P=P.slice(m),H.push({tagName:d,data:f(g,r)})}_(H,w["6"])&&(I=new Date(1e3*(y=W+C(H,w["6"]))).toISOString());let V=b(a.concat([a.from(R,"utf8"),a.from(v(O,5,8))])),z=o.Signature.fromCompact(L).addRecoveryBit(N),X=a.from(z.recoverPublicKey(V).toRawBytes(!0));if(_(H,w["19"])&&C(H,w["19"])!==X.toString("hex"))throw Error("Lightning Payment Request signature pubkey does not match payee pubkey");let K={paymentRequest:t,complete:!0,prefix:R,wordsTemp:n.encode("temp",O.concat(x),Number.MAX_SAFE_INTEGER),network:r,satoshis:i,millisatoshis:s,timestamp:W,timestampString:j,payeeNodeKey:X.toString("hex"),signature:L.toString("hex"),recoveryFlag:N,tags:H};return l&&delete K.satoshis,y&&(K=Object.assign(K,{timeExpireDate:y,timeExpireDateString:I})),F(K,!0)},sign:function(t,e){let r,i,s=l(t),u=A(e);if(s.complete&&s.paymentRequest)return s;if(void 0===u||32!==u.length||!o.utils.isValidPrivateKey(u))throw Error("privateKey must be a 32 byte Buffer and valid private key");if(_(s.tags,w["19"])&&(i=A(C(s.tags,w["19"]))),s.payeeNodeKey&&(r=A(s.payeeNodeKey)),r&&i&&!i.equals(r))throw Error("payee node key tag and payeeNodeKey attribute must match");r=i||r;let c=a.from(o.getPublicKey(u,!0));if(r&&!c.equals(r))throw Error("The private key given is not the private key of the node public key given");let h=n.decode(s.wordsTemp,Number.MAX_SAFE_INTEGER).words,p=b(a.concat([a.from(s.prefix,"utf8"),B(h)])),d=o.sign(p,u,{lowS:!0});s.signature=a.from(d.toCompactRawBytes()).toString("hex");let f=R(s.signature+"0"+d.recovery);return s.payeeNodeKey=c.toString("hex"),s.recoveryFlag=d.recovery,s.wordsTemp=n.encode("temp",h.concat(f),Number.MAX_SAFE_INTEGER),s.complete=!0,s.paymentRequest=n.encode(s.prefix,h.concat(f),Number.MAX_SAFE_INTEGER),F(s)},satToHrp:P,millisatToHrp:x,hrpToSat:D,hrpToMillisat:k}},146768,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IEscrowSwap=r.isIEscrowSwapInit=void 0;let i=t.r(185670),n=t.r(154585),a=t.r(389215),s=t.r(500874),o=t.r(844485);function l(t){return"object"==typeof t&&null!=t.feeRate&&(null==t.signatureData||"object"==typeof t.signatureData&&"string"==typeof t.signatureData.prefix&&"string"==typeof t.signatureData.timeout&&"string"==typeof t.signatureData.signature)&&(null==t.data||"object"==typeof t.data)&&(0,i.isISwapInit)(t)}r.isIEscrowSwapInit=l;class u extends i.ISwap{constructor(t,e){super(t,e),l(e)||(this.data=null!=e.data?new t.swapDataDeserializer(e.data):null,this.signatureData=null==e.signature?null:{prefix:e.prefix,timeout:e.timeout,signature:e.signature},this.feeRate=e.feeRate,this.commitTxId=e.commitTxId,this.claimTxId=e.claimTxId,this.refundTxId=e.refundTxId)}getIdentifierHash(){let t=s.Buffer.from(this.getClaimHash(),"hex");return null==this.randomNonce?t:s.Buffer.concat([t,s.Buffer.from(this.randomNonce,"hex")])}getIdentifierHashString(){let t=this.getIdentifierHash();return null==t?null:t.toString("hex")}_getEscrowHash(){return this.data?.getEscrowHash()}getEscrowHash(){return this._getEscrowHash()}getClaimHash(){return this.data?.getClaimHash()}getId(){return this.getIdentifierHashString()}async watchdogWaitTillSignatureExpiry(t,e=5){let r=!1;for(;!r;){await (0,a.timeoutPromise)(1e3*e,t);try{r=await this.wrapper.contract.isInitAuthorizationExpired(this.data,this.signatureData)}catch(t){this.logger.error("watchdogWaitTillSignatureExpiry(): Error when checking signature expiry: ",t)}}null!=t&&t.throwIfAborted()}async watchdogWaitTillCommited(t,e=5){let r={type:n.SwapCommitStateType.NOT_COMMITED};for(;r?.type===n.SwapCommitStateType.NOT_COMMITED;){await (0,a.timeoutPromise)(1e3*e,t);try{if(r=await this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data),r?.type===n.SwapCommitStateType.NOT_COMMITED&&await this.wrapper.contract.isInitAuthorizationExpired(this.data,this.signatureData))return!1}catch(t){this.logger.error("watchdogWaitTillCommited(): Error when fetching commit status or signature expiry: ",t)}}return null!=t&&t.throwIfAborted(),!0}async watchdogWaitTillResult(t,e=5){let r={type:n.SwapCommitStateType.COMMITED};for(;r?.type===n.SwapCommitStateType.COMMITED||r?.type===n.SwapCommitStateType.REFUNDABLE;){await (0,a.timeoutPromise)(1e3*e,t);try{r=await this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data)}catch(t){this.logger.error("watchdogWaitTillResult(): Error when fetching commit status: ",t)}}return null!=t&&t.throwIfAborted(),r}async verifyQuoteDefinitelyExpired(){return(0,a.tryWithRetries)(()=>this.wrapper.contract.isInitAuthorizationExpired(this.data,this.signatureData))}async verifyQuoteValid(){try{return await (0,a.tryWithRetries)(()=>this.wrapper.contract.isValidInitAuthorization(this._getInitiator(),this.data,this.signatureData,this.feeRate),null,n.SignatureVerificationError),!0}catch(t){if(t instanceof n.SignatureVerificationError)return!1}}getCommitFee(){return this.wrapper.contract.getCommitFee(this.data,this.feeRate)}async getSmartChainNetworkFee(){let t=this.wrapper.contract;return(0,o.toTokenAmount)(await (null!=t.getRawCommitFee?t.getRawCommitFee(this.data,this.feeRate):t.getCommitFee(this.data,this.feeRate)),this.wrapper.getNativeToken(),this.wrapper.prices)}serialize(){return{...super.serialize(),data:null!=this.data?this.data.serialize():null,prefix:this.signatureData?.prefix,timeout:this.signatureData?.timeout,signature:this.signatureData?.signature,feeRate:null==this.feeRate?null:this.feeRate.toString(),commitTxId:this.commitTxId,claimTxId:this.claimTxId,refundTxId:this.refundTxId}}}r.IEscrowSwap=u},302887,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.FeeType=void 0,function(t){t[t.SWAP=0]="SWAP",t[t.NETWORK_OUTPUT=1]="NETWORK_OUTPUT"}(r.FeeType||(r.FeeType={}))},582992,(t,e,r)=>{"use strict";var i;Object.defineProperty(r,"__esModule",{value:!0}),r.ToBTCSwapState=r.IToBTCSwap=r.isIToBTCSwapInit=void 0;let n=t.r(154585),a=t.r(302071),s=t.r(46575),o=t.r(389215),l=t.r(844485),u=t.r(146768),c=t.r(302887),h=t.r(185670);function p(t){return"bigint"==typeof t.networkFee&&(null==t.networkFeeBtc||"bigint"==typeof t.networkFeeBtc)&&(0,u.isIEscrowSwapInit)(t)}r.isIToBTCSwapInit=p;class d extends u.IEscrowSwap{constructor(t,e){super(t,e),p(e)?this.state=i.CREATED:(this.networkFee=null==e.networkFee?null:BigInt(e.networkFee),this.networkFeeBtc=null==e.networkFeeBtc?null:BigInt(e.networkFeeBtc))}upgradeVersion(){if(null==this.version){switch(this.state){case -2:this.state=i.REFUNDED;break;case -1:this.state=i.QUOTE_EXPIRED;break;case 0:this.state=i.CREATED;break;case 1:this.state=i.COMMITED;break;case 2:this.state=i.CLAIMED;break;case 3:this.state=i.REFUNDABLE}this.version=1}}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getOutput().rawAmount/this.getInputWithoutFee().rawAmount),null==this.networkFeeBtc&&(this.networkFeeBtc=this.networkFee*this.getOutput().rawAmount/this.getInputWithoutFee().rawAmount),super.tryRecomputeSwapPrice()}getLpIdentifier(){return this.getClaimHash()}getInputTxId(){return this.commitTxId}requiresAction(){return this.isRefundable()}isFinished(){return this.state===i.CLAIMED||this.state===i.REFUNDED||this.state===i.QUOTE_EXPIRED}isRefundable(){return this.state===i.REFUNDABLE}isQuoteExpired(){return this.state===i.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===i.QUOTE_EXPIRED||this.state===i.QUOTE_SOFT_EXPIRED}isSuccessful(){return this.state===i.CLAIMED}isFailed(){return this.state===i.REFUNDED}_getInitiator(){return this.data.getOfferer()}getSwapFee(){let t=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getOutput().rawAmount;return{amountInSrcToken:(0,l.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),amountInDstToken:(0,l.toTokenAmount)(this.swapFeeBtc,this.outputToken,this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,t,e),composition:{base:(0,l.toTokenAmount)(this.pricingInfo.satsBaseFee,this.outputToken,this.wrapper.prices),percentage:(0,h.ppmToPercentage)(t)}}}getNetworkFee(){return{amountInSrcToken:(0,l.toTokenAmount)(this.networkFee,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),amountInDstToken:(0,l.toTokenAmount)(this.networkFeeBtc,this.outputToken,this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(this.networkFeeBtc,t,e)}}getFee(){return{amountInSrcToken:(0,l.toTokenAmount)(this.swapFee+this.networkFee,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),amountInDstToken:(0,l.toTokenAmount)(this.swapFeeBtc+this.networkFeeBtc,this.outputToken,this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc+this.networkFeeBtc,t,e)}}getFeeBreakdown(){return[{type:c.FeeType.SWAP,fee:this.getSwapFee()},{type:c.FeeType.NETWORK_OUTPUT,fee:this.getNetworkFee()}]}getInput(){return(0,l.toTokenAmount)(this.data.getAmount(),this.wrapper.tokens[this.data.getToken()],this.wrapper.prices)}getInputWithoutFee(){return(0,l.toTokenAmount)(this.data.getAmount()-(this.swapFee+this.networkFee),this.wrapper.tokens[this.data.getToken()],this.wrapper.prices)}async hasEnoughBalance(){let[t,e]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.data.getToken(),!1),this.data.getToken()===this.wrapper.chain.getNativeCurrencyAddress()?this.getCommitFee():Promise.resolve(null)]),r=this.data.getAmount();return null!=e&&(r+=e),{enoughBalance:t>=r,balance:(0,l.toTokenAmount)(t,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices),required:(0,l.toTokenAmount)(r,this.wrapper.tokens[this.data.getToken()],this.wrapper.prices)}}async hasEnoughForTxFees(){let[t,e]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.wrapper.chain.getNativeCurrencyAddress(),!1),this.getCommitFee()]);return{enoughBalance:t>=e,balance:(0,l.toTokenAmount)(t,this.wrapper.getNativeToken(),this.wrapper.prices),required:(0,l.toTokenAmount)(e,this.wrapper.getNativeToken(),this.wrapper.prices)}}async txsCommit(t){if(this.state!==i.CREATED)throw Error("Must be in CREATED state!");return this.initiated||(this.initiated=!0,await this._saveAndEmit()),await this.wrapper.contract.txsInit(this._getInitiator(),this.data,this.signatureData,t,this.feeRate).catch(t=>Promise.reject(t instanceof n.SignatureVerificationError?Error("Request timed out"):t))}async commit(t,e,r){this.checkSigner(t);let n=await this.wrapper.chain.sendAndConfirm(t,await this.txsCommit(r),!0,e);return this.commitTxId=n[n.length-1],(this.state===i.CREATED||this.state===i.QUOTE_SOFT_EXPIRED||this.state===i.QUOTE_EXPIRED)&&await this._saveAndEmit(i.COMMITED),this.commitTxId}async waitTillCommited(t){if(this.state===i.COMMITED||this.state===i.CLAIMED)return Promise.resolve();if(this.state!==i.CREATED&&this.state!==i.QUOTE_SOFT_EXPIRED)throw Error("Invalid state (not CREATED)");let e=(0,o.extendAbortController)(t),r=await Promise.race([this.watchdogWaitTillCommited(e.signal),this.waitTillState(i.COMMITED,"gte",e.signal).then(()=>0)]);if(e.abort(),0===r&&this.logger.debug("waitTillCommited(): Resolved from state change"),!0===r&&this.logger.debug("waitTillCommited(): Resolved from watchdog - commited"),!1===r){if(this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expiry"),this.state===i.QUOTE_SOFT_EXPIRED||this.state===i.CREATED)throw await this._saveAndEmit(i.QUOTE_EXPIRED),Error("Quote expired while waiting for transaction confirmation!");return}(this.state===i.QUOTE_SOFT_EXPIRED||this.state===i.CREATED||this.state===i.QUOTE_EXPIRED)&&await this._saveAndEmit(i.COMMITED)}async waitTillIntermediarySwapProcessed(t,e=5){let r={code:a.RefundAuthorizationResponseCodes.PENDING,msg:""};for(;!t.aborted&&(r.code===a.RefundAuthorizationResponseCodes.PENDING||r.code===a.RefundAuthorizationResponseCodes.NOT_FOUND);)(r=await a.IntermediaryAPI.getRefundAuthorization(this.url,this.getLpIdentifier(),this.data.getSequence())).code===a.RefundAuthorizationResponseCodes.PAID&&(await this._setPaymentResult(r.data,!0)?(this.state===i.COMMITED||this.state===i.REFUNDABLE)&&await this._saveAndEmit(i.SOFT_CLAIMED):r={code:a.RefundAuthorizationResponseCodes.PENDING,msg:""}),(r.code===a.RefundAuthorizationResponseCodes.PENDING||r.code===a.RefundAuthorizationResponseCodes.NOT_FOUND)&&await (0,o.timeoutPromise)(1e3*e,t);return r}async checkIntermediarySwapProcessed(t=!0){if(this.state===i.CREATED||this.state==i.QUOTE_EXPIRED)return!1;if(this.isFinished()||this.isRefundable())return!0;let e=await a.IntermediaryAPI.getRefundAuthorization(this.url,this.getLpIdentifier(),this.data.getSequence());switch(e.code){case a.RefundAuthorizationResponseCodes.PAID:let r=await this._setPaymentResult(e.data,!0);return r&&(this.state=i.SOFT_CLAIMED,t&&await this._saveAndEmit()),r;case a.RefundAuthorizationResponseCodes.REFUND_DATA:return await (0,o.tryWithRetries)(()=>this.wrapper.contract.isValidRefundAuthorization(this.data,e.data),null,n.SignatureVerificationError),this.state=i.REFUNDABLE,t&&await this._saveAndEmit(),!0;default:return!1}}async waitForPayment(t,e){if(this.state===i.CLAIMED)return Promise.resolve(!0);if(this.state!==i.COMMITED&&this.state!==i.SOFT_CLAIMED)throw Error("Invalid state (not COMMITED)");let r=(0,o.extendAbortController)(t),l=await Promise.race([this.waitTillState(i.CLAIMED,"gte",r.signal),this.waitTillIntermediarySwapProcessed(r.signal,e)]);if(r.abort(),"object"!=typeof l){if(this.state===i.REFUNDABLE)throw Error("Swap expired");return this.logger.debug("waitTillRefunded(): Resolved from state change"),!0}switch(this.logger.debug("waitTillRefunded(): Resolved from intermediary response"),l.code){case a.RefundAuthorizationResponseCodes.PAID:return!0;case a.RefundAuthorizationResponseCodes.REFUND_DATA:return await (0,o.tryWithRetries)(()=>this.wrapper.contract.isValidRefundAuthorization(this.data,l.data),null,n.SignatureVerificationError,t),await this._saveAndEmit(i.REFUNDABLE),!1;case a.RefundAuthorizationResponseCodes.EXPIRED:if(await this.wrapper.contract.isExpired(this._getInitiator(),this.data))throw Error("Swap expired");throw new s.IntermediaryError("Swap expired");case a.RefundAuthorizationResponseCodes.NOT_FOUND:if(this.state===i.CLAIMED)return!0;throw Error("Intermediary swap not found")}}getRefundFee(){return this.wrapper.contract.getRefundFee(this.data)}async txsRefund(t){if(!this.isRefundable())throw Error("Must be in REFUNDABLE state or expired!");if(t??=this._getInitiator(),await this.wrapper.contract.isExpired(this._getInitiator(),this.data))return await this.wrapper.contract.txsRefund(t,this.data,!0,!0);{let e=await a.IntermediaryAPI.getRefundAuthorization(this.url,this.getLpIdentifier(),this.data.getSequence());if(e.code===a.RefundAuthorizationResponseCodes.REFUND_DATA)return await this.wrapper.contract.txsRefundWithAuthorization(t,this.data,e.data,!0,!0);throw new s.IntermediaryError("Invalid intermediary cooperative message returned")}}async refund(t,e){let r=await this.wrapper.chain.sendAndConfirm(t,await this.txsRefund(t.getAddress()),!0,e);return this.refundTxId=r[0],(this.state===i.COMMITED||this.state===i.REFUNDABLE||this.state===i.SOFT_CLAIMED)&&await this._saveAndEmit(i.REFUNDED),r[0]}async waitTillRefunded(t){if(this.state===i.REFUNDED)return Promise.resolve();if(this.state!==i.COMMITED&&this.state!==i.SOFT_CLAIMED)throw Error("Invalid state (not COMMITED)");let e=new AbortController;null!=t&&t.addEventListener("abort",()=>e.abort(t.reason));let r=await Promise.race([this.watchdogWaitTillResult(e.signal),this.waitTillState(i.REFUNDED,"eq",e.signal).then(()=>0),this.waitTillState(i.CLAIMED,"eq",e.signal).then(()=>1)]);if(e.abort(),0===r)return void this.logger.debug("waitTillRefunded(): Resolved from state change (REFUNDED)");if(1===r)throw this.logger.debug("waitTillRefunded(): Resolved from state change (CLAIMED)"),Error("Tried to refund swap, but claimer claimed it in the meantime!");if(this.logger.debug("waitTillRefunded(): Resolved from watchdog"),r?.type===n.SwapCommitStateType.PAID)throw null==this.claimTxId&&(this.claimTxId=await r.getClaimTxId()),await this._saveAndEmit(i.CLAIMED),Error("Tried to refund swap, but claimer claimed it in the meantime!");r?.type===n.SwapCommitStateType.NOT_COMMITED&&(null==this.refundTxId&&null!=r.getRefundTxId&&(this.refundTxId=await r.getRefundTxId()),await this._saveAndEmit(i.REFUNDED))}serialize(){return{...super.serialize(),networkFee:null==this.networkFee?null:this.networkFee.toString(10),networkFeeBtc:null==this.networkFeeBtc?null:this.networkFeeBtc.toString(10)}}async syncStateFromChain(){if(this.state===i.CREATED||this.state===i.QUOTE_SOFT_EXPIRED||this.state===i.COMMITED||this.state===i.SOFT_CLAIMED||this.state===i.REFUNDABLE){let t=!1;(this.state===i.CREATED||this.state===i.QUOTE_SOFT_EXPIRED)&&(t=await this.verifyQuoteDefinitelyExpired());let e=await (0,o.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(e?.type){case n.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await e.getClaimTxId()),this.state=i.CLAIMED,!0;case n.SwapCommitStateType.REFUNDABLE:return this.state=i.REFUNDABLE,!0;case n.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&e.getRefundTxId&&(this.refundTxId=await e.getRefundTxId()),this.state=i.QUOTE_EXPIRED,!0;case n.SwapCommitStateType.NOT_COMMITED:if(null==this.refundTxId&&e.getRefundTxId&&(this.refundTxId=await e.getRefundTxId()),this.state===i.COMMITED||this.state===i.REFUNDABLE)return this.state=i.REFUNDED,!0;break;case n.SwapCommitStateType.COMMITED:if(this.state!==i.COMMITED&&this.state!==i.REFUNDABLE)return this.state=i.COMMITED,!0}if((this.state===i.CREATED||this.state===i.QUOTE_SOFT_EXPIRED)&&t)return this.state=i.QUOTE_EXPIRED,!0}}async _sync(t){let e=await this.syncStateFromChain();return(this.state===i.COMMITED||this.state===i.SOFT_CLAIMED)&&await this.checkIntermediarySwapProcessed(!1)&&(e=!0),t&&e&&await this._saveAndEmit(),e}async _tick(t){switch(this.state){case i.CREATED:if(this.expiry<Date.now())return this.state=i.QUOTE_SOFT_EXPIRED,t&&await this._saveAndEmit(),!0;break;case i.COMMITED:case i.SOFT_CLAIMED:if(await this.wrapper.contract.isExpired(this._getInitiator(),this.data))return this.state=i.REFUNDABLE,t&&await this._saveAndEmit(),!0}return!1}}r.IToBTCSwap=d,function(t){t[t.REFUNDED=-3]="REFUNDED",t[t.QUOTE_EXPIRED=-2]="QUOTE_EXPIRED",t[t.QUOTE_SOFT_EXPIRED=-1]="QUOTE_SOFT_EXPIRED",t[t.CREATED=0]="CREATED",t[t.COMMITED=1]="COMMITED",t[t.SOFT_CLAIMED=2]="SOFT_CLAIMED",t[t.CLAIMED=3]="CLAIMED",t[t.REFUNDABLE=4]="REFUNDABLE"}(i=r.ToBTCSwapState||(r.ToBTCSwapState={}))},144637,(t,e,r)=>{"use strict";function i(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function n(t){if("boolean"!=typeof t)throw Error(`boolean expected, not ${t}`)}function a(t){if(!Number.isSafeInteger(t)||t<0)throw Error("positive integer expected, got "+t)}function s(t,...e){if(!i(t))throw Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw Error("Uint8Array expected of length "+e+", got length="+t.length)}function o(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}Object.defineProperty(r,"__esModule",{value:!0}),r.wrapCipher=r.Hash=r.nextTick=r.isLE=void 0,r.isBytes=i,r.abool=n,r.anumber=a,r.abytes=s,r.ahash=function(t){if("function"!=typeof t||"function"!=typeof t.create)throw Error("Hash should be wrapped by utils.createHasher");a(t.outputLen),a(t.blockLen)},r.aexists=function(t,e=!0){if(t.destroyed)throw Error("Hash instance has been destroyed");if(e&&t.finished)throw Error("Hash#digest() has already been called")},r.aoutput=function(t,e){s(t);let r=e.outputLen;if(t.length<r)throw Error("digestInto() expects output buffer of length at least "+r)},r.u8=function(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)},r.u32=function(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))},r.clean=function(...t){for(let e=0;e<t.length;e++)t[e].fill(0)},r.createView=o,r.bytesToHex=c,r.hexToBytes=d,r.hexToNumber=f,r.bytesToNumberBE=function(t){return f(c(t))},r.numberToBytesBE=function(t,e){return d(t.toString(16).padStart(2*e,"0"))},r.utf8ToBytes=m,r.bytesToUtf8=function(t){return new TextDecoder().decode(t)},r.toBytes=function(t){if("string"==typeof t)t=m(t);else if(i(t))t=T(t);else throw Error("Uint8Array expected, got "+typeof t);return t},r.overlapBytes=g,r.complexOverlapBytes=function(t,e){if(g(t,e)&&t.byteOffset<e.byteOffset)throw Error("complex overlap of input and output is not supported")},r.concatBytes=function(...t){let e=0;for(let r=0;r<t.length;r++){let i=t[r];s(i),e+=i.length}let r=new Uint8Array(e);for(let e=0,i=0;e<t.length;e++){let n=t[e];r.set(n,i),i+=n.length}return r},r.checkOpts=function(t,e){if(null==e||"object"!=typeof e)throw Error("options must be defined");return Object.assign(t,e)},r.equalBytes=function(t,e){if(t.length!==e.length)return!1;let r=0;for(let i=0;i<t.length;i++)r|=t[i]^e[i];return 0===r},r.getOutput=function(t,e,r=!0){if(void 0===e)return new Uint8Array(t);if(e.length!==t)throw Error("invalid output length, expected "+t+", got: "+e.length);if(r&&!y(e))throw Error("invalid output, must be aligned");return e},r.setBigUint64=w,r.u64Lengths=function(t,e,r){n(r);let i=new Uint8Array(16),a=o(i);return w(a,0,BigInt(e),r),w(a,8,BigInt(t),r),i},r.isAligned32=y,r.copyBytes=T,r.isLE=68===new Uint8Array(new Uint32Array([0x11223344]).buffer)[0];let l="function"==typeof Uint8Array.from([]).toHex&&"function"==typeof Uint8Array.fromHex,u=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function c(t){if(s(t),l)return t.toHex();let e="";for(let r=0;r<t.length;r++)e+=u[t[r]];return e}let h={_0:48,_9:57,A:65,F:70,a:97,f:102};function p(t){return t>=h._0&&t<=h._9?t-h._0:t>=h.A&&t<=h.F?t-(h.A-10):t>=h.a&&t<=h.f?t-(h.a-10):void 0}function d(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);if(l)return Uint8Array.fromHex(t);let e=t.length,r=e/2;if(e%2)throw Error("hex string expected, got unpadded hex of length "+e);let i=new Uint8Array(r);for(let e=0,n=0;e<r;e++,n+=2){let r=p(t.charCodeAt(n)),a=p(t.charCodeAt(n+1));if(void 0===r||void 0===a)throw Error('hex string expected, got non-hex character "'+(t[n]+t[n+1])+'" at index '+n);i[e]=16*r+a}return i}function f(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return BigInt(""===t?"0":"0x"+t)}function m(t){if("string"!=typeof t)throw Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function g(t,e){return t.buffer===e.buffer&&t.byteOffset<e.byteOffset+e.byteLength&&e.byteOffset<t.byteOffset+t.byteLength}function w(t,e,r,i){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,i);let n=BigInt(32),a=BigInt(0xffffffff),s=Number(r>>n&a),o=Number(r&a),l=4*!!i,u=4*!i;t.setUint32(e+l,s,i),t.setUint32(e+u,o,i)}function y(t){return t.byteOffset%4==0}function T(t){return Uint8Array.from(t)}r.nextTick=async()=>{},r.Hash=class{},r.wrapCipher=(t,e)=>{function i(n,...a){if(s(n),!r.isLE)throw Error("Non little-endian hardware is not yet supported");if(void 0!==t.nonceLength){let e=a[0];if(!e)throw Error("nonce / iv required");t.varSizeNonce?s(e):s(e,t.nonceLength)}let o=t.tagLength;o&&void 0!==a[1]&&s(a[1]);let l=e(n,...a),u=(t,e)=>{if(void 0!==e){if(2!==t)throw Error("cipher output not supported");s(e)}},c=!1;return{encrypt(t,e){if(c)throw Error("cannot encrypt() twice with same key + nonce");return c=!0,s(t),u(l.encrypt.length,e),l.encrypt(t,e)},decrypt(t,e){if(s(t),o&&t.length<o)throw Error("invalid ciphertext length: smaller than tagLength="+o);return u(l.decrypt.length,e),l.decrypt(t,e)}}}return Object.assign(i,t),i}},613267,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.polyval=r.ghash=void 0,r._toGHASHKey=l;let i=t.r(144637),n=new Uint8Array(16),a=(0,i.u32)(n),s=(t,e,r,i)=>({s3:r<<31|i>>>1,s2:e<<31|r>>>1,s1:t<<31|e>>>1,s0:t>>>1^-0x1f000000&-(1&i&1)}),o=t=>(t>>>0&255)<<24|(t>>>8&255)<<16|(t>>>16&255)<<8|t>>>24&255;function l(t){t.reverse();let e=1&t[15],r=0;for(let e=0;e<t.length;e++){let i=t[e];t[e]=i>>>1|r,r=(1&i)<<7}return t[0]^=225&-e,t}class u{constructor(t,e){this.blockLen=16,this.outputLen=16,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,t=(0,i.toBytes)(t),(0,i.abytes)(t,16);let r=(0,i.createView)(t),n=r.getUint32(0,!1),a=r.getUint32(4,!1),l=r.getUint32(8,!1),u=r.getUint32(12,!1),c=[];for(let t=0;t<128;t++)c.push({s0:o(n),s1:o(a),s2:o(l),s3:o(u)}),{s0:n,s1:a,s2:l,s3:u}=s(n,a,l,u);let h=(t=>t>65536?8:t>1024?4:2)(e||1024);if(![1,2,4,8].includes(h))throw Error("ghash: invalid window size, expected 2, 4 or 8");this.W=h;let p=128/h,d=this.windowSize=2**h,f=[];for(let t=0;t<p;t++)for(let e=0;e<d;e++){let r=0,i=0,n=0,a=0;for(let s=0;s<h;s++){if(!(e>>>h-s-1&1))continue;let{s0:o,s1:l,s2:u,s3:p}=c[h*t+s];r^=o,i^=l,n^=u,a^=p}f.push({s0:r,s1:i,s2:n,s3:a})}this.t=f}_updateBlock(t,e,r,i){t^=this.s0,e^=this.s1,r^=this.s2,i^=this.s3;let{W:n,t:a,windowSize:s}=this,o=0,l=0,u=0,c=0,h=(1<<n)-1,p=0;for(let d of[t,e,r,i])for(let t=0;t<4;t++){let e=d>>>8*t&255;for(let t=8/n-1;t>=0;t--){let{s0:r,s1:i,s2:d,s3:f}=a[p*s+(e>>>n*t&h)];o^=r,l^=i,u^=d,c^=f,p+=1}}this.s0=o,this.s1=l,this.s2=u,this.s3=c}update(t){(0,i.aexists)(this),t=(0,i.toBytes)(t),(0,i.abytes)(t);let e=(0,i.u32)(t),r=Math.floor(t.length/16),s=t.length%16;for(let t=0;t<r;t++)this._updateBlock(e[4*t+0],e[4*t+1],e[4*t+2],e[4*t+3]);return s&&(n.set(t.subarray(16*r)),this._updateBlock(a[0],a[1],a[2],a[3]),(0,i.clean)(a)),this}destroy(){let{t}=this;for(let e of t)e.s0=0,e.s1=0,e.s2=0,e.s3=0}digestInto(t){(0,i.aexists)(this),(0,i.aoutput)(t,this),this.finished=!0;let{s0:e,s1:r,s2:n,s3:a}=this,s=(0,i.u32)(t);return s[0]=e,s[1]=r,s[2]=n,s[3]=a,t}digest(){let t=new Uint8Array(16);return this.digestInto(t),this.destroy(),t}}class c extends u{constructor(t,e){t=(0,i.toBytes)(t),(0,i.abytes)(t);let r=l((0,i.copyBytes)(t));super(r,e),(0,i.clean)(r)}update(t){t=(0,i.toBytes)(t),(0,i.aexists)(this);let e=(0,i.u32)(t),r=t.length%16,s=Math.floor(t.length/16);for(let t=0;t<s;t++)this._updateBlock(o(e[4*t+3]),o(e[4*t+2]),o(e[4*t+1]),o(e[4*t+0]));return r&&(n.set(t.subarray(16*s)),this._updateBlock(o(a[3]),o(a[2]),o(a[1]),o(a[0])),(0,i.clean)(a)),this}digestInto(t){(0,i.aexists)(this),(0,i.aoutput)(t,this),this.finished=!0;let{s0:e,s1:r,s2:n,s3:a}=this,s=(0,i.u32)(t);return s[0]=e,s[1]=r,s[2]=n,s[3]=a,t.reverse()}}function h(t){let e=(e,r)=>t(r,e.length).update((0,i.toBytes)(e)).digest(),r=t(new Uint8Array(16),0);return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=(e,r)=>t(e,r),e}r.ghash=h((t,e)=>new u(t,e)),r.polyval=h((t,e)=>new c(t,e))},328906,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.unsafe=r.aeskwp=r.aeskw=r.siv=r.gcmsiv=r.gcm=r.cfb=r.cbc=r.ecb=r.ctr=void 0;let i=t.r(613267),n=t.r(144637),a=new Uint8Array(16);function s(t){return t<<1^283&-(t>>7)}function o(t,e){let r=0;for(;e>0;e>>=1)r^=t&-(1&e),t=s(t);return r}let l=(()=>{let t=new Uint8Array(256);for(let e=0,r=1;e<256;e++,r^=s(r))t[e]=r;let e=new Uint8Array(256);e[0]=99;for(let r=0;r<255;r++){let i=t[255-r];i|=i<<8,e[t[r]]=(i^i>>4^i>>5^i>>6^i>>7^99)&255}return(0,n.clean)(t),e})(),u=l.map((t,e)=>l.indexOf(e)),c=t=>t<<24|t>>>8,h=t=>t<<8|t>>>24,p=t=>t<<24&0xff000000|t<<8&0xff0000|t>>>8&65280|t>>>24&255;function d(t,e){if(256!==t.length)throw Error("Wrong sbox length");let r=new Uint32Array(256).map((r,i)=>e(t[i])),i=r.map(h),n=i.map(h),a=n.map(h),s=new Uint32Array(65536),o=new Uint32Array(65536),l=new Uint16Array(65536);for(let e=0;e<256;e++)for(let u=0;u<256;u++){let c=256*e+u;s[c]=r[e]^i[u],o[c]=n[e]^a[u],l[c]=t[e]<<8|t[u]}return{sbox:t,sbox2:l,T0:r,T1:i,T2:n,T3:a,T01:s,T23:o}}let f=d(l,t=>o(t,3)<<24|t<<16|t<<8|o(t,2)),m=d(u,t=>o(t,11)<<24|o(t,13)<<16|o(t,9)<<8|o(t,14)),g=(()=>{let t=new Uint8Array(16);for(let e=0,r=1;e<16;e++,r=s(r))t[e]=r;return t})();function w(t){(0,n.abytes)(t);let e=t.length;if(![16,24,32].includes(e))throw Error("aes: invalid key size, should be 16, 24 or 32, got "+e);let{sbox2:r}=f,i=[];(0,n.isAligned32)(t)||i.push(t=(0,n.copyBytes)(t));let a=(0,n.u32)(t),s=a.length,o=t=>S(r,t,t,t,t),l=new Uint32Array(e+28);l.set(a);for(let t=s;t<l.length;t++){let e=l[t-1];t%s==0?e=o(c(e))^g[t/s-1]:s>6&&t%s==4&&(e=o(e)),l[t]=l[t-s]^e}return(0,n.clean)(...i),l}function y(t){let e=w(t),r=e.slice(),i=e.length,{sbox2:a}=f,{T0:s,T1:o,T2:l,T3:u}=m;for(let t=0;t<i;t+=4)for(let n=0;n<4;n++)r[t+n]=e[i-t-4+n];(0,n.clean)(e);for(let t=4;t<i-4;t++){let e=r[t],i=S(a,e,e,e,e);r[t]=s[255&i]^o[i>>>8&255]^l[i>>>16&255]^u[i>>>24]}return r}function T(t,e,r,i,n,a){return t[r<<8&65280|i>>>8&255]^e[n>>>8&65280|a>>>24&255]}function S(t,e,r,i,n){return t[255&e|65280&r]|t[i>>>16&255|n>>>16&65280]<<16}function E(t,e,r,i,n){let{sbox2:a,T01:s,T23:o}=f,l=0;e^=t[l++],r^=t[l++],i^=t[l++],n^=t[l++];let u=t.length/4-2;for(let a=0;a<u;a++){let a=t[l++]^T(s,o,e,r,i,n),u=t[l++]^T(s,o,r,i,n,e),c=t[l++]^T(s,o,i,n,e,r),h=t[l++]^T(s,o,n,e,r,i);e=a,r=u,i=c,n=h}let c=t[l++]^S(a,e,r,i,n),h=t[l++]^S(a,r,i,n,e);return{s0:c,s1:h,s2:t[l++]^S(a,i,n,e,r),s3:t[l++]^S(a,n,e,r,i)}}function I(t,e,r,i,n){let{sbox2:a,T01:s,T23:o}=m,l=0;e^=t[l++],r^=t[l++],i^=t[l++],n^=t[l++];let u=t.length/4-2;for(let a=0;a<u;a++){let a=t[l++]^T(s,o,e,n,i,r),u=t[l++]^T(s,o,r,e,n,i),c=t[l++]^T(s,o,i,r,e,n),h=t[l++]^T(s,o,n,i,r,e);e=a,r=u,i=c,n=h}let c=t[l++]^S(a,e,n,i,r),h=t[l++]^S(a,r,e,n,i);return{s0:c,s1:h,s2:t[l++]^S(a,i,r,e,n),s3:t[l++]^S(a,n,i,r,e)}}function b(t,e,r,i){(0,n.abytes)(e,16),(0,n.abytes)(r);let a=r.length;i=(0,n.getOutput)(a,i),(0,n.complexOverlapBytes)(r,i);let s=(0,n.u32)(e),{s0:o,s1:l,s2:u,s3:c}=E(t,s[0],s[1],s[2],s[3]),h=(0,n.u32)(r),p=(0,n.u32)(i);for(let r=0;r+4<=h.length;r+=4){p[r+0]=h[r+0]^o,p[r+1]=h[r+1]^l,p[r+2]=h[r+2]^u,p[r+3]=h[r+3]^c;let i=1;for(let t=e.length-1;t>=0;t--)i=i+(255&e[t])|0,e[t]=255&i,i>>>=8;({s0:o,s1:l,s2:u,s3:c}=E(t,s[0],s[1],s[2],s[3]))}let d=16*Math.floor(h.length/4);if(d<a){let t=new Uint32Array([o,l,u,c]),e=(0,n.u8)(t);for(let t=d,n=0;t<a;t++,n++)i[t]=r[t]^e[n];(0,n.clean)(t)}return i}function v(t,e,r,i,a){(0,n.abytes)(r,16),(0,n.abytes)(i),a=(0,n.getOutput)(i.length,a);let s=(0,n.u32)(r),o=(0,n.createView)(r),l=(0,n.u32)(i),u=(0,n.u32)(a),c=12*!e,h=i.length,p=o.getUint32(c,e),{s0:d,s1:f,s2:m,s3:g}=E(t,s[0],s[1],s[2],s[3]);for(let r=0;r+4<=l.length;r+=4)u[r+0]=l[r+0]^d,u[r+1]=l[r+1]^f,u[r+2]=l[r+2]^m,u[r+3]=l[r+3]^g,p=p+1>>>0,o.setUint32(c,p,e),{s0:d,s1:f,s2:m,s3:g}=E(t,s[0],s[1],s[2],s[3]);let w=16*Math.floor(l.length/4);if(w<h){let t=new Uint32Array([d,f,m,g]),e=(0,n.u8)(t);for(let t=w,r=0;t<h;t++,r++)a[t]=i[t]^e[r];(0,n.clean)(t)}return a}function B(t){if((0,n.abytes)(t),t.length%16!=0)throw Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size 16")}function A(t,e,r){(0,n.abytes)(t);let i=t.length,a=i%16;if(!e&&0!==a)throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");(0,n.isAligned32)(t)||(t=(0,n.copyBytes)(t));let s=(0,n.u32)(t);if(e){let t=16-a;t||(t=16),i+=t}return r=(0,n.getOutput)(i,r),(0,n.complexOverlapBytes)(t,r),{b:s,o:(0,n.u32)(r),out:r}}function R(t,e){if(!e)return t;let r=t.length;if(!r)throw Error("aes/pcks5: empty ciphertext not allowed");let i=t[r-1];if(i<=0||i>16)throw Error("aes/pcks5: wrong padding");let n=t.subarray(0,-i);for(let e=0;e<i;e++)if(t[r-e-1]!==i)throw Error("aes/pcks5: wrong padding");return n}function C(t){let e=new Uint8Array(16),r=(0,n.u32)(e);e.set(t);let i=16-t.length;for(let t=16-i;t<16;t++)e[t]=i;return r}function _(t,e,r,i,a){let s=a?a.length:0,o=t.create(r,i.length+s);a&&o.update(a);let l=(0,n.u64Lengths)(8*i.length,8*s,e);o.update(i),o.update(l);let u=o.digest();return(0,n.clean)(l),u}r.ctr=(0,n.wrapCipher)({blockSize:16,nonceLength:16},function(t,e){function r(r,i){if((0,n.abytes)(r),void 0!==i&&((0,n.abytes)(i),!(0,n.isAligned32)(i)))throw Error("unaligned destination");let a=w(t),s=(0,n.copyBytes)(e),o=[a,s];(0,n.isAligned32)(r)||o.push(r=(0,n.copyBytes)(r));let l=b(a,s,r,i);return(0,n.clean)(...o),l}return{encrypt:(t,e)=>r(t,e),decrypt:(t,e)=>r(t,e)}}),r.ecb=(0,n.wrapCipher)({blockSize:16},function(t,e={}){let r=!e.disablePadding;return{encrypt(e,i){let{b:a,o:s,out:o}=A(e,r,i),l=w(t),u=0;for(;u+4<=a.length;){let{s0:t,s1:e,s2:r,s3:i}=E(l,a[u+0],a[u+1],a[u+2],a[u+3]);s[u++]=t,s[u++]=e,s[u++]=r,s[u++]=i}if(r){let t=C(e.subarray(4*u)),{s0:r,s1:i,s2:n,s3:a}=E(l,t[0],t[1],t[2],t[3]);s[u++]=r,s[u++]=i,s[u++]=n,s[u++]=a}return(0,n.clean)(l),o},decrypt(e,i){B(e);let a=y(t);i=(0,n.getOutput)(e.length,i);let s=[a];(0,n.isAligned32)(e)||s.push(e=(0,n.copyBytes)(e)),(0,n.complexOverlapBytes)(e,i);let o=(0,n.u32)(e),l=(0,n.u32)(i);for(let t=0;t+4<=o.length;){let{s0:e,s1:r,s2:i,s3:n}=I(a,o[t+0],o[t+1],o[t+2],o[t+3]);l[t++]=e,l[t++]=r,l[t++]=i,l[t++]=n}return(0,n.clean)(...s),R(i,r)}}}),r.cbc=(0,n.wrapCipher)({blockSize:16,nonceLength:16},function(t,e,r={}){let i=!r.disablePadding;return{encrypt(r,a){let s=w(t),{b:o,o:l,out:u}=A(r,i,a),c=e,h=[s];(0,n.isAligned32)(c)||h.push(c=(0,n.copyBytes)(c));let p=(0,n.u32)(c),d=p[0],f=p[1],m=p[2],g=p[3],y=0;for(;y+4<=o.length;)d^=o[y+0],f^=o[y+1],m^=o[y+2],g^=o[y+3],({s0:d,s1:f,s2:m,s3:g}=E(s,d,f,m,g)),l[y++]=d,l[y++]=f,l[y++]=m,l[y++]=g;if(i){let t=C(r.subarray(4*y));d^=t[0],f^=t[1],m^=t[2],g^=t[3],({s0:d,s1:f,s2:m,s3:g}=E(s,d,f,m,g)),l[y++]=d,l[y++]=f,l[y++]=m,l[y++]=g}return(0,n.clean)(...h),u},decrypt(r,a){B(r);let s=y(t),o=e,l=[s];(0,n.isAligned32)(o)||l.push(o=(0,n.copyBytes)(o));let u=(0,n.u32)(o);a=(0,n.getOutput)(r.length,a),(0,n.isAligned32)(r)||l.push(r=(0,n.copyBytes)(r)),(0,n.complexOverlapBytes)(r,a);let c=(0,n.u32)(r),h=(0,n.u32)(a),p=u[0],d=u[1],f=u[2],m=u[3];for(let t=0;t+4<=c.length;){let e=p,r=d,i=f,n=m;p=c[t+0],d=c[t+1];let{s0:a,s1:o,s2:l,s3:u}=I(s,p,d,f=c[t+2],m=c[t+3]);h[t++]=a^e,h[t++]=o^r,h[t++]=l^i,h[t++]=u^n}return(0,n.clean)(...l),R(a,i)}}}),r.cfb=(0,n.wrapCipher)({blockSize:16,nonceLength:16},function(t,e){function r(r,i,a){(0,n.abytes)(r);let s=r.length;if(a=(0,n.getOutput)(s,a),(0,n.overlapBytes)(r,a))throw Error("overlapping src and dst not supported.");let o=w(t),l=e,u=[o];(0,n.isAligned32)(l)||u.push(l=(0,n.copyBytes)(l)),(0,n.isAligned32)(r)||u.push(r=(0,n.copyBytes)(r));let c=(0,n.u32)(r),h=(0,n.u32)(a),p=i?h:c,d=(0,n.u32)(l),f=d[0],m=d[1],g=d[2],y=d[3];for(let t=0;t+4<=c.length;){let{s0:e,s1:r,s2:i,s3:n}=E(o,f,m,g,y);h[t+0]=c[t+0]^e,h[t+1]=c[t+1]^r,h[t+2]=c[t+2]^i,h[t+3]=c[t+3]^n,f=p[t++],m=p[t++],g=p[t++],y=p[t++]}let T=16*Math.floor(c.length/4);if(T<s){({s0:f,s1:m,s2:g,s3:y}=E(o,f,m,g,y));let t=(0,n.u8)(new Uint32Array([f,m,g,y]));for(let e=T,i=0;e<s;e++,i++)a[e]=r[e]^t[i];(0,n.clean)(t)}return(0,n.clean)(...u),a}return{encrypt:(t,e)=>r(t,!0,e),decrypt:(t,e)=>r(t,!1,e)}}),r.gcm=(0,n.wrapCipher)({blockSize:16,nonceLength:12,tagLength:16,varSizeNonce:!0},function(t,e,r){if(e.length<8)throw Error("aes/gcm: invalid nonce length");function s(t,e,n){let a=_(i.ghash,!1,t,n,r);for(let t=0;t<e.length;t++)a[t]^=e[t];return a}function o(){let r=w(t),s=a.slice(),o=a.slice();if(v(r,!1,o,o,s),12===e.length)o.set(e);else{let t=a.slice(),r=(0,n.createView)(t);(0,n.setBigUint64)(r,8,BigInt(8*e.length),!1);let l=i.ghash.create(s).update(e).update(t);l.digestInto(o),l.destroy()}let l=v(r,!1,o,a);return{xk:r,authKey:s,counter:o,tagMask:l}}return{encrypt(t){let{xk:e,authKey:r,counter:i,tagMask:a}=o(),l=new Uint8Array(t.length+16),u=[e,r,i,a];(0,n.isAligned32)(t)||u.push(t=(0,n.copyBytes)(t)),v(e,!1,i,t,l.subarray(0,t.length));let c=s(r,a,l.subarray(0,l.length-16));return u.push(c),l.set(c,t.length),(0,n.clean)(...u),l},decrypt(t){let{xk:e,authKey:r,counter:i,tagMask:a}=o(),l=[e,r,a,i];(0,n.isAligned32)(t)||l.push(t=(0,n.copyBytes)(t));let u=t.subarray(0,-16),c=t.subarray(-16),h=s(r,a,u);if(l.push(h),!(0,n.equalBytes)(h,c))throw Error("aes/gcm: invalid ghash tag");let p=v(e,!1,i,u);return(0,n.clean)(...l),p}}});let F=(t,e,r)=>i=>{if(!Number.isSafeInteger(i)||e>i||i>r)throw Error(""+t+": expected value in range "+("["+e+"..")+r+"], got "+i)};function P(t){return t instanceof Uint32Array||ArrayBuffer.isView(t)&&"Uint32Array"===t.constructor.name}function x(t,e){if((0,n.abytes)(e,16),!P(t))throw Error("_encryptBlock accepts result of expandKeyLE");let r=(0,n.u32)(e),{s0:i,s1:a,s2:s,s3:o}=E(t,r[0],r[1],r[2],r[3]);return r[0]=i,r[1]=a,r[2]=s,r[3]=o,e}function D(t,e){if((0,n.abytes)(e,16),!P(t))throw Error("_decryptBlock accepts result of expandKeyLE");let r=(0,n.u32)(e),{s0:i,s1:a,s2:s,s3:o}=I(t,r[0],r[1],r[2],r[3]);return r[0]=i,r[1]=a,r[2]=s,r[3]=o,e}r.gcmsiv=(0,n.wrapCipher)({blockSize:16,nonceLength:12,tagLength:16,varSizeNonce:!0},function(t,e,r){let a=F("AAD",0,0x1000000000),s=F("plaintext",0,0x1000000000),o=F("nonce",12,12),l=F("ciphertext",16,0x1000000000+16);function u(){let r=w(t),i=new Uint8Array(t.length),a=new Uint8Array(16),s=[r,i],o=e;(0,n.isAligned32)(o)||s.push(o=(0,n.copyBytes)(o));let l=(0,n.u32)(o),u=0,c=l[0],h=l[1],p=l[2],d=0;for(let t of[a,i].map(n.u32)){let e=(0,n.u32)(t);for(let t=0;t<e.length;t+=2){let{s0:i,s1:n}=E(r,u,c,h,p);e[t+0]=i,e[t+1]=n,u=++d}}let f={authKey:a,encKey:w(i)};return(0,n.clean)(...s),f}function c(t,a,s){let o=_(i.polyval,!0,a,s,r);for(let t=0;t<12;t++)o[t]^=e[t];o[15]&=127;let l=(0,n.u32)(o),u=l[0],c=l[1],h=l[2],p=l[3];return{s0:u,s1:c,s2:h,s3:p}=E(t,u,c,h,p),l[0]=u,l[1]=c,l[2]=h,l[3]=p,o}function h(t,e,r){let i=(0,n.copyBytes)(e);i[15]|=128;let a=v(t,!0,i,r);return(0,n.clean)(i),a}return(0,n.abytes)(t,16,24,32),o(e.length),void 0!==r&&a(r.length),{encrypt(t){s(t.length);let{encKey:e,authKey:r}=u(),i=c(e,r,t),a=[e,r,i];(0,n.isAligned32)(t)||a.push(t=(0,n.copyBytes)(t));let o=new Uint8Array(t.length+16);return o.set(i,t.length),o.set(h(e,i,t)),(0,n.clean)(...a),o},decrypt(t){l(t.length);let e=t.subarray(-16),{encKey:r,authKey:i}=u(),a=[r,i];(0,n.isAligned32)(t)||a.push(t=(0,n.copyBytes)(t));let s=h(r,e,t.subarray(0,-16)),o=c(r,i,s);if(a.push(o),!(0,n.equalBytes)(e,o))throw(0,n.clean)(...a),Error("invalid polyval tag");return(0,n.clean)(...a),s}}}),r.siv=r.gcmsiv;let k={encrypt(t,e){if(e.length>=0x100000000)throw Error("plaintext should be less than 4gb");let r=w(t);if(16===e.length)x(r,e);else{let t=(0,n.u32)(e),i=t[0],a=t[1];for(let e=0,n=1;e<6;e++)for(let e=2;e<t.length;e+=2,n++){let{s0:s,s1:o,s2:l,s3:u}=E(r,i,a,t[e],t[e+1]);i=s,a=o^p(n),t[e]=l,t[e+1]=u}t[0]=i,t[1]=a}r.fill(0)},decrypt(t,e){if(e.length-8>=0x100000000)throw Error("ciphertext should be less than 4gb");let r=y(t),i=e.length/8-1;if(1===i)D(r,e);else{let t=(0,n.u32)(e),a=t[0],s=t[1];for(let e=0,n=6*i;e<6;e++)for(let e=2*i;e>=1;e-=2,n--){let{s0:i,s1:o,s2:l,s3:u}=I(r,a,s^=p(n),t[e],t[e+1]);a=i,s=o,t[e]=l,t[e+1]=u}t[0]=a,t[1]=s}r.fill(0)}},O=new Uint8Array(8).fill(166);r.aeskw=(0,n.wrapCipher)({blockSize:8},t=>({encrypt(e){if(!e.length||e.length%8!=0)throw Error("invalid plaintext length");if(8===e.length)throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");let r=(0,n.concatBytes)(O,e);return k.encrypt(t,r),r},decrypt(e){if(e.length%8!=0||e.length<24)throw Error("invalid ciphertext length");let r=(0,n.copyBytes)(e);if(k.decrypt(t,r),!(0,n.equalBytes)(r.subarray(0,8),O))throw Error("integrity check failed");return r.subarray(0,8).fill(0),r.subarray(8)}})),r.aeskwp=(0,n.wrapCipher)({blockSize:8},t=>({encrypt(e){if(!e.length)throw Error("invalid plaintext length");let r=new Uint8Array(8+8*Math.ceil(e.length/8));r.set(e,8);let i=(0,n.u32)(r);return i[0]=0xa65959a6,i[1]=p(e.length),k.encrypt(t,r),r},decrypt(e){if(e.length<16)throw Error("invalid ciphertext length");let r=(0,n.copyBytes)(e),i=(0,n.u32)(r);k.decrypt(t,r);let a=p(i[1])>>>0,s=8*Math.ceil(a/8);if(0xa65959a6!==i[0]||r.length-8!==s)throw Error("integrity check failed");for(let t=a;t<s;t++)if(0!==r[8+t])throw Error("integrity check failed");return r.subarray(0,8).fill(0),r.subarray(8,8+a)}})),r.unsafe={expandKeyLE:w,expandKeyDecLE:y,encrypt:E,decrypt:I,encryptBlock:x,decryptBlock:D,ctrCounter:b,ctr32:v}},245282,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.LNURL=r.MAIL_REGEX=r.BASE64_REGEX=r.isLNURLPaySuccessAction=r.isLNURLPayResult=r.isLNURLWithdrawParams=r.isLNURLPayParams=r.isLNURLError=r.isLNURLWithdraw=r.isLNURLPay=void 0;let i=t.r(742396),n=t.r(916232),a=t.r(223682),s=t.r(389215),o=t.r(942340),l=t.r(328906),u=t.r(500874),c=t.r(1083);function h(t){return"ERROR"===t.status&&(null==t.reason||"string"==typeof t.reason)}function p(t){return"payRequest"===t.tag}function d(t){return"withdrawRequest"===t.tag}function f(t,e){return"string"==typeof t.pr&&(null==t.routes||Array.isArray(t.routes))&&(null===t.disposable||void 0===t.disposable||"boolean"==typeof t.disposable)&&(null==t.successAction||m(t.successAction,e))}function m(t,e){if(null==t||"object"!=typeof t||"string"!=typeof t.tag)return!1;switch(t.tag){case"message":return null!=t.message&&t.message.length<=144;case"url":return null!=t.description&&t.description.length<=144&&null!=t.url&&(null==e||new URL(t.url).hostname===e);case"aes":return null!=t.description&&t.description.length<=144&&null!=t.ciphertext&&t.ciphertext.length<=4096&&r.BASE64_REGEX.test(t.ciphertext)&&null!=t.iv&&t.iv.length<=24&&r.BASE64_REGEX.test(t.iv);default:return!1}}r.isLNURLPay=function(t){return"object"==typeof t&&null!=t&&"pay"===t.type&&"bigint"==typeof t.min&&"bigint"==typeof t.max&&"number"==typeof t.commentMaxLength&&"string"==typeof t.shortDescription&&(void 0===t.longDescription||"string"==typeof t.longDescription)&&(void 0===t.icon||"string"==typeof t.icon)&&p(t.params)},r.isLNURLWithdraw=function(t){return"object"==typeof t&&null!=t&&"withdraw"===t.type&&"bigint"==typeof t.min&&"bigint"==typeof t.max&&d(t.params)},r.isLNURLError=h,r.isLNURLPayParams=p,r.isLNURLWithdrawParams=d,r.isLNURLPayResult=f,r.isLNURLPaySuccessAction=m,r.BASE64_REGEX=/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/,r.MAIL_REGEX=/(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[A-z0-9](?:[A-z0-9-]*[A-z0-9])?\.)+[A-z0-9](?:[A-z0-9-]*[A-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[A-z0-9-]*[A-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/;class g{static findBech32LNURL(t){let e=/,*?((lnurl)([0-9]{1,}[a-z0-9]+){1})/.exec(t.toLowerCase());return null==e?null:e[1]}static isBech32LNURL(t){return null!=this.findBech32LNURL(t)}static isBareLNURL(t){try{return t.startsWith("lnurlw://")||t.startsWith("lnurlp://")}catch(t){}return!1}static isLightningAddress(t){return r.MAIL_REGEX.test(t)}static isLNURL(t){return g.isBech32LNURL(t)||g.isLightningAddress(t)||g.isBareLNURL(t)}static extractCallUrl(t){if(r.MAIL_REGEX.test(t)){let e=t.split("@"),r=e[0],i=e[1],n="https";return i.endsWith(".onion")&&(n="http"),n+"://"+i+"/.well-known/lnurlp/"+r}if(g.isBareLNURL(t)){let e=t.substring(9),r=new URL("http://"+e),i="https";return r.hostname.endsWith(".onion")&&(i="http"),i+"://"+e}{let e=g.findBech32LNURL(t);if(null!=e){let{prefix:t,words:r}=o.bech32.decode(e,2e3),i=o.bech32.fromWords(r);return u.Buffer.from(i).toString()}}return null}static async getLNURL(t,e=!0,r,n){null==e&&(e=!0);let a=g.extractCallUrl(t);if(null!=a){let o=()=>(0,s.httpGet)(a,r,n,!0),l=e?await (0,s.tryWithRetries)(o,null,i.RequestError,n):await o();if(h(l))return null;if("payRequest"===l.tag)try{l.decodedMetadata=JSON.parse(l.metadata)}catch(t){l.decodedMetadata=[]}return p(l)||d(l)?{...l,url:t}:null}}static async getLNURLType(t,e,r,i){let n=await g.getLNURL(t,e,r,i);if("payRequest"===n.tag){let t,e,r;return n.decodedMetadata.forEach(i=>{switch(i[0]){case"text/plain":t=i[1];break;case"text/long-desc":e=i[1];break;case"image/png;base64":case"image/jpeg;base64":r="data:"+i[0]+","+i[1]}}),{type:"pay",min:BigInt(n.minSendable)/1000n,max:BigInt(n.maxSendable)/1000n,commentMaxLength:n.commentAllowed||0,shortDescription:t,longDescription:e,icon:r,params:n}}return"withdrawRequest"===n.tag?{type:"withdraw",min:BigInt(n.minWithdrawable)/1000n,max:BigInt(n.maxWithdrawable)/1000n,params:n}:null}static async useLNURLPay(t,e,r,a,o){let l=["amount="+(1000n*e).toString(10)];null!=r&&l.push("comment="+encodeURIComponent(r));let p=(t.callback.includes("?")?"&":"?")+l.join("&"),d=await (0,s.tryWithRetries)(()=>(0,s.httpGet)(t.callback+p,a,o,!0),null,i.RequestError,o);if(h(d))throw new i.RequestError("LNURL callback error: "+d.reason,200);if(!f(d))throw new i.RequestError("Invalid LNURL response!",200);let m=(0,n.decode)(d.pr),g=u.Buffer.from((0,c.sha256)(t.metadata)).toString("hex");if(m.tagsObject.purpose_commit_hash!==g)throw new i.RequestError("Invalid invoice received (description hash)!",200);if(BigInt(m.millisatoshis)!==1000n*e)throw new i.RequestError("Invalid invoice received (amount)!",200);return{invoice:d.pr,parsedInvoice:m,successAction:d.successAction}}static async postInvoiceToLNURLWithdraw(t,e){let r=["pr="+e,"k1="+t.k1],n=(t.callback.includes("?")?"&":"?")+r.join("&"),a=await (0,s.tryWithRetries)(()=>(0,s.httpGet)(t.callback+n,null,null,!0),null,i.RequestError);if(h(a))throw new i.RequestError("LNURL callback error: "+a.reason,200)}static async useLNURLWithdraw(t,e){let r=BigInt(t.minWithdrawable)/1000n,i=BigInt(t.maxWithdrawable)/1000n,s=(BigInt((0,n.decode)(e).millisatoshis)+999n)/1000n;if(s<r)throw new a.UserError("Invoice amount less than minimum LNURL-withdraw limit");if(s>i)throw new a.UserError("Invoice amount more than maximum LNURL-withdraw limit");return await g.postInvoiceToLNURLWithdraw(t,e)}static decodeSuccessAction(t,e){if(null==e)return null;if("message"===t.tag)return{description:t.message};if("url"===t.tag)return{description:t.description,url:t.url};if("aes"===t.tag){let r=(0,l.cbc)(u.Buffer.from(e,"hex"),u.Buffer.from(t.iv,"hex")).decrypt(u.Buffer.from(t.ciphertext,"base64")),i=r.length,n=r[i-1];return{description:t.description,text:u.Buffer.from(r).toString("utf8",0,i-n)}}}}r.LNURL=g},66448,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ToBTCLNSwap=r.isToBTCLNSwapInit=void 0;let i=t.r(916232),n=t.r(582992),a=t.r(853312),s=t.r(500874),o=t.r(1083),l=t.r(46575),u=t.r(245282),c=t.r(844485),h=t.r(389215);function p(t){return"number"==typeof t.confidence&&"string"==typeof t.pr&&(null==t.lnurl||"string"==typeof t.lnurl)&&(null==t.successAction||(0,u.isLNURLPaySuccessAction)(t.successAction))&&(0,n.isIToBTCSwapInit)(t)}r.isToBTCLNSwapInit=p;let d=new Set(["038f8f113c580048d847d6949371726653e02b928196bad310e3eda39ff61723f6","03a6ce61fcaacd38d31d4e3ce2d506602818e3856b4b44faff1dde9642ba705976"]);class f extends n.IToBTCSwap{constructor(t,e){p(e)&&(e.url+="/tobtcln"),super(t,e),this.outputToken=c.BitcoinTokens.BTCLN,this.TYPE=a.SwapType.TO_BTCLN,p(e)||(this.confidence=e.confidence,this.pr=e.pr,this.lnurl=e.lnurl,this.successAction=e.successAction,this.secret=e.secret),this.paymentHash=this.getPaymentHash().toString("hex"),this.logger=(0,h.getLogger)("ToBTCLN("+this.getIdentifierHashString()+"): "),this.tryRecomputeSwapPrice()}_setPaymentResult(t,e=!1){if(null==t)return Promise.resolve(!1);if(null==t.secret)throw new l.IntermediaryError("No payment secret returned!");if(e){let e=s.Buffer.from(t.secret,"hex");if(!s.Buffer.from((0,o.sha256)(e)).equals(this.getPaymentHash()))throw new l.IntermediaryError("Invalid payment secret returned")}return this.secret=t.secret,Promise.resolve(!0)}getOutput(){let t=(BigInt((0,i.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,c.toTokenAmount)(t,this.outputToken,this.wrapper.prices)}getOutputTxId(){return this.getLpIdentifier()}getOutputAddress(){return this.lnurl??this.pr}getSecret(){return this.secret}getConfidence(){return this.confidence}willLikelyFail(){let t=(0,i.decode)(this.pr);if(null!=t.tagsObject.routing_info){for(let e of t.tagsObject.routing_info)if(d.has(e.pubkey))return!1}return 0===this.confidence}isPayingToNonCustodialWallet(){let t=(0,i.decode)(this.pr);return null!=t.tagsObject.routing_info&&t.tagsObject.routing_info.length>0}getIdentifierHash(){let t=this.getPaymentHash();return null==this.randomNonce?t:s.Buffer.concat([t,s.Buffer.from(this.randomNonce,"hex")])}getPaymentHash(){if(null==this.pr)return null;let t=(0,i.decode)(this.pr);return s.Buffer.from(t.tagsObject.payment_hash,"hex")}getLpIdentifier(){return null==this.pr?null:(0,i.decode)(this.pr).tagsObject.payment_hash}isLNURL(){return null!=this.lnurl}getLNURL(){return this.lnurl}hasSuccessAction(){return null!=this.successAction}getSuccessAction(){return u.LNURL.decodeSuccessAction(this.successAction,this.secret)}serialize(){return{...super.serialize(),paymentHash:this.getPaymentHash().toString("hex"),pr:this.pr,confidence:this.confidence,secret:this.secret,lnurl:this.lnurl,successAction:this.successAction}}}r.ToBTCLNSwap=f},498372,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IEscrowSwapWrapper=void 0;let i=t.r(934867),n=t.r(154585),a=t.r(389215);class s extends i.ISwapWrapper{constructor(t,e,r,i,n,a,s,o,l,u){super(t,e,r,i,a,s,l,u),this.swapDataDeserializer=o,this.contract=n}preFetchSignData(t){return null==this.contract.preFetchForInitSignatureVerification?Promise.resolve(null):t.then(t=>null==t?null:this.contract.preFetchForInitSignatureVerification(t)).catch(t=>(this.logger.error("preFetchSignData(): Error: ",t),null))}async verifyReturnedSignature(t,e,r,i,s,o){let[l,u]=await Promise.all([i,s]);return await (0,a.tryWithRetries)(()=>this.contract.isValidInitAuthorization(t,e,r,l,u),null,n.SignatureVerificationError,o),await (0,a.tryWithRetries)(()=>this.contract.getInitAuthorizationExpiry(e,r,u),null,n.SignatureVerificationError,o)}async processEvent(t,e){if(null==e)return;let r=!1;return t instanceof n.InitializeEvent&&(r=await this.processEventInitialize(e,t),t.meta?.txId!=null&&e.commitTxId!==t.meta.txId&&(e.commitTxId=t.meta.txId,r||=!0)),t instanceof n.ClaimEvent&&(r=await this.processEventClaim(e,t),t.meta?.txId!=null&&e.claimTxId!==t.meta.txId&&(e.claimTxId=t.meta.txId,r||=!0)),t instanceof n.RefundEvent&&(r=await this.processEventRefund(e,t),t.meta?.txId!=null&&e.refundTxId!==t.meta.txId&&(e.refundTxId=t.meta.txId,r||=!0)),this.logger.info("processEvents(): "+t.constructor.name+" processed for "+e.getId()+" swap: ",e),r&&await e._saveAndEmit(),!0}}r.IEscrowSwapWrapper=s},157333,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IToBTCWrapper=void 0;let i=t.r(582992),n=t.r(389215),a=t.r(46575),s=t.r(498372);class o extends s.IEscrowSwapWrapper{constructor(){super(...arguments),this.pendingSwapStates=[i.ToBTCSwapState.CREATED,i.ToBTCSwapState.QUOTE_SOFT_EXPIRED,i.ToBTCSwapState.COMMITED,i.ToBTCSwapState.SOFT_CLAIMED,i.ToBTCSwapState.REFUNDABLE],this.tickSwapState=[i.ToBTCSwapState.CREATED,i.ToBTCSwapState.COMMITED,i.ToBTCSwapState.SOFT_CLAIMED],this.refundableSwapStates=[i.ToBTCSwapState.REFUNDABLE]}preFetchIntermediaryReputation(t,e,r){return e.getReputation(this.chainIdentifier,this.contract,[t.token.toString()],r.signal).then(t=>{if(null==t)throw new a.IntermediaryError("Invalid data returned - invalid LP vault");return t}).catch(t=>(this.logger.warn("preFetchIntermediaryReputation(): Error: ",t),r.abort(t),null))}preFetchFeeRate(t,e,r,i){return(0,n.tryWithRetries)(()=>this.contract.getInitPayInFeeRate(t,null,e.token,r),null,null,i.signal).catch(t=>(this.logger.warn("preFetchFeeRate(): Error: ",t),i.abort(t),null))}async processEventInitialize(t,e){if(t.state===i.ToBTCSwapState.CREATED||t.state===i.ToBTCSwapState.QUOTE_SOFT_EXPIRED){let r=await e.swapData();return(null==t.data||!!t.data.equals(r))&&((t.state===i.ToBTCSwapState.CREATED||t.state===i.ToBTCSwapState.QUOTE_SOFT_EXPIRED)&&(t.state=i.ToBTCSwapState.COMMITED),t.data=r,!0)}}processEventClaim(t,e){return t.state!==i.ToBTCSwapState.REFUNDED&&t.state!==i.ToBTCSwapState.CLAIMED?(t.state=i.ToBTCSwapState.CLAIMED,t._setPaymentResult({secret:e.result,txId:Buffer.from(e.result,"hex").reverse().toString("hex")}),Promise.resolve(!0)):Promise.resolve(!1)}processEventRefund(t,e){return t.state!==i.ToBTCSwapState.CLAIMED&&t.state!==i.ToBTCSwapState.REFUNDED?(t.state=i.ToBTCSwapState.REFUNDED,Promise.resolve(!0)):Promise.resolve(!1)}}r.IToBTCWrapper=o},845838,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ToBTCLNWrapper=void 0;let i=t.r(916232),n=t.r(66448),a=t.r(157333),s=t.r(223682),o=t.r(154585),l=t.r(46575),u=t.r(853312),c=t.r(389215),h=t.r(302071),p=t.r(742396),d=t.r(245282),f=t.r(582992);class m extends a.IToBTCWrapper{constructor(t,e,r,i,a,s,o,l,c,h){null==c&&(c={}),c.paymentTimeoutSeconds??=345600,c.lightningBaseFee??=10,c.lightningFeePPM??=2e3,super(t,e,r,i,a,s,o,l,c,h),this.TYPE=u.SwapType.TO_BTCLN,this.swapDeserializer=n.ToBTCLNSwap}async checkPaymentHashWasPaid(t){for(let e of(await this.unifiedStorage.query([[{key:"type",value:this.TYPE},{key:"paymentHash",value:t}]],t=>new this.swapDeserializer(this,t))))if(e.state===f.ToBTCSwapState.CLAIMED||e.state===f.ToBTCSwapState.SOFT_CLAIMED)throw new s.UserError("Lightning invoice was already paid!")}calculateFeeForAmount(t,e,r){return BigInt(e??this.options.lightningBaseFee)+t*BigInt(r??this.options.lightningFeePPM)/1000000n}async verifyReturnedData(t,e,r,i,n,a,s){if(t.routingFeeSats>await n.maxFee)throw new l.IntermediaryError("Invalid max fee sats returned");if(null!=s&&t.total!==s)throw new l.IntermediaryError("Invalid data returned - total amount");let u=this.contract.getHashForHtlc(Buffer.from(e.tagsObject.payment_hash,"hex"));if(a.getAmount()!==t.total||!Buffer.from(a.getClaimHash(),"hex").equals(u)||a.getExpiry()!==n.expiryTimestamp||a.getType()!==o.ChainSwapType.HTLC||!a.isPayIn()||!a.isToken(r)||a.getClaimer()!==i.getAddress(this.chainIdentifier))throw new l.IntermediaryError("Invalid data returned")}async getIntermediaryQuote(t,e,r,i,a,s,o,l,d){let f=l instanceof AbortController?l:(0,c.extendAbortController)(l);o.reputationPromise??=this.preFetchIntermediaryReputation(e,r,f);try{let{signDataPromise:l,resp:m}=await (0,c.tryWithRetries)(async n=>{let{signDataPrefetch:a,response:l}=h.IntermediaryAPI.initToBTCLN(this.chainIdentifier,r.url,{offerer:t,pr:i,maxFee:await s.maxFee,expiryTimestamp:s.expiryTimestamp,token:e.token,feeRate:o.feeRatePromise,additionalParams:d},this.options.postRequestTimeout,f.signal,!(n>0)&&null);return{signDataPromise:this.preFetchSignData(a),resp:await l}},null,t=>t instanceof p.RequestError,f.signal),g=(BigInt(a.millisatoshis)+999n)/1000n;m.swapFee,m.maxFee;let w=new this.swapDataDeserializer(m.data);w.setOfferer(t),await this.verifyReturnedData(m,a,e.token,r,s,w);let[y,T,S]=await Promise.all([this.verifyReturnedPrice(r.services[u.SwapType.TO_BTCLN],!0,g,w.getAmount(),e.token,{networkFee:m.maxFee},o.pricePreFetchPromise,f.signal),this.verifyReturnedSignature(t,w,m,o.feeRatePromise,l,f.signal),o.reputationPromise]);f.signal.throwIfAborted(),r.reputation[e.token.toString()]=S;let E=new n.ToBTCLNSwap(this,{pricingInfo:y,url:r.url,expiry:T,swapFee:m.swapFee,feeRate:await o.feeRatePromise,signatureData:m,data:w,networkFee:m.maxFee,networkFeeBtc:m.routingFeeSats,confidence:m.confidence,pr:i,exactIn:!1});return await E._save(),E}catch(t){throw f.abort(t),t}}async create(t,e,r,n,a,o,l,u){a??={},a.expirySeconds??=this.options.paymentTimeoutSeconds,a.expiryTimestamp??=BigInt(Math.floor(Date.now()/1e3)+a.expirySeconds);let h=(0,i.decode)(e);if(null==h.millisatoshis)throw new s.UserError("Must be an invoice with amount");let p=(BigInt(h.millisatoshis)+999n)/1000n;a.maxFee??=this.calculateFeeForAmount(p,a.maxRoutingBaseFee,a.maxRoutingPPM),await this.checkPaymentHashWasPaid(h.tagsObject.payment_hash);let d=this.contract.getHashForHtlc(Buffer.from(h.tagsObject.payment_hash,"hex")),f=(0,c.extendAbortController)(l);return null==u&&(u={pricePreFetchPromise:this.preFetchPrice(r,f.signal),feeRatePromise:this.preFetchFeeRate(t,r,d.toString("hex"),f)}),n.map(i=>({intermediary:i,quote:this.getIntermediaryQuote(t,r,i,e,h,a,u,f.signal,o)}))}async getLNURLPay(t,e){if("string"!=typeof t)return t;let r=await d.LNURL.getLNURL(t,!0,this.options.getRequestTimeout,e);if(null==r)throw new s.UserError("Invalid LNURL");if("payRequest"!==r.tag)throw new s.UserError("Not a LNURL-pay");return r}async getIntermediaryQuoteExactIn(t,e,r,i,a,o,f,m,g){let w=(0,c.extendAbortController)(m),y=this.preFetchIntermediaryReputation(e,i,w);try{let{signDataPromise:T,prepareResp:S}=await (0,c.tryWithRetries)(async r=>{let{signDataPrefetch:n,response:s}=h.IntermediaryAPI.prepareToBTCLNExactIn(this.chainIdentifier,i.url,{token:e.token,offerer:t,pr:a,amount:e.amount,maxFee:await o.maxFee,expiryTimestamp:o.expiryTimestamp,additionalParams:g},this.options.postRequestTimeout,w.signal,!(r>0)&&null);return{signDataPromise:this.preFetchSignData(n),prepareResp:await s}},null,t=>t instanceof p.RequestError,w.signal);if(S.amount<=0n)throw new l.IntermediaryError("Invalid amount returned (zero or negative)");let E=BigInt(r.minSendable)/1000n,I=BigInt(r.maxSendable)/1000n;if(S.amount<E)throw new s.UserError("Amount less than minimum");if(S.amount>I)throw new s.UserError("Amount more than maximum");let{invoice:b,parsedInvoice:v,successAction:B}=await d.LNURL.useLNURLPay(r,S.amount,o.comment,this.options.getRequestTimeout,w.signal),A=await (0,c.tryWithRetries)(t=>h.IntermediaryAPI.initToBTCLNExactIn(i.url,{pr:b,reqId:S.reqId,feeRate:f.feeRatePromise,additionalParams:g},this.options.postRequestTimeout,w.signal,!(t>0)&&null),null,p.RequestError,w.signal);A.swapFee,A.maxFee;let R=new this.swapDataDeserializer(A.data);R.setOfferer(t),await this.verifyReturnedData(A,v,e.token,i,o,R,e.amount);let[C,_,F]=await Promise.all([this.verifyReturnedPrice(i.services[u.SwapType.TO_BTCLN],!0,S.amount,R.getAmount(),e.token,{networkFee:A.maxFee},f.pricePreFetchPromise,m),this.verifyReturnedSignature(t,R,A,f.feeRatePromise,T,w.signal),y]);w.signal.throwIfAborted(),i.reputation[e.token.toString()]=F;let P=new n.ToBTCLNSwap(this,{pricingInfo:C,url:i.url,expiry:_,swapFee:A.swapFee,feeRate:await f.feeRatePromise,signatureData:A,data:R,networkFee:A.maxFee,networkFeeBtc:A.routingFeeSats,confidence:A.confidence,pr:b,lnurl:r.url,successAction:B,exactIn:!0});return await P._save(),P}catch(t){throw w.abort(t),t}}async createViaLNURL(t,e,r,i,n,a,o){if(!this.isInitialized)throw Error("Not initialized, call init() first!");n??={},n.expirySeconds??=this.options.paymentTimeoutSeconds,n.expiryTimestamp??=BigInt(Math.floor(Date.now()/1e3)+n.expirySeconds);let l=(0,c.extendAbortController)(o),u=this.preFetchPrice(r,l.signal),h=this.preFetchFeeRate(t,r,null,l);n.maxRoutingPPM??=BigInt(this.options.lightningFeePPM),n.maxRoutingBaseFee??=BigInt(this.options.lightningBaseFee),r.exactIn?n.maxFee??=u.then(t=>this.prices.getFromBtcSwapAmount(this.chainIdentifier,n.maxRoutingBaseFee,r.token,o,t)).then(t=>this.calculateFeeForAmount(r.amount,t,n.maxRoutingPPM)):n.maxFee=this.calculateFeeForAmount(r.amount,n.maxRoutingBaseFee,n.maxRoutingPPM);try{let o=await this.getLNURLPay(e,l.signal);if(null!=n.comment&&(null==o.commentAllowed||n.comment.length>o.commentAllowed))throw new s.UserError("Comment not allowed or too long");if(r.exactIn){let{invoice:e}=await d.LNURL.useLNURLPay(o,BigInt(o.minSendable)/1000n,null,this.options.getRequestTimeout,l.signal);return i.map(i=>({quote:this.getIntermediaryQuoteExactIn(t,r,o,i,e,n,{pricePreFetchPromise:u,feeRatePromise:h},l.signal,a),intermediary:i}))}{let e=BigInt(o.minSendable)/1000n,c=BigInt(o.maxSendable)/1000n;if(r.amount<e)throw new s.UserError("Amount less than minimum");if(r.amount>c)throw new s.UserError("Amount more than maximum");let{invoice:p,parsedInvoice:f,successAction:m}=await d.LNURL.useLNURLPay(o,r.amount,n.comment,this.options.getRequestTimeout,l.signal);return(await this.create(t,p,r,i,n,a,l.signal,{feeRatePromise:h,pricePreFetchPromise:u})).map(t=>({quote:t.quote.then(t=>(t.lnurl=o.url,t.successAction=m,t)),intermediary:t.intermediary}))}}catch(t){throw l.abort(t),t}}}r.ToBTCLNWrapper=m},533780,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ToBTCSwap=r.isToBTCSwapInit=void 0;let i=t.r(582992),n=t.r(853312),a=t.r(500874),s=t.r(46575),o=t.r(844485),l=t.r(389215);function u(t){return"string"==typeof t.address&&"bigint"==typeof t.amount&&"number"==typeof t.confirmationTarget&&"number"==typeof t.satsPerVByte&&(0,i.isIToBTCSwapInit)(t)}r.isToBTCSwapInit=u;class c extends i.IToBTCSwap{constructor(t,e){u(e)&&(e.url+="/tobtc"),super(t,e),this.outputToken=o.BitcoinTokens.BTC,this.TYPE=n.SwapType.TO_BTC,u(e)||(this.address=e.address,this.amount=BigInt(e.amount),this.confirmationTarget=e.confirmationTarget,this.satsPerVByte=e.satsPerVByte,this.txId=e.txId,this.requiredConfirmations=e.requiredConfirmations??this.data.getConfirmationsHint(),this.nonce=(null==e.nonce?null:BigInt(e.nonce))??this.data.getNonceHint()),this.logger=(0,l.getLogger)("ToBTC("+this.getIdentifierHashString()+"): "),this.tryRecomputeSwapPrice()}async _setPaymentResult(t,e=!1){if(null==t)return!1;if(null==t.txId)throw new s.IntermediaryError("No btc txId returned!");if(e){let e=await this.wrapper.btcRpc.getTransaction(t.txId);if(null==e)return!1;if(null==e.outs.find(t=>this.data.getClaimHash()===this.wrapper.contract.getHashForOnchain(a.Buffer.from(t.scriptPubKey.hex,"hex"),BigInt(t.value),this.requiredConfirmations,this.nonce).toString("hex")))throw new s.IntermediaryError("Invalid btc txId returned")}return this.txId=t.txId,!0}getOutput(){return(0,o.toTokenAmount)(this.amount,this.outputToken,this.wrapper.prices)}getOutputAddress(){return this.address}getOutputTxId(){return this.txId}getBitcoinFeeRate(){return this.satsPerVByte}serialize(){return{...super.serialize(),address:this.address,amount:this.amount.toString(10),confirmationTarget:this.confirmationTarget,satsPerVByte:this.satsPerVByte,nonce:null==this.nonce?null:this.nonce.toString(10),requiredConfirmations:this.requiredConfirmations,txId:this.txId}}}r.ToBTCSwap=c},94005,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.ToBTCWrapper=void 0;let i=t.r(533780),n=t.r(157333),a=t.r(154585),s=t.r(223682),o=t.r(46575),l=t.r(853312),u=t.r(389215),c=t.r(302071),h=t.r(742396),p=t.r(196225);class d extends n.IToBTCWrapper{constructor(t,e,r,n,a,s,o,u,c,h,d){null==h&&(h={}),h.bitcoinNetwork=h.bitcoinNetwork??p.TEST_NETWORK,h.safetyFactor=h.safetyFactor||2,h.maxConfirmations=h.maxConfirmations||6,h.bitcoinBlocktime=h.bitcoinBlocktime||600,h.maxExpectedOnchainSendSafetyFactor=h.maxExpectedOnchainSendSafetyFactor||4,h.maxExpectedOnchainSendGracePeriodBlocks=h.maxExpectedOnchainSendGracePeriodBlocks||12,super(t,e,r,n,a,s,o,u,h,d),this.TYPE=l.SwapType.TO_BTC,this.swapDeserializer=i.ToBTCSwap,this.btcRpc=c}getRandomNonce(){return BigInt(Math.floor(Date.now()/1e3)-7e8)<<24n|a.BigIntBufferUtils.fromBuffer((0,u.randomBytes)(3))}btcAddressToOutputScript(t){try{return(0,u.toOutputScript)(this.options.bitcoinNetwork,t)}catch(t){throw new s.UserError("Invalid address specified")}}verifyReturnedData(t,e,r,i,n,s){if(t.totalFee!==t.swapFee+t.networkFee)throw new o.IntermediaryError("Invalid totalFee returned");if(e.exactIn){if(t.total!==e.amount)throw new o.IntermediaryError("Invalid total returned")}else if(t.amount!==e.amount)throw new o.IntermediaryError("Invalid amount returned");let l=BigInt(i.confirmations+i.confirmationTarget+this.options.maxExpectedOnchainSendGracePeriodBlocks)*BigInt(this.options.maxExpectedOnchainSendSafetyFactor)*BigInt(this.options.bitcoinBlocktime),u=BigInt(Math.floor(Date.now()/1e3));if(n.getExpiry()>u+l)throw new o.IntermediaryError("Expiry time returned too high!");if(n.getAmount()!==t.total||n.getClaimHash()!==s||n.getType()!==a.ChainSwapType.CHAIN_NONCED||!n.isPayIn()||!n.isToken(e.token)||n.getClaimer()!==r.getAddress(this.chainIdentifier))throw new o.IntermediaryError("Invalid data returned")}create(t,e,r,n,a,s,o){if(!this.isInitialized)throw Error("Not initialized, call init() first!");a??={},a.confirmationTarget??=3,a.confirmations??=2;let p=this.getRandomNonce(),d=this.btcAddressToOutputScript(e),f=r.exactIn?null:this.contract.getHashForOnchain(d,r.amount,a.confirmations,p).toString("hex"),m=(0,u.extendAbortController)(o),g=this.preFetchPrice(r,m.signal),w=this.preFetchFeeRate(t,r,f,m);return n.map(n=>({intermediary:n,quote:(async()=>{let o=(0,u.extendAbortController)(m.signal),y=this.preFetchIntermediaryReputation(r,n,o);try{let{signDataPromise:m,resp:T}=await (0,u.tryWithRetries)(async i=>{let{signDataPrefetch:l,response:u}=c.IntermediaryAPI.initToBTC(this.chainIdentifier,n.url,{btcAddress:e,amount:r.amount,confirmationTarget:a.confirmationTarget,confirmations:a.confirmations,nonce:p,token:r.token,offerer:t,exactIn:r.exactIn,feeRate:w,additionalParams:s},this.options.postRequestTimeout,o.signal,!(i>0)&&null);return{signDataPromise:this.preFetchSignData(l),resp:await u}},null,h.RequestError,o.signal),S=r.exactIn?this.contract.getHashForOnchain(d,T.amount,a.confirmations,p).toString("hex"):f,E=new this.swapDataDeserializer(T.data);E.setOfferer(t),this.verifyReturnedData(T,r,n,a,E,S);let[I,b,v]=await Promise.all([this.verifyReturnedPrice(n.services[l.SwapType.TO_BTC],!0,T.amount,E.getAmount(),r.token,T,g,o.signal),this.verifyReturnedSignature(t,E,T,w,m,o.signal),y]);o.signal.throwIfAborted(),n.reputation[r.token.toString()]=v;let B=new i.ToBTCSwap(this,{pricingInfo:I,url:n.url,expiry:b,swapFee:T.swapFee,feeRate:await w,signatureData:T,data:E,networkFee:T.networkFee,address:e,amount:T.amount,confirmationTarget:a.confirmationTarget,satsPerVByte:Number(T.satsPervByte),exactIn:r.exactIn??!1,requiredConfirmations:a.confirmations,nonce:p});return await B._save(),B}catch(t){throw o.abort(t),t}})()}))}}r.ToBTCWrapper=d},11757,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IFromBTCSwap=void 0;let i=t.r(185670),n=t.r(154585),a=t.r(844485),s=t.r(146768),o=t.r(302887);class l extends s.IEscrowSwap{constructor(t,e){super(t,e)}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getInput().rawAmount/this.getOutAmountWithoutFee()),super.tryRecomputeSwapPrice()}getSwapData(){return this.data}_getInitiator(){return this.getSwapData().getClaimer()}getOutputTxId(){return this.claimTxId}getOutputAddress(){return this._getInitiator()}requiresAction(){return this.isClaimable()}getOutAmountWithoutFee(){return this.getSwapData().getAmount()+this.swapFee}getSwapFee(){let t=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getInputWithoutFee().rawAmount;return{amountInSrcToken:(0,a.toTokenAmount)(this.swapFeeBtc,this.inputToken,this.wrapper.prices),amountInDstToken:(0,a.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.getSwapData().getToken()],this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,t,e),composition:{base:(0,a.toTokenAmount)(this.pricingInfo.satsBaseFee,this.inputToken,this.wrapper.prices),percentage:(0,i.ppmToPercentage)(t)}}}getFee(){return this.getSwapFee()}getFeeBreakdown(){return[{type:o.FeeType.SWAP,fee:this.getSwapFee()}]}getOutput(){return(0,a.toTokenAmount)(this.getSwapData().getAmount(),this.wrapper.tokens[this.getSwapData().getToken()],this.wrapper.prices)}getInputWithoutFee(){return(0,a.toTokenAmount)(this.getInput().rawAmount-this.swapFeeBtc,this.inputToken,this.wrapper.prices)}getSecurityDeposit(){return(0,a.toTokenAmount)(this.getSwapData().getSecurityDeposit(),this.wrapper.getNativeToken(),this.wrapper.prices)}getTotalDeposit(){return(0,a.toTokenAmount)(this.getSwapData().getTotalDeposit(),this.wrapper.getNativeToken(),this.wrapper.prices)}async hasEnoughForTxFees(){let[t,e]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.wrapper.chain.getNativeCurrencyAddress(),!1),this.getCommitFee()]),r=e+this.getSwapData().getTotalDeposit();return{enoughBalance:t>=r,balance:(0,a.toTokenAmount)(t,this.wrapper.getNativeToken(),this.wrapper.prices),required:(0,a.toTokenAmount)(r,this.wrapper.getNativeToken(),this.wrapper.prices)}}async txsCommit(t){if(!this.canCommit())throw Error("Must be in CREATED state!");return this.initiated||(this.initiated=!0,await this._saveAndEmit()),await this.wrapper.contract.txsInit(this._getInitiator(),this.data,this.signatureData,t,this.feeRate).catch(t=>Promise.reject(t instanceof n.SignatureVerificationError?Error("Request timed out"):t))}getClaimFee(){return this.wrapper.contract.getClaimFee(this._getInitiator(),this.getSwapData())}}r.IFromBTCSwap=l},116793,(t,e,r)=>{"use strict";var i;Object.defineProperty(r,"__esModule",{value:!0}),r.FromBTCLNSwap=r.isFromBTCLNSwapInit=r.FromBTCLNSwapState=void 0;let n=t.r(916232),a=t.r(11757),s=t.r(853312),o=t.r(154585),l=t.r(500874),u=t.r(245282),c=t.r(223682),h=t.r(302071),p=t.r(46575),d=t.r(389215),f=t.r(844485),m=t.r(146768);function g(t){return"string"==typeof t.pr&&"string"==typeof t.secret&&(null==t.lnurl||"string"==typeof t.lnurl)&&(null==t.lnurlK1||"string"==typeof t.lnurlK1)&&(null==t.lnurlCallback||"string"==typeof t.lnurlCallback)&&(0,m.isIEscrowSwapInit)(t)}!function(t){t[t.FAILED=-4]="FAILED",t[t.QUOTE_EXPIRED=-3]="QUOTE_EXPIRED",t[t.QUOTE_SOFT_EXPIRED=-2]="QUOTE_SOFT_EXPIRED",t[t.EXPIRED=-1]="EXPIRED",t[t.PR_CREATED=0]="PR_CREATED",t[t.PR_PAID=1]="PR_PAID",t[t.CLAIM_COMMITED=2]="CLAIM_COMMITED",t[t.CLAIM_CLAIMED=3]="CLAIM_CLAIMED"}(i=r.FromBTCLNSwapState||(r.FromBTCLNSwapState={})),r.isFromBTCLNSwapInit=g;class w extends a.IFromBTCSwap{getSwapData(){return this.data??this.initialSwapData}constructor(t,e){g(e)&&(e.url+="/frombtcln"),super(t,e),this.inputToken=f.BitcoinTokens.BTCLN,this.TYPE=s.SwapType.FROM_BTCLN,this.lnurlFailSignal=new AbortController,this.prPosted=!1,g(e)?this.state=i.PR_CREATED:(this.pr=e.pr,this.secret=e.secret,this.initialSwapData=null==e.initialSwapData?null:o.SwapData.deserialize(e.initialSwapData),this.lnurl=e.lnurl,this.lnurlK1=e.lnurlK1,this.lnurlCallback=e.lnurlCallback,this.prPosted=e.prPosted,this.state===i.PR_CREATED&&null!=this.data&&(this.initialSwapData=this.data,delete this.data)),this.tryRecomputeSwapPrice(),this.logger=(0,d.getLogger)("FromBTCLN("+this.getIdentifierHashString()+"): ")}upgradeVersion(){if(null==this.version){switch(this.state){case -2:this.state=i.QUOTE_EXPIRED;break;case -1:this.state=i.FAILED;break;case 0:this.state=i.PR_CREATED;break;case 1:this.state=i.PR_PAID;break;case 2:this.state=i.CLAIM_COMMITED;break;case 3:this.state=i.CLAIM_CLAIMED}this.version=1}}getIdentifierHash(){let t=this.getPaymentHash();return null==this.randomNonce?t:l.Buffer.concat([t,l.Buffer.from(this.randomNonce,"hex")])}getPaymentHash(){if(null==this.pr)return null;let t=(0,n.decode)(this.pr);return l.Buffer.from(t.tagsObject.payment_hash,"hex")}canCommit(){return this.state===i.PR_PAID}getInputTxId(){return this.getPaymentHash().toString("hex")}getAddress(){return this.pr}getHyperlink(){return"lightning:"+this.pr.toUpperCase()}getTimeoutTime(){return null==this.pr?null:1e3*(0,n.decode)(this.pr).timeExpireDate}getHtlcTimeoutTime(){return 1e3*Number(this.wrapper.getHtlcTimeout(this.data))}isFinished(){return this.state===i.CLAIM_CLAIMED||this.state===i.QUOTE_EXPIRED||this.state===i.FAILED}isClaimable(){return this.state===i.PR_PAID||this.state===i.CLAIM_COMMITED}isSuccessful(){return this.state===i.CLAIM_CLAIMED}isFailed(){return this.state===i.FAILED||this.state===i.EXPIRED}isQuoteExpired(){return this.state===i.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===i.QUOTE_EXPIRED||this.state===i.QUOTE_SOFT_EXPIRED}verifyQuoteValid(){return this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED&&null==this.signatureData?Promise.resolve(this.getTimeoutTime()>Date.now()):super.verifyQuoteValid()}getInput(){let t=(BigInt((0,n.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,f.toTokenAmount)(t,this.inputToken,this.wrapper.prices)}async getSmartChainNetworkFee(){return(0,f.toTokenAmount)(await this.getCommitAndClaimFee(),this.wrapper.getNativeToken(),this.wrapper.prices)}async hasEnoughForTxFees(){let[t,e]=await Promise.all([this.wrapper.contract.getBalance(this._getInitiator(),this.wrapper.chain.getNativeCurrencyAddress(),!1),null!=this.feeRate?Promise.resolve(this.feeRate):this.wrapper.contract.getInitFeeRate(this.getSwapData().getOfferer(),this.getSwapData().getClaimer(),this.getSwapData().getToken(),this.getSwapData().getClaimHash())]),r=await this.wrapper.contract.getCommitFee(this.getSwapData(),e)+await this.wrapper.contract.getClaimFee(this._getInitiator(),this.getSwapData(),e)+this.getSwapData().getTotalDeposit();return{enoughBalance:t>=r,balance:(0,f.toTokenAmount)(t,this.wrapper.getNativeToken(),this.wrapper.prices),required:(0,f.toTokenAmount)(r,this.wrapper.getNativeToken(),this.wrapper.prices)}}async checkIntermediaryPaymentReceived(t=!0){if(this.state===i.PR_PAID||this.state===i.CLAIM_COMMITED||this.state===i.CLAIM_CLAIMED||this.state===i.FAILED)return!0;if(this.state===i.QUOTE_EXPIRED||this.state===i.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)return!1;let e=await h.IntermediaryAPI.getPaymentAuthorization(this.url,this.getPaymentHash().toString("hex"));switch(e.code){case h.PaymentAuthorizationResponseCodes.AUTH_DATA:let r=new this.wrapper.swapDataDeserializer(e.data.data);try{return await this.checkIntermediaryReturnedAuthData(this._getInitiator(),r,e.data),this.expiry=await (0,d.tryWithRetries)(()=>this.wrapper.contract.getInitAuthorizationExpiry(r,e.data)),this.state=i.PR_PAID,delete this.initialSwapData,this.data=r,this.signatureData={prefix:e.data.prefix,timeout:e.data.timeout,signature:e.data.signature},this.initiated=!0,t&&await this._saveAndEmit(),!0}catch(t){}return null;case h.PaymentAuthorizationResponseCodes.EXPIRED:return this.state=i.QUOTE_EXPIRED,this.initiated=!0,t&&await this._saveAndEmit(),!1;default:return null}}async checkIntermediaryReturnedAuthData(t,e,r){if(e.setClaimer(t),e.getOfferer()!==this.getSwapData().getOfferer())throw new p.IntermediaryError("Invalid offerer used");if(!e.isToken(this.getSwapData().getToken()))throw new p.IntermediaryError("Invalid token used");if(e.getSecurityDeposit()>this.getSwapData().getSecurityDeposit())throw new p.IntermediaryError("Invalid security deposit!");if(e.getAmount()<this.getSwapData().getAmount())throw new p.IntermediaryError("Invalid amount received!");if(e.getClaimHash()!==this.getSwapData().getClaimHash())throw new p.IntermediaryError("Invalid payment hash used!");if(!e.isDepositToken(this.getSwapData().getDepositToken()))throw new p.IntermediaryError("Invalid deposit token used!");await Promise.all([(0,d.tryWithRetries)(()=>this.wrapper.contract.isValidInitAuthorization(this._getInitiator(),e,r,this.feeRate),null,o.SignatureVerificationError),(0,d.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(e.getClaimer(),e)).then(t=>{if(t?.type!==o.SwapCommitStateType.NOT_COMMITED)throw Error("Swap already committed on-chain!")})])}async waitForPayment(t,e=5){if(this.state!==i.PR_CREATED&&(this.state!==i.QUOTE_SOFT_EXPIRED||null!=this.signatureData))throw Error("Must be in PR_CREATED state!");let r=new AbortController;null!=t&&t.addEventListener("abort",()=>r.abort(t.reason));let n=!1;null==this.lnurl||this.prPosted||(u.LNURL.postInvoiceToLNURLWithdraw({k1:this.lnurlK1,callback:this.lnurlCallback},this.pr).catch(t=>{this.lnurlFailSignal.abort(t)}),this.prPosted=!0,n||=!0),this.initiated||(this.initiated=!0,n||=!0),n&&await this._saveAndEmit();let a=()=>r.abort(this.lnurlFailSignal.signal.reason);this.lnurlFailSignal.signal.addEventListener("abort",a),this.lnurlFailSignal.signal.throwIfAborted();let s={code:h.PaymentAuthorizationResponseCodes.PENDING,msg:""};for(;!r.signal.aborted&&s.code===h.PaymentAuthorizationResponseCodes.PENDING;)(s=await h.IntermediaryAPI.getPaymentAuthorization(this.url,this.getPaymentHash().toString("hex"))).code===h.PaymentAuthorizationResponseCodes.PENDING&&await (0,d.timeoutPromise)(1e3*e,r.signal);if(this.lnurlFailSignal.signal.removeEventListener("abort",a),r.signal.throwIfAborted(),s.code===h.PaymentAuthorizationResponseCodes.AUTH_DATA){let t=s.data,e=new this.wrapper.swapDataDeserializer(s.data.data);return await this.checkIntermediaryReturnedAuthData(this._getInitiator(),e,t),this.expiry=await (0,d.tryWithRetries)(()=>this.wrapper.contract.getInitAuthorizationExpiry(e,t)),(this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED)&&(delete this.initialSwapData,this.data=e,this.signatureData={prefix:t.prefix,timeout:t.timeout,signature:t.signature},await this._saveAndEmit(i.PR_PAID)),!0}if(this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED)return s.code===h.PaymentAuthorizationResponseCodes.EXPIRED&&await this._saveAndEmit(i.QUOTE_EXPIRED),!1}async commit(t,e,r){this.checkSigner(t);let n=await this.wrapper.chain.sendAndConfirm(t,await this.txsCommit(r),!0,e);return this.commitTxId=n[0],(this.state===i.PR_PAID||this.state===i.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(i.CLAIM_COMMITED),n[0]}async waitTillCommited(t){if(this.state===i.CLAIM_COMMITED||this.state===i.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==i.PR_PAID&&this.state!==i.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)throw Error("Invalid state");let e=(0,d.extendAbortController)(t),r=await Promise.race([this.watchdogWaitTillCommited(e.signal),this.waitTillState(i.CLAIM_COMMITED,"gte",e.signal).then(()=>0)]);if(e.abort(),0===r&&this.logger.debug("waitTillCommited(): Resolved from state changed"),!0===r&&this.logger.debug("waitTillCommited(): Resolved from watchdog - commited"),!1===r){this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expired"),(this.state===i.PR_PAID||this.state===i.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(i.QUOTE_EXPIRED);return}(this.state===i.PR_PAID||this.state===i.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(i.CLAIM_COMMITED)}txsClaim(t){if(this.state!==i.CLAIM_COMMITED)throw Error("Must be in CLAIM_COMMITED state!");return this.wrapper.contract.txsClaimWithSecret(t??this._getInitiator(),this.data,this.secret,!0,!0)}async claim(t,e){let r=await this.wrapper.chain.sendAndConfirm(t,await this.txsClaim(),!0,e);return this.claimTxId=r[0],(i.CLAIM_COMMITED||i.EXPIRED||i.FAILED)&&await this._saveAndEmit(i.CLAIM_CLAIMED),r[0]}async waitTillClaimed(t){if(this.state===i.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==i.CLAIM_COMMITED)throw Error("Invalid state (not CLAIM_COMMITED)");let e=new AbortController;null!=t&&t.addEventListener("abort",()=>e.abort(t.reason));let r=await Promise.race([this.watchdogWaitTillResult(e.signal),this.waitTillState(i.CLAIM_CLAIMED,"eq",e.signal).then(()=>0),this.waitTillState(i.EXPIRED,"eq",e.signal).then(()=>1)]);if(e.abort(),0===r)return void this.logger.debug("waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)");if(1===r)throw this.logger.debug("waitTillClaimed(): Resolved from state change (EXPIRED)"),Error("Swap expired during claiming");this.logger.debug("waitTillClaimed(): Resolved from watchdog"),r?.type===o.SwapCommitStateType.PAID&&this.state!==i.CLAIM_CLAIMED&&(this.claimTxId=await r.getClaimTxId(),await this._saveAndEmit(i.CLAIM_CLAIMED)),(r?.type===o.SwapCommitStateType.NOT_COMMITED||r?.type===o.SwapCommitStateType.EXPIRED)&&this.state!==i.CLAIM_CLAIMED&&this.state!==i.FAILED&&(this.refundTxId=null==r.getRefundTxId?null:await r.getRefundTxId(),await this._saveAndEmit(i.FAILED))}async getCommitAndClaimFee(){let t=this.wrapper.contract,e=this.feeRate??await t.getInitFeeRate(this.getSwapData().getOfferer(),this.getSwapData().getClaimer(),this.getSwapData().getToken(),this.getSwapData().getClaimHash());return await (null!=t.getRawCommitFee?t.getRawCommitFee(this.getSwapData(),e):t.getCommitFee(this.getSwapData(),e))+await (null!=t.getRawClaimFee?t.getRawClaimFee(this._getInitiator(),this.getSwapData(),e):t.getClaimFee(this._getInitiator(),this.getSwapData(),e))}canCommitAndClaimInOneShot(){return null!=this.wrapper.contract.initAndClaimWithSecret}async txsCommitAndClaim(t){if(this.state===i.CLAIM_COMMITED)return await this.txsClaim();if(this.state!==i.PR_PAID&&(this.state!==i.QUOTE_SOFT_EXPIRED||null==this.signatureData))throw Error("Must be in PR_PAID state!");let e=await this.txsCommit(t),r=await this.wrapper.contract.txsClaimWithSecret(this._getInitiator(),this.data,this.secret,!0,!0,null,!0);return e.concat(r)}async commitAndClaim(t,e,r){if(!this.canCommitAndClaimInOneShot())throw Error("Cannot commitAndClaim in single action, please run commit and claim separately!");if(this.checkSigner(t),this.state===i.CLAIM_COMMITED)return[null,await this.claim(t)];let n=await this.wrapper.chain.sendAndConfirm(t,await this.txsCommitAndClaim(r),!0,e);return this.commitTxId=n[0]||this.commitTxId,this.claimTxId=n[n.length-1]||this.claimTxId,this.state!==i.CLAIM_CLAIMED&&await this._saveAndEmit(i.CLAIM_CLAIMED),n}isLNURL(){return null!=this.lnurl}getLNURL(){return this.lnurl}async settleWithLNURLWithdraw(t){let e;if(null!=this.lnurl)throw Error("Cannot settle LNURL-withdraw swap with different LNURL");if("string"==typeof t){let r=await u.LNURL.getLNURL(t);if(null==r||"withdrawRequest"!==r.tag)throw new c.UserError("Invalid LNURL-withdraw to settle the swap");e=r}else e=t.params;u.LNURL.useLNURLWithdraw(e,this.pr).catch(t=>this.lnurlFailSignal.abort(t)),this.lnurl=e.url,this.lnurlCallback=e.callback,this.lnurlK1=e.k1,this.prPosted=!0,await this._saveAndEmit()}serialize(){return{...super.serialize(),pr:this.pr,secret:this.secret,lnurl:this.lnurl,lnurlK1:this.lnurlK1,lnurlCallback:this.lnurlCallback,prPosted:this.prPosted,initialSwapData:null==this.initialSwapData?null:this.initialSwapData.serialize()}}async syncStateFromChain(){let t=!1;if((this.state===i.PR_PAID||this.state===i.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)&&(t=await this.verifyQuoteDefinitelyExpired()),this.state===i.CLAIM_COMMITED||this.state===i.EXPIRED){let t=await (0,d.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));if(t?.type===o.SwapCommitStateType.PAID)return null==this.claimTxId&&(this.claimTxId=await t.getClaimTxId()),this.state=i.CLAIM_CLAIMED,!0;if(t?.type===o.SwapCommitStateType.NOT_COMMITED||t?.type===o.SwapCommitStateType.EXPIRED)return null==this.refundTxId&&t.getRefundTxId&&(this.refundTxId=await t.getRefundTxId()),this.state=i.FAILED,!0}if(this.state===i.PR_PAID||this.state===i.QUOTE_SOFT_EXPIRED&&null!=this.signatureData){let t=await (0,d.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(t?.type){case o.SwapCommitStateType.COMMITED:return this.state=i.CLAIM_COMMITED,!0;case o.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&t.getRefundTxId&&(this.refundTxId=await t.getRefundTxId()),this.state=i.QUOTE_EXPIRED,!0;case o.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await t.getClaimTxId()),this.state=i.CLAIM_CLAIMED,!0}}if((this.state===i.PR_PAID||this.state===i.QUOTE_SOFT_EXPIRED&&null!=this.signatureData)&&t)return this.state=i.QUOTE_EXPIRED,!0}async _sync(t){let e=!1;return(this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED&&null==this.signatureData)&&(this.getTimeoutTime()<Date.now()&&(this.state=i.QUOTE_SOFT_EXPIRED,e||=!0),null!==await this.checkIntermediaryPaymentReceived(!1)&&(e||=!0)),await this.syncStateFromChain()&&(e=!0),t&&e&&await this._saveAndEmit(),e}async _tick(t){switch(this.state){case i.PR_CREATED:if(this.getTimeoutTime()<Date.now())return this.state=i.QUOTE_SOFT_EXPIRED,t&&await this._saveAndEmit(),!0;break;case i.PR_PAID:if(this.expiry<Date.now())return this.state=i.QUOTE_SOFT_EXPIRED,t&&await this._saveAndEmit(),!0;break;case i.CLAIM_COMMITED:if(await this.wrapper.contract.isExpired(this._getInitiator(),this.data))return this.state=i.EXPIRED,t&&await this._saveAndEmit(),!0}}}r.FromBTCLNSwap=w},384904,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IFromBTCWrapper=void 0;let i=t.r(46575),n=t.r(389215),a=t.r(154585),s=t.r(498372);class o extends s.IEscrowSwapWrapper{getRandomSequence(){return a.BigIntBufferUtils.fromBuffer((0,n.randomBytes)(8))}preFetchFeeRate(t,e,r,i){return(0,n.tryWithRetries)(()=>this.contract.getInitFeeRate(null,t,e.token,r),null,null,i.signal).catch(t=>(this.logger.warn("preFetchFeeRate(): Error: ",t),i.abort(t),null))}preFetchIntermediaryLiquidity(t,e,r){return e.getLiquidity(this.chainIdentifier,this.contract,t.token.toString(),r.signal).catch(t=>(this.logger.warn("preFetchIntermediaryLiquidity(): Error: ",t),r.abort(t),null))}async verifyIntermediaryLiquidity(t,e){if(await e<t)throw new i.IntermediaryError("Intermediary doesn't have enough liquidity")}}r.IFromBTCWrapper=o},642673,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.FromBTCLNWrapper=void 0;let i=t.r(116793),n=t.r(384904),a=t.r(916232),s=t.r(154585),o=t.r(500874),l=t.r(223682),u=t.r(1083),c=t.r(46575),h=t.r(853312),p=t.r(389215),d=t.r(302071),f=t.r(742396),m=t.r(245282);class g extends n.IFromBTCWrapper{constructor(t,e,r,n,a,s,o,l,u,c,p){super(t,e,r,n,a,s,o,l,c,p),this.TYPE=h.SwapType.FROM_BTCLN,this.swapDeserializer=i.FromBTCLNSwap,this.pendingSwapStates=[i.FromBTCLNSwapState.PR_CREATED,i.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED,i.FromBTCLNSwapState.PR_PAID,i.FromBTCLNSwapState.CLAIM_COMMITED,i.FromBTCLNSwapState.EXPIRED],this.tickSwapState=[i.FromBTCLNSwapState.PR_CREATED,i.FromBTCLNSwapState.PR_PAID,i.FromBTCLNSwapState.CLAIM_COMMITED],this.lnApi=u}processEventInitialize(t,e){return t.state===i.FromBTCLNSwapState.PR_PAID||t.state===i.FromBTCLNSwapState.QUOTE_SOFT_EXPIRED?(t.state=i.FromBTCLNSwapState.CLAIM_COMMITED,Promise.resolve(!0)):Promise.resolve(!1)}processEventClaim(t,e){return t.state!==i.FromBTCLNSwapState.FAILED&&t.state!==i.FromBTCLNSwapState.CLAIM_CLAIMED?(t.state=i.FromBTCLNSwapState.CLAIM_CLAIMED,Promise.resolve(!0)):Promise.resolve(!1)}processEventRefund(t,e){return t.state!==i.FromBTCLNSwapState.CLAIM_CLAIMED&&t.state!==i.FromBTCLNSwapState.FAILED?(t.state=i.FromBTCLNSwapState.FAILED,Promise.resolve(!0)):Promise.resolve(!1)}getHtlcTimeout(t){return t.getExpiry()-600n}getSecretAndHash(){let t=(0,p.randomBytes)(32),e=o.Buffer.from((0,u.sha256)(t));return{secret:t,paymentHash:e}}preFetchLnCapacity(t){return t.then(t=>null==t?null:this.lnApi.getLNNodeLiquidity(t)).catch(t=>(this.logger.warn("preFetchLnCapacity(): Error: ",t),null))}verifyReturnedData(t,e,r,i,n,a){if(r.getAddress(this.chainIdentifier)!==t.intermediaryKey)throw new c.IntermediaryError("Invalid intermediary address/pubkey");if(null!=i.descriptionHash&&n.tagsObject.purpose_commit_hash!==i.descriptionHash.toString("hex"))throw new c.IntermediaryError("Invalid pr returned - description hash");if(e.exactIn){if(a!==e.amount)throw new c.IntermediaryError("Invalid payment request returned, amount mismatch")}else if(t.total!=e.amount)throw new c.IntermediaryError("Invalid amount returned")}async verifyLnNodeCapacity(t,e,r,i,n){let a=null==i?null:await i;if(null==a&&(a=await this.lnApi.getLNNodeLiquidity(e.payeeNodeKey)),null!=n&&n.throwIfAborted(),null===a)throw new c.IntermediaryError("LP's lightning node not found in the lightning network graph!");if(t.lnData=a,e.payeeNodeKey!==a.publicKey)throw new c.IntermediaryError("Invalid pr returned - payee pubkey");if(a.capacity<r)throw new c.IntermediaryError("LP's lightning node doesn't have enough inbound capacity for the swap!");if(a.capacity/2n<r)throw Error("LP's lightning node probably doesn't have enough inbound capacity for the swap!")}create(t,e,r,n,o,u,c){if(null==n&&(n={}),n.unsafeSkipLnNodeCheck??=this.options.unsafeSkipLnNodeCheck,null==c&&(c={}),null!=n.descriptionHash&&32!==n.descriptionHash.length)throw new l.UserError("Invalid description hash length");let{secret:m,paymentHash:g}=this.getSecretAndHash(),w=this.contract.getHashForHtlc(g),y=(0,p.extendAbortController)(u);c.pricePrefetchPromise??=this.preFetchPrice(e,y.signal);let T=this.chain.getNativeCurrencyAddress();return c.feeRatePromise??=this.preFetchFeeRate(t,e,w.toString("hex"),y),r.map(r=>({intermediary:r,quote:(async()=>{let l=(0,p.extendAbortController)(y.signal),u=this.preFetchIntermediaryLiquidity(e,r,l),{lnCapacityPromise:S,resp:E}=await (0,p.tryWithRetries)(async i=>{let{lnPublicKey:a,response:s}=d.IntermediaryAPI.initFromBTCLN(this.chainIdentifier,r.url,T,{paymentHash:g,amount:e.amount,claimer:t,token:e.token.toString(),descriptionHash:n.descriptionHash,exactOut:!e.exactIn,feeRate:c.feeRatePromise,additionalParams:o},this.options.postRequestTimeout,l.signal,!(i>0)&&null);return{lnCapacityPromise:n.unsafeSkipLnNodeCheck?null:this.preFetchLnCapacity(a),resp:await s}},null,f.RequestError,l.signal),I=(0,a.decode)(E.pr),b=(BigInt(I.millisatoshis)+999n)/1000n;try{this.verifyReturnedData(E,e,r,n,I,b);let[a]=await Promise.all([this.verifyReturnedPrice(r.services[h.SwapType.FROM_BTCLN],!1,b,E.total,e.token,{},c.pricePrefetchPromise,l.signal),this.verifyIntermediaryLiquidity(E.total,u),n.unsafeSkipLnNodeCheck?Promise.resolve():this.verifyLnNodeCapacity(r,I,b,S,l.signal)]),o=new i.FromBTCLNSwap(this,{pricingInfo:a,url:r.url,expiry:1e3*I.timeExpireDate,swapFee:E.swapFee,feeRate:await c.feeRatePromise,initialSwapData:await this.contract.createSwapData(s.ChainSwapType.HTLC,r.getAddress(this.chainIdentifier),t,e.token,E.total,w.toString("hex"),this.getRandomSequence(),BigInt(Math.floor(Date.now()/1e3)),!1,!0,E.securityDeposit,0n,T),pr:E.pr,secret:m.toString("hex"),exactIn:e.exactIn??!0});return await o._save(),o}catch(t){throw l.abort(t),t}})()}))}async getLNURLWithdraw(t,e){if("string"!=typeof t)return t;let r=await m.LNURL.getLNURL(t,!0,this.options.getRequestTimeout,e);if(null==r)throw new l.UserError("Invalid LNURL");if("withdrawRequest"!==r.tag)throw new l.UserError("Not a LNURL-withdrawal");return r}async createViaLNURL(t,e,r,i,n,a){if(!this.isInitialized)throw Error("Not initialized, call init() first!");let s=(0,p.extendAbortController)(a),o={pricePrefetchPromise:this.preFetchPrice(r,s.signal),feeRatePromise:this.preFetchFeeRate(t,r,null,s)};try{let u=r.exactIn?null:o.pricePrefetchPromise.then(t=>this.prices.getToBtcSwapAmount(this.chainIdentifier,r.amount,r.token,s.signal,t)).catch(t=>(s.abort(t),null)),c=await this.getLNURLWithdraw(e,s.signal),h=BigInt(c.minWithdrawable)/1000n,p=BigInt(c.maxWithdrawable)/1000n;if(r.exactIn){if(r.amount<h)throw new l.UserError("Amount less than LNURL-withdraw minimum");if(r.amount>p)throw new l.UserError("Amount more than LNURL-withdraw maximum")}else{let t=await u;if(s.signal.throwIfAborted(),95n*t/100n<h)throw new l.UserError("Amount less than LNURL-withdraw minimum");if(105n*t/100n>p)throw new l.UserError("Amount more than LNURL-withdraw maximum")}return this.create(t,r,i,null,n,a,o).map(t=>({quote:t.quote.then(t=>{t.lnurl=c.url,t.lnurlK1=c.k1,t.lnurlCallback=c.callback;let e=t.getInput().rawAmount;if(e<h)throw new l.UserError("Amount less than LNURL-withdraw minimum");if(e>p)throw new l.UserError("Amount more than LNURL-withdraw maximum");return t}),intermediary:t.intermediary}))}catch(t){throw s.abort(t),t}}}r.FromBTCLNWrapper=g},757423,(t,e,r)=>{"use strict";var i;Object.defineProperty(r,"__esModule",{value:!0}),r.FromBTCSwap=r.isFromBTCSwapInit=r.FromBTCSwapState=void 0;let n=t.r(11757),a=t.r(853312),s=t.r(154585),o=t.r(500874),l=t.r(844485),u=t.r(389215),c=t.r(146768),h=t.r(824341),p=t.r(839596),d=t.r(199974);function f(t){return"string"==typeof t.address&&"bigint"==typeof t.amount&&(0,c.isIEscrowSwapInit)(t)}!function(t){t[t.FAILED=-4]="FAILED",t[t.EXPIRED=-3]="EXPIRED",t[t.QUOTE_EXPIRED=-2]="QUOTE_EXPIRED",t[t.QUOTE_SOFT_EXPIRED=-1]="QUOTE_SOFT_EXPIRED",t[t.PR_CREATED=0]="PR_CREATED",t[t.CLAIM_COMMITED=1]="CLAIM_COMMITED",t[t.BTC_TX_CONFIRMED=2]="BTC_TX_CONFIRMED",t[t.CLAIM_CLAIMED=3]="CLAIM_CLAIMED"}(i=r.FromBTCSwapState||(r.FromBTCSwapState={})),r.isFromBTCSwapInit=f;class m extends n.IFromBTCSwap{constructor(t,e){f(e)&&(e.url+="/frombtc"),super(t,e),this.inputToken=l.BitcoinTokens.BTC,this.TYPE=a.SwapType.FROM_BTC,f(e)?this.state=i.PR_CREATED:(this.address=e.address,this.amount=BigInt(e.amount),this.txId=e.txId,this.vout=e.vout,this.requiredConfirmations=e.requiredConfirmations??this.data.getConfirmationsHint()),this.tryRecomputeSwapPrice(),this.logger=(0,u.getLogger)("FromBTC("+this.getIdentifierHashString()+"): ")}upgradeVersion(){if(null==this.version){switch(this.state){case -2:this.state=i.FAILED;break;case -1:this.state=i.QUOTE_EXPIRED;break;case 0:this.state=i.PR_CREATED;break;case 1:this.state=i.CLAIM_COMMITED;break;case 2:this.state=i.BTC_TX_CONFIRMED;break;case 3:this.state=i.CLAIM_CLAIMED}this.version=1}}getAddress(){return this.state===i.PR_CREATED?null:this.address}getHyperlink(){return this.state===i.PR_CREATED?null:"bitcoin:"+this.address+"?amount="+encodeURIComponent((Number(this.amount)/1e8).toString(10))}getInputTxId(){return this.txId}getTimeoutTime(){return 1e3*Number(this.wrapper.getOnchainSendTimeout(this.data,this.requiredConfirmations))}requiresAction(){return this.isClaimable()||this.state===i.CLAIM_COMMITED&&this.getTimeoutTime()>Date.now()}isFinished(){return this.state===i.CLAIM_CLAIMED||this.state===i.QUOTE_EXPIRED||this.state===i.FAILED}isClaimable(){return this.state===i.BTC_TX_CONFIRMED}isSuccessful(){return this.state===i.CLAIM_CLAIMED}isFailed(){return this.state===i.FAILED||this.state===i.EXPIRED&&null!=this.txId}isQuoteExpired(){return this.state===i.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===i.QUOTE_EXPIRED||this.state===i.QUOTE_SOFT_EXPIRED}canCommit(){return this.state===i.PR_CREATED&&this.wrapper.getOnchainSendTimeout(this.data,this.requiredConfirmations)-BigInt(Math.floor(Date.now()/1e3))>=this.wrapper.options.minSendWindow}getInput(){return(0,l.toTokenAmount)(this.amount,this.inputToken,this.wrapper.prices)}getClaimerBounty(){return(0,l.toTokenAmount)(this.data.getClaimerBounty(),this.wrapper.tokens[this.data.getDepositToken()],this.wrapper.prices)}getRequiredConfirmationsCount(){return this.requiredConfirmations}async getBitcoinPayment(){let t=await this.wrapper.btcRpc.checkAddressTxos(this.address,o.Buffer.from(this.data.getTxoHashHint(),"hex"));return null==t?null:{txId:t.tx.txid,vout:t.vout,confirmations:t.tx.confirmations,targetConfirmations:this.requiredConfirmations}}async waitForBitcoinTransaction(t,e,r){if(this.state!==i.CLAIM_COMMITED&&this.state!==i.EXPIRED)throw Error("Must be in COMMITED state!");let n=await this.wrapper.btcRpc.waitForAddressTxo(this.address,o.Buffer.from(this.data.getTxoHashHint(),"hex"),this.requiredConfirmations,(t,e,i,n)=>{null!=r&&r(e,t,this.requiredConfirmations,n)},t,e);return null!=t&&t.throwIfAborted(),this.txId=n.tx.txid,this.vout=n.vout,this.state!==i.CLAIM_CLAIMED&&this.state!==i.FAILED&&(this.state=i.BTC_TX_CONFIRMED),await this._saveAndEmit(),n.tx.txid}async getFundedPsbt(t,e){let r;if(this.state!==i.CLAIM_COMMITED)throw Error("Swap not committed yet, please initiate the swap first with commit() call!");r=(0,h.isIBitcoinWallet)(t)?t:new d.SingleAddressBitcoinWallet(this.wrapper.btcRpc,this.wrapper.options.bitcoinNetwork,t),null==e&&(e=await r.getFeeRate());let n=new p.Transaction({allowUnknownOutputs:!0,allowLegacyWitnessUtxo:!0});n.addOutput({amount:this.amount,script:(0,u.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address)});let a=await r.fundPsbt(n,e),s=[];for(let t=0;t<a.inputsLength;t++)s.push(t);return{psbt:a,signInputs:s}}async submitPsbt(t){if(this.state!==i.CLAIM_COMMITED)throw Error("Swap not committed yet, please initiate the swap first with commit() call!");if(this.getTimeoutTime()<Date.now())throw Error("Swap address expired!");let e=t.getOutput(0);if(e.amount!==this.amount)throw Error("PSBT output amount invalid, expected: "+this.amount+" got: "+e.amount);if(!(0,u.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address).equals(e.script))throw Error("PSBT output script invalid!");return t.isFinal||t.finalize(),await this.wrapper.btcRpc.sendRawTransaction(o.Buffer.from(t.toBytes(!0,!0)).toString("hex"))}async estimateBitcoinFee(t,e){let r=await t.getTransactionFee(this.address,this.amount,e);return(0,l.toTokenAmount)(null==r?null:BigInt(r),l.BitcoinTokens.BTC,this.wrapper.prices)}async sendBitcoinTransaction(t,e){if(this.state!==i.CLAIM_COMMITED)throw Error("Swap not committed yet, please initiate the swap first with commit() call!");return await t.sendTransaction(this.address,this.amount,e)}async commit(t,e,r){this.checkSigner(t);let n=await this.wrapper.chain.sendAndConfirm(t,await this.txsCommit(r),!0,e);return this.commitTxId=n[0],(this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(i.CLAIM_COMMITED),n[0]}async waitTillCommited(t){if(this.state===i.CLAIM_COMMITED||this.state===i.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==i.PR_CREATED&&this.state!==i.QUOTE_SOFT_EXPIRED)throw Error("Invalid state");let e=(0,u.extendAbortController)(t),r=await Promise.race([this.watchdogWaitTillCommited(e.signal),this.waitTillState(i.CLAIM_COMMITED,"gte",e.signal).then(()=>0)]);if(e.abort(),0===r&&this.logger.debug("waitTillCommited(): Resolved from state changed"),!0===r&&this.logger.debug("waitTillCommited(): Resolved from watchdog - commited"),!1===r){this.logger.debug("waitTillCommited(): Resolved from watchdog - signature expired"),(this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(i.QUOTE_EXPIRED);return}(this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED)&&await this._saveAndEmit(i.CLAIM_COMMITED)}async txsClaim(t){if(this.state!==i.BTC_TX_CONFIRMED)throw Error("Must be in BTC_TX_CONFIRMED state!");let e=await this.wrapper.btcRpc.getTransaction(this.txId);return await this.wrapper.contract.txsClaimWithTxData(t??this._getInitiator(),this.data,{blockhash:e.blockhash,confirmations:e.confirmations,txid:e.txid,hex:e.hex,height:e.blockheight},this.requiredConfirmations,this.vout,null,this.wrapper.synchronizer,!0)}async claim(t,e){let r;try{r=await this.wrapper.chain.sendAndConfirm(t,await this.txsClaim(t),!0,e)}catch(e){if(this.logger.info("claim(): Failed to claim ourselves, checking swap claim state..."),this.state===i.CLAIM_CLAIMED)return this.logger.info("claim(): Transaction state is CLAIM_CLAIMED, swap was successfully claimed by the watchtower"),this.claimTxId;let t=await this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data);if(t?.type===s.SwapCommitStateType.PAID)return this.logger.info("claim(): Transaction commit status is PAID, swap was successfully claimed by the watchtower"),null==this.claimTxId&&(this.claimTxId=await t.getClaimTxId()),await this._saveAndEmit(i.CLAIM_CLAIMED),this.claimTxId;throw e}return this.claimTxId=r[r.length-1],(this.state===i.CLAIM_COMMITED||this.state===i.BTC_TX_CONFIRMED||this.state===i.EXPIRED||this.state===i.FAILED)&&await this._saveAndEmit(i.CLAIM_CLAIMED),r[0]}async waitTillClaimed(t){if(this.state===i.CLAIM_CLAIMED)return Promise.resolve();if(this.state!==i.BTC_TX_CONFIRMED)throw Error("Invalid state (not BTC_TX_CONFIRMED)");let e=new AbortController;null!=t&&t.addEventListener("abort",()=>e.abort(t.reason));let r=await Promise.race([this.watchdogWaitTillResult(e.signal),this.waitTillState(i.CLAIM_CLAIMED,"eq",e.signal).then(()=>0),this.waitTillState(i.FAILED,"eq",e.signal).then(()=>1)]);if(e.abort(),0===r)return void this.logger.debug("waitTillClaimed(): Resolved from state change (CLAIM_CLAIMED)");if(1===r)throw this.logger.debug("waitTillClaimed(): Resolved from state change (FAILED)"),Error("Offerer refunded during claiming");this.logger.debug("waitTillClaimed(): Resolved from watchdog"),r?.type===s.SwapCommitStateType.PAID&&this.state!==i.CLAIM_CLAIMED&&(this.claimTxId=await r.getClaimTxId(),await this._saveAndEmit(i.CLAIM_CLAIMED)),(r?.type===s.SwapCommitStateType.NOT_COMMITED||r?.type===s.SwapCommitStateType.EXPIRED)&&this.state!==i.CLAIM_CLAIMED&&this.state!==i.FAILED&&(this.refundTxId=null==r.getRefundTxId?null:await r.getRefundTxId(),await this._saveAndEmit(i.FAILED))}serialize(){return{...super.serialize(),address:this.address,amount:this.amount.toString(10),requiredConfirmations:this.requiredConfirmations,txId:this.txId,vout:this.vout}}async syncStateFromChain(){if(this.state===i.PR_CREATED||this.state===i.QUOTE_SOFT_EXPIRED){let t=await this.verifyQuoteDefinitelyExpired(),e=await (0,u.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(e?.type){case s.SwapCommitStateType.COMMITED:return this.state=i.CLAIM_COMMITED,!0;case s.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&e.getRefundTxId&&(this.refundTxId=await e.getRefundTxId()),this.state=i.QUOTE_EXPIRED,!0;case s.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await e.getClaimTxId()),this.state=i.CLAIM_CLAIMED,!0}return!!t&&(this.state=i.QUOTE_EXPIRED,!0)}if(this.state===i.CLAIM_COMMITED||this.state===i.BTC_TX_CONFIRMED||this.state===i.EXPIRED){let t=await (0,u.tryWithRetries)(()=>this.wrapper.contract.getCommitStatus(this._getInitiator(),this.data));switch(t?.type){case s.SwapCommitStateType.PAID:return null==this.claimTxId&&(this.claimTxId=await t.getClaimTxId()),this.state=i.CLAIM_CLAIMED,!0;case s.SwapCommitStateType.NOT_COMMITED:case s.SwapCommitStateType.EXPIRED:return null==this.refundTxId&&t.getRefundTxId&&(this.refundTxId=await t.getRefundTxId()),this.state=i.FAILED,!0;case s.SwapCommitStateType.COMMITED:let e=await this.getBitcoinPayment();if(null!=e&&e.confirmations>=this.requiredConfirmations)return this.txId=e.txId,this.vout=e.vout,this.state=i.BTC_TX_CONFIRMED,!0}}}async _sync(t){let e=await this.syncStateFromChain();return e&&t&&await this._saveAndEmit(),e}async _tick(t){switch(this.state){case i.PR_CREATED:if(this.expiry<Date.now())return this.state=i.QUOTE_SOFT_EXPIRED,t&&await this._saveAndEmit(),!0;break;case i.CLAIM_COMMITED:if(this.getTimeoutTime()<Date.now())return this.state=i.EXPIRED,t&&await this._saveAndEmit(),!0;case i.EXPIRED:if(Math.floor(Date.now()/1e3)%120==0)try{let e=await this.getBitcoinPayment();if(null!=e&&e.confirmations>=this.requiredConfirmations)return this.txId=e.txId,this.vout=e.vout,this.state=i.BTC_TX_CONFIRMED,t&&await this._saveAndEmit(),!0}catch(t){this.logger.warn("tickSwap("+this.getIdentifierHashString()+"): ",t)}}}}r.FromBTCSwap=m},442135,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.FromBTCWrapper=void 0;let i=t.r(384904),n=t.r(757423),a=t.r(154585),s=t.r(500874),o=t.r(46575),l=t.r(853312),u=t.r(389215),c=t.r(302071),h=t.r(742396),p=t.r(196225);class d extends i.IFromBTCWrapper{constructor(t,e,r,i,a,s,o,u,c,h,d,f,m){null==f&&(f={}),f.bitcoinNetwork=f.bitcoinNetwork??p.TEST_NETWORK,f.safetyFactor=f.safetyFactor||2,f.blocksTillTxConfirms=f.blocksTillTxConfirms||12,f.maxConfirmations=f.maxConfirmations||6,f.minSendWindow=f.minSendWindow||1800,f.bitcoinBlocktime=f.bitcoinBlocktime||600,super(t,e,r,i,a,s,o,u,f,m),this.TYPE=l.SwapType.FROM_BTC,this.swapDeserializer=n.FromBTCSwap,this.pendingSwapStates=[n.FromBTCSwapState.PR_CREATED,n.FromBTCSwapState.QUOTE_SOFT_EXPIRED,n.FromBTCSwapState.CLAIM_COMMITED,n.FromBTCSwapState.BTC_TX_CONFIRMED,n.FromBTCSwapState.EXPIRED],this.tickSwapState=[n.FromBTCSwapState.PR_CREATED,n.FromBTCSwapState.CLAIM_COMMITED,n.FromBTCSwapState.EXPIRED],this.btcRelay=c,this.synchronizer=h,this.btcRpc=d}processEventInitialize(t,e){return t.state===n.FromBTCSwapState.PR_CREATED||t.state===n.FromBTCSwapState.QUOTE_SOFT_EXPIRED?(t.state=n.FromBTCSwapState.CLAIM_COMMITED,Promise.resolve(!0)):Promise.resolve(!1)}processEventClaim(t,e){return t.state!==n.FromBTCSwapState.FAILED&&t.state!==n.FromBTCSwapState.CLAIM_CLAIMED?(t.state=n.FromBTCSwapState.CLAIM_CLAIMED,Promise.resolve(!0)):Promise.resolve(!1)}processEventRefund(t,e){return t.state!==n.FromBTCSwapState.CLAIM_CLAIMED&&t.state!==n.FromBTCSwapState.FAILED?(t.state=n.FromBTCSwapState.FAILED,Promise.resolve(!0)):Promise.resolve(!1)}getOnchainSendTimeout(t,e){let r=(this.options.blocksTillTxConfirms+e)*this.options.bitcoinBlocktime*this.options.safetyFactor;return t.getExpiry()-BigInt(r)}async preFetchClaimerBounty(t,e,r,i){let n=BigInt(Math.floor(Date.now()/1e3));if(r.unsafeZeroWatchtowerFee)return{feePerBlock:0n,safetyFactor:r.blockSafetyFactor,startTimestamp:n,addBlock:0,addFee:0n};let s=BigInt(Math.floor(0x1000000*Math.random())),o=await this.contract.createSwapData(a.ChainSwapType.CHAIN,t,t,e.token,s,this.contract.getHashForOnchain((0,u.randomBytes)(20),s,3).toString("hex"),this.getRandomSequence(),n,!1,!0,BigInt(Math.floor(65536*Math.random())),BigInt(Math.floor(65536*Math.random())));try{let[e,a,s,l]=await Promise.all([(0,u.tryWithRetries)(()=>this.btcRelay.getFeePerBlock(),null,null,i.signal),(0,u.tryWithRetries)(()=>this.btcRelay.getTipData(),null,null,i.signal),this.btcRpc.getTipHeight(),(0,u.tryWithRetries)(()=>this.contract.getClaimFee(t,o),null,null,i.signal)]),c=a.blockheight,h=Math.max(s-c,0);return{feePerBlock:e*r.feeSafetyFactor,safetyFactor:r.blockSafetyFactor,startTimestamp:n,addBlock:h,addFee:l*r.feeSafetyFactor}}catch(t){return i.abort(t),null}}getClaimerBounty(t,e,r){let i=(t.getExpiry()-r.startTimestamp)/BigInt(this.options.bitcoinBlocktime)*BigInt(e.blockSafetyFactor)+BigInt(r.addBlock);return r.addFee+i*r.feePerBlock}verifyReturnedData(t,e,r,i,n,c,h,p){if(e.exactIn){if(t.amount!==e.amount)throw new o.IntermediaryError("Invalid amount returned")}else if(t.total!==e.amount)throw new o.IntermediaryError("Invalid total returned");let d=t.confirmations??r.services[l.SwapType.FROM_BTC].data.confirmations;if(d>this.options.maxConfirmations)throw new o.IntermediaryError("Requires too many confirmations");let f=this.getClaimerBounty(n,i,h);if(n.getClaimerBounty()!==f||n.getType()!=a.ChainSwapType.CHAIN||n.getSequence()!==c||n.getAmount()!==t.total||n.isPayIn()||!n.isToken(e.token)||n.getOfferer()!==r.getAddress(this.chainIdentifier)||!n.isDepositToken(p))throw new o.IntermediaryError("Invalid data returned");if(this.getOnchainSendTimeout(n,d)-BigInt(Math.floor(Date.now()/1e3))<BigInt(this.options.minSendWindow))throw new o.IntermediaryError("Send window too low");let m=(0,u.toOutputScript)(this.options.bitcoinNetwork,t.btcAddress),g=this.contract.getExtraData(m,t.amount,d);if(!this.contract.getHashForOnchain(m,t.amount,d).equals(s.Buffer.from(n.getClaimHash(),"hex")))throw new o.IntermediaryError("Invalid claim hash returned!");if(!g.equals(s.Buffer.from(n.getExtraData(),"hex")))throw new o.IntermediaryError("Invalid extra data returned!")}create(t,e,r,i,a,s){i??={},i.blockSafetyFactor??=1,i.feeSafetyFactor??=2n;let o=this.getRandomSequence(),p=(0,u.extendAbortController)(s),d=this.preFetchPrice(e,p.signal),f=this.preFetchClaimerBounty(t,e,i,p),m=this.chain.getNativeCurrencyAddress(),g=this.preFetchFeeRate(t,e,null,p);return r.map(r=>({intermediary:r,quote:(async()=>{let s=(0,u.extendAbortController)(p.signal),w=this.preFetchIntermediaryLiquidity(e,r,s);try{let{signDataPromise:p,resp:y}=await (0,u.tryWithRetries)(async i=>{let{signDataPrefetch:n,response:l}=c.IntermediaryAPI.initFromBTC(this.chainIdentifier,r.url,m,{claimer:t,amount:e.amount,token:e.token.toString(),exactOut:!e.exactIn,sequence:o,claimerBounty:f,feeRate:g,additionalParams:a},this.options.postRequestTimeout,s.signal,!(i>0)&&null);return{signDataPromise:this.preFetchSignData(n),resp:await l}},null,t=>t instanceof h.RequestError,s.signal),T=new this.swapDataDeserializer(y.data);T.setClaimer(t),this.verifyReturnedData(y,e,r,i,T,o,await f,m);let[S,E]=await Promise.all([this.verifyReturnedPrice(r.services[l.SwapType.FROM_BTC],!1,y.amount,y.total,e.token,{},d,s.signal),this.verifyReturnedSignature(t,T,y,g,p,s.signal),this.verifyIntermediaryLiquidity(T.getAmount(),w)]),I=new n.FromBTCSwap(this,{pricingInfo:S,url:r.url,expiry:E,swapFee:y.swapFee,feeRate:await g,signatureData:y,data:T,address:y.btcAddress,amount:y.amount,exactIn:e.exactIn??!0,requiredConfirmations:y.confirmations??r.services[l.SwapType.FROM_BTC].data.confirmations});return await I._save(),I}catch(t){throw s.abort(t),t}})()}))}}r.FromBTCWrapper=d},274516,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.TrustedIntermediaryAPI=r.InvoiceStatusResponseCodes=r.AddressStatusResponseCodes=void 0;let i=t.r(389215),n=t.r(742396),a=t.r(187433);!function(t){t[t.EXPIRED=10001]="EXPIRED",t[t.PAID=1e4]="PAID",t[t.AWAIT_PAYMENT=10010]="AWAIT_PAYMENT",t[t.AWAIT_CONFIRMATION=10011]="AWAIT_CONFIRMATION",t[t.PENDING=10013]="PENDING",t[t.TX_SENT=10012]="TX_SENT",t[t.REFUNDED=10014]="REFUNDED",t[t.DOUBLE_SPENT=10015]="DOUBLE_SPENT",t[t.REFUNDABLE=10016]="REFUNDABLE"}(r.AddressStatusResponseCodes||(r.AddressStatusResponseCodes={}));let s={paymentHash:a.FieldTypeEnum.String,sequence:a.FieldTypeEnum.BigInt,btcAddress:a.FieldTypeEnum.String,amountSats:a.FieldTypeEnum.BigInt,swapFeeSats:a.FieldTypeEnum.BigInt,swapFee:a.FieldTypeEnum.BigInt,total:a.FieldTypeEnum.BigInt,intermediaryKey:a.FieldTypeEnum.String,recommendedFee:a.FieldTypeEnum.Number,expiresAt:a.FieldTypeEnum.Number};!function(t){t[t.EXPIRED=10001]="EXPIRED",t[t.PAID=1e4]="PAID",t[t.AWAIT_PAYMENT=10010]="AWAIT_PAYMENT",t[t.PENDING=10011]="PENDING",t[t.TX_SENT=10012]="TX_SENT"}(r.InvoiceStatusResponseCodes||(r.InvoiceStatusResponseCodes={}));let o={pr:a.FieldTypeEnum.String,swapFee:a.FieldTypeEnum.BigInt,total:a.FieldTypeEnum.BigInt};r.TrustedIntermediaryAPI=class{static async getInvoiceStatus(t,e,r,a){return(0,i.tryWithRetries)(()=>(0,i.httpGet)(t+"/getInvoiceStatus?paymentHash="+encodeURIComponent(e),r,a),null,n.RequestError,a)}static async initTrustedFromBTCLN(t,e,r,s,l){let u=await (0,i.tryWithRetries)(()=>(0,i.httpGet)(e+"/lnforgas/createInvoice?address="+encodeURIComponent(r.address)+"&amount="+encodeURIComponent(r.amount.toString(10))+"&chain="+encodeURIComponent(t)+"&token="+encodeURIComponent(r.token),s,l),null,n.RequestError,l);if(1e4!==u.code)throw n.RequestError.parse(JSON.stringify(u),400);return(0,a.verifySchema)(u.data,o)}static async getAddressStatus(t,e,r,a,s){return(0,i.tryWithRetries)(()=>(0,i.httpGet)(t+"/getAddressStatus?paymentHash="+encodeURIComponent(e)+"&sequence="+encodeURIComponent(r.toString(10)),a,s),null,n.RequestError,s)}static async setRefundAddress(t,e,r,a,s,o){return(0,i.tryWithRetries)(()=>(0,i.httpGet)(t+"/setRefundAddress?paymentHash="+encodeURIComponent(e)+"&sequence="+encodeURIComponent(r.toString(10))+"&refundAddress="+encodeURIComponent(a),s,o),null,n.RequestError,o)}static async initTrustedFromBTC(t,e,r,o,l){let u=await (0,i.tryWithRetries)(()=>(0,i.httpGet)(e+"/frombtc_trusted/getAddress?chain="+encodeURIComponent(t)+"&address="+encodeURIComponent(r.address)+"&amount="+encodeURIComponent(r.amount.toString(10))+"&refundAddress="+encodeURIComponent(r.refundAddress)+"&exactIn=true&token="+encodeURIComponent(r.token),o,l),null,n.RequestError,l);if(1e4!==u.code)throw n.RequestError.parse(JSON.stringify(u),400);return(0,a.verifySchema)(u.data,s)}}},892114,(t,e,r)=>{"use strict";var i;Object.defineProperty(r,"__esModule",{value:!0}),r.LnForGasSwap=r.isLnForGasSwapInit=r.LnForGasSwapState=void 0;let n=t.r(916232),a=t.r(853312),s=t.r(894705),o=t.r(389215),l=t.r(185670),u=t.r(274516),c=t.r(844485),h=t.r(302887);function p(t){return"string"==typeof t.pr&&"bigint"==typeof t.outputAmount&&"string"==typeof t.recipient&&"string"==typeof t.token&&(0,l.isISwapInit)(t)}!function(t){t[t.EXPIRED=-2]="EXPIRED",t[t.FAILED=-1]="FAILED",t[t.PR_CREATED=0]="PR_CREATED",t[t.PR_PAID=1]="PR_PAID",t[t.FINISHED=2]="FINISHED"}(i=r.LnForGasSwapState||(r.LnForGasSwapState={})),r.isLnForGasSwapInit=p;class d extends l.ISwap{constructor(t,e){if(p(e)&&(e.url+="/lnforgas"),super(t,e),this.currentVersion=2,this.TYPE=a.SwapType.TRUSTED_FROM_BTCLN,p(e)?this.state=i.PR_CREATED:(this.pr=e.pr,this.outputAmount=null==e.outputAmount?null:BigInt(e.outputAmount),this.recipient=e.recipient,this.token=e.token,this.scTxId=e.scTxId),this.tryRecomputeSwapPrice(),null!=this.pr){let t=(0,n.decode)(this.pr);this.expiry=1e3*t.timeExpireDate}this.logger=(0,o.getLogger)("LnForGas("+this.getId()+"): ")}upgradeVersion(){1==this.version&&(1===this.state&&(this.state=i.FINISHED),this.version=2),null==this.version&&(this.version=1)}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getInput().rawAmount/this.getOutAmountWithoutFee()),super.tryRecomputeSwapPrice()}_getEscrowHash(){return this.getId()}getOutputAddress(){return this.recipient}getInputTxId(){return this.getId()}getOutputTxId(){return this.scTxId}getId(){return null==this.pr?null:(0,n.decode)(this.pr).tagsObject.payment_hash}getAddress(){return this.pr}getHyperlink(){return"lightning:"+this.pr.toUpperCase()}requiresAction(){return!1}isFinished(){return this.state===i.FINISHED||this.state===i.FAILED||this.state===i.EXPIRED}isQuoteExpired(){return this.state===i.EXPIRED}isQuoteSoftExpired(){return this.expiry<Date.now()}isFailed(){return this.state===i.FAILED}isSuccessful(){return this.state===i.FINISHED}verifyQuoteValid(){return Promise.resolve(this.expiry>Date.now())}getOutAmountWithoutFee(){return this.outputAmount+this.swapFee}getOutput(){return(0,c.toTokenAmount)(this.outputAmount,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices)}getInput(){let t=(BigInt((0,n.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,c.toTokenAmount)(t,c.BitcoinTokens.BTCLN,this.wrapper.prices)}getInputWithoutFee(){let t=(BigInt((0,n.decode)(this.pr).millisatoshis)+999n)/1000n;return(0,c.toTokenAmount)(t-this.swapFeeBtc,c.BitcoinTokens.BTCLN,this.wrapper.prices)}getSwapFee(){let t=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getInputWithoutFee().rawAmount;return{amountInSrcToken:(0,c.toTokenAmount)(this.swapFeeBtc,c.BitcoinTokens.BTCLN,this.wrapper.prices),amountInDstToken:(0,c.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,t,e),composition:{base:(0,c.toTokenAmount)(this.pricingInfo.satsBaseFee,c.BitcoinTokens.BTCLN,this.wrapper.prices),percentage:(0,l.ppmToPercentage)(t)}}}getFee(){return this.getSwapFee()}getFeeBreakdown(){return[{type:h.FeeType.SWAP,fee:this.getSwapFee()}]}async checkInvoicePaid(t=!0){if(this.state===i.FAILED||this.state===i.EXPIRED)return!1;if(this.state===i.FINISHED)return!0;let e=(0,n.decode)(this.pr).tagsObject.payment_hash,r=await u.TrustedIntermediaryAPI.getInvoiceStatus(this.url,e,this.wrapper.options.getRequestTimeout);switch(this.logger.debug("checkInvoicePaid(): LP response: ",r),r.code){case u.InvoiceStatusResponseCodes.PAID:if(this.scTxId=r.data.txId,"success"===await this.wrapper.chain.getTxIdStatus(this.scTxId))return this.state=i.FINISHED,t&&await this._saveAndEmit(),!0;return null;case u.InvoiceStatusResponseCodes.EXPIRED:return this.state===i.PR_CREATED?this.state=i.EXPIRED:this.state=i.FAILED,t&&await this._saveAndEmit(),!1;case u.InvoiceStatusResponseCodes.TX_SENT:return this.scTxId=r.data.txId,this.state===i.PR_CREATED&&(this.state=i.PR_PAID,t&&await this._saveAndEmit()),null;case u.InvoiceStatusResponseCodes.PENDING:return this.state===i.PR_CREATED&&(this.state=i.PR_PAID,t&&await this._saveAndEmit()),null;case u.InvoiceStatusResponseCodes.AWAIT_PAYMENT:return null;default:return this.state=i.FAILED,t&&await this._saveAndEmit(),!1}}async waitForPayment(t,e=5){if(this.state!==i.PR_CREATED)throw Error("Must be in PR_CREATED state!");for(this.initiated||(this.initiated=!0,await this._saveAndEmit());!t.aborted&&(this.state===i.PR_CREATED||this.state===i.PR_PAID);)await this.checkInvoicePaid(!0),(this.state===i.PR_CREATED||this.state===i.PR_PAID)&&await (0,o.timeoutPromise)(1e3*e,t);if(this.isFailed())throw new s.PaymentAuthError("Swap failed");return!this.isQuoteExpired()}serialize(){return{...super.serialize(),pr:this.pr,outputAmount:null==this.outputAmount?null:this.outputAmount.toString(10),recipient:this.recipient,token:this.token,scTxId:this.scTxId}}_getInitiator(){return this.recipient}async _sync(t){return this.state===i.PR_CREATED&&null!==await this.checkInvoicePaid(!1)&&(t&&await this._saveAndEmit(),!0)}_tick(t){return Promise.resolve(!1)}}r.LnForGasSwap=d},725827,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.LnForGasWrapper=void 0;let i=t.r(892114),n=t.r(934867),a=t.r(274516),s=t.r(916232),o=t.r(46575),l=t.r(853312);class u extends n.ISwapWrapper{constructor(){super(...arguments),this.TYPE=l.SwapType.TRUSTED_FROM_BTCLN,this.swapDeserializer=i.LnForGasSwap,this.pendingSwapStates=[i.LnForGasSwapState.PR_CREATED],this.tickSwapState=null,this.processEvent=null}async create(t,e,r){if(!this.isInitialized)throw Error("Not initialized, call init() first!");let n="string"==typeof r?r:r.url,u=this.chain.getNativeCurrencyAddress(),c=await a.TrustedIntermediaryAPI.initTrustedFromBTCLN(this.chainIdentifier,n,{address:t,amount:e,token:u},this.options.getRequestTimeout),h=(0,s.decode)(c.pr),p=(BigInt(h.millisatoshis)+999n)/1000n;if(c.total!==e)throw new o.IntermediaryError("Invalid total returned");let d=await this.verifyReturnedPrice("string"==typeof r?{swapFeePPM:1e4,swapBaseFee:10}:r.services[l.SwapType.TRUSTED_FROM_BTCLN],!1,p,e,u,{}),f=new i.LnForGasSwap(this,{pr:c.pr,outputAmount:c.total,recipient:t,pricingInfo:d,url:n,expiry:1e3*h.timeExpireDate,swapFee:c.swapFee,token:u,exactIn:!1});return await f._save(),f}}r.LnForGasWrapper=u},458402,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.wrapSwapWithSigner=void 0;let i=t.r(582992),n=t.r(11757),a=t.r(116793);r.wrapSwapWithSigner=function(t,e){return new Proxy(t,{get:(r,s,o)=>"commit"===s&&(t instanceof i.IToBTCSwap||t instanceof n.IFromBTCSwap)?(r,i)=>t.commit(e,r,i):"refund"===s&&t instanceof i.IToBTCSwap?r=>t.refund(e,r):"claim"===s&&t instanceof n.IFromBTCSwap?r=>t.claim(e,r):"commitAndClaim"===s&&t instanceof a.FromBTCLNSwap?(r,i)=>t.commitAndClaim(e,r,i):Reflect.get(r,s,o)})}},583360,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SwapperWithSigner=void 0;let i=t.r(458402);r.SwapperWithSigner=class{get prices(){return this.swapper.prices}get intermediaryDiscovery(){return this.swapper.intermediaryDiscovery}get mempoolApi(){return this.swapper.mempoolApi}get bitcoinRpc(){return this.swapper.bitcoinRpc}get bitcoinNetwork(){return this.swapper.bitcoinNetwork}get Utils(){return this.swapper.Utils}get SwapTypeInfo(){return this.swapper.SwapTypeInfo}constructor(t,e){this.swapper=t,this.signer=e}createToBTCSwap(t,e,r,n,a,s){return this.swapper.createToBTCSwap(this.signer.getAddress(),t,e,r,n,a,s).then(t=>(0,i.wrapSwapWithSigner)(t,this.signer))}createToBTCLNSwap(t,e,r,n){return this.swapper.createToBTCLNSwap(this.signer.getAddress(),t,e,r,n).then(t=>(0,i.wrapSwapWithSigner)(t,this.signer))}createToBTCLNSwapViaLNURL(t,e,r,n,a,s){return this.swapper.createToBTCLNSwapViaLNURL(this.signer.getAddress(),t,e,r,n,a,s).then(t=>(0,i.wrapSwapWithSigner)(t,this.signer))}createFromBTCSwap(t,e,r,n,a){return this.swapper.createFromBTCSwap(this.signer.getAddress(),t,e,r,n,a).then(t=>(0,i.wrapSwapWithSigner)(t,this.signer))}createFromBTCLNSwap(t,e,r,n,a){return this.swapper.createFromBTCLNSwap(this.signer.getAddress(),t,e,r,n,a).then(t=>(0,i.wrapSwapWithSigner)(t,this.signer))}createFromBTCLNSwapViaLNURL(t,e,r,n,a){return this.swapper.createFromBTCLNSwapViaLNURL(this.signer.getAddress(),t,e,r,n,a).then(t=>(0,i.wrapSwapWithSigner)(t,this.signer))}createTrustedLNForGasSwap(t,e){return this.swapper.createTrustedLNForGasSwap(this.signer.getAddress(),t,e)}createTrustedOnchainForGasSwap(t,e,r){return this.swapper.createTrustedOnchainForGasSwap(this.signer.getAddress(),t,e,r)}create(t,e,r,n,a){return this.swapper.create(this.signer.getAddress(),t,e,r,n,a).then(t=>(0,i.wrapSwapWithSigner)(t,this.signer))}getAllSwaps(){return this.swapper.getAllSwaps(this.signer.getAddress())}getActionableSwaps(){return this.swapper.getActionableSwaps(this.signer.getAddress())}getRefundableSwaps(){return this.swapper.getRefundableSwaps(this.signer.getAddress())}getSwapById(t){return this.swapper.getSwapById(t,this.signer.getAddress())}async _syncSwaps(){return this.swapper._syncSwaps(this.signer.getAddress())}supportsSwapType(t){return this.swapper.supportsSwapType(t)}getSwapType(t,e){return this.swapper.getSwapType(t,e)}getSwapLimits(t,e){return this.swapper.getSwapLimits(t,e)}getSwapCounterTokens(t,e){return this.swapper.getSwapCounterTokens(t,e)}getSwapBounds(){return this.swapper.getSwapBounds()}getMaximum(t,e){return this.swapper.getMaximum(t,e)}getMinimum(t,e){return this.swapper.getMinimum(t,e)}}},938944,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SwapperWithChain=void 0;let i=t.r(853312),n=t.r(228252),a=t.r(844485),s=t.r(583360);r.SwapperWithChain=class{get intermediaryDiscovery(){return this.swapper.intermediaryDiscovery}get mempoolApi(){return this.swapper.mempoolApi}get bitcoinRpc(){return this.swapper.bitcoinRpc}get bitcoinNetwork(){return this.swapper.bitcoinNetwork}get Utils(){return this.swapper.Utils}get SwapTypeInfo(){return this.swapper.SwapTypeInfo}constructor(t,e){this.swapper=t,this.chainIdentifier=e,this.prices=new n.SwapPriceWithChain(t.prices,e)}createToBTCSwap(t,e,r,i,n,a,s){return this.swapper.createToBTCSwap(this.chainIdentifier,t,e,r,i,n,a,s)}createToBTCLNSwap(t,e,r,i,n){return this.swapper.createToBTCLNSwap(this.chainIdentifier,t,e,r,i,n)}createToBTCLNSwapViaLNURL(t,e,r,i,n,a,s){return this.swapper.createToBTCLNSwapViaLNURL(this.chainIdentifier,t,e,r,i,n,a,s)}createFromBTCSwap(t,e,r,i,n,a){return this.swapper.createFromBTCSwap(this.chainIdentifier,t,e,r,i,n,a)}createFromBTCLNSwap(t,e,r,i,n,a){return this.swapper.createFromBTCLNSwap(this.chainIdentifier,t,e,r,i,n,a)}createFromBTCLNSwapViaLNURL(t,e,r,i,n,a){return this.swapper.createFromBTCLNSwapViaLNURL(this.chainIdentifier,t,e,r,i,n,a)}createTrustedLNForGasSwap(t,e,r){return this.swapper.createTrustedLNForGasSwap(this.chainIdentifier,t,e,r)}createTrustedOnchainForGasSwap(t,e,r,i){return this.swapper.createTrustedOnchainForGasSwap(this.chainIdentifier,t,e,r,i)}create(t,e,r,i,n,a){return this.swapper.create(t,e,r,i,n,a)}swap(t,e,r,i,n,a,s){return this.swapper.swap(t,e,r,i,n,a,s)}getAllSwaps(t){return this.swapper.getAllSwaps(this.chainIdentifier,t)}getActionableSwaps(t){return this.swapper.getActionableSwaps(this.chainIdentifier,t)}getRefundableSwaps(t){return this.swapper.getRefundableSwaps(this.chainIdentifier,t)}getSwapById(t,e){return this.swapper.getSwapById(t,this.chainIdentifier,e)}async _syncSwaps(t){return this.swapper._syncSwaps(this.chainIdentifier,t)}supportsSwapType(t){return this.swapper.supportsSwapType(this.chainIdentifier,t)}getSwapType(t,e){return this.swapper.getSwapType(t,e)}getSwapLimits(t,e){return this.swapper.getSwapLimits(t,e)}getSupportedTokens(t){let e=[];return this.intermediaryDiscovery.intermediaries.forEach(r=>{let n=t;if((n===i.SwapType.FROM_BTC&&this.supportsSwapType(i.SwapType.SPV_VAULT_FROM_BTC)&&(n=i.SwapType.SPV_VAULT_FROM_BTC),null!=r.services[n])&&null!=r.services[n].chainTokens)for(let t of r.services[n].chainTokens[this.chainIdentifier]){let r=this.swapper.tokens?.[this.chainIdentifier]?.[t];null!=r&&e.push(r)}}),e}getSupportedTokenAddresses(t){let e=new Set;return this.intermediaryDiscovery.intermediaries.forEach(r=>{null!=r.services[t]&&null!=r.services[t].chainTokens&&null!=r.services[t].chainTokens[this.chainIdentifier]&&r.services[t].chainTokens[this.chainIdentifier].forEach(t=>e.add(t))}),e}getSwapCounterTokens(t,e){if((0,a.isSCToken)(t)){let r=[];if(e)this.getSupportedTokenAddresses(i.SwapType.TO_BTCLN).has(t.address)&&r.push(a.BitcoinTokens.BTCLN),this.getSupportedTokenAddresses(i.SwapType.TO_BTC).has(t.address)&&r.push(a.BitcoinTokens.BTC);else{this.getSupportedTokenAddresses(i.SwapType.FROM_BTCLN).has(t.address)&&r.push(a.BitcoinTokens.BTCLN);let e=this.supportsSwapType(i.SwapType.SPV_VAULT_FROM_BTC)?i.SwapType.SPV_VAULT_FROM_BTC:i.SwapType.FROM_BTC;this.getSupportedTokenAddresses(e).has(t.address)&&r.push(a.BitcoinTokens.BTC)}return r}if(e)if(t.lightning)return this.getSupportedTokens(i.SwapType.FROM_BTCLN);else return this.getSupportedTokens(i.SwapType.FROM_BTC);return t.lightning?this.getSupportedTokens(i.SwapType.TO_BTCLN):this.getSupportedTokens(i.SwapType.TO_BTC)}withChain(t){return new s.SwapperWithSigner(this,t)}getSwapBounds(){return this.swapper.getSwapBounds(this.chainIdentifier)}getMaximum(t,e){return this.swapper.getMaximum(this.chainIdentifier,t,e)}getMinimum(t,e){return this.swapper.getMinimum(this.chainIdentifier,t,e)}}},552269,(t,e,r)=>{"use strict";var i;Object.defineProperty(r,"__esModule",{value:!0}),r.OnchainForGasSwap=r.isOnchainForGasSwapInit=r.OnchainForGasSwapState=void 0;let n=t.r(853312),a=t.r(894705),s=t.r(389215),o=t.r(185670),l=t.r(274516),u=t.r(844485),c=t.r(302887),h=t.r(824341),p=t.r(839596),d=t.r(199974),f=t.r(500874);function m(t){return"string"==typeof t.paymentHash&&"bigint"==typeof t.sequence&&"string"==typeof t.address&&"bigint"==typeof t.inputAmount&&"bigint"==typeof t.outputAmount&&"string"==typeof t.recipient&&"string"==typeof t.token&&(null==t.refundAddress||"string"==typeof t.refundAddress)&&(0,o.isISwapInit)(t)}!function(t){t[t.EXPIRED=-3]="EXPIRED",t[t.FAILED=-2]="FAILED",t[t.REFUNDED=-1]="REFUNDED",t[t.PR_CREATED=0]="PR_CREATED",t[t.FINISHED=1]="FINISHED",t[t.REFUNDABLE=2]="REFUNDABLE"}(i=r.OnchainForGasSwapState||(r.OnchainForGasSwapState={})),r.isOnchainForGasSwapInit=m;class g extends o.ISwap{constructor(t,e){m(e)&&(e.url+="/frombtc_trusted"),super(t,e),this.getSmartChainNetworkFee=null,this.TYPE=n.SwapType.TRUSTED_FROM_BTC,m(e)?this.state=i.PR_CREATED:(this.paymentHash=e.paymentHash,this.sequence=null==e.sequence?null:BigInt(e.sequence),this.address=e.address,this.inputAmount=null==e.inputAmount?null:BigInt(e.inputAmount),this.outputAmount=null==e.outputAmount?null:BigInt(e.outputAmount),this.recipient=e.recipient,this.token=e.token,this.refundAddress=e.refundAddress,this.scTxId=e.scTxId,this.txId=e.txId,this.refundTxId=e.refundTxId),this.logger=(0,s.getLogger)("OnchainForGas("+this.getId()+"): "),this.tryRecomputeSwapPrice()}upgradeVersion(){null==this.version&&(this.version=1)}tryRecomputeSwapPrice(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.getInput().rawAmount/this.getOutAmountWithoutFee()),super.tryRecomputeSwapPrice()}_getEscrowHash(){return this.paymentHash}getOutputAddress(){return this.recipient}getInputTxId(){return this.txId}getOutputTxId(){return this.scTxId}getId(){return this.paymentHash}getAddress(){return this.address}getHyperlink(){return"bitcoin:"+this.address+"?amount="+encodeURIComponent((Number(this.inputAmount)/1e8).toString(10))}requiresAction(){return this.state===i.REFUNDABLE}isFinished(){return this.state===i.FINISHED||this.state===i.FAILED||this.state===i.EXPIRED||this.state===i.REFUNDED}isQuoteExpired(){return this.state===i.EXPIRED}isQuoteSoftExpired(){return this.expiry<Date.now()}isFailed(){return this.state===i.FAILED}isSuccessful(){return this.state===i.FINISHED}verifyQuoteValid(){return Promise.resolve(this.expiry>Date.now())}getOutAmountWithoutFee(){return this.outputAmount+this.swapFee}getOutput(){return(0,u.toTokenAmount)(this.outputAmount,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices)}getInput(){return(0,u.toTokenAmount)(this.inputAmount,u.BitcoinTokens.BTC,this.wrapper.prices)}getInputWithoutFee(){return(0,u.toTokenAmount)(this.inputAmount-this.swapFeeBtc,u.BitcoinTokens.BTC,this.wrapper.prices)}getSwapFee(){let t=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/this.getInputWithoutFee().rawAmount;return{amountInSrcToken:(0,u.toTokenAmount)(this.swapFeeBtc,u.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,u.toTokenAmount)(this.swapFee,this.wrapper.tokens[this.wrapper.chain.getNativeCurrencyAddress()],this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc,t,e),composition:{base:(0,u.toTokenAmount)(this.pricingInfo.satsBaseFee,u.BitcoinTokens.BTC,this.wrapper.prices),percentage:(0,o.ppmToPercentage)(t)}}}getFee(){return this.getSwapFee()}getFeeBreakdown(){return[{type:c.FeeType.SWAP,fee:this.getSwapFee()}]}getRequiredConfirmationsCount(){return 1}async getFundedPsbt(t,e){let r;if(this.state!==i.PR_CREATED)throw Error("Swap already paid for!");r=(0,h.isIBitcoinWallet)(t)?t:new d.SingleAddressBitcoinWallet(this.wrapper.btcRpc,this.wrapper.options.bitcoinNetwork,t),null==e&&(e=await r.getFeeRate());let n=new p.Transaction({allowUnknownOutputs:!0,allowLegacyWitnessUtxo:!0});n.addOutput({amount:this.outputAmount,script:(0,s.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address)});let a=await r.fundPsbt(n,e),o=[];for(let t=0;t<a.inputsLength;t++)o.push(t);return{psbt:a,signInputs:o}}async submitPsbt(t){if(this.state!==i.PR_CREATED)throw Error("Swap already paid for!");if(this.expiry<Date.now())throw Error("Swap expired!");let e=t.getOutput(0);if(e.amount!==this.outputAmount)throw Error("PSBT output amount invalid, expected: "+this.outputAmount+" got: "+e.amount);if(!(0,s.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.address).equals(e.script))throw Error("PSBT output script invalid!");return t.isFinal||t.finalize(),await this.wrapper.btcRpc.sendRawTransaction(f.Buffer.from(t.toBytes(!0,!0)).toString("hex"))}async estimateBitcoinFee(t,e){let r=await t.getTransactionFee(this.address,this.inputAmount,e);return(0,u.toTokenAmount)(null==r?null:BigInt(r),u.BitcoinTokens.BTC,this.wrapper.prices)}async sendBitcoinTransaction(t,e){if(this.state!==i.PR_CREATED)throw Error("Swap already paid for!");return await t.sendTransaction(this.address,this.inputAmount,e)}async checkAddress(t=!0){if(this.state===i.FAILED||this.state===i.EXPIRED||this.state===i.REFUNDED||this.state===i.FINISHED)return!1;let e=await l.TrustedIntermediaryAPI.getAddressStatus(this.url,this.paymentHash,this.sequence,this.wrapper.options.getRequestTimeout);switch(e.code){case l.AddressStatusResponseCodes.AWAIT_PAYMENT:if(null!=this.txId)return this.txId=null,t&&await this._save(),!0;return!1;case l.AddressStatusResponseCodes.AWAIT_CONFIRMATION:case l.AddressStatusResponseCodes.PENDING:case l.AddressStatusResponseCodes.TX_SENT:let r=BigInt(e.data.adjustedAmount),n=BigInt(e.data.adjustedTotal),a=null==e.data.adjustedFee?null:BigInt(e.data.adjustedFee),s=null==e.data.adjustedFeeSats?null:BigInt(e.data.adjustedFeeSats),o=e.data.txId;if(this.txId!=o||this.inputAmount!==r||this.outputAmount!==n)return this.txId=o,this.inputAmount=r,this.outputAmount=n,null!=a&&(this.swapFee=a),null!=s&&(this.swapFeeBtc=s),t&&await this._save(),!0;return!1;case l.AddressStatusResponseCodes.PAID:if("success"===await this.wrapper.chain.getTxIdStatus(e.data.txId))return this.state=i.FINISHED,this.scTxId=e.data.txId,t&&await this._saveAndEmit(),!0;return!1;case l.AddressStatusResponseCodes.EXPIRED:return this.state=i.EXPIRED,t&&await this._saveAndEmit(),!0;case l.AddressStatusResponseCodes.REFUNDABLE:if(this.state===i.REFUNDABLE)return null;return this.state=i.REFUNDABLE,t&&await this._saveAndEmit(),!0;case l.AddressStatusResponseCodes.REFUNDED:return this.state=i.REFUNDED,this.refundTxId=e.data.txId,t&&await this._saveAndEmit(),!0;default:return this.state=i.FAILED,t&&await this._saveAndEmit(),!0}}async setRefundAddress(t){if(null!=this.refundAddress){if(this.refundAddress!==t)throw Error("Different refund address already set!");return}await l.TrustedIntermediaryAPI.setRefundAddress(this.url,this.paymentHash,this.sequence,t,this.wrapper.options.getRequestTimeout),this.refundAddress=t}async waitForBitcoinTransaction(t,e=5,r){if(this.state!==i.PR_CREATED)throw Error("Must be in PR_CREATED state!");for(this.initiated||(this.initiated=!0,await this._saveAndEmit());!t.aborted&&this.state===i.PR_CREATED;){if(await this.checkAddress(!0),null!=this.txId&&null!=r){let t=await this.wrapper.btcRpc.getTransaction(this.txId);if(null==t)r(null,null,1,null);else if(t.confirmations>0)r(t.txid,t.confirmations,1,0);else{let e=await this.wrapper.btcRpc.getConfirmationDelay(t,1);r(t.txid,0,1,e)}}this.state===i.PR_CREATED&&await (0,s.timeoutPromise)(1e3*e,t)}if(this.state===i.REFUNDABLE||this.state===i.REFUNDED)return this.txId;if(this.isQuoteExpired())throw new a.PaymentAuthError("Swap expired");if(this.isFailed())throw new a.PaymentAuthError("Swap failed");return this.txId}async waitTillRefunded(t,e=5){if(this.state!==i.REFUNDED){if(this.state!==i.REFUNDABLE)throw Error("Must be in REFUNDABLE state!");for(;!t.aborted&&this.state===i.REFUNDABLE;)await this.checkAddress(!0),this.state===i.REFUNDABLE&&await (0,s.timeoutPromise)(1e3*e,t);if(this.isQuoteExpired())throw new a.PaymentAuthError("Swap expired");if(this.isFailed())throw new a.PaymentAuthError("Swap failed")}}async requestRefund(t,e){null!=t&&await this.setRefundAddress(t),await this.waitTillRefunded(e)}serialize(){return{...super.serialize(),paymentHash:this.paymentHash,sequence:null==this.sequence?null:this.sequence.toString(10),address:this.address,inputAmount:null==this.inputAmount?null:this.inputAmount.toString(10),outputAmount:null==this.outputAmount?null:this.outputAmount.toString(10),recipient:this.recipient,token:this.token,refundAddress:this.refundAddress,scTxId:this.scTxId,txId:this.txId,refundTxId:this.refundTxId}}_getInitiator(){return this.recipient}async _sync(t){return!!(this.state===i.PR_CREATED&&await this.checkAddress(!1))&&(t&&await this._saveAndEmit(),!0)}_tick(t){return Promise.resolve(!1)}}r.OnchainForGasSwap=g},538657,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.OnchainForGasWrapper=void 0;let i=t.r(934867),n=t.r(274516),a=t.r(46575),s=t.r(552269),o=t.r(853312);class l extends i.ISwapWrapper{constructor(t,e,r,i,n,a,l,u,c){super(t,e,r,i,n,a,u,c),this.TYPE=o.SwapType.TRUSTED_FROM_BTC,this.swapDeserializer=s.OnchainForGasSwap,this.pendingSwapStates=[s.OnchainForGasSwapState.PR_CREATED],this.tickSwapState=null,this.processEvent=null,this.btcRpc=l}async create(t,e,r,i){if(!this.isInitialized)throw Error("Not initialized, call init() first!");let l="string"==typeof r?r:r.url,u=this.chain.getNativeCurrencyAddress(),c=await n.TrustedIntermediaryAPI.initTrustedFromBTC(this.chainIdentifier,l,{address:t,amount:e,refundAddress:i,token:u},this.options.getRequestTimeout);if(c.total!==e)throw new a.IntermediaryError("Invalid total returned");let h=await this.verifyReturnedPrice("string"==typeof r?{swapFeePPM:1e4,swapBaseFee:10}:r.services[o.SwapType.TRUSTED_FROM_BTC],!1,c.amountSats,e,this.chain.getNativeCurrencyAddress(),{}),p=new s.OnchainForGasSwap(this,{paymentHash:c.paymentHash,sequence:c.sequence,address:c.btcAddress,inputAmount:c.amountSats,outputAmount:c.total,recipient:t,refundAddress:i,pricingInfo:h,url:l,expiry:c.expiresAt,swapFee:c.swapFee,swapFeeBtc:c.swapFeeSats,exactIn:!1,token:u});return await p._save(),p}}r.OnchainForGasWrapper=l},207901,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.IndexedDBUnifiedStorage=void 0;let i=t.r(389215),n={escrowHash:{key:"escrowHash",unique:!0},type:{key:"type",unique:!1},initiator:{key:"initiator",unique:!1},"initiator, id":{key:["initiator","id"],unique:!1},"type, state":{key:["type","state"],unique:!1},"type, paymentHash":{key:["type","paymentHash"],unique:!1},"type, initiator, state":{key:["type","initiator","state"],unique:!1}};r.IndexedDBUnifiedStorage=class{constructor(t){this.storageKey=t,this.logger=(0,i.getLogger)("IndexedDBUnifiedStorage("+this.storageKey+"): ")}async tryMigrateLocalStorage(t,e,r){let i,n=window.localStorage.getItem(t);if(null==n)return!1;try{i=JSON.parse(n)}catch(e){return this.logger.warn("tryMigrate("+t+"): Tried to migrate the database, but cannot parse old local storage!"),!1}let a=Object.keys(i).map(t=>{let n=i[t];return n.type=e,r(n)});return await this.saveAll(a.map(t=>t.serialize())),window.localStorage.removeItem(t),this.logger.info("tryMigrate("+t+"): Database successfully migrated from localStorage to unifiedIndexedDB!"),!0}async tryMigrateOldIndexedDB(t,e,r){let i;if(null==(await window.indexedDB.databases()).find(e=>e.name===t))return this.logger.info("tryMigrateOldIndexedDB("+t+"): Old database not found!"),!1;this.logger.debug("tryMigrateOldIndexedDB("+t+"): Old database found!");try{i=await new Promise((e,r)=>{let i=window.indexedDB.open(t,1);i.onerror=t=>r(t),i.onsuccess=t=>e(t.target.result)})}catch(e){return this.logger.warn("tryMigrateOldIndexedDB("+t+"): Error opening old IndexedDB!",e),!1}this.logger.debug("tryMigrateOldIndexedDB("+t+"): Connection opened!");try{let n=await new Promise((t,e)=>{let r=i.transaction("swaps","readonly",{durability:"strict"}).objectStore("swaps").getAll();r.onsuccess=e=>t(e.target.result),r.onerror=t=>e(t)});this.logger.debug("tryMigrateOldIndexedDB("+t+"): Data retrieved!");let a=n.map(({id:t,data:i})=>(i.type=e,r(i)));return this.logger.debug("tryMigrateOldIndexedDB("+t+"): Data revived!"),await this.saveAll(a.map(t=>t.serialize())),this.logger.debug("tryMigrateOldIndexedDB("+t+"): Data saved!"),i.close(),this.logger.debug("tryMigrateOldIndexedDB("+t+"): DB connection closed!"),await new Promise((e,r)=>{let i=window.indexedDB.deleteDatabase(t);i.onsuccess=()=>e(),i.onerror=t=>r(t)}),this.logger.info("tryMigrateOldIndexedDB("+t+"): Database successfully migrated from oldIndexedDB to unifiedIndexedDB!"),!0}catch(e){return this.logger.warn("tryMigrateOldIndexedDB("+t+"): Tried to migrate the database, but cannot parse oldIndexedDB!",e),!1}}async tryMigrate(t,e){let r=!1;for(let i of t)this.logger.info("tryMigrate(): Trying to migrate...",i),await this.tryMigrateLocalStorage(i[0],i[1],e)&&(r=!0),await this.tryMigrateOldIndexedDB(i[0],i[1],e)&&(r=!0);return r}executeTransaction(t,e){return new Promise((r,i)=>{let n=t(this.db.transaction("swaps",e?"readonly":"readwrite",{durability:"strict"}).objectStore("swaps"));n.onsuccess=t=>r(t.target.result),n.onerror=t=>i(t)})}executeTransactionArr(t,e){return Promise.all(t(this.db.transaction("swaps",e?"readonly":"readwrite",{durability:"strict"}).objectStore("swaps")).map(t=>new Promise((e,r)=>{t.onsuccess=t=>e(t.target.result),t.onerror=t=>r(t)})))}executeTransactionWithCursor(t,e){return new Promise((r,i)=>{let n=t(this.db.transaction("swaps","readonly",{durability:"strict"}).objectStore("swaps")),a=[];for(let t of n)t.onsuccess=t=>{let i=t.target.result;if(null!=i){let t=i.value;e(t)&&a.push(t),i.continue()}else r(a)},t.onerror=t=>i(t)})}async init(){null==this.db&&(this.db=await new Promise((t,e)=>{let r=window.indexedDB.open(this.storageKey,1);r.onupgradeneeded=t=>{let e=t.target.result.createObjectStore("swaps",{keyPath:"id"});Object.keys(n).forEach(t=>{let r=n[t];e.createIndex(t,r.key,{unique:r.unique})})},r.onerror=t=>e(t),r.onsuccess=e=>t(e.target.result)}))}async query(t){return 0===t.length?await this.querySingle([]):Array.from(new Set((await Promise.all(t.map(t=>this.querySingle(t)))).flat()))}async querySingle(t){if(0===t.length)return await this.executeTransaction(t=>t.getAll(),!0);let e=t.map(t=>t.key).join(", ");if("id"===e){let e=Array.isArray(t[0].value)?t[0].value:[t[0].value];return(await this.executeTransactionArr(t=>e.map(e=>t.getAll(e)),!0)).flat()}if(null!=n[e]){let r=function t(e){if(0===e.length)return[];if(1===e.length)return e[0];{let r=[],i=e.shift(),n=t(e);for(let t of i)for(let e of n)r.push([t].concat(e));return r}}(t.map(t=>Array.isArray(t.value)?t.value:[t.value]));return(await this.executeTransactionArr(t=>{let i=t.index(e);return r.map(t=>i.getAll(t))},!0)).flat()}{this.logger.warn("query(): Index cannot be used for query, required index: "+e+" query params: ",t);let r=t.map(t=>({key:t.key,values:new Set(Array.isArray(t.value)?t.value:[t.value])}));return await this.executeTransactionWithCursor(t=>[t.openCursor()],t=>(function(t,e){for(let r of t){let t=e[r.key];if(!r.values.has(t))return!1}return!0})(r,t))}}async remove(t){await this.executeTransaction(e=>e.delete(t.id),!1).catch(()=>null)}async removeAll(t){0!==t.length&&await this.executeTransactionArr(e=>t.map(t=>e.delete(t.id)),!1)}async save(t){await this.executeTransaction(e=>e.put(t),!1)}async saveAll(t){0!==t.length&&await this.executeTransactionArr(e=>t.map(t=>e.put(t)),!1)}}},706581,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.UnifiedSwapStorage=void 0;let i=(0,t.r(389215).getLogger)("UnifiedSwapStorage: "),n=[{key:"id",type:"string",unique:!0,nullable:!1},{key:"escrowHash",type:"string",unique:!0,nullable:!0},{key:"type",type:"number",unique:!1,nullable:!1},{key:"initiator",type:"string",unique:!1,nullable:!1},{key:"state",type:"number",unique:!1,nullable:!1},{key:"paymentHash",type:"string",unique:!1,nullable:!0}],a=[{keys:["initiator","id"],unique:!1},{keys:["type","state"],unique:!1},{keys:["type","paymentHash"],unique:!1},{keys:["type","initiator","state"],unique:!1}];r.UnifiedSwapStorage=class{constructor(t,e){this.weakRefCache=new Map,this.storage=t,this.noWeakRefMap=e}init(){return this.storage.init(n,a)}async query(t,e){return(await this.storage.query(t)).map(t=>{if(!this.noWeakRefMap){let e=this.weakRefCache.get(t.id)?.deref();if(null!=e)return e;i.debug("query(): Reviving new swap instance: "+t.id)}let r=e(t);return this.noWeakRefMap||this.weakRefCache.set(t.id,new WeakRef(r)),r})}save(t){return this.noWeakRefMap||this.weakRefCache.set(t.getId(),new WeakRef(t)),this.storage.save(t.serialize())}saveAll(t){return this.noWeakRefMap||t.forEach(t=>this.weakRefCache.set(t.getId(),new WeakRef(t))),this.storage.saveAll(t.map(t=>t.serialize()))}remove(t){return this.noWeakRefMap||this.weakRefCache.delete(t.getId()),this.storage.remove(t.serialize())}removeAll(t){return this.noWeakRefMap||t.forEach(t=>this.weakRefCache.delete(t.getId())),this.storage.removeAll(t.map(t=>t.serialize()))}}},491357,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.UnifiedSwapEventListener=void 0;let i=t.r(154585);function n(t){return t instanceof i.SwapEvent?t.escrowHash:t instanceof i.SpvVaultFrontEvent||t instanceof i.SpvVaultClaimEvent||t instanceof i.SpvVaultCloseEvent?t.btcTxId:void 0}r.UnifiedSwapEventListener=class{constructor(t,e){this.listeners={},this.storage=t,this.events=e}async processEvents(t){let e={};for(let r of(t.forEach(t=>{e[n(t)]=null}),(await this.storage.query([[{key:"escrowHash",value:Object.keys(e)}]],t=>{let e=this.listeners[t.type];return null==e?null:new e.reviver(t)})).forEach(t=>e[t._getEscrowHash()]=t),t)){let t=e[n(r)];if(null==t)continue;let i=this.listeners[t.getType()];null!=i&&await i.listener(r,t)}}async start(){null==this.listener&&(await this.storage.init(),await this.events.init(),this.events.registerListener(this.listener=async t=>(await this.processEvents(t),!0)))}stop(){return this.events.unregisterListener(this.listener),this.events.stop()}registerListener(t,e,r){this.listeners[t]={listener:e,reviver:r}}unregisterListener(t){return!this.listeners[t]&&(delete this.listeners[t],!0)}}},90222,(t,e,r)=>{"use strict";var i;Object.defineProperty(r,"__esModule",{value:!0}),r.SpvFromBTCSwap=r.isSpvFromBTCSwapInit=r.SpvFromBTCSwapState=void 0;let n=t.r(185670),a=t.r(154585),s=t.r(853312),o=t.r(389215),l=t.r(839596),u=t.r(844485),c=t.r(500874),h=t.r(302887),p=t.r(824341),d=t.r(302071),f=t.r(199974);function m(t){return"object"==typeof t&&"string"==typeof t.quoteId&&"string"==typeof t.recipient&&"string"==typeof t.vaultOwner&&"bigint"==typeof t.vaultId&&"number"==typeof t.vaultRequiredConfirmations&&Array.isArray(t.vaultTokenMultipliers)&&t.vaultTokenMultipliers.reduce((t,e)=>t&&"bigint"==typeof e,!0)&&"string"==typeof t.vaultBtcAddress&&"string"==typeof t.vaultUtxo&&"bigint"==typeof t.vaultUtxoValue&&"string"==typeof t.btcDestinationAddress&&"bigint"==typeof t.btcAmount&&"bigint"==typeof t.btcAmountSwap&&"bigint"==typeof t.btcAmountGas&&"number"==typeof t.minimumBtcFeeRate&&"bigint"==typeof t.outputTotalSwap&&"string"==typeof t.outputSwapToken&&"bigint"==typeof t.outputTotalGas&&"string"==typeof t.outputGasToken&&"bigint"==typeof t.gasSwapFeeBtc&&"bigint"==typeof t.gasSwapFee&&"bigint"==typeof t.callerFeeShare&&"bigint"==typeof t.frontingFeeShare&&"bigint"==typeof t.executionFeeShare&&(0,n.isISwapInit)(t)}!function(t){t[t.CLOSED=-5]="CLOSED",t[t.FAILED=-4]="FAILED",t[t.DECLINED=-3]="DECLINED",t[t.QUOTE_EXPIRED=-2]="QUOTE_EXPIRED",t[t.QUOTE_SOFT_EXPIRED=-1]="QUOTE_SOFT_EXPIRED",t[t.CREATED=0]="CREATED",t[t.SIGNED=1]="SIGNED",t[t.POSTED=2]="POSTED",t[t.BROADCASTED=3]="BROADCASTED",t[t.FRONTED=4]="FRONTED",t[t.BTC_TX_CONFIRMED=5]="BTC_TX_CONFIRMED",t[t.CLAIMED=6]="CLAIMED"}(i=r.SpvFromBTCSwapState||(r.SpvFromBTCSwapState={})),r.isSpvFromBTCSwapInit=m;class g extends n.ISwap{constructor(t,e){if(m(e)&&(e.url+="/frombtc_spv"),super(t,e),this.TYPE=s.SwapType.SPV_VAULT_FROM_BTC,m(e)){this.state=i.CREATED;let t=(0,o.toCoinselectAddressType)((0,o.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.vaultBtcAddress));if("p2tr"!==t&&"p2wpkh"!==t&&"p2wsh"!==t)throw Error("Vault address type must be of witness type: p2tr, p2wpkh, p2wsh")}else this.quoteId=e.quoteId,this.recipient=e.recipient,this.vaultOwner=e.vaultOwner,this.vaultId=BigInt(e.vaultId),this.vaultRequiredConfirmations=e.vaultRequiredConfirmations,this.vaultTokenMultipliers=e.vaultTokenMultipliers.map(t=>BigInt(t)),this.vaultBtcAddress=e.vaultBtcAddress,this.vaultUtxo=e.vaultUtxo,this.vaultUtxoValue=BigInt(e.vaultUtxoValue),this.btcDestinationAddress=e.btcDestinationAddress,this.btcAmount=BigInt(e.btcAmount),this.btcAmountSwap=BigInt(e.btcAmountSwap),this.btcAmountGas=BigInt(e.btcAmountGas),this.minimumBtcFeeRate=e.minimumBtcFeeRate,this.outputTotalSwap=BigInt(e.outputTotalSwap),this.outputSwapToken=e.outputSwapToken,this.outputTotalGas=BigInt(e.outputTotalGas),this.outputGasToken=e.outputGasToken,this.gasSwapFeeBtc=BigInt(e.gasSwapFeeBtc),this.gasSwapFee=BigInt(e.gasSwapFee),this.callerFeeShare=BigInt(e.callerFeeShare),this.frontingFeeShare=BigInt(e.frontingFeeShare),this.executionFeeShare=BigInt(e.executionFeeShare),this.claimTxId=e.claimTxId,this.frontTxId=e.frontTxId,this.data=null==e.data?null:new this.wrapper.spvWithdrawalDataDeserializer(e.data);this.tryCalculateSwapFee(),this.logger=(0,o.getLogger)("SPVFromBTC("+this.getId()+"): ")}upgradeVersion(){}tryCalculateSwapFee(){null==this.swapFeeBtc&&(this.swapFeeBtc=this.swapFee*this.btcAmountSwap/this.getOutputWithoutFee().rawAmount),null==this.pricingInfo.swapPriceUSatPerToken&&(this.pricingInfo=this.wrapper.prices.recomputePriceInfoReceive(this.chainIdentifier,this.btcAmountSwap,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,this.getOutputWithoutFee().rawAmount,this.outputSwapToken))}async refreshPriceData(){if(null==this.pricingInfo)return null;this.pricingInfo=await this.wrapper.prices.isValidAmountReceive(this.chainIdentifier,this.btcAmountSwap,this.pricingInfo.satsBaseFee,this.pricingInfo.feePPM,this.getOutputWithoutFee().rawAmount,this.outputSwapToken)}_getInitiator(){return this.recipient}_getEscrowHash(){return this.data?.btcTx?.txid}getId(){return this.quoteId+this.randomNonce}getQuoteExpiry(){return this.expiry-2e4}verifyQuoteValid(){return Promise.resolve(this.expiry>Date.now()&&(this.state===i.CREATED||this.state===i.QUOTE_SOFT_EXPIRED))}getOutputAddress(){return this.recipient}getOutputTxId(){return this.frontTxId??this.claimTxId}getInputTxId(){return this.data?.btcTx?.txid}requiresAction(){return this.state===i.BTC_TX_CONFIRMED}isFinished(){return this.state===i.CLAIMED||this.state===i.QUOTE_EXPIRED||this.state===i.FAILED}isClaimable(){return this.state===i.BTC_TX_CONFIRMED}isSuccessful(){return this.state===i.FRONTED||this.state===i.CLAIMED}isFailed(){return this.state===i.FAILED||this.state===i.DECLINED||this.state===i.CLOSED}isQuoteExpired(){return this.state===i.QUOTE_EXPIRED}isQuoteSoftExpired(){return this.state===i.QUOTE_EXPIRED||this.state===i.QUOTE_SOFT_EXPIRED}getInputSwapAmountWithoutFee(){return(this.btcAmountSwap-this.swapFeeBtc)*100000n/(100000n+this.callerFeeShare+this.frontingFeeShare+this.executionFeeShare)}getInputGasAmountWithoutFee(){return(this.btcAmountGas-this.gasSwapFeeBtc)*100000n/(100000n+this.callerFeeShare+this.frontingFeeShare)}getInputAmountWithoutFee(){return this.getInputSwapAmountWithoutFee()+this.getInputGasAmountWithoutFee()}getOutputWithoutFee(){return(0,u.toTokenAmount)(this.outputTotalSwap*(100000n+this.callerFeeShare+this.frontingFeeShare+this.executionFeeShare)/100000n+this.swapFee,this.wrapper.tokens[this.outputSwapToken],this.wrapper.prices)}getSwapFee(){let t=this.wrapper.tokens[this.outputSwapToken],e=this.gasSwapFeeBtc*10n**BigInt(t.decimals)*1000000n/this.pricingInfo.swapPriceUSatPerToken,r=1000000n*(this.swapFeeBtc-this.pricingInfo.satsBaseFee)/(this.btcAmount-this.swapFeeBtc-this.gasSwapFeeBtc);return{amountInSrcToken:(0,u.toTokenAmount)(this.swapFeeBtc+this.gasSwapFeeBtc,u.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,u.toTokenAmount)(this.swapFee+e,t,this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(this.swapFeeBtc+this.gasSwapFeeBtc,t,e),composition:{base:(0,u.toTokenAmount)(this.pricingInfo.satsBaseFee,u.BitcoinTokens.BTC,this.wrapper.prices),percentage:(0,n.ppmToPercentage)(r)}}}getWatchtowerFee(){let t=this.callerFeeShare+this.frontingFeeShare,e=this.wrapper.tokens[this.outputSwapToken],r=this.getInputGasAmountWithoutFee()*t*10n**BigInt(e.decimals)*1000000n/this.pricingInfo.swapPriceUSatPerToken/100000n,i=this.getInputAmountWithoutFee()*(t+this.executionFeeShare)/100000n;return{amountInSrcToken:(0,u.toTokenAmount)(i,u.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,u.toTokenAmount)(this.outputTotalSwap*(t+this.executionFeeShare)/100000n+r,e,this.wrapper.prices),usdValue:(t,e)=>this.wrapper.prices.getBtcUsdValue(i,t,e)}}getFee(){let t=this.getSwapFee(),e=this.getWatchtowerFee();return{amountInSrcToken:(0,u.toTokenAmount)(t.amountInSrcToken.rawAmount+e.amountInSrcToken.rawAmount,u.BitcoinTokens.BTC,this.wrapper.prices),amountInDstToken:(0,u.toTokenAmount)(t.amountInDstToken.rawAmount+e.amountInDstToken.rawAmount,this.wrapper.tokens[this.outputSwapToken],this.wrapper.prices),usdValue:(r,i)=>this.wrapper.prices.getBtcUsdValue(t.amountInSrcToken.rawAmount+e.amountInSrcToken.rawAmount,r,i)}}getFeeBreakdown(){return[{type:h.FeeType.SWAP,fee:this.getSwapFee()},{type:h.FeeType.NETWORK_OUTPUT,fee:this.getWatchtowerFee()}]}getOutput(){return(0,u.toTokenAmount)(this.outputTotalSwap,this.wrapper.tokens[this.outputSwapToken],this.wrapper.prices)}getGasDropOutput(){return(0,u.toTokenAmount)(this.outputTotalGas,this.wrapper.tokens[this.outputGasToken],this.wrapper.prices)}getInputWithoutFee(){return(0,u.toTokenAmount)(this.getInputAmountWithoutFee(),u.BitcoinTokens.BTC,this.wrapper.prices)}getInput(){return(0,u.toTokenAmount)(this.btcAmount,u.BitcoinTokens.BTC,this.wrapper.prices)}getRequiredConfirmationsCount(){return this.vaultRequiredConfirmations}async getTransactionDetails(){let[t,e]=this.vaultUtxo.split(":"),r=(0,o.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.vaultBtcAddress),i=(0,o.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.btcDestinationAddress),n=this.wrapper.contract.toOpReturnData(this.recipient,[this.outputTotalSwap/this.vaultTokenMultipliers[0],this.outputTotalGas/this.vaultTokenMultipliers[1]]),a=c.Buffer.concat([n.length>75?c.Buffer.from([106,76,n.length]):c.Buffer.from([106,n.length]),n]);if(this.callerFeeShare<0n||this.callerFeeShare>1048575n)throw Error("Caller fee out of bounds!");if(this.frontingFeeShare<0n||this.frontingFeeShare>1048575n)throw Error("Fronting fee out of bounds!");if(this.executionFeeShare<0n||this.executionFeeShare>1048575n)throw Error("Execution fee out of bounds!");let s=2147483648n|1048575n&this.callerFeeShare|(1047552n&this.frontingFeeShare)<<10n,l=2147483648n|1048575n&this.executionFeeShare|(1023n&this.frontingFeeShare)<<20n;return{in0txid:t,in0vout:parseInt(e),in0sequence:Number(s),vaultAmount:this.vaultUtxoValue,vaultScript:r,in1sequence:Number(l),out1script:a,out2amount:this.btcAmount,out2script:i,locktime:5e8+Math.floor(1e9*Math.random())}}async getPsbt(){let t=await this.getTransactionDetails(),e=new l.Transaction({allowUnknownOutputs:!0,allowLegacyWitnessUtxo:!0,lockTime:t.locktime});return e.addInput({txid:t.in0txid,index:t.in0vout,witnessUtxo:{amount:t.vaultAmount,script:t.vaultScript},sequence:t.in0sequence}),e.addOutput({amount:t.vaultAmount,script:t.vaultScript}),e.addOutput({amount:0n,script:t.out1script}),e.addOutput({amount:t.out2amount,script:t.out2script}),{psbt:e,in1sequence:t.in1sequence}}async getFundedPsbt(t,e){let r;if(r=(0,p.isIBitcoinWallet)(t)?t:new f.SingleAddressBitcoinWallet(this.wrapper.btcRpc,this.wrapper.options.bitcoinNetwork,t),null!=e){if(e<this.minimumBtcFeeRate)throw Error("Bitcoin tx fee needs to be at least "+this.minimumBtcFeeRate+" sats/vB")}else e=Math.max(this.minimumBtcFeeRate,await r.getFeeRate());let{psbt:i,in1sequence:n}=await this.getPsbt();(i=await r.fundPsbt(i,e)).updateInput(1,{sequence:n});let a=[];for(let t=1;t<i.inputsLength;t++)a.push(t);return{psbt:i,signInputs:a}}async submitPsbt(t){if(this.expiry<Date.now())throw Error("Quote expired!");if(this.state!==i.QUOTE_SOFT_EXPIRED&&this.state!==i.CREATED)throw Error("Invalid swap state!");for(let e=1;e<t.inputsLength;e++){if("legacy"===(0,l.getInputType)(t.getInput(e)).txType)throw Error("Legacy (non-segwit) inputs are not allowed in the transaction!");t.finalizeIdx(e)}let e=await this.wrapper.btcRpc.parseTransaction(c.Buffer.from(t.toBytes(!0)).toString("hex")),r=await this.wrapper.contract.getWithdrawalData(e);if(this.logger.debug("submitPsbt(): parsed withdrawal data: ",r),!r.isRecipient(this.recipient)||r.rawAmounts[0]*this.vaultTokenMultipliers[0]!==this.outputTotalSwap||(r.rawAmounts[1]??0n)*this.vaultTokenMultipliers[1]!==this.outputTotalGas||r.callerFeeRate!==this.callerFeeShare||r.frontingFeeRate!==this.frontingFeeShare||r.executionFeeRate!==this.executionFeeShare||r.getSpentVaultUtxo()!==this.vaultUtxo||BigInt(r.getNewVaultBtcAmount())!==this.vaultUtxoValue||!r.getNewVaultScript().equals((0,o.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.vaultBtcAddress))||null!=r.getExecutionData())throw Error("Invalid withdrawal tx data submitted!");let n=t.getOutput(2);if(n.amount!==this.btcAmount||!(0,o.toOutputScript)(this.wrapper.options.bitcoinNetwork,this.btcDestinationAddress).equals(c.Buffer.from(n.script)))throw Error("Invalid LP bitcoin output in transaction!");if(await this.wrapper.btcRpc.isSpent(this.vaultUtxo))throw Error("Vault UTXO already spent, please create new swap!");try{await this.wrapper.contract.checkWithdrawalTx(r)}catch(t){throw Error("Transaction not parsable by the contract: "+(t.message??t.toString()))}if(this.expiry<Date.now())throw Error("Quote expired!");this.data=r,this.initiated=!0,await this._saveAndEmit(i.SIGNED);try{await d.IntermediaryAPI.initSpvFromBTC(this.chainIdentifier,this.url,{quoteId:this.quoteId,psbtHex:c.Buffer.from(t.toPSBT(0)).toString("hex")}),await this._saveAndEmit(i.POSTED)}catch(t){throw await this._saveAndEmit(i.DECLINED),t}return this.data.getTxId()}async estimateBitcoinFee(t,e){let r=await t.getFundedPsbtFee((await this.getPsbt()).psbt,e);return(0,u.toTokenAmount)(null==r?null:BigInt(r),u.BitcoinTokens.BTC,this.wrapper.prices)}async sendBitcoinTransaction(t,e){let{psbt:r,signInputs:i}=await this.getFundedPsbt(t,e);return r=await t.signPsbt(r,i),await this.submitPsbt(r)}async getBitcoinPayment(){if(this.data?.btcTx?.txid==null)return null;let t=await this.wrapper.btcRpc.getTransaction(this.data?.btcTx?.txid);return null==t?null:{txId:t.txid,confirmations:t.confirmations,targetConfirmations:this.vaultRequiredConfirmations}}async waitForBitcoinTransaction(t,e,r){if(this.state!==i.POSTED&&this.state!==i.BROADCASTED&&!(this.state===i.QUOTE_SOFT_EXPIRED&&this.initiated))throw Error("Must be in POSTED or BROADCASTED state!");let n=await this.wrapper.btcRpc.waitForTransaction(this.data.btcTx.txid,this.vaultRequiredConfirmations,(t,e,n)=>{null!=r&&r(e,t,this.vaultRequiredConfirmations,n),null!=e&&(this.state===i.POSTED||this.state==i.QUOTE_SOFT_EXPIRED)&&this._saveAndEmit(i.BROADCASTED)},t,e);return null!=t&&t.throwIfAborted(),this.state!==i.FRONTED&&this.state!==i.CLAIMED&&await this._saveAndEmit(i.BTC_TX_CONFIRMED),n.txid}async txsClaim(t){if(!this.isClaimable())throw Error("Must be in BTC_TX_CONFIRMED state!");let e=await this.wrapper.contract.getVaultData(this.vaultOwner,this.vaultId),r=[await this.wrapper.btcRpc.getTransaction(this.data.btcTx.txid)],i=e.getUtxo();for(;r[0].ins[0].txid+":"+r[0].ins[0].vout!==i;)r.unshift(await this.wrapper.btcRpc.getTransaction(r[0].ins[0].txid));let n=[];for(let t of r)n.push(await this.wrapper.contract.getWithdrawalData(t));return await this.wrapper.contract.txsClaim(null==t?this._getInitiator():t.getAddress(),e,n.map(t=>({tx:t})),this.wrapper.synchronizer,!0)}async claim(t,e){let r;try{r=await this.wrapper.chain.sendAndConfirm(t,await this.txsClaim(t),!0,e)}catch(e){if(this.logger.info("claim(): Failed to claim ourselves, checking swap claim state..."),this.state===i.CLAIMED)return this.logger.info("claim(): Transaction state is CLAIMED, swap was successfully claimed by the watchtower"),this.claimTxId;let t=await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);if(t.type===a.SpvWithdrawalStateType.CLAIMED)return this.logger.info("claim(): Transaction status is CLAIMED, swap was successfully claimed by the watchtower"),this.claimTxId=t.txId,await this._saveAndEmit(i.CLAIMED),null;throw e}return this.claimTxId=r[0],(this.state===i.POSTED||this.state===i.BROADCASTED||this.state===i.BTC_TX_CONFIRMED||this.state===i.FAILED||this.state===i.FRONTED)&&await this._saveAndEmit(i.CLAIMED),r[0]}async watchdogWaitTillResult(t,e=5){let r={type:a.SpvWithdrawalStateType.NOT_FOUND};for(;r.type===a.SpvWithdrawalStateType.NOT_FOUND;){await (0,o.timeoutPromise)(1e3*e,t);try{r=await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid)}catch(t){this.logger.error("watchdogWaitTillResult(): Error when fetching commit status: ",t)}}return null!=t&&t.throwIfAborted(),r}async waitTillClaimedOrFronted(t){if(this.state===i.CLAIMED||this.state===i.FRONTED)return Promise.resolve();let e=new AbortController;null!=t&&t.addEventListener("abort",()=>e.abort(t.reason));let r=await Promise.race([this.watchdogWaitTillResult(e.signal),this.waitTillState(i.CLAIMED,"eq",e.signal).then(()=>0),this.waitTillState(i.FRONTED,"eq",e.signal).then(()=>1),this.waitTillState(i.FAILED,"eq",e.signal).then(()=>2)]);if(e.abort(),"number"==typeof r){if(0===r)return void this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (CLAIMED)");if(1===r)return void this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (FRONTED)");if(2===r)throw this.logger.debug("waitTillClaimedOrFronted(): Resolved from state change (FAILED)"),Error("Swap failed while waiting for claim or front");return}this.logger.debug("waitTillClaimedOrFronted(): Resolved from watchdog"),r.type===a.SpvWithdrawalStateType.FRONTED&&(this.state!==i.FRONTED||this.state!==i.CLAIMED)&&(this.frontTxId=r.txId,await this._saveAndEmit(i.FRONTED)),r.type===a.SpvWithdrawalStateType.CLAIMED&&this.state!==i.CLAIMED&&(this.claimTxId=r.txId,await this._saveAndEmit(i.FRONTED)),r.type===a.SpvWithdrawalStateType.CLOSED&&this.state!==i.CLOSED&&await this._saveAndEmit(i.CLOSED)}async waitTillExecuted(t,e,r){await this.waitForBitcoinTransaction(t,e,r),await this.waitTillClaimedOrFronted(t)}serialize(){return{...super.serialize(),quoteId:this.quoteId,recipient:this.recipient,vaultOwner:this.vaultOwner,vaultId:this.vaultId.toString(10),vaultRequiredConfirmations:this.vaultRequiredConfirmations,vaultTokenMultipliers:this.vaultTokenMultipliers.map(t=>t.toString(10)),vaultBtcAddress:this.vaultBtcAddress,vaultUtxo:this.vaultUtxo,vaultUtxoValue:this.vaultUtxoValue.toString(10),btcDestinationAddress:this.btcDestinationAddress,btcAmount:this.btcAmount.toString(10),btcAmountSwap:this.btcAmountSwap.toString(10),btcAmountGas:this.btcAmountGas.toString(10),minimumBtcFeeRate:this.minimumBtcFeeRate,outputTotalSwap:this.outputTotalSwap.toString(10),outputSwapToken:this.outputSwapToken,outputTotalGas:this.outputTotalGas.toString(10),outputGasToken:this.outputGasToken,gasSwapFeeBtc:this.gasSwapFeeBtc.toString(10),gasSwapFee:this.gasSwapFee.toString(10),callerFeeShare:this.callerFeeShare.toString(10),frontingFeeShare:this.frontingFeeShare.toString(10),executionFeeShare:this.executionFeeShare.toString(10),claimTxId:this.claimTxId,frontTxId:this.frontTxId,data:this.data?.serialize()}}async syncStateFromBitcoin(t){if(this.data?.btcTx==null)return!1;let e=await this.getBitcoinPayment();if(null==e){for(let e of this.data.btcTx.ins)if(await this.wrapper.btcRpc.isSpent(e.txid+":"+e.vout,!0))return this.state===i.SIGNED||this.state===i.POSTED||this.state===i.QUOTE_SOFT_EXPIRED||this.state===i.DECLINED?this.state=i.QUOTE_EXPIRED:this.state=i.FAILED,t&&await this._saveAndEmit(),!0}else if(e.confirmations>=this.vaultRequiredConfirmations){if(this.state!==i.FRONTED&&this.state!==i.CLAIMED)return this.state=i.BTC_TX_CONFIRMED,t&&await this._saveAndEmit(),!0}else if(this.state===i.QUOTE_SOFT_EXPIRED||this.state===i.POSTED||this.state===i.SIGNED||this.state===i.DECLINED)return this.state=i.BROADCASTED,t&&await this._saveAndEmit(),!0;return!1}async syncStateFromChain(){let t=!1;if((this.state===i.SIGNED||this.state===i.POSTED||this.state===i.BROADCASTED||this.state===i.QUOTE_SOFT_EXPIRED||this.state===i.DECLINED)&&await this.syncStateFromBitcoin(!1)&&(t||=!0),this.state===i.BROADCASTED||this.state===i.BTC_TX_CONFIRMED){let e=await this.wrapper.contract.getWithdrawalState(this.data.btcTx.txid);switch(this.logger.debug("syncStateFromChain(): status of "+this.data.btcTx.txid,e),e.type){case a.SpvWithdrawalStateType.FRONTED:this.frontTxId=e.txId,this.state=i.FRONTED,t||=!0;break;case a.SpvWithdrawalStateType.CLAIMED:this.claimTxId=e.txId,this.state=i.CLAIMED,t||=!0;break;case a.SpvWithdrawalStateType.CLOSED:this.state=i.CLOSED,t||=!0}}return(this.state===i.CREATED||this.state===i.SIGNED||this.state===i.POSTED)&&this.expiry<Date.now()&&(this.state===i.CREATED?this.state=i.QUOTE_EXPIRED:this.state=i.QUOTE_SOFT_EXPIRED,t||=!0),t}async _sync(t){let e=await this.syncStateFromChain();return e&&t&&await this._saveAndEmit(),e}async _tick(t){if((this.state===i.CREATED||this.state===i.SIGNED)&&this.getQuoteExpiry()<Date.now())return this.state=i.QUOTE_SOFT_EXPIRED,t&&await this._saveAndEmit(),!0;if(this.state===i.QUOTE_SOFT_EXPIRED&&!this.initiated&&this.expiry<Date.now())return this.state=i.QUOTE_EXPIRED,t&&await this._saveAndEmit(),!0;if(Math.floor(Date.now()/1e3)%120==0&&(this.state===i.POSTED||this.state===i.BROADCASTED))try{return await this.syncStateFromBitcoin(t)}catch(t){this.logger.error("tickSwap("+this.getId()+"): ",t)}}}r.SpvFromBTCSwap=g},309741,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SpvFromBTCWrapper=void 0;let i=t.r(934867),n=t.r(154585),a=t.r(90222),s=t.r(196225),o=t.r(853312),l=t.r(389215),u=t.r(302071),c=t.r(742396),h=t.r(46575),p=t.r(839596);class d extends i.ISwapWrapper{constructor(t,e,r,i,n,l,u,c,h,p,d,f,m){null==f&&(f={}),f.bitcoinNetwork??=s.TEST_NETWORK,f.maxConfirmations??=6,f.bitcoinBlocktime??=600,f.maxTransactionsDelta??=3,f.maxRawAmountAdjustmentDifferencePPM??=100,f.maxBtcFeeOffset??=5,f.maxBtcFeeMultiplier??=1.5,super(t,e,r,i,l,u,f,m),this.TYPE=o.SwapType.SPV_VAULT_FROM_BTC,this.swapDeserializer=a.SpvFromBTCSwap,this.pendingSwapStates=[a.SpvFromBTCSwapState.CREATED,a.SpvFromBTCSwapState.SIGNED,a.SpvFromBTCSwapState.POSTED,a.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,a.SpvFromBTCSwapState.BROADCASTED,a.SpvFromBTCSwapState.DECLINED,a.SpvFromBTCSwapState.BTC_TX_CONFIRMED],this.tickSwapState=[a.SpvFromBTCSwapState.CREATED,a.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED,a.SpvFromBTCSwapState.SIGNED,a.SpvFromBTCSwapState.POSTED,a.SpvFromBTCSwapState.BROADCASTED],this.spvWithdrawalDataDeserializer=c,this.contract=n,this.btcRelay=h,this.synchronizer=p,this.btcRpc=d}processEventFront(t,e){return(e.state===a.SpvFromBTCSwapState.SIGNED||e.state===a.SpvFromBTCSwapState.POSTED||e.state===a.SpvFromBTCSwapState.BROADCASTED||e.state===a.SpvFromBTCSwapState.DECLINED||e.state===a.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED||e.state===a.SpvFromBTCSwapState.BTC_TX_CONFIRMED)&&(e.state=a.SpvFromBTCSwapState.FRONTED,!0)}processEventClaim(t,e){return(e.state===a.SpvFromBTCSwapState.SIGNED||e.state===a.SpvFromBTCSwapState.POSTED||e.state===a.SpvFromBTCSwapState.BROADCASTED||e.state===a.SpvFromBTCSwapState.DECLINED||e.state===a.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED||e.state===a.SpvFromBTCSwapState.BTC_TX_CONFIRMED)&&(e.state=a.SpvFromBTCSwapState.CLAIMED,!0)}processEventClose(t,e){return(e.state===a.SpvFromBTCSwapState.SIGNED||e.state===a.SpvFromBTCSwapState.POSTED||e.state===a.SpvFromBTCSwapState.BROADCASTED||e.state===a.SpvFromBTCSwapState.DECLINED||e.state===a.SpvFromBTCSwapState.QUOTE_SOFT_EXPIRED||e.state===a.SpvFromBTCSwapState.BTC_TX_CONFIRMED)&&(e.state=a.SpvFromBTCSwapState.CLOSED,!0)}async processEvent(t,e){if(null==e)return;let r=!1;return t instanceof n.SpvVaultFrontEvent&&(r=this.processEventFront(t,e),t.meta?.txId!=null&&e.frontTxId!==t.meta.txId&&(e.frontTxId=t.meta.txId,r||=!0)),t instanceof n.SpvVaultClaimEvent&&(r=this.processEventClaim(t,e),t.meta?.txId!=null&&e.claimTxId!==t.meta.txId&&(e.claimTxId=t.meta.txId,r||=!0)),t instanceof n.SpvVaultCloseEvent&&(r=this.processEventClose(t,e)),this.logger.info("processEvents(): "+t.constructor.name+" processed for "+e.getId()+" swap: ",e),r&&await e._saveAndEmit(),!0}async preFetchCallerFeeShare(t,e,r,i,n,a){if(r.unsafeZeroWatchtowerFee||0n===e.amount)return 0n;try{let t,[s,o,u,c,h]=await Promise.all([(0,l.tryWithRetries)(()=>this.btcRelay.getFeePerBlock(),null,null,a.signal),(0,l.tryWithRetries)(()=>this.btcRelay.getTipData(),null,null,a.signal),this.btcRpc.getTipHeight(),(0,l.tryWithRetries)(()=>this.contract.getClaimFee(this.chain.randomAddress(),null,null),null,null,a.signal),n??(e.token===this.chain.getNativeCurrencyAddress()?i:this.prices.preFetchPrice(this.chainIdentifier,this.chain.getNativeCurrencyAddress(),a.signal))]),p=o.blockheight,d=Math.max(u-p+this.options.maxConfirmations,0),f=(BigInt(d)*s+c*BigInt(this.options.maxTransactionsDelta))*BigInt(Math.floor(1e6*r.feeSafetyFactor))/1000000n;if(e.exactIn)t=await this.prices.getFromBtcSwapAmount(this.chainIdentifier,e.amount,this.chain.getNativeCurrencyAddress(),a.signal,h)-f;else if(e.token===this.chain.getNativeCurrencyAddress())t=e.amount;else{let r=await this.prices.getToBtcSwapAmount(this.chainIdentifier,e.amount,e.token,a.signal,await i);t=await this.prices.getFromBtcSwapAmount(this.chainIdentifier,r,this.chain.getNativeCurrencyAddress(),a.signal,h)}this.logger.debug("preFetchCallerFeeShare(): Caller fee in native token: "+f.toString(10)+" total payout in native token: "+t.toString(10));let m=(100000n*f+t-1n)/t;if(m<0n)return 0n;if(m>=2n**20n)return 2n**20n-1n;return m}catch(t){return a.abort(t),null}}async verifyReturnedData(t,e,r,i,n,a){let s,o,u,c,p;if(t.btcFeeRate>await a)throw new h.IntermediaryError("Bitcoin fee rate returned too high!");try{s=(0,l.toOutputScript)(this.options.bitcoinNetwork,t.vaultBtcAddress),o=(0,l.toCoinselectAddressType)(s),u=(0,l.toOutputScript)(this.options.bitcoinNetwork,t.btcAddress)}catch(t){throw new h.IntermediaryError("Invalid btc address data returned!")}let d=t.btcUtxo.split(":");if(t.address!==r.getAddress(this.chainIdentifier)||t.vaultId<0n||null==s||null==u||"p2pkh"===o||"p2sh-p2wpkh"===o||2!==d.length||64!==d[0].length||isNaN(parseInt(d[1]))||t.btcFeeRate<1||t.btcFeeRate>1e4)throw new h.IntermediaryError("Invalid vault data returned!");if(t.btcAmountSwap+t.btcAmountGas!==t.btcAmount)throw Error("Btc amount mismatch");if(t.swapFeeBtc+t.gasSwapFeeBtc!==t.totalFeeBtc)throw Error("Btc fee mismatch");if(t.callerFeeShare!==n||0n!==t.frontingFeeShare||0n!==t.executionFeeShare)throw new h.IntermediaryError("Invalid caller/fronting/execution fee returned");if(t.expiry<Math.floor(Date.now()/1e3))throw new h.IntermediaryError("Quote already expired");try{c=await this.contract.getVaultData(t.address,t.vaultId)}catch(e){throw this.logger.error("Error getting spv vault (owner: "+t.address+" vaultId: "+t.vaultId.toString(10)+"): ",e),new h.IntermediaryError("Spv swap vault not found!")}if(!c.isOpened())throw new h.IntermediaryError("Returned spv swap vault is not opened!");if(c.getConfirmations()>this.options.maxConfirmations)throw new h.IntermediaryError("SPV swap vault needs too many confirmations: "+c.getConfirmations());let f=c.getTokenData();if(e.exactIn){if(t.btcAmount!==e.amount)throw new h.IntermediaryError("Invalid amount returned")}else{let r=e.amount/f[0].multiplier*f[0].multiplier;if((e.amount-r)*1000000n/e.amount>this.options.maxRawAmountAdjustmentDifferencePPM)throw new h.IntermediaryError("Invalid amount0 multiplier used, rawAmount diff too high");if(t.total!==r)throw new h.IntermediaryError("Invalid total returned")}if(null==i.gasAmount||0n===i.gasAmount){if(0n!==t.totalGas)throw new h.IntermediaryError("Invalid gas total returned")}else{let e=i.gasAmount/f[0].multiplier*f[0].multiplier;if((i.gasAmount-e)*1000000n/i.gasAmount>this.options.maxRawAmountAdjustmentDifferencePPM)throw new h.IntermediaryError("Invalid amount1 multiplier used, rawAmount diff too high");if(t.totalGas!==e)throw new h.IntermediaryError("Invalid gas total returned")}let m=t.btcUtxo.toLowerCase(),[g,w]=m.split(":"),y=await this.btcRpc.getTransaction(g);if(null==y.confirmations||y.confirmations<1)throw new h.IntermediaryError("SPV vault UTXO not confirmed");let T=parseInt(w);if(null==y.outs[T])throw new h.IntermediaryError("Invalid UTXO, doesn't exist");let S=y.outs[T].value;if(await this.btcRpc.isSpent(m))throw new h.IntermediaryError("Returned spv vault UTXO is already spent");this.logger.debug("verifyReturnedData(): Vault UTXO: "+c.getUtxo()+" current utxo: "+m);let E=[];for(;c.getUtxo()!==m;){let[t,e]=m.split(":");y.txid!==t&&(y=await this.btcRpc.getTransaction(t));let r=await this.contract.getWithdrawalData(y);if(E.unshift(r),m=E[0].getSpentVaultUtxo(),this.logger.debug("verifyReturnedData(): Vault UTXO: "+c.getUtxo()+" current utxo: "+m),E.length>=this.options.maxTransactionsDelta)throw new h.IntermediaryError("BTC <> SC state difference too deep, maximum: "+this.options.maxTransactionsDelta)}try{p=c.calculateStateAfter(E)}catch(e){throw this.logger.error("Error calculating spv vault balance (owner: "+t.address+" vaultId: "+t.vaultId.toString(10)+"): ",e),new h.IntermediaryError("Spv swap vault balance prediction failed!")}if(p.balances[0].scaledAmount<t.total)throw new h.IntermediaryError("SPV swap vault, insufficient balance, required: "+t.total.toString(10)+" has: "+p.balances[0].scaledAmount.toString(10));if(p.balances[1].scaledAmount<t.totalGas)throw new h.IntermediaryError("SPV swap vault, insufficient balance, required: "+t.totalGas.toString(10)+" has: "+p.balances[1].scaledAmount.toString(10));try{for(let t of E)await this.contract.checkWithdrawalTx(t)}catch(e){throw this.logger.error("Error calculating spv vault balance (owner: "+t.address+" vaultId: "+t.vaultId.toString(10)+"): ",e),new h.IntermediaryError("Spv swap vault balance prediction failed!")}return{vault:c,vaultUtxoValue:S}}create(t,e,r,i,n,s){i??={},i.gasAmount??=0n,i.feeSafetyFactor??=1.25;let h=(0,l.extendAbortController)(s),p=this.preFetchPrice(e,h.signal),d=this.chain.getNativeCurrencyAddress(),f=0n===i.gasAmount?null:this.preFetchPrice({token:d},h.signal),m=this.preFetchCallerFeeShare(t,e,i,p,f,h),g=null!=i.maxAllowedNetworkFeeRate?Promise.resolve(i.maxAllowedNetworkFeeRate):this.btcRpc.getFeeRate().then(t=>this.options.maxBtcFeeOffset+t*this.options.maxBtcFeeMultiplier).catch(t=>(h.abort(t),null));return r.map(r=>({intermediary:r,quote:(async()=>{let s=(0,l.extendAbortController)(h.signal);try{let h=await (0,l.tryWithRetries)(async a=>await u.IntermediaryAPI.prepareSpvFromBTC(this.chainIdentifier,r.url,{address:t,amount:e.amount,token:e.token.toString(),exactOut:!e.exactIn,gasToken:d,gasAmount:i.gasAmount,callerFeeRate:m,frontingFeeRate:0n,additionalParams:n},this.options.postRequestTimeout,s.signal,!(a>0)&&null),null,t=>t instanceof c.RequestError,s.signal);this.logger.debug("create("+r.url+"): LP response: ",h);let w=await m,[y,T,{vault:S,vaultUtxoValue:E}]=await Promise.all([this.verifyReturnedPrice(r.services[o.SwapType.SPV_VAULT_FROM_BTC],!1,h.btcAmountSwap,h.total*(100000n+w)/100000n,e.token,{},p,s.signal),0n===i.gasAmount?Promise.resolve():this.verifyReturnedPrice({...r.services[o.SwapType.SPV_VAULT_FROM_BTC],swapBaseFee:0},!1,h.btcAmountGas,h.totalGas*(100000n+w)/100000n,d,{},f,s.signal),this.verifyReturnedData(h,e,r,i,w,g)]),I={pricingInfo:y,url:r.url,expiry:1e3*h.expiry,swapFee:h.swapFee,swapFeeBtc:h.swapFeeBtc,exactIn:e.exactIn??!0,quoteId:h.quoteId,recipient:t,vaultOwner:h.address,vaultId:h.vaultId,vaultRequiredConfirmations:S.getConfirmations(),vaultTokenMultipliers:S.getTokenData().map(t=>t.multiplier),vaultBtcAddress:h.vaultBtcAddress,vaultUtxo:h.btcUtxo,vaultUtxoValue:BigInt(E),btcDestinationAddress:h.btcAddress,btcAmount:h.btcAmount,btcAmountSwap:h.btcAmountSwap,btcAmountGas:h.btcAmountGas,minimumBtcFeeRate:h.btcFeeRate,outputTotalSwap:h.total,outputSwapToken:e.token,outputTotalGas:h.totalGas,outputGasToken:d,gasSwapFeeBtc:h.gasSwapFeeBtc,gasSwapFee:h.gasSwapFee,callerFeeShare:h.callerFeeShare,frontingFeeShare:h.frontingFeeShare,executionFeeShare:h.executionFeeShare},b=new a.SpvFromBTCSwap(this,I);return await b._save(),b}catch(t){throw s.abort(t),t}})()}))}getDummySwapPsbt(t=!1){let e=new p.Transaction({allowUnknownInputs:!0,allowLegacyWitnessUtxo:!0,allowUnknownOutputs:!0}),r=p.OutScript.encode({type:"tr",pubkey:Buffer.from("0101010101010101010101010101010101010101010101010101010101010101","hex")});e.addInput({txid:(0,l.randomBytes)(32),index:0,witnessUtxo:{script:r,amount:600n}}),e.addOutput({script:r,amount:600n});let i=this.contract.toOpReturnData(this.chain.randomAddress(),t?[0xffffffffffffffffn,0xffffffffffffffffn]:[0xffffffffffffffffn]);return e.addOutput({script:Buffer.concat([i.length<=75?Buffer.from([106,i.length]):Buffer.from([106,76,i.length]),i]),amount:0n}),e}}r.SpvFromBTCWrapper=d},93907,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SwapperUtils=void 0;let i=t.r(916232),n=t.r(839596),a=t.r(245282),s=t.r(853312),o=t.r(844485),l=t.r(199974),u=t.r(154585),c=t.r(389215);r.SwapperUtils=class{constructor(t){this.bitcoinNetwork=t.bitcoinNetwork,this.root=t}isLightningInvoice(t){try{return(0,i.decode)(t),!0}catch(t){}return!1}isValidBitcoinAddress(t){try{return(0,n.Address)(this.bitcoinNetwork).decode(t),!0}catch(t){return!1}}isValidLightningInvoice(t){try{let e=(0,i.decode)(t);if(null!=e.millisatoshis)return!0}catch(t){}return!1}isValidLNURL(t){return a.LNURL.isLNURL(t)}getLNURLTypeAndData(t,e){return a.LNURL.getLNURLType(t,e)}getLightningInvoiceValue(t){let e=(0,i.decode)(t);return null!=e.millisatoshis?(BigInt(e.millisatoshis)+999n)/1000n:null}parseBitcoinAddress(t){let e=null;if(t.includes("?")){let r=t.split("?");for(let i of(t=r[0],r[1].split("&"))){let t=i.split("="),r=t[0],n=decodeURIComponent(t[1]);"amount"===r&&(e=(0,o.fromDecimal)(parseFloat(n).toFixed(8),8))}}if(this.isValidBitcoinAddress(t))return{address:t,type:"BITCOIN",swapType:s.SwapType.TO_BTC,amount:(0,o.toTokenAmount)(e,o.BitcoinTokens.BTC,this.root.prices)}}parseLNURLSync(t){if(this.isValidLNURL(t))return{address:t,type:"LNURL",swapType:null}}async parseLNURL(t){if(this.isValidLNURL(t))try{let e=await this.getLNURLTypeAndData(t);if(null==e)throw Error("Invalid LNURL specified!");let r={address:t,type:"LNURL",swapType:(0,a.isLNURLPay)(e)?s.SwapType.TO_BTCLN:(0,a.isLNURLWithdraw)(e)?s.SwapType.FROM_BTCLN:null,lnurl:e};if(e.min===e.max)return{...r,amount:(0,o.toTokenAmount)(e.min,o.BitcoinTokens.BTCLN,this.root.prices)};return{...r,min:(0,o.toTokenAmount)(e.min,o.BitcoinTokens.BTCLN,this.root.prices),max:(0,o.toTokenAmount)(e.max,o.BitcoinTokens.BTCLN,this.root.prices)}}catch(t){throw Error("Failed to contact LNURL service, check your internet connection and retry later.")}}parseLightningInvoice(t){if(this.isLightningInvoice(t))if(this.isValidLightningInvoice(t)){let e=this.getLightningInvoiceValue(t);return{address:t,type:"LIGHTNING",swapType:s.SwapType.TO_BTCLN,amount:(0,o.toTokenAmount)(e,o.BitcoinTokens.BTCLN,this.root.prices)}}else throw Error("Lightning invoice needs to contain an amount!")}parseSmartchainAddress(t){for(let e of this.root.getSmartChains())if(this.root.chains[e].chainInterface.isValidAddress(t))if(this.root.supportsSwapType(e,s.SwapType.SPV_VAULT_FROM_BTC))return{address:t,type:e,swapType:s.SwapType.SPV_VAULT_FROM_BTC};else return{address:t,type:e,swapType:null}}async parseAddress(t){if(t.startsWith("bitcoin:")){let e=this.parseBitcoinAddress(t.substring(8));if(null!=e)return e;throw Error("Invalid bitcoin address!")}let e=this.parseBitcoinAddress(t);if(null!=e)return e;if(t.startsWith("lightning:")){let e=t.substring(10),r=await this.parseLNURL(e);if(null!=r)return r;let i=this.parseLightningInvoice(e);if(null!=i)return i;throw Error("Invalid lightning network invoice or LNURL!")}let r=await this.parseLNURL(t);if(null!=r)return r;let i=this.parseLightningInvoice(t);return null!=i?i:this.parseSmartchainAddress(t)}parseAddressSync(t){if(t.startsWith("bitcoin:")){let e=this.parseBitcoinAddress(t.substring(8));if(null!=e)return e;throw Error("Invalid bitcoin address!")}let e=this.parseBitcoinAddress(t);if(null!=e)return e;if(t.startsWith("lightning:")){let e=t.substring(10),r=this.parseLNURLSync(e);if(null!=r)return r;let i=this.parseLightningInvoice(e);if(null!=i)return i;throw Error("Invalid lightning network invoice or LNURL!")}let r=this.parseLNURLSync(t);if(null!=r)return r;let i=this.parseLightningInvoice(t);return null!=i?i:this.parseSmartchainAddress(t)}getRandomSpvVaultPsbt(t,e){let r=this.root.chains[t].wrappers[s.SwapType.SPV_VAULT_FROM_BTC];if(null==r)throw Error("Chain doesn't support spv vault swaps!");return r.getDummySwapPsbt(e)}async getBitcoinSpendableBalance(t,e,r){let i,n;if("string"!=typeof t&&null==t.getTransactionFee)throw Error("Wallet must be a string address or IBitcoinWallet");i="string"==typeof t?new l.SingleAddressBitcoinWallet(this.root.bitcoinRpc,this.bitcoinNetwork,t):t;let a=r?.feeRate??await i.getFeeRate();return r?.minFeeRate!=null&&(a=Math.max(a,r.minFeeRate)),n=null!=e&&this.root.supportsSwapType(e,s.SwapType.SPV_VAULT_FROM_BTC)?await i.getSpendableBalance(this.getRandomSpvVaultPsbt(e,r?.gasDrop),a):await i.getSpendableBalance(void 0,a),{balance:(0,o.toTokenAmount)(n.balance,o.BitcoinTokens.BTC,this.root.prices),feeRate:n.feeRate}}async getSpendableBalance(t,e,r){let i;if("string"!=typeof t&&null==t.getAddress)throw Error("Signer must be a string or smart chain signer");if(null==this.root.chains[e.chainId])throw Error("Invalid chain identifier! Unknown chain: "+e.chainId);let{swapContract:n,chainInterface:a}=this.root.chains[e.chainId],s="string"==typeof t?t:t.getAddress();if(a.getNativeCurrencyAddress()!==e.address)i=await a.getBalance(s,e.address);else{let[t,o]=await Promise.all([a.getBalance(s,e.address),n.getCommitFee(await n.createSwapData(u.ChainSwapType.HTLC,s,null,e.address,0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn,n.getHashForHtlc((0,c.randomBytes)(32)).toString("hex"),u.BigIntBufferUtils.fromBuffer((0,c.randomBytes)(8)),BigInt(Math.floor(Date.now()/1e3)),!0,!1,u.BigIntBufferUtils.fromBuffer((0,c.randomBytes)(2)),u.BigIntBufferUtils.fromBuffer((0,c.randomBytes)(2))),r?.feeRate)]);r?.feeMultiplier!=null&&(o=o*BigInt(Math.floor(1e6*r.feeMultiplier))/1000000n),i=(0,c.bigIntMax)(t-o,0n)}return(0,o.toTokenAmount)(i,e,this.root.prices)}getNativeToken(t){if(null==this.root.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);return this.root.tokens[t][this.root.chains[t].chainInterface.getNativeCurrencyAddress()]}randomSigner(t){if(null==this.root.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);return this.root.chains[t].chainInterface.randomSigner()}randomAddress(t){if(null==this.root.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);return this.root.chains[t].chainInterface.randomAddress()}}},152825,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.Swapper=void 0;let i=t.r(154585),n=t.r(845838),a=t.r(94005),s=t.r(642673),o=t.r(442135),l=t.r(483930),u=t.r(916232),c=t.r(46575),h=t.r(853312),p=t.r(873547),d=t.r(725827),f=t.r(427699),m=t.r(245282),g=t.r(389215),w=t.r(742396),y=t.r(938944),T=t.r(844485),S=t.r(538657),E=t.r(196225),I=t.r(207901),b=t.r(706581),v=t.r(491357),B=t.r(309741),A=t.r(93907);class R extends f.EventEmitter{constructor(t,e,r,u,c){super(),this.logger=(0,g.getLogger)(this.constructor.name+": "),this.SwapTypeInfo={[h.SwapType.TO_BTC]:{requiresInputWallet:!0,requiresOutputWallet:!1,supportsGasDrop:!1},[h.SwapType.TO_BTCLN]:{requiresInputWallet:!0,requiresOutputWallet:!1,supportsGasDrop:!1},[h.SwapType.FROM_BTC]:{requiresInputWallet:!1,requiresOutputWallet:!0,supportsGasDrop:!1},[h.SwapType.FROM_BTCLN]:{requiresInputWallet:!1,requiresOutputWallet:!0,supportsGasDrop:!1},[h.SwapType.SPV_VAULT_FROM_BTC]:{requiresInputWallet:!0,requiresOutputWallet:!1,supportsGasDrop:!0},[h.SwapType.TRUSTED_FROM_BTC]:{requiresInputWallet:!1,requiresOutputWallet:!1,supportsGasDrop:!1},[h.SwapType.TRUSTED_FROM_BTCLN]:{requiresInputWallet:!1,requiresOutputWallet:!1,supportsGasDrop:!1}};let f=c?.storagePrefix??"atomiq-";for(let e of(c.bitcoinNetwork=null==c.bitcoinNetwork?i.BitcoinNetwork.TESTNET:c.bitcoinNetwork,c.swapStorage??=t=>new I.IndexedDBUnifiedStorage(t),this._bitcoinNetwork=c.bitcoinNetwork,this.bitcoinNetwork=c.bitcoinNetwork===i.BitcoinNetwork.MAINNET?E.NETWORK:c.bitcoinNetwork===i.BitcoinNetwork.TESTNET||c.bitcoinNetwork===i.BitcoinNetwork.TESTNET4?E.TEST_NETWORK:{bech32:"bcrt",pubKeyHash:111,scriptHash:196,wif:239},this.Utils=new A.SwapperUtils(this),this.prices=r,this.bitcoinRpc=t,this.mempoolApi=t.api,this.options=c,this.tokens={},u))for(let t in e.chains){let r=e.chains[t];this.tokens[t]??={},this.tokens[t][r.address]={chain:"SC",chainId:t,ticker:e.ticker,name:e.name,decimals:r.decimals,displayDecimals:r.displayDecimals,address:r.address}}this.swapStateListener=t=>{this.emit("swapState",t)},this.chains=(0,g.objectMap)(e,(e,l)=>{let{swapContract:m,chainEvents:g,btcRelay:w,chainInterface:y,spvVaultContract:T,spvVaultWithdrawalDataConstructor:E}=e,I=new p.MempoolBtcRelaySynchronizer(w,t),A=c.swapStorage(f+e.chainId),R=new b.UnifiedSwapStorage(A,this.options.noSwapCache),C=new v.UnifiedSwapEventListener(R,g),_={};return _[h.SwapType.TO_BTCLN]=new n.ToBTCLNWrapper(l,R,C,y,m,r,u,e.swapDataConstructor,{getRequestTimeout:c.getRequestTimeout,postRequestTimeout:c.postRequestTimeout}),_[h.SwapType.TO_BTC]=new a.ToBTCWrapper(l,R,C,y,m,r,u,e.swapDataConstructor,this.bitcoinRpc,{getRequestTimeout:c.getRequestTimeout,postRequestTimeout:c.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork}),_[h.SwapType.FROM_BTCLN]=new s.FromBTCLNWrapper(l,R,C,y,m,r,u,e.swapDataConstructor,t,{getRequestTimeout:c.getRequestTimeout,postRequestTimeout:c.postRequestTimeout,unsafeSkipLnNodeCheck:this._bitcoinNetwork===i.BitcoinNetwork.TESTNET4||this._bitcoinNetwork===i.BitcoinNetwork.REGTEST}),_[h.SwapType.FROM_BTC]=new o.FromBTCWrapper(l,R,C,y,m,r,u,e.swapDataConstructor,w,I,this.bitcoinRpc,{getRequestTimeout:c.getRequestTimeout,postRequestTimeout:c.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork}),_[h.SwapType.TRUSTED_FROM_BTCLN]=new d.LnForGasWrapper(l,R,C,y,r,u,{getRequestTimeout:c.getRequestTimeout,postRequestTimeout:c.postRequestTimeout}),_[h.SwapType.TRUSTED_FROM_BTC]=new S.OnchainForGasWrapper(l,R,C,y,r,u,t,{getRequestTimeout:c.getRequestTimeout,postRequestTimeout:c.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork}),null!=T&&(_[h.SwapType.SPV_VAULT_FROM_BTC]=new B.SpvFromBTCWrapper(l,R,C,y,T,r,u,E,w,I,t,{getRequestTimeout:c.getRequestTimeout,postRequestTimeout:c.postRequestTimeout,bitcoinNetwork:this.bitcoinNetwork})),Object.keys(_).forEach(t=>_[t].events.on("swapState",this.swapStateListener)),{chainEvents:g,spvVaultContract:T,swapContract:m,chainInterface:y,btcRelay:w,synchronizer:I,wrappers:_,unifiedChainEvents:C,unifiedSwapStorage:R,reviver:t=>{let e=_[t.type];return null==e?null:new e.swapDeserializer(e,t)}}});let m=(0,g.objectMap)(e,t=>t.swapContract);null!=c.intermediaryUrl?this.intermediaryDiscovery=new l.IntermediaryDiscovery(m,c.registryUrl,Array.isArray(c.intermediaryUrl)?c.intermediaryUrl:[c.intermediaryUrl],c.getRequestTimeout):this.intermediaryDiscovery=new l.IntermediaryDiscovery(m,c.registryUrl,null,c.getRequestTimeout),this.intermediaryDiscovery.on("removed",t=>{this.emit("lpsRemoved",t)}),this.intermediaryDiscovery.on("added",t=>{this.emit("lpsAdded",t)})}async init(){for(let t in this.chains){let{swapContract:e,unifiedChainEvents:r,unifiedSwapStorage:i,wrappers:n,reviver:a}=this.chains[t];if(await e.start(),this.logger.debug("init(): Intialized swap contract: "+t),await i.init(),i.storage instanceof I.IndexedDBUnifiedStorage){let e="SOLANA"===t?"SOLv4-"+this._bitcoinNetwork+"-Swaps-":"atomiqsdk-"+this._bitcoinNetwork+t+"-Swaps-";await i.storage.tryMigrate([[e+"FromBTC",h.SwapType.FROM_BTC],[e+"FromBTCLN",h.SwapType.FROM_BTCLN],[e+"ToBTC",h.SwapType.TO_BTC],[e+"ToBTCLN",h.SwapType.TO_BTCLN]],t=>{let e=a(t);if(null==e.randomNonce){let t=e.getId();e.randomNonce=(0,g.randomBytes)(16).toString("hex");let r=e.getId();this.logger.info("init(): Found older swap version without randomNonce, replacing, old hash: "+t+" new hash: "+r)}return e})}for(let e in this.options.noEvents||await r.start(),this.logger.debug("init(): Intialized events: "+t),n)await n[e].init(this.options.noTimers,this.options.dontCheckPastSwaps)}this.logger.debug("init(): Initializing intermediary discovery"),this.options.dontFetchLPs||await this.intermediaryDiscovery.init(),null!=this.options.defaultTrustedIntermediaryUrl&&(this.defaultTrustedIntermediary=await this.intermediaryDiscovery.getIntermediary(this.options.defaultTrustedIntermediaryUrl))}async stop(){for(let t in this.chains){let{wrappers:e,unifiedChainEvents:r}=this.chains[t];for(let t in e)e[t].events.removeListener("swapState",this.swapStateListener),await e[t].stop();await r.stop()}}async createSwap(t,e,r,i,n=2e3){let a;if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);let s=i===h.SwapType.TO_BTCLN||i===h.SwapType.TO_BTC?!r.exactIn:r.exactIn;a=s?this.intermediaryDiscovery.getSwapCandidates(t,i,r.token,r.amount):this.intermediaryDiscovery.getSwapCandidates(t,i,r.token);let o=!1;if(0===a.length){if(this.logger.warn("createSwap(): No valid intermediary found, reloading intermediary database..."),await this.intermediaryDiscovery.reloadIntermediaries(),o=!0,s){if(0===(a=this.intermediaryDiscovery.getSwapCandidates(t,i,r.token,r.amount)).length){let e=this.intermediaryDiscovery.getSwapMinimum(t,i,r.token),n=this.intermediaryDiscovery.getSwapMaximum(t,i,r.token);if(null!=e&&null!=n){if(r.amount<BigInt(e))throw new w.OutOfBoundsError("Amount too low!",200,BigInt(e),BigInt(n));if(r.amount>BigInt(n))throw new w.OutOfBoundsError("Amount too high!",200,BigInt(e),BigInt(n))}}}else a=this.intermediaryDiscovery.getSwapCandidates(t,i,r.token);if(0===a.length)throw Error("No intermediary found!")}let l=new AbortController;this.logger.debug("createSwap() Swap candidates: ",a.map(t=>t.url).join());let u=await e(a,l.signal,this.chains[t]),p=new Promise((e,a)=>{let s,h,p,d,f=0,m=[];u.forEach(y=>{y.quote.then(t=>{if(0===f&&(d=setTimeout(()=>{l.abort(Error("Timed out waiting for quote!")),e(m)},n)),f++,m.push({quote:t,intermediary:y.intermediary}),f===u.length){clearTimeout(d),e(m);return}}).catch(n=>{if(f++,n instanceof c.IntermediaryError)this.intermediaryDiscovery.removeIntermediary(y.intermediary),o=!0;else if(n instanceof w.OutOfBoundsError){null==s||null==h?(s=n.min,h=n.max):(s=(0,g.bigIntMin)(s,n.min),h=(0,g.bigIntMax)(h,n.max)),y.intermediary.swapBounds[i]??={},y.intermediary.swapBounds[i][t]??={};let e=y.intermediary.swapBounds[i][t][r.token]??={input:null,output:null};r.exactIn?e.input={min:n.min,max:n.max}:e.output={min:n.min,max:n.max},o=!0}if(this.logger.warn("createSwap(): Intermediary "+y.intermediary.url+" error: ",n),p=n,f===u.length){if(null!=d&&clearTimeout(d),m.length>0)return void e(m);if(null!=s&&null!=h)return void a(new w.OutOfBoundsError("Out of bounds",400,s,h));a(p)}})})});try{let t=await p;t.sort((t,e)=>r.exactIn?(0,g.bigIntCompare)(e.quote.getOutput().rawAmount,t.quote.getOutput().rawAmount):(0,g.bigIntCompare)(t.quote.getInput().rawAmount,e.quote.getInput().rawAmount)),this.logger.debug("createSwap(): Sorted quotes, best price to worst: ",t),o&&this.emit("swapLimitsChanged");let e=t[0].quote;return this.options.saveUninitializedSwaps&&(e._setInitiated(),await e._save()),e}catch(t){throw o&&this.emit("swapLimitsChanged"),t}}createToBTCSwap(t,e,r,i,n,a,s=this.options.defaultAdditionalParameters,o){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if(i.startsWith("bitcoin:")&&(i=i.substring(8).split("?")[0]),!this.Utils.isValidBitcoinAddress(i))throw Error("Invalid bitcoin address");if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");o??={},o.confirmationTarget??=3,o.confirmations??=2;let l={amount:n,token:r,exactIn:a};return this.createSwap(t,(t,r,n)=>Promise.resolve(n.wrappers[h.SwapType.TO_BTC].create(e,i,l,t,o,s,r)),l,h.SwapType.TO_BTC)}async createToBTCLNSwap(t,e,r,i,n=this.options.defaultAdditionalParameters,a){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if(a??={},i.startsWith("lightning:")&&(i=i.substring(10)),!this.Utils.isValidLightningInvoice(i))throw Error("Invalid lightning network invoice");if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");let s={amount:(BigInt((0,u.decode)(i).millisatoshis)+999n)/1000n,token:r,exactIn:!1};return a.expirySeconds??=432e3,this.createSwap(t,(t,r,o)=>o.wrappers[h.SwapType.TO_BTCLN].create(e,i,s,t,a,n,r),s,h.SwapType.TO_BTCLN)}async createToBTCLNSwapViaLNURL(t,e,r,i,n,a,s=this.options.defaultAdditionalParameters,o){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if("string"==typeof i&&!this.Utils.isValidLNURL(i))throw Error("Invalid LNURL-pay link");if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");o??={};let l={amount:n,token:r,exactIn:a};return o.expirySeconds??=432e3,this.createSwap(t,(t,r,n)=>n.wrappers[h.SwapType.TO_BTCLN].createViaLNURL(e,"string"==typeof i?i.startsWith("lightning:")?i.substring(10):i:i.params,l,t,o,s,r),l,h.SwapType.TO_BTCLN)}async createFromBTCSwapNew(t,e,r,i,n,a=this.options.defaultAdditionalParameters,s){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");let o={amount:i,token:r,exactIn:!n};return this.createSwap(t,(t,r,i)=>Promise.resolve(i.wrappers[h.SwapType.SPV_VAULT_FROM_BTC].create(e,o,t,s,a,r)),o,h.SwapType.SPV_VAULT_FROM_BTC)}async createFromBTCSwap(t,e,r,i,n,a=this.options.defaultAdditionalParameters,s){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");let o={amount:i,token:r,exactIn:!n};return this.createSwap(t,(t,r,i)=>Promise.resolve(i.wrappers[h.SwapType.FROM_BTC].create(e,o,t,s,a,r)),o,h.SwapType.FROM_BTC)}async createFromBTCLNSwap(t,e,r,i,n,a=this.options.defaultAdditionalParameters,s){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");let o={amount:i,token:r,exactIn:!n};return this.createSwap(t,(t,r,i)=>Promise.resolve(i.wrappers[h.SwapType.FROM_BTCLN].create(e,o,t,s,a,r)),o,h.SwapType.FROM_BTCLN)}async createFromBTCLNSwapViaLNURL(t,e,r,i,n,a,s=this.options.defaultAdditionalParameters){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if("string"==typeof i&&!this.Utils.isValidLNURL(i))throw Error("Invalid LNURL-withdraw link");if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");let o={amount:n,token:r,exactIn:!a};return this.createSwap(t,(t,r,n)=>n.wrappers[h.SwapType.FROM_BTCLN].createViaLNURL(e,"string"==typeof i?i.startsWith("lightning:")?i.substring(10):i:i.params,o,t,s,r),o,h.SwapType.FROM_BTCLN)}createTrustedLNForGasSwap(t,e,r,i){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");let n=i??this.defaultTrustedIntermediary??this.options.defaultTrustedIntermediaryUrl;if(null==n)throw Error("No trusted intermediary specified!");return this.chains[t].wrappers[h.SwapType.TRUSTED_FROM_BTCLN].create(e,r,n)}createTrustedOnchainForGasSwap(t,e,r,i,n){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);if(!this.chains[t].chainInterface.isValidAddress(e))throw Error("Invalid "+t+" address");let a=n??this.defaultTrustedIntermediary??this.options.defaultTrustedIntermediaryUrl;if(null==a)throw Error("No trusted intermediary specified!");return this.chains[t].wrappers[h.SwapType.TRUSTED_FROM_BTC].create(e,r,a,i)}create(t,e,r,i,n,a){return"BTC"===e.chain?this.swap(e,r,i,n,a,t):this.swap(e,r,i,n,t,a)}swap(t,e,r,i,n,a,s){if("BTC"===t.chain){if("SC"===e.chain){if("string"!=typeof a)throw Error("Destination for BTC/BTC-LN -> smart chain swaps must be a smart chain address!");if(t.lightning)if(null==n)return this.createFromBTCLNSwap(e.chainId,a,e.address,r,!i,void 0,s);else{if("string"!=typeof n&&!(0,m.isLNURLWithdraw)(n))throw Error("LNURL must be a string or LNURLWithdraw object!");return this.createFromBTCLNSwapViaLNURL(e.chainId,a,e.address,n,r,!i)}return this.supportsSwapType(e.chainId,h.SwapType.SPV_VAULT_FROM_BTC)?this.createFromBTCSwapNew(e.chainId,a,e.address,r,!i,void 0,s):this.createFromBTCSwap(e.chainId,a,e.address,r,!i,void 0,s)}}else if("BTC"===e.chain){if("string"!=typeof n)throw Error("Source address for BTC/BTC-LN -> smart chain swaps must be a smart chain address!");if(e.lightning){if("string"!=typeof a&&!(0,m.isLNURLPay)(a))throw Error("Destination LNURL link/lightning invoice must be a string or LNURLPay object!");if((0,m.isLNURLPay)(a)||this.Utils.isValidLNURL(a))return this.createToBTCLNSwapViaLNURL(t.chainId,n,t.address,a,r,i,void 0,s);if(this.Utils.isLightningInvoice(a)){if(!this.Utils.isValidLightningInvoice(a))throw Error("Invalid lightning invoice specified, lightning invoice MUST contain pre-set amount!");if(i)throw Error("Only exact out swaps are possible with lightning invoices, use LNURL links for exact in lightning swaps!");return this.createToBTCLNSwap(t.chainId,n,t.address,a,void 0,s)}throw Error("Supplied parameter is not LNURL link nor lightning invoice (bolt11)!")}if("string"!=typeof a)throw Error("Destination bitcoin address must be a string!");return this.createToBTCSwap(t.chainId,n,t.address,a,r,i,void 0,s)}throw Error("Unsupported swap type")}async getAllSwaps(t,e){let r=[];if(null!=e&&r.push({key:"intiator",value:e}),null==t)return(await Promise.all(Object.keys(this.chains).map(t=>{let{unifiedSwapStorage:e,reviver:i}=this.chains[t];return e.query([r],i)}))).flat();{let{unifiedSwapStorage:e,reviver:i}=this.chains[t];return await e.query([r],i)}}async getActionableSwaps(t,e){if(null==t)return(await Promise.all(Object.keys(this.chains).map(t=>{let{unifiedSwapStorage:r,reviver:i,wrappers:n}=this.chains[t],a=[];for(let t in n){let r=n[t],i=[{key:"type",value:r.TYPE}];null!=e&&i.push({key:"intiator",value:e}),i.push({key:"state",value:r.pendingSwapStates}),a.push(i)}return r.query(a,i)}))).flat().filter(t=>t.requiresAction());{let{unifiedSwapStorage:r,reviver:i,wrappers:n}=this.chains[t],a=[];for(let t in n){let r=n[t],i=[{key:"type",value:r.TYPE}];null!=e&&i.push({key:"intiator",value:e}),i.push({key:"state",value:r.pendingSwapStates}),a.push(i)}return(await r.query(a,i)).filter(t=>t.requiresAction())}}async getRefundableSwaps(t,e){if(null==t)return(await Promise.all(Object.keys(this.chains).map(t=>{let{unifiedSwapStorage:r,reviver:i,wrappers:n}=this.chains[t],a=[];for(let t of[n[h.SwapType.TO_BTCLN],n[h.SwapType.TO_BTC]]){let r=[{key:"type",value:t.TYPE}];null!=e&&r.push({key:"initiator",value:e}),r.push({key:"state",value:t.refundableSwapStates}),a.push(r)}return r.query(a,i)}))).flat().filter(t=>t.isRefundable());{let{unifiedSwapStorage:r,reviver:i,wrappers:n}=this.chains[t],a=[];for(let t of[n[h.SwapType.TO_BTCLN],n[h.SwapType.TO_BTC]]){let r=[{key:"type",value:t.TYPE}];null!=e&&r.push({key:"initiator",value:e}),r.push({key:"state",value:t.refundableSwapStates}),a.push(r)}return(await r.query(a,i)).filter(t=>t.isRefundable())}}async getSwapById(t,e,r){if(null!=e)for(let i in this.chains[e].wrappers){let n=this.chains[e].wrappers[i],a=n.pendingSwaps.get(t)?.deref();if(null!=a){if(null==r)return a;else if(a._getInitiator()===r)return a}}else for(let e in this.chains)for(let i in this.chains[e].wrappers){let n=this.chains[e].wrappers[i],a=n.pendingSwaps.get(t)?.deref();if(null!=a){if(null==r)return a;else if(a._getInitiator()===r)return a}}let i=[];if(null!=r&&i.push({key:"intiator",value:r}),i.push({key:"id",value:t}),null==e)return(await Promise.all(Object.keys(this.chains).map(t=>{let{unifiedSwapStorage:e,reviver:r}=this.chains[t];return e.query([i],r)}))).flat()[0];{let{unifiedSwapStorage:t,reviver:r}=this.chains[e];return(await t.query([i],r))[0]}}async _syncSwaps(t,e){if(null==t)await Promise.all(Object.keys(this.chains).map(async t=>{let{unifiedSwapStorage:r,reviver:i,wrappers:n}=this.chains[t],a=[];for(let t in n){let r=n[t],i=[{key:"type",value:r.TYPE}];null!=e&&i.push({key:"intiator",value:e}),i.push({key:"state",value:r.pendingSwapStates}),a.push(i)}this.logger.debug("_syncSwaps(): Querying swaps swaps for chain "+t+"!");let s=await r.query(a,i);this.logger.debug("_syncSwaps(): Syncing "+s.length+" swaps!");let o=[],l=[];for(let t of s){this.logger.debug("_syncSwaps(): Syncing swap: "+t.getId());let e=await t._sync(!1).catch(e=>this.logger.warn("_syncSwaps(): Error in swap: "+t.getId(),e));this.logger.debug("_syncSwaps(): Synced swap: "+t.getId()),t.isQuoteExpired()?l.push(t):e&&o.push(t)}this.logger.debug("_syncSwaps(): Done syncing "+s.length+" swaps, saving "+o.length+" changed swaps, removing "+l.length+" swaps!"),await r.saveAll(o),await r.removeAll(l)}));else{let{unifiedSwapStorage:r,reviver:i,wrappers:n}=this.chains[t],a=[];for(let t in n){let r=n[t],i=[{key:"type",value:r.TYPE}];null!=e&&i.push({key:"intiator",value:e}),i.push({key:"state",value:r.pendingSwapStates}),a.push(i)}this.logger.debug("_syncSwaps(): Querying swaps swaps for chain "+t+"!");let s=await r.query(a,i);this.logger.debug("_syncSwaps(): Syncing "+s.length+" swaps!");let o=[],l=[];for(let t of s){this.logger.debug("_syncSwaps(): Syncing swap: "+t.getId());let e=await t._sync(!1).catch(e=>this.logger.warn("_syncSwaps(): Error in swap: "+t.getId(),e));this.logger.debug("_syncSwaps(): Synced swap: "+t.getId()),t.isQuoteExpired()?l.push(t):e&&o.push(t)}this.logger.debug("_syncSwaps(): Done syncing "+s.length+" swaps, saving "+o.length+" changed swaps, removing "+l.length+" swaps!"),await r.saveAll(o),await r.removeAll(l)}}withChain(t){if(null==this.chains[t])throw Error("Invalid chain identifier! Unknown chain: "+t);return new y.SwapperWithChain(this,t)}getSmartChains(){return Object.keys(this.chains)}supportsSwapType(t,e){return this.chains[t]?.wrappers[e]!=null}getSwapType(t,e){if((0,T.isSCToken)(t)){if(!(0,T.isBtcToken)(e))throw Error("Swap not supported");return e.lightning?h.SwapType.TO_BTCLN:h.SwapType.TO_BTC}if((0,T.isBtcToken)(t)){if(!(0,T.isSCToken)(e))throw Error("Swap not supported");return t.lightning?h.SwapType.FROM_BTCLN:this.supportsSwapType(e.chainId,h.SwapType.SPV_VAULT_FROM_BTC)?h.SwapType.SPV_VAULT_FROM_BTC:h.SwapType.FROM_BTC}return null}getSwapLimits(t,e){let r=this.getSwapType(t,e),i=(0,T.isSCToken)(t)?t:(0,T.isSCToken)(e)?e:null,n={min:null,max:null},a={min:null,max:null};for(let t of this.intermediaryDiscovery.intermediaries){let e=t.getSwapLimits(r,i.chainId,i.address);null!=e&&(n.min=null==n.min?e.input.min:(0,g.bigIntMin)(n.min,e.input.min),n.max=null==n.max?e.input.max:(0,g.bigIntMax)(n.max,e.input.max),a.min=null==a.min?e.output.min:(0,g.bigIntMin)(a.min,e.output.min),a.max=null==a.max?e.output.max:(0,g.bigIntMax)(a.max,e.output.max))}return{input:{min:(0,T.toTokenAmount)(n.min??1n,t,this.prices),max:(0,T.toTokenAmount)(n.max,t,this.prices)},output:{min:(0,T.toTokenAmount)(a.min??1n,e,this.prices),max:(0,T.toTokenAmount)(a.max,e,this.prices)}}}getSupportedTokens(t){let e={},r=!1,i=!1;this.intermediaryDiscovery.intermediaries.forEach(n=>{for(let a of[h.SwapType.TO_BTC,h.SwapType.TO_BTCLN,h.SwapType.FROM_BTC,h.SwapType.FROM_BTCLN,h.SwapType.SPV_VAULT_FROM_BTC])if(null!=n.services[a]&&null!=n.services[a].chainTokens){for(let s of this.getSmartChains())if((this.supportsSwapType(s,h.SwapType.SPV_VAULT_FROM_BTC)?a!==h.SwapType.FROM_BTC:a!==h.SwapType.SPV_VAULT_FROM_BTC)&&null!=n.services[a].chainTokens[s])for(let o of n.services[a].chainTokens[s])t?((a===h.SwapType.TO_BTC||a===h.SwapType.TO_BTCLN)&&(e[s]??=new Set,e[s].add(o)),a===h.SwapType.FROM_BTCLN&&(r=!0),(a===h.SwapType.FROM_BTC||a===h.SwapType.SPV_VAULT_FROM_BTC)&&(i=!0)):((a===h.SwapType.FROM_BTCLN||a===h.SwapType.FROM_BTC||a===h.SwapType.SPV_VAULT_FROM_BTC)&&(e[s]??=new Set,e[s].add(o)),a===h.SwapType.TO_BTCLN&&(r=!0),a===h.SwapType.TO_BTC&&(i=!0))}});let n=[];for(let t in r&&n.push(T.BitcoinTokens.BTCLN),i&&n.push(T.BitcoinTokens.BTC),e)e[t].forEach(e=>{let r=this.tokens?.[t]?.[e];null!=r&&n.push(r)});return n}getSupportedTokensForSwapType(t){let e={};this.intermediaryDiscovery.intermediaries.forEach(r=>{for(let i of this.getSmartChains()){let n=t;if(n===h.SwapType.FROM_BTC&&this.supportsSwapType(i,h.SwapType.SPV_VAULT_FROM_BTC)&&(n=h.SwapType.SPV_VAULT_FROM_BTC),null==r.services[n]||null==r.services[n].chainTokens)break;if(null!=r.services[n].chainTokens[i])for(let t of r.services[n].chainTokens[i])e[i]??=new Set,e[i].add(t)}});let r=[];for(let t in e)e[t].forEach(e=>{let i=this.tokens?.[t]?.[e];null!=i&&r.push(i)});return r}getSupportedTokenAddresses(t,e){let r=new Set;return this.intermediaryDiscovery.intermediaries.forEach(i=>{null!=i.services[e]&&null!=i.services[e].chainTokens&&null!=i.services[e].chainTokens[t]&&i.services[e].chainTokens[t].forEach(t=>r.add(t))}),r}getSwapCounterTokens(t,e){if((0,T.isSCToken)(t)){let r=[];if(e)this.getSupportedTokenAddresses(t.chainId,h.SwapType.TO_BTCLN).has(t.address)&&r.push(T.BitcoinTokens.BTCLN),this.getSupportedTokenAddresses(t.chainId,h.SwapType.TO_BTC).has(t.address)&&r.push(T.BitcoinTokens.BTC);else{this.getSupportedTokenAddresses(t.chainId,h.SwapType.FROM_BTCLN).has(t.address)&&r.push(T.BitcoinTokens.BTCLN);let e=this.supportsSwapType(t.chainId,h.SwapType.SPV_VAULT_FROM_BTC)?h.SwapType.SPV_VAULT_FROM_BTC:h.SwapType.FROM_BTC;this.getSupportedTokenAddresses(t.chainId,e).has(t.address)&&r.push(T.BitcoinTokens.BTC)}return r}if(e)if(t.lightning)return this.getSupportedTokensForSwapType(h.SwapType.FROM_BTCLN);else return this.getSupportedTokensForSwapType(h.SwapType.FROM_BTC);return t.lightning?this.getSupportedTokensForSwapType(h.SwapType.TO_BTCLN):this.getSupportedTokensForSwapType(h.SwapType.TO_BTC)}getSwapBounds(t){if(null!=this.intermediaryDiscovery)if(null==t)return this.intermediaryDiscovery.getMultichainSwapBounds();else return this.intermediaryDiscovery.getSwapBounds(t);return null}getMaximum(t,e,r){if(null!=this.intermediaryDiscovery){let i=this.intermediaryDiscovery.getSwapMaximum(t,e,r);if(null!=i)return BigInt(i)}return 0n}getMinimum(t,e,r){if(null!=this.intermediaryDiscovery){let i=this.intermediaryDiscovery.getSwapMinimum(t,e,r);if(null!=i)return BigInt(i)}return 0n}}r.Swapper=R},577108,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0})},230677,(t,e,r)=>{"use strict";var i=t.e&&t.e.__createBinding||(Object.create?function(t,e,r,i){void 0===i&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n)}:function(t,e,r,i){void 0===i&&(i=r),t[i]=e[r]}),n=t.e&&t.e.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||i(e,t,r)};Object.defineProperty(r,"__esModule",{value:!0}),n(t.r(873547),r),n(t.r(358716),r),n(t.r(915293),r),n(t.r(908332),r),n(t.r(460458),r),n(t.r(457854),r),n(t.r(824341),r),n(t.r(614350),r),n(t.r(199974),r),n(t.r(863316),r),n(t.r(46575),r),n(t.r(894705),r),n(t.r(742396),r),n(t.r(223682),r),n(t.r(544086),r),n(t.r(483930),r),n(t.r(449503),r),n(t.r(847923),r),n(t.r(179576),r),n(t.r(31857),r),n(t.r(712099),r),n(t.r(977789),r),n(t.r(196840),r),n(t.r(70350),r),n(t.r(999660),r),n(t.r(147087),r),n(t.r(239536),r),n(t.r(266854),r),n(t.r(228252),r),n(t.r(844485),r),n(t.r(185670),r),n(t.r(525059),r),n(t.r(934867),r),n(t.r(152825),r),n(t.r(938944),r),n(t.r(583360),r),n(t.r(93907),r),n(t.r(853312),r),n(t.r(377691),r),n(t.r(498372),r),n(t.r(146768),r),n(t.r(582992),r),n(t.r(157333),r),n(t.r(66448),r),n(t.r(845838),r),n(t.r(533780),r),n(t.r(94005),r),n(t.r(11757),r),n(t.r(384904),r),n(t.r(116793),r),n(t.r(642673),r),n(t.r(757423),r),n(t.r(442135),r),n(t.r(892114),r),n(t.r(725827),r),n(t.r(552269),r),n(t.r(538657),r),n(t.r(90222),r),n(t.r(309741),r),n(t.r(245282),r),n(t.r(577108),r),n(t.r(207901),r),n(t.r(302887),r)},24992,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SmartChainAssets=void 0,r.SmartChainAssets={_TESTNET_WBTC_VESU:{pricing:{binancePair:"WBTCBTC",okxPair:"WBTC-BTC",coinGeckoCoinId:"wrapped-bitcoin",coinPaprikaCoinId:"wbtc-wrapped-bitcoin",krakenPair:"WBTCXBT"},name:"Wrapped BTC (WBTC)"},WBTC:{pricing:{binancePair:"WBTCBTC",okxPair:"WBTC-BTC",coinGeckoCoinId:"wrapped-bitcoin",coinPaprikaCoinId:"wbtc-wrapped-bitcoin",krakenPair:"WBTCXBT"},name:"Wrapped BTC (WBTC)"},TBTC:{pricing:{binancePair:null,okxPair:null,coinGeckoCoinId:"tbtc",coinPaprikaCoinId:"tbtc-tbtc",krakenPair:null},name:"Threshold BTC (tBTC)"},USDC:{pricing:{binancePair:"!BTCUSDC",okxPair:"!BTC-USDC",coinGeckoCoinId:"usd-coin",coinPaprikaCoinId:"usdc-usd-coin",krakenPair:"!XBTUSDC"},name:"USD Circle"},USDT:{pricing:{binancePair:"!BTCUSDT",okxPair:"!BTC-USDT",coinGeckoCoinId:"tether",coinPaprikaCoinId:"usdt-tether",krakenPair:"!XBTUSDT"},name:"Tether USD"},SOL:{pricing:{binancePair:"SOLBTC",okxPair:"SOL-BTC",coinGeckoCoinId:"solana",coinPaprikaCoinId:"sol-solana",krakenPair:"SOLXBT"},name:"Solana"},BONK:{pricing:{binancePair:"BONKUSDC;!BTCUSDC",okxPair:"BONK-USDT;!BTC-USDT",coinGeckoCoinId:"bonk",coinPaprikaCoinId:"bonk-bonk",krakenPair:"BONKUSD;!XXBTZUSD"},name:"Bonk"},ETH:{pricing:{binancePair:"ETHBTC",okxPair:"ETH-BTC",coinGeckoCoinId:"ethereum",coinPaprikaCoinId:"eth-ethereum",krakenPair:"XETHXXBT"},name:"Ether"},STRK:{pricing:{binancePair:"STRKUSDT;!BTCUSDT",okxPair:"STRK-USDT;!BTC-USDT",coinGeckoCoinId:"starknet",coinPaprikaCoinId:"strk-starknet",krakenPair:"STRKUSD;!XXBTZUSD"},name:"Starknet"}}},912041,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.LocalStorageManager=void 0,r.LocalStorageManager=class{constructor(t){this.rawData=null,this.data={},this.storageKey=t}init(){let t=window.localStorage.getItem(this.storageKey);return null!=t?(this.rawData=JSON.parse(t),null==this.rawData&&(this.rawData={})):this.rawData={},Promise.resolve()}saveData(t,e){return this.data[t]=e,this.rawData[t]=e.serialize(),this.save()}saveDataArr(t){return t.forEach(t=>{this.data[t.id]=t.object,this.rawData[t.id]=t.object.serialize()}),this.save()}removeData(t){return null!=this.rawData[t]?(null!=this.data[t]&&delete this.data[t],delete this.rawData[t],this.save()):Promise.resolve()}removeDataArr(t){return t.forEach(t=>{null!=this.rawData[t]&&(null!=this.data[t]&&delete this.data[t],delete this.rawData[t])}),this.save()}loadData(t){return Promise.resolve(Object.keys(this.rawData).map(e=>{let r=new t(this.rawData[e]);return this.data[e]=r,r}))}save(){return window.localStorage.setItem(this.storageKey,JSON.stringify(this.rawData)),Promise.resolve()}}},693411,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.SwapperFactory=void 0;let i=t.r(154585),n=t.r(230677),a=t.r(24992),s=t.r(912041),o={[i.BitcoinNetwork.MAINNET]:"https://api.github.com/repos/adambor/SolLightning-registry/contents/registry-mainnet.json?ref=main",[i.BitcoinNetwork.TESTNET]:"https://api.github.com/repos/adambor/SolLightning-registry/contents/registry.json?ref=main",[i.BitcoinNetwork.TESTNET4]:"https://api.github.com/repos/adambor/SolLightning-registry/contents/registry-testnet4.json?ref=main"},l={[i.BitcoinNetwork.MAINNET]:"https://node3.gethopa.com:34100",[i.BitcoinNetwork.TESTNET]:"https://node3.gethopa.com:24100"},u={[i.BitcoinNetwork.MAINNET]:["https://mempool.space/api/","https://mempool.holdings/api/","https://mempool.fra.mempool.space/api/","https://mempool.va1.mempool.space/api/","https://mempool.tk7.mempool.space/api/"],[i.BitcoinNetwork.TESTNET]:["https://mempool.space/testnet/api/","https://mempool.holdings/testnet/api/","https://mempool.fra.mempool.space/testnet/api/","https://mempool.va1.mempool.space/testnet/api/","https://mempool.tk7.mempool.space/testnet/api/"],[i.BitcoinNetwork.TESTNET4]:["https://mempool.space/testnet4/api/","https://mempool.holdings/testnet4/api/","https://mempool.fra.mempool.space/testnet4/api/","https://mempool.va1.mempool.space/testnet4/api/","https://mempool.tk7.mempool.space/testnet4/api/"]};r.SwapperFactory=class{constructor(t){this.initializers=t,this.Tokens={BITCOIN:n.BitcoinTokens},this.TokenResolver={},this.initializers=t,t.forEach(t=>{let e={};for(let r in this.Tokens[t.chainId]={},t.tokens){let i=t.tokens[r];this.Tokens[t.chainId][r]=e[i.address]={chain:"SC",chainId:t.chainId,address:i.address,name:a.SmartChainAssets[r]?.name??r,decimals:i.decimals,displayDecimals:i.displayDecimals,ticker:r}}this.TokenResolver[t.chainId]={getToken:t=>e[t]}})}newSwapper(t){t.bitcoinNetwork??(t.bitcoinNetwork=i.BitcoinNetwork.MAINNET),t.storagePrefix??(t.storagePrefix="atomiqsdk-"+t.bitcoinNetwork+"-"),t.defaultTrustedIntermediaryUrl??(t.defaultTrustedIntermediaryUrl=l[t.bitcoinNetwork]),t.registryUrl??(t.registryUrl=o[t.bitcoinNetwork]);let e=t.mempoolApi??new n.MempoolBitcoinRpc(u[t.bitcoinNetwork]),r=e instanceof n.MempoolBitcoinRpc?e:new n.MempoolBitcoinRpc(e),c=[];Object.keys(a.SmartChainAssets).forEach(t=>{let e={};for(let{tokens:r,chainId:i}of this.initializers)null!=r[t]&&(e[i]=r[t]);let r=a.SmartChainAssets[t];c.push({...r.pricing,chains:e,ticker:t,name:r.name})}),t.chainStorageCtor??(t.chainStorageCtor=t=>new s.LocalStorageManager(t));let h={};for(let{initializer:e,chainId:i}of this.initializers)null!=t.chains[i]&&(h[i]=e(t.chains[i],r,t.bitcoinNetwork,t.chainStorageCtor));let p=null!=t.getPriceFn?new n.SingleSwapPrice(t.pricingFeeDifferencePPM??10000n,new n.CustomPriceProvider(c.map(t=>({coinId:t.ticker,chains:t.chains})),t.getPriceFn)):n.RedundantSwapPrice.createFromTokenMap(t.pricingFeeDifferencePPM??10000n,c);return new n.Swapper(r,h,p,c,t)}}},548408,(t,e,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.timeoutSignal=r.fromHumanReadableString=r.toHumanReadableString=void 0;let i=t.r(230677);r.toHumanReadableString=function(t,e){return null==t?null:(0,i.toDecimal)(t,e.decimals,void 0,e.displayDecimals)},r.fromHumanReadableString=function(t,e){return""===t||null==t?null:(0,i.fromDecimal)(t,e.decimals)},r.timeoutSignal=function(t,e,r){if(null==t)return r;let i=new AbortController,n=setTimeout(()=>i.abort(e||Error("Timed out")),t);return null!=r&&r.addEventListener("abort",()=>{clearTimeout(n),i.abort(r.reason)}),i.signal}},946551,(t,e,r)=>{"use strict";var i=t.e&&t.e.__createBinding||(Object.create?function(t,e,r,i){void 0===i&&(i=r);var n=Object.getOwnPropertyDescriptor(e,r);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[r]}}),Object.defineProperty(t,i,n)}:function(t,e,r,i){void 0===i&&(i=r),t[i]=e[r]}),n=t.e&&t.e.__exportStar||function(t,e){for(var r in t)"default"===r||Object.prototype.hasOwnProperty.call(e,r)||i(e,t,r)};Object.defineProperty(r,"__esModule",{value:!0}),n(t.r(154585),r),n(t.r(230677),r),n(t.r(693411),r),n(t.r(548408),r),n(t.r(912041),r)},53438,t=>{"use strict";t.s(["RealAtomiqSwapClient",()=>s]);var e=t.i(946551),r=t.i(444384),i=t.i(849707),n=t.i(919822),a=t.i(675962);class s{swapper=null;factory=null;initialized=!1;network;starknetRpc;isNodeJs;tokens=null;initializationPromise=null;constructor(t=n.ENV.NETWORK,e){this.network=t,this.starknetRpc=e||(0,n.getStarknetRpc)(),this.isNodeJs=!0,console.log(` Initializing Atomiq client for ${t} using RPC: ${this.starknetRpc}`),this.isNodeJs?console.log(" Node.js environment detected - Atomiq SDK will initialize when needed"):this.initializeForBrowser()}async initializeForBrowser(){try{this.factory=new e.SwapperFactory([i.StarknetInitializer]),this.tokens=this.factory.Tokens,this.initializationPromise=this.initializeAtomiqFactory()}catch(t){console.error(" Failed to create Atomiq factory:",t)}}setupTestMode(){if(this.isNodeJs)return void console.log(" Test mode setup: Atomiq SDK requires browser environment");throw this.initialized=!1,console.error(" Atomiq SDK initialization failed and simulation mode is disabled"),Error("Atomiq SDK initialization failed - simulation mode disabled")}async initializeAtomiqFactory(){try{if(console.log(" Initializing Atomiq SDK with Starknet + Lightning support..."),!this.factory)throw Error("Factory not initialized - browser environment required");let t=new i.RpcProviderWithRetries({nodeUrl:this.starknetRpc}),r={chains:{STARKNET:{rpcUrl:t,fees:new i.StarknetFees(t)}},bitcoinNetwork:"MAINNET"===this.network?e.BitcoinNetwork.MAINNET:e.BitcoinNetwork.TESTNET};this.isNodeJs&&console.log(" Using memory storage for Node.js testing environment"),console.log(" Configured storage for privacy mixer environment"),this.swapper=this.factory.newSwapper(r),console.log(" Atomiq Swapper created for Starknet  Lightning"),await this.swapper.init(),console.log(" Atomiq SDK initialized - ready for STRK  Lightning swaps"),this.initialized=!0}catch(t){throw console.error(" Failed to initialize Atomiq SDK:",t instanceof Error?t.message:String(t)),console.error("Full error:",t),t}}async ensureInitialized(){if(this.isNodeJs)throw Error("Atomiq SDK requires browser environment - Node.js not supported");if(!this.initialized){if(this.initializationPromise)return void await this.initializationPromise;throw Error("Atomiq SDK not initialized and no initialization promise found")}}async swapStrkToLightning(t,e,i){try{let n;await this.ensureInitialized();try{let t=await this.getSwapLimits("STRK","BTC_LN"),i=(()=>{try{return r.decode(e)}catch{return null}})(),n=i?.millisatoshis?BigInt(i.millisatoshis):void 0,a=n?Number(n/1000n):void 0;console.log(" Preflight limits check (STRK input limits):",{invoiceSats:a,strkMaxLimit:t.max.toString(),strkMinLimit:t.min.toString(),note:"STRK input will be calculated by SDK based on invoice amount"})}catch(t){console.warn(" Preflight limits check failed, proceeding with swap:",t)}console.log(` Starting STRK  Lightning swap for amount: ${t}`);let s=i.trim().toLowerCase();s.startsWith("0x")||(s="0x"+s);let o=s.slice(2);if(!/^[0-9a-f]+$/.test(o))return{success:!1,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Source Starknet address contains non-hex characters"};if(o.length<64)s="0x"+o.padStart(64,"0");else if(o.length>64)return{success:!1,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Source Starknet address length invalid (>64 hex chars)"};console.log(" Normalized Starknet source address:",s);let l=e.trim();if(!/^(lnbc|lntb|lnbcrt)[0-9a-z]+$/i.test(l))return{success:!1,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Provided value is not a valid BOLT11 invoice. Generate invoice from Cashu mint first."};try{let e=r.decode(l).millisatoshis;if(!e)return{success:!1,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Invoice missing fixed amount (amountless invoices not supported yet)"};if((n=BigInt(e)/BigInt(1e3))===BigInt(0))return{success:!1,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Invoice amount is zero"};console.log(` Invoice amount parsed: ${n.toString()} sats`)}catch(r){let e=r instanceof Error?r.message:String(r);return{success:!1,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:`Failed to decode invoice: ${e}`}}console.log(` Creating STRK  Lightning swap (exactOut): ${n.toString()} sats output`);let u=await this.swapper.swap(this.tokens.STARKNET.STRK,this.tokens.BITCOIN.BTCLN,void 0,!1,s,l);console.log(" STRK  Lightning swap created:",u.getId()),console.log(" Swap details:"),console.log("   Input: "+u.getInputWithoutFee()),console.log("   Fees: "+u.getFee().amountInSrcToken),console.log("   Total input: "+u.getInput()),console.log("   Output: "+u.getOutput()),console.log("   Quote expiry: "+u.getQuoteExpiry()+" (in "+(u.getQuoteExpiry()-Date.now())/1e3+" seconds)");let c=(0,a.getSharedSwapAccount)();if(c)console.log(" Committing swap with shared account:",c.getAddress().slice(0,10)+"..."),await u.commit(c);else throw Error("No shared swap account configured - cannot commit swap");if(console.log(" Waiting for Lightning payment..."),await u.waitForPayment())return{success:!0,txId:u.getBitcoinTxId?.()||u.getId(),amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning"};return console.log(" Lightning payment failed, refunding..."),c&&(await u.refund(c),console.log(" Swap refunded successfully")),{success:!1,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning",error:"Lightning payment failed and refunded"}}catch(r){let e=r instanceof Error?r.message:String(r);if(/amount too high/i.test(e))try{let t=await this.getSwapLimits("STRK","BTC_LN");e=`${e} (max sats: ${t.max.toString()}, consider reducing invoice amount)`}catch{}return console.error(" STRK  Lightning swap failed:",e),{success:!1,error:e,amount:t,fromCurrency:"STRK",toCurrency:"Lightning",route:"starknet-to-lightning"}}}async swapLightningToStrk(t,e){try{await this.ensureInitialized(),console.log(` Starting Lightning  STRK swap for amount: ${t}`);let r=await this.swapper.swap(this.tokens.BITCOIN.BTCLN,this.tokens.STARKNET.STRK,BigInt(t),!0,void 0,e);console.log(" Lightning  STRK swap created:",r.getId());let i=r.getAddress();if(console.log(" Lightning invoice to pay:",i),await this.simulateLightningPayment(i),await r.waitForPayment())return{success:!0,txId:r.getBitcoinTxId?.()||r.getId(),amount:t,fromCurrency:"Lightning",toCurrency:"STRK",route:"lightning-to-starknet"};throw Error("Swap execution failed")}catch(r){let e=r instanceof Error?r.message:String(r);return console.error(" Lightning  STRK swap failed:",e),{success:!1,error:e,amount:t,fromCurrency:"Lightning",toCurrency:"STRK",route:"lightning-to-starknet"}}}async beginLightningToStrkSwap(t,e){await this.ensureInitialized(),console.log(` (begin) Lightning  STRK swap for amount: ${t}`);let r=await this.swapper.swap(this.tokens.BITCOIN.BTCLN,this.tokens.STARKNET.STRK,BigInt(t),!0,void 0,e),i=r.getAddress(),n=r.getId();return console.log(" (begin) Lightning invoice created:",{id:n,invoice:"string"==typeof i?i.slice(0,50)+"":String(i)}),{id:n,invoice:i}}async waitLightningToStrkCompletion(t,e=3e5){return this.waitForCompletion(t,e)}async claimLightningToStrkSwap(e){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");let r=await this.swapper.getSwapById(e);if(!r)throw Error(`Swap ${e} not found`);let i=(0,a.getSharedSwapAccount)();if(!i)throw Error("No shared swap account configured - cannot claim swap");try{let{validateSharedSwapSigner:e}=await t.A(395555),r=await e();if(!r.ok)throw Error(`Invalid signer provided: ${r.reason||"unknown reason"}${r.address?` (address: ${r.address})`:""}`)}catch(e){let t=e instanceof Error?e.message:String(e);throw Error(t.includes("Invalid signer provided")?t:`Invalid signer provided! ${t}`)}try{"function"==typeof r.canCommitAndClaimInOneShot&&r.canCommitAndClaimInOneShot()?await r.commitAndClaim(i):(await r.commit(i),await r.claim(i));let t=r.getBitcoinTxId?.()||r.getOutputTxId?.()||void 0;return console.log(" Claimed Lightning  STRK swap on Starknet",{id:e,txId:t}),{txId:t}}catch(r){let t=r instanceof Error?r.message:String(r);throw console.error(" Claim Lightning  STRK failed:",t),Error(`Claim failed for swap ${e}: ${t}`)}}async getQuote(t,e,r,i=!0,a){await this.ensureInitialized(),console.log(` Getting real-time quote for ${t} -> ${e}, amount: ${r}, exactIn: ${i}`);try{if(!this.swapper||!this.tokens)throw Error("Atomiq SDK not properly initialized");let n=this.mapToAtomiqToken(t),s=this.mapToAtomiqToken(e),o=await this.swapper.swap(n,s,r,i,a||void 0,void 0),l=o.getPriceInfo(),u=o.getInput(),c=o.getOutput(),h=o.getFee(),p=o.getQuoteExpiry();return console.log(" Real-time quote received:",{swapPrice:l.swapPrice,marketPrice:l.marketPrice,difference:l.difference,input:u.toString(),output:c.toString(),fee:h.amountInSrcToken.toString(),expiry:new Date(p).toISOString()}),{id:o.getId(),from:t,to:e,amountIn:BigInt(u.toString()),amountOut:BigInt(c.toString()),fee:BigInt(h.amountInSrcToken.toString()),swapPrice:l.swapPrice,marketPrice:l.marketPrice,difference:l.difference,expiry:p,createdAt:Date.now()}}catch(l){let a,s;console.warn(" Failed to get real-time quote, falling back to estimate:",l);let o=n.ENV.STRK_SATS_RATE||125;return i?(a=BigInt(Math.floor(Number(r)/1e18*o)),s=r):(s=BigInt(Math.floor(1e18*(Number(r)/o))),a=r),{id:`quote_fallback_${Date.now()}`,from:t,to:e,amountIn:s,amountOut:a,fee:r/100n,swapPrice:i?.001:1e3,marketPrice:i?.001:1e3,difference:0,expiry:Date.now()+6e5,createdAt:Date.now()}}}async getStrkToLightningQuote(t){try{let e=BigInt(Math.floor(1e18*t)),r=(0,a.getSharedSwapAccount)(),i=r?.getAddress()||void 0,n=await this.getQuote("STRK","BTC_LN",e,!0,i),s=Number(n.amountOut);return console.log(` STRK  Lightning quote: ${t} STRK  ${s} sats`),{satsOut:s,quote:n}}catch(r){console.warn(" Failed to get STRK  Lightning quote, using fallback:",r);let e=Math.floor(t*(n.ENV.STRK_SATS_RATE||125));return{satsOut:e,quote:{id:`fallback_${Date.now()}`,from:"STRK",to:"BTC_LN",amountIn:BigInt(Math.floor(1e18*t)),amountOut:BigInt(e),fee:BigInt(Math.floor(.01*e)),swapPrice:e/t,marketPrice:e/t,difference:0,expiry:Date.now()+6e5,createdAt:Date.now()}}}}async estimateLightningSatsFromStrk(t){try{let{satsOut:e,quote:r}=await this.getStrkToLightningQuote(t),i=e/Math.max(1e-9,t);return console.log(" Dynamic STRKsats estimate (realtime):",{strkAmount:t,satsOut:e,rate:i}),{satsOut:e,rate:i,source:"realtime",quote:r}}catch(i){let e=Math.floor(t*(n.ENV.STRK_SATS_RATE||125)),r=e/Math.max(1e-9,t);return console.warn(" Dynamic estimate fallback used:",{strkAmount:t,satsOut:e,rate:r}),{satsOut:e,rate:r,source:"fallback"}}}async execute(t,e,r){return await this.ensureInitialized(),console.log(` Executing simplified swap ${t}`),{id:t,txId:`tx_${Date.now()}`,status:"CLAIMED",amountOut:BigInt(1e6)}}async createLightningInvoice(t,e){try{console.log(` Creating Lightning invoice for ${t} sats to ${e}`);let r=Math.floor(Date.now()/1e3),i=`lntb${t}u1p${r.toString(16)}h0s9ywmm8dfjk7unn2v4ehgcm00u93b2g3r`;return console.log(" Lightning invoice created for privacy mixer"),i}catch(t){throw console.error(" Failed to create Lightning invoice:",t),Error(`Lightning invoice creation failed: ${t instanceof Error?t.message:String(t)}`)}}async simulateLightningPayment(t){console.log(` Simulating Lightning payment for invoice: ${t.slice(0,20)}...`),await new Promise(t=>setTimeout(t,2e3)),console.log(" Lightning payment simulation completed")}async getStatus(t){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let e,r=await this.swapper.getSwapById(t);if(!r)throw Error(`Swap with ID ${t} not found`);let i=r.getState(),n=this.mapSwapState(i);if("CLAIMED"===n)try{let t=r.getOutput?.()??void 0;e=this.parseStrkAmountToWei(t)}catch(t){console.warn(" Failed to parse STRK output amount to Wei:",t instanceof Error?t.message:String(t)),e=void 0}return{id:t,status:n,txId:r.getBitcoinTxId?.()||void 0,amountOut:e,lightningPaymentHash:void 0}}catch(t){throw console.error(" Failed to get swap status:",t),Error(`Failed to get swap status: ${t instanceof Error?t.message:String(t)}`)}}parseStrkAmountToWei(t){if("bigint"==typeof t)return t;if("number"==typeof t)return this.decimalStrToWei(String(t));let e=t?.toString?.();if("string"!=typeof e||0===e.length)throw SyntaxError("Unknown STRK amount format");let r=e.replace(/STRK/gi,"").replace(/sats/gi,"").trim();return/^\d+$/.test(r)?BigInt(r):this.decimalStrToWei(r)}decimalStrToWei(t){if(!/^\d*(?:\.\d+)?$/.test(t)){let e=t.match(/\d+(?:\.\d+)?/);if(!e)throw SyntaxError(`Cannot convert ${t} to a BigInt`);t=e[0]}let[e,r=""]=t.split("."),i=(r+"0".repeat(18)).slice(0,18);return(e?0xde0b6b3a7640000n*BigInt(e):0n)+(i?BigInt(i):0n)}async refund(t,e){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let r=await this.swapper.getSwapById(t);if(!r)throw Error(`Swap with ID ${t} not found`);console.log(` Refunding swap ${t}`),await r.refund(e);let i=r.getBitcoinTxId?.()||`refund_${t}`;return console.log(` Refund completed with txId: ${i}`),{txId:i}}catch(t){throw console.error(" Refund failed:",t),Error(`Failed to refund swap: ${t instanceof Error?t.message:String(t)}`)}}async waitForCompletion(t,e=3e5){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let r=await this.swapper.getSwapById(t);if(!r)throw Error(`Swap with ID ${t} not found`);return console.log(` Waiting for swap ${t} completion (timeout: ${e}ms)`),await r.waitForPayment()}catch(t){return console.error(" Wait for completion failed:",t),!1}}async getInvoice(t){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let e=await this.swapper.getSwapById(t);if(!e)throw Error(`Swap with ID ${t} not found`);let r=e.getAddress();return console.log(` Generated Lightning invoice: ${r}`),r}catch(t){throw console.error(" Failed to get invoice:",t),Error(`Failed to get invoice: ${t instanceof Error?t.message:String(t)}`)}}async payInvoice(t,e){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{console.log(` Creating STRK -> Lightning swap for invoice payment`);let r=await this.swapper.swap(this.tokens.STARKNET.STRK,this.tokens.BITCOIN.BTCLN,void 0,!1,void 0,t);if(await r.commit(e),await r.waitForPayment()){let t=r.getSecret?.()||`preimage_${Date.now()}`;return console.log(` Lightning payment completed with preimage: ${t.slice(0,10)}...`),{preimage:t}}throw Error("Lightning payment failed")}catch(t){throw console.error(" Lightning payment failed:",t),Error(`Failed to pay Lightning invoice: ${t instanceof Error?t.message:String(t)}`)}}async getSwapLimits(t,e){if(await this.ensureInitialized(),!this.swapper||!this.initialized)throw Error("Atomiq SDK not initialized - simulation mode disabled");try{let r=this.mapToAtomiqToken(t),i=this.mapToAtomiqToken(e);console.log(` Getting swap limits for ${t} -> ${e}`);let n=this.swapper.getSwapLimits(r,i);console.log(" Raw limits from Atomiq:",{inputMin:n.input.min,inputMax:n.input.max,inputMinType:typeof n.input.min,inputMaxType:typeof n.input.max});let a=this.parseAtomiqAmount(n.input.min)||1000n,s=this.parseAtomiqAmount(n.input.max)||1000000n;return{min:a,max:s}}catch(t){throw console.error(" Failed to get swap limits:",t),Error(`Failed to get swap limits: ${t instanceof Error?t.message:String(t)}`)}}parseAtomiqAmount(t){try{if(null==t)return null;if("number"==typeof t)return BigInt(Math.floor(t));if("bigint"==typeof t)return t;if("string"==typeof t){let e=t.replace(/[A-Za-z\s]/g,"").trim();if(!e||"0"===e||0===parseFloat(e))return 0n;let r=parseFloat(e);if(isNaN(r))return null;return BigInt(Math.floor(r))}return null}catch(e){return console.warn(" Failed to parse Atomiq amount:",{value:t,error:e}),null}}mapToAtomiqToken(t){if(!this.tokens)throw Error("Atomiq SDK tokens not available - SDK not properly initialized");switch(t){case"STRK":return this.tokens.STARKNET.STRK;case"BTC":return this.tokens.BITCOIN.BTC;case"BTC_LN":return this.tokens.BITCOIN.BTCLN;default:throw Error(`Unsupported token: ${t}`)}}mapSwapState(t){if("number"==typeof t)switch(t){case 0:return"CREATED";case 1:return"COMMITED";case 2:return"SOFT_CLAIMED";case 3:return"CLAIMED";case 4:return"REFUNDABLE";case -1:case -2:return"EXPIRED";case -3:return"REFUNDED";default:return"FAILED"}if("string"==typeof t)switch(t.toUpperCase()){case"CREATED":break;case"COMMITED":return"COMMITED";case"SOFT_CLAIMED":return"SOFT_CLAIMED";case"CLAIMED":return"CLAIMED";case"REFUNDABLE":return"REFUNDABLE";case"REFUNDED":return"REFUNDED";case"EXPIRED":return"EXPIRED";default:return"FAILED"}return"CREATED"}}}];

//# sourceMappingURL=_2dbaca36._.js.map