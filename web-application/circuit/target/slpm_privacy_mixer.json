{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":5416927793301017412,"abi":{"parameters":[{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"path_elements","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"private"},{"name":"path_indices","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"private"},{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"},{"name":"amount_low","type":{"kind":"field"},"visibility":"public"},{"name":"amount_high","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"12504151944586406243":{"error_kind":"string","string":"Invalid Merkle proof"}}},"bytecode":"H4sIAAAAAAAA/9Vc6VITQRDuJFzeIEGICqggiCDMZHMKAsqlgqCCoIIggeB98RI+gX98BcuH8wUsp2W2atxs6cp2b+10VddubeDL9/WRr3Im4CD2Vd6B2kjo46Q+OqKQy1WL2ap05LbIliulvMjlK4WSLMl8Kb+bLTlOtZQrFcuVclGUZc6pyr182dkTB9FhYIn/C8d7AbmdVlnn4fpTn7ca52njvEOfu/+XUXlW5TmV543rXDXoPHwNaoKTZ9fheWa9F/7Vq4xx3mmcd3l61a3ygsqLKi/p617Mv9VEhAt5hA5LmHx7OAn3MOD2Eg4al+5eo8BEuL5cw+pPaK7UuDvMukW4kBkm3bvA8wBbR6w/Qaj5MiEvwrmRtvQiQ9iLPqYdjtNe+Bk6zqBr3H0QzND7VV5ROaDyKkRv6EeBx9AHOQkPMuAOQbwNHXUPGQUmwmUx9KTmSo1bZdYtwoXsZ9K9B3aYSJJQ8zVCXoRzI23pRT9hL4aZdjhOe+Fn6DiDrnEPQzBDH0EuKqXKLERv6MeAx9AdTsIOA24O4m3oqDtnFJgIl8XQU5orNe4LZt0iXMgRJt0vwQ4TSRFqzhPyIpwbaUsvRgh7UWDa4TjthZ+h4wy6xl2AYIZeVFlSWVZ5HaI39OPAY+ijnIRHGXDHIN6GjrrHjAIT4bIYep3mSo37ilm3CBeyyKT7NdhhInWEmm8Q8iKcG2lLL4qEvRhn2uE47YWfoeMMusY9DsEMfUJzuqnyFkRv6CeAx9CnOAlPMeBOQ7wNHXVPGwUmwmUx9HrNlRr3DbNuES7kBJPut2CHidQTap4h5EU4N9KWXkwQ9mKWaYfjtBd+ho4z6Br3LAQz9DmVt+HgA5x3IXpDPwk8hj7PSXieAXcB4m3oqHvBKDARLouhN2iu1LjvmHWLcCHnmHS/BztMpIFQ8z1CXoRzI23pxRxhLxaZdjhOe+Fn6DiDrnEvQjBDX1J5X+UDlQ8hekM/BTyGvsxJeJkBdwXibeioe8UoMBEui6E3aq7UuB+YdYtwIZeYdH8EO0ykkVDzI0JehHMjbenFEmEvVpl2OE574WfoOIOuca9CMENfU/lY5ROVTyF6Q28GHkNf5yS8zoC7AfE2dNS9YRSYCJfF0Js0V2rcT8y6RbiQa0y698EOE2ki1PyMkBfh3EhberFG2ItNph2O0174GTrOoGvcmxDM0LdUPle5rbICtb8ZkPT0OWwNWghnZgt4ZturWYQL2UZYv25LNJ8h1JyJSHOcZrsdaB8r3L1uMfQndA1S+nZ8CxpftcYnuuiN+NMD+G1F/IIDfiYSP0aB77zgizXNHkx8LMLfKUlrPAyce5yDdvjzycGMPu4MfPn649vn7yYf0PdrHtuM21OENXbx0zz4v18o8kabcZ726Ewat00ScXDx3J7UQ20kPbe5f9vk4Zeg5ye9XFI+9+VGqz6mjWtuPX8BV5C8iABIAAA=","debug_symbols":"7ZvdasJAEIXfZa+92P9NfJVSStRYAiFK1EIR371RXOuMQcncCefOzc5ZyDcwc3aCR7WqF4fvr6Zbb3Zq/nFU7WZZ7ZtNN6yOSl8e7bZVd17t9lW/V3NjrJmpuludfyZ7mql109ZqHt1p9hDsYo71NvyH2rHQEG+h+hZ6Vj2E2mTKa6xNzj0PNinlg00qw4tgfTvZ6FjcB3/OlAEPwsOO8rCxyBKnw3MeIWQeUdu35+HAg/Dw4EF4hFEewessCYHUj0ESp0vSdEkxKolluL24fVHYTHKZqElvn6gSPGjj0wBCgRgAoUAsgFAgbnoZNl6gETQVE5EsmqwEIBQIHAEDAkvA7n6wBAyImV6IrRVoBI3FeiSLJisACAUCS8CAwBIwILAEDEg5vRA7LdAIGovDdYyNZh2AUCAeQCgQWAIGBJaAARFM1l0h0Agai8d1jCbLY0LLgMASMCCwBAyIBxAKRDBb94Ivtl7QWDyuYyxZmNBSIAGWgAGBJWBAYAkYEMFsPXiBRtBYAq5jLFmY0DIgsAQMCCwBBRJhCRgQwWw9Cj7aRkFjiR7JosnChJYBgSVgQGAJGBBYAgZk3BIUOr+kKawnhXhYLPqmbZvvr/s/Rw2Pf6q+qRZtfV2uD93ybnf/u807Wb/tN8t6dejr80mXveH4Pw==","file_map":{"25":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"62":{"source":"// Merkle tree utilities for SLPM Privacy Mixer\n\nuse std::hash::poseidon2;\n\n// Compute parent hash in Merkle tree\npub fn hash_pair(left: Field, right: Field) -> Field {\n    poseidon2::Poseidon2::hash([left, right], 2)\n}\n\n// Compute commitment from secret and amount\npub fn compute_commitment(secret: Field, amount_low: Field, amount_high: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret, amount_low, amount_high], 3)\n}\n\n// Compute nullifier from secret and commitment\npub fn compute_nullifier(secret: Field, commitment: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret, commitment], 2)\n}\n\n// Verify Merkle proof with fixed depth\npub fn verify_merkle_proof(\n    leaf: Field,\n    path_elements: [Field; 8],\n    path_indices: [Field; 8],\n    expected_root: Field,\n) -> bool {\n    let mut current = leaf;\n    \n    for i in 0..8 {\n        let path_element = path_elements[i];\n        let is_left = path_indices[i];\n        \n        let left = if is_left == 0 { current } else { path_element };\n        let right = if is_left == 0 { path_element } else { current };\n        \n        current = hash_pair(left, right);\n    }\n    \n    current == expected_root\n}\n","path":"/Users/mac/Desktop/CODE/SLPM-enhanced/circuit/src/lib.nr"},"63":{"source":"// SLPM Privacy Mixer Circuit\n// This circuit proves the following without revealing the secret:\n// 1. The prover knows a secret that corresponds to a commitment in the Merkle tree\n// 2. The nullifier is correctly derived from the secret\n// 3. The withdrawal parameters (recipient, amount) are bound to the proof\n//\n// Privacy guarantees:\n// - Unlinkability: No one can link the deposit to the withdrawal\n// - Nullifier prevents double-spending\n// - Merkle tree provides anonymity set\n// - Amount and recipient are committed to prevent front-running\n\nmod lib;\nuse lib::{compute_commitment, compute_nullifier};\n\n// Merkle tree depth for anonymity set\nglobal MERKLE_TREE_DEPTH: u32 = 8; // Supports up to 256 commitments\n\nfn main(\n    // Private inputs (known only to prover)\n    secret: Field,\n    path_elements: [Field; MERKLE_TREE_DEPTH],\n    path_indices: [Field; MERKLE_TREE_DEPTH],\n    // Public inputs\n    root: pub Field,\n    recipient: pub Field,\n    amount_low: pub Field,\n    amount_high: pub Field,\n) -> pub (Field, Field, Field) {\n    // Step 1: Generate commitment from secret and amount\n    let commitment = compute_commitment(secret, amount_low, amount_high);\n    \n    // Step 2: Compute nullifier (this becomes a public output)\n    let nullifier_hash = compute_nullifier(secret, commitment);\n    \n    // Step 3: Compute expected root from commitment and path\n    let mut expected_root = commitment;\n    for i in 0..8 {\n        let path_element = path_elements[i];\n        let is_left = path_indices[i];\n        let left = if is_left == 0 { expected_root } else { path_element };\n        let right = if is_left == 0 { path_element } else { expected_root };\n        expected_root = lib::hash_pair(left, right);\n    }\n    \n    // Step 4: Verify the provided root matches expected\n    assert(expected_root == root, \"Invalid Merkle proof\");\n    \n    // Step 5: Bind recipient to the proof (prevents front-running)\n    // We just ensure recipient is included as public input\n    // The contract will verify the recipient matches the transaction\n    let _recipient_check = recipient;\n    \n    // Step 6: Bind amount to the proof\n    // The amounts are public inputs, preventing tampering\n    let _amount_check_low = amount_low;\n    let _amount_check_high = amount_high;\n    \n    // Return nullifier, commitment, and computed root as public outputs\n    (nullifier_hash, commitment, expected_root)\n}\n\n#[test]\nfn test_privacy_circuit_valid_proof() {\n    // Test with valid inputs\n    let secret = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n    let amount_low = 1000000000000000000; // 1 STRK\n    let amount_high = 0;\n    \n    // Generate commitment\n    let commitment = compute_commitment(secret, amount_low, amount_high);\n    \n    // Generate nullifier\n    let nullifier = compute_nullifier(secret, commitment);\n    \n    // Create a simple Merkle tree with just the commitment as root\n    // For testing, we'll create a tree with empty siblings\n    let path_elements = [0; MERKLE_TREE_DEPTH];\n    let path_indices = [0; MERKLE_TREE_DEPTH];\n    \n    // Calculate root by hashing up the tree\n    let mut current = commitment;\n    for _i in 0..MERKLE_TREE_DEPTH {\n        current = lib::hash_pair(current, 0);\n    }\n    let root = current;\n    \n    let recipient = 0x1ad102b4c4b3e40a51b6fb8a446275d600555bd63a95cdceed3e5cef8a6bc1d;\n    \n    // This should pass - the function returns (nullifier, commitment, root)\n    let (computed_nullifier, computed_commitment, computed_root) = main(\n        secret,\n        path_elements,\n        path_indices,\n        root,\n        recipient,\n        amount_low,\n        amount_high,\n    );\n    \n    // Verify the computed values match what we expect\n    assert(computed_nullifier == nullifier);\n    assert(computed_commitment == commitment);\n    assert(computed_root == root);\n}\n\n// Note: Invalid nullifier test removed since nullifier is now computed, not provided\n\n#[test(should_fail)]\nfn test_privacy_circuit_invalid_merkle_proof() {\n    let secret = 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef;\n    let amount_low = 1000000000000000000;\n    let amount_high = 0;\n    \n    let path_elements = [0; MERKLE_TREE_DEPTH];\n    let path_indices = [0; MERKLE_TREE_DEPTH];\n    \n    // Wrong root\n    let wrong_root = 0x8888;\n    \n    let recipient = 0x1ad102b4c4b3e40a51b6fb8a446275d600555bd63a95cdceed3e5cef8a6bc1d;\n    \n    // This should fail due to invalid Merkle proof\n    let _ = main(\n        secret,\n        path_elements,\n        path_indices,\n        wrong_root,\n        recipient,\n        amount_low,\n        amount_high,\n    );\n}\n","path":"/Users/mac/Desktop/CODE/SLPM-enhanced/circuit/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}